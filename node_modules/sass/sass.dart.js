var self = Object.create(global);

// TODO: This isn't really a correct transformation. For example, it will fail
// for paths that contain characters that need to be escaped in URLs. Once
// dart-lang/sdk#27979 is fixed, it should be possible to make it better.
self.location = {
  get href() {
    return "file://" + (function() {
      var cwd = process.cwd();
      if (process.platform != "win32") return cwd;
      return "/" + cwd.replace(/\\/g, "/");
    })() + "/";
  }
};

self.scheduleImmediate = setImmediate;
self.require = require;
self.exports = exports;
self.process = process;

self.__dirname = __dirname;
self.__filename = __filename;

(function() {
  function computeCurrentScript() {
    try {
      throw new Error();
    } catch(e) {
      var stack = e.stack;
      var re = new RegExp("^ *at [^(]*\\((.*):[0-9]*:[0-9]*\\)$", "mg");
      var lastMatch = null;
      do {
        var match = re.exec(stack);
        if (match != null) lastMatch = match;
      } while (match != null);
      return lastMatch[1];
    }
  }

  var cachedCurrentScript = null;
  self.document = {
    get currentScript() {
      if (cachedCurrentScript == null) {
        cachedCurrentScript = {src: computeCurrentScript()};
      }
      return cachedCurrentScript;
    }
  };
})();

self.dartDeferredLibraryLoader = function(uri, successCallback, errorCallback) {
  try {
    load(uri);
    successCallback();
  } catch (error) {
    errorCallback(error);
  }
};
// Generated by dart2js (full emitter), the Dart to JavaScript compiler version: 2.0.0-dev.62.0.
// The code supports the following hooks:
// dartPrint(message):
//    if this function is defined it is called instead of the Dart [print]
//    method.
//
// dartMainRunner(main, args):
//    if this function is defined, the Dart [main] method will not be invoked
//    directly. Instead, a closure that will invoke [main], and its arguments
//    [args] is passed to [dartMainRunner].
//
// dartDeferredLibraryLoader(uri, successCallback, errorCallback):
//    if this function is defined, it will be called when a deferred library
//    is loaded. It should load and eval the javascript of `uri`, and call
//    successCallback. If it fails to do so, it should call errorCallback with
//    an error.
//
// defaultPackagesBase:
//    Override the location where `package:` uris are resolved from. By default
//    they are resolved under "packages/" from the current window location.
(function() {
  // /* ::norenaming:: */
  var supportsDirectProtoAccess = function() {
    var cls = function() {
    };
    cls.prototype = {p: {}};
    var object = new cls();
    if (!(object.__proto__ && object.__proto__.p === cls.prototype.p))
      return false;
    try {
      if (typeof navigator != "undefined" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Chrome/") >= 0)
        return true;
      if (typeof version == "function" && version.length == 0) {
        var v = version();
        if (/^\d+\.\d+\.\d+\.\d+$/.test(v))
          return true;
      }
    } catch (_) {
    }
    return false;
  }();
  function map(x) {
    x = Object.create(null);
    x.x = 0;
    delete x.x;
    return x;
  }
  // The global objects start as so-called "slow objects". For V8, this
  // means that it won't try to make map transitions as we add properties
  // to these objects. Later on, we attempt to turn these objects into
  // fast objects by calling "convertToFastObject" (see
  // [emitConvertToFastObjectFunction]).
  var A = map();
  var B = map();
  var C = map();
  var D = map();
  var E = map();
  var F = map();
  var G = map();
  var H = map();
  var J = map();
  var K = map();
  var L = map();
  var M = map();
  var N = map();
  var O = map();
  var P = map();
  var Q = map();
  var R = map();
  var S = map();
  var T = map();
  var U = map();
  var V = map();
  var W = map();
  var X = map();
  var Y = map();
  var Z = map();
  function Isolate() {
  }
  init();
  // Constructors are generated at runtime.
  function setupProgram(programData, metadataOffset, typesOffset) {
    "use strict";
    function generateAccessor(fieldDescriptor, accessors, cls) {
      var fieldInformation = fieldDescriptor.split("-");
      var field = fieldInformation[0];
      var len = field.length;
      var code = field.charCodeAt(len - 1);
      var reflectable;
      if (fieldInformation.length > 1)
        reflectable = true;
      else
        reflectable = false;
      code = code >= 60 && code <= 64 ? code - 59 : code >= 123 && code <= 126 ? code - 117 : code >= 37 && code <= 43 ? code - 27 : 0;
      if (code) {
        var getterCode = code & 3;
        var setterCode = code >> 2;
        var accessorName = field = field.substring(0, len - 1);
        var divider = field.indexOf(":");
        if (divider > 0) {
          accessorName = field.substring(0, divider);
          field = field.substring(divider + 1);
        }
        if (getterCode) {
          var args = getterCode & 2 ? "receiver" : "";
          var receiver = getterCode & 1 ? "this" : "receiver";
          var body = "return " + receiver + "." + field;
          var property = cls + ".prototype.get$" + accessorName + "=";
          var fn = "function(" + args + "){" + body + "}";
          if (reflectable)
            accessors.push(property + "$reflectable(" + fn + ");\n");
          else
            accessors.push(property + fn + ";\n");
        }
        if (setterCode) {
          var args = setterCode & 2 ? "receiver, value" : "value";
          var receiver = setterCode & 1 ? "this" : "receiver";
          var body = receiver + "." + field + " = value";
          var property = cls + ".prototype.set$" + accessorName + "=";
          var fn = "function(" + args + "){" + body + "}";
          if (reflectable)
            accessors.push(property + "$reflectable(" + fn + ");\n");
          else
            accessors.push(property + fn + ";\n");
        }
      }
      return field;
    }
    function defineClass(name, fields) {
      var accessors = [];
      var str = "function " + name + "(";
      var comma = "", body = "";
      for (var i = 0; i < fields.length; i++) {
        var fieldDescriptor = fields[i];
        if (fieldDescriptor.charCodeAt(0) == 48) {
          fieldDescriptor = fieldDescriptor.substring(1);
          var field = generateAccessor(fieldDescriptor, accessors, name);
          body += "this." + field + " = null;\n";
        } else {
          var field = generateAccessor(fieldDescriptor, accessors, name);
          var parameter = "p_" + field;
          str += comma;
          comma = ", ";
          str += parameter;
          body += "this." + field + " = " + parameter + ";\n";
        }
      }
      if (supportsDirectProtoAccess)
        body += "this." + "$deferredAction" + "();";
      str += ") {\n" + body + "}\n";
      str += name + ".builtin$cls=\"" + name + "\";\n";
      str += "$desc=$collectedClasses." + name + "[1];\n";
      str += name + ".prototype = $desc;\n";
      if (typeof defineClass.name != "string")
        str += name + ".name=\"" + name + "\";\n";
      str += accessors.join("");
      return str;
    }
    var inheritFrom = supportsDirectProtoAccess ? function(constructor, superConstructor) {
      var prototype = constructor.prototype;
      prototype.__proto__ = superConstructor.prototype;
      prototype.constructor = constructor;
      prototype["$is" + constructor.name] = constructor;
      return convertToFastObject(prototype);
    } : function() {
      function tmp() {
      }
      return function(constructor, superConstructor) {
        tmp.prototype = superConstructor.prototype;
        var object = new tmp();
        convertToSlowObject(object);
        var properties = constructor.prototype;
        var members = Object.keys(properties);
        for (var i = 0; i < members.length; i++) {
          var member = members[i];
          object[member] = properties[member];
        }
        object["$is" + constructor.name] = constructor;
        object.constructor = constructor;
        constructor.prototype = object;
        return object;
      };
    }();
    function finishClasses(processedClasses) {
      var allClasses = init.allClasses;
      processedClasses.combinedConstructorFunction += "return [\n" + processedClasses.constructorsList.join(",\n  ") + "\n]";
      var constructors = new Function("$collectedClasses", processedClasses.combinedConstructorFunction)(processedClasses.collected);
      processedClasses.combinedConstructorFunction = null;
      for (var i = 0; i < constructors.length; i++) {
        var constructor = constructors[i];
        var cls = constructor.name;
        var desc = processedClasses.collected[cls];
        var globalObject = desc[0];
        desc = desc[1];
        allClasses[cls] = constructor;
        globalObject[cls] = constructor;
      }
      constructors = null;
      var finishedClasses = init.finishedClasses;
      function finishClass(cls) {
        if (finishedClasses[cls])
          return;
        finishedClasses[cls] = true;
        var superclass = processedClasses.pending[cls];
        if (superclass && superclass.indexOf("+") > 0) {
          var s = superclass.split("+");
          superclass = s[0];
          var mixinClass = s[1];
          finishClass(mixinClass);
          var mixin = allClasses[mixinClass];
          var mixinPrototype = mixin.prototype;
          var clsPrototype = allClasses[cls].prototype;
          var properties = Object.keys(mixinPrototype);
          for (var i = 0; i < properties.length; i++) {
            var d = properties[i];
            if (!hasOwnProperty.call(clsPrototype, d))
              clsPrototype[d] = mixinPrototype[d];
          }
        }
        if (!superclass || typeof superclass != "string") {
          var constructor = allClasses[cls];
          var prototype = constructor.prototype;
          prototype.constructor = constructor;
          prototype.$isObject = constructor;
          prototype.$deferredAction = function() {
          };
          return;
        }
        finishClass(superclass);
        var superConstructor = allClasses[superclass];
        if (!superConstructor)
          superConstructor = existingIsolateProperties[superclass];
        var constructor = allClasses[cls];
        var prototype = inheritFrom(constructor, superConstructor);
        if (mixinPrototype)
          prototype.$deferredAction = mixinDeferredActionHelper(mixinPrototype, prototype);
        if (Object.prototype.hasOwnProperty.call(prototype, "%")) {
          var nativeSpec = prototype["%"].split(";");
          if (nativeSpec[0]) {
            var tags = nativeSpec[0].split("|");
            for (var i = 0; i < tags.length; i++) {
              init.interceptorsByTag[tags[i]] = constructor;
              init.leafTags[tags[i]] = true;
            }
          }
          if (nativeSpec[1]) {
            tags = nativeSpec[1].split("|");
            if (nativeSpec[2]) {
              var subclasses = nativeSpec[2].split("|");
              for (var i = 0; i < subclasses.length; i++) {
                var subclass = allClasses[subclasses[i]];
                subclass.$nativeSuperclassTag = tags[0];
              }
            }
            for (i = 0; i < tags.length; i++) {
              init.interceptorsByTag[tags[i]] = constructor;
              init.leafTags[tags[i]] = false;
            }
          }
          prototype.$deferredAction();
        }
        if (prototype.$isInterceptor)
          prototype.$deferredAction();
      }
      var properties = Object.keys(processedClasses.pending);
      for (var i = 0; i < properties.length; i++)
        finishClass(properties[i]);
    }
    function finishAddStubsHelper() {
      var prototype = this;
      while (!prototype.hasOwnProperty("$deferredAction"))
        prototype = prototype.__proto__;
      delete prototype.$deferredAction;
      var properties = Object.keys(prototype);
      for (var index = 0; index < properties.length; index++) {
        var property = properties[index];
        var firstChar = property.charCodeAt(0);
        var elem;
        if (property !== "^" && property !== "$reflectable" && firstChar !== 43 && firstChar !== 42 && (elem = prototype[property]) != null && elem.constructor === Array && property !== "<>")
          addStubs(prototype, elem, property, false, []);
      }
      convertToFastObject(prototype);
      prototype = prototype.__proto__;
      prototype.$deferredAction();
    }
    function mixinDeferredActionHelper(mixinPrototype, targetPrototype) {
      var chain;
      if (targetPrototype.hasOwnProperty("$deferredAction"))
        chain = targetPrototype.$deferredAction;
      return function foo() {
        if (!supportsDirectProtoAccess)
          return;
        var prototype = this;
        while (!prototype.hasOwnProperty("$deferredAction"))
          prototype = prototype.__proto__;
        if (chain)
          prototype.$deferredAction = chain;
        else {
          delete prototype.$deferredAction;
          convertToFastObject(prototype);
        }
        mixinPrototype.$deferredAction();
        prototype.$deferredAction();
      };
    }
    function processClassData(cls, descriptor, processedClasses) {
      descriptor = convertToSlowObject(descriptor);
      var previousProperty;
      var properties = Object.keys(descriptor);
      var hasDeferredWork = false;
      var shouldDeferWork = supportsDirectProtoAccess && cls != "Object";
      for (var i = 0; i < properties.length; i++) {
        var property = properties[i];
        var firstChar = property.charCodeAt(0);
        if (property === "static") {
          processStatics(init.statics[cls] = descriptor.static, processedClasses);
          delete descriptor.static;
        } else if (firstChar === 43) {
          mangledNames[previousProperty] = property.substring(1);
          var flag = descriptor[property];
          if (flag > 0)
            descriptor[previousProperty].$reflectable = flag;
        } else if (firstChar === 42) {
          descriptor[previousProperty].$defaultValues = descriptor[property];
          var optionalMethods = descriptor.$methodsWithOptionalArguments;
          if (!optionalMethods)
            descriptor.$methodsWithOptionalArguments = optionalMethods = {};
          optionalMethods[property] = previousProperty;
        } else {
          var elem = descriptor[property];
          if (property !== "^" && elem != null && elem.constructor === Array && property !== "<>")
            if (shouldDeferWork)
              hasDeferredWork = true;
            else
              addStubs(descriptor, elem, property, false, []);
          else
            previousProperty = property;
        }
      }
      if (hasDeferredWork)
        descriptor.$deferredAction = finishAddStubsHelper;
      var classData = descriptor["^"], split, supr, fields = classData;
      var s = fields.split(";");
      fields = s[1] ? s[1].split(",") : [];
      supr = s[0];
      split = supr.split(":");
      if (split.length == 2) {
        supr = split[0];
        var functionSignature = split[1];
        if (functionSignature)
          descriptor.$signature = function(s) {
            return function() {
              return init.types[s];
            };
          }(functionSignature);
      }
      if (supr)
        processedClasses.pending[cls] = supr;
      processedClasses.combinedConstructorFunction += defineClass(cls, fields);
      processedClasses.constructorsList.push(cls);
      processedClasses.collected[cls] = [globalObject, descriptor];
      classes.push(cls);
    }
    function processStatics(descriptor, processedClasses) {
      var properties = Object.keys(descriptor);
      for (var i = 0; i < properties.length; i++) {
        var property = properties[i];
        if (property === "^")
          continue;
        var element = descriptor[property];
        var firstChar = property.charCodeAt(0);
        var previousProperty;
        if (firstChar === 43) {
          mangledGlobalNames[previousProperty] = property.substring(1);
          var flag = descriptor[property];
          if (flag > 0)
            descriptor[previousProperty].$reflectable = flag;
          if (element && element.length)
            init.typeInformation[previousProperty] = element;
        } else if (firstChar === 42) {
          globalObject[previousProperty].$defaultValues = element;
          var optionalMethods = descriptor.$methodsWithOptionalArguments;
          if (!optionalMethods)
            descriptor.$methodsWithOptionalArguments = optionalMethods = {};
          optionalMethods[property] = previousProperty;
        } else if (typeof element === "function") {
          globalObject[previousProperty = property] = element;
          functions.push(property);
        } else if (element.constructor === Array)
          addStubs(globalObject, element, property, true, functions);
        else {
          previousProperty = property;
          processClassData(property, element, processedClasses);
        }
      }
    }
    function addStubs(prototype, array, name, isStatic, functions) {
      var index = 0, applyTrampolineIndex = index, alias = array[index], f;
      if (typeof alias == "string")
        f = array[++index];
      else {
        f = alias;
        alias = name;
      }
      if (typeof f == "number") {
        applyTrampolineIndex = f;
        f = array[++index];
      }
      prototype[name] = prototype[alias] = f;
      var funcs = [f];
      f.$stubName = name;
      functions.push(name);
      for (index++; index < array.length; index++) {
        f = array[index];
        if (typeof f != "function")
          break;
        if (!isStatic)
          f.$stubName = array[++index];
        funcs.push(f);
        if (f.$stubName) {
          prototype[f.$stubName] = f;
          functions.push(f.$stubName);
        }
      }
      for (var i = 0; i < funcs.length; index++, i++)
        funcs[i].$callName = array[index];
      var getterStubName = array[index];
      array = array.slice(++index);
      var requiredParameterInfo = array[0];
      var isIntercepted = (requiredParameterInfo & 1) === 1;
      requiredParameterInfo = requiredParameterInfo >> 1;
      var requiredParameterCount = requiredParameterInfo >> 1;
      var isAccessor = (requiredParameterInfo & 1) === 1;
      var isSetter = requiredParameterInfo === 3;
      var isGetter = requiredParameterInfo === 1;
      var optionalParameterInfo = array[1];
      var optionalParameterCount = optionalParameterInfo >> 1;
      var optionalParametersAreNamed = (optionalParameterInfo & 1) === 1;
      var totalParameterCount = requiredParameterCount + optionalParameterCount;
      var functionTypeIndex = array[2];
      if (typeof functionTypeIndex == "number")
        array[2] = functionTypeIndex + typesOffset;
      if (metadataOffset > 0) {
        var position = 3;
        for (var i = 0; i < optionalParameterCount; i++) {
          if (typeof array[position] == "number")
            array[position] = array[position] + metadataOffset;
          position++;
        }
        for (var i = 0; i < totalParameterCount; i++) {
          array[position] = array[position] + metadataOffset;
          position++;
        }
      }
      var unmangledNameIndex = 2 * optionalParameterCount + requiredParameterCount + 3;
      if (getterStubName) {
        f = tearOff(funcs, applyTrampolineIndex, array, isStatic, name, isIntercepted);
        prototype[name].$getter = f;
        f.$getterStub = true;
        if (isStatic)
          functions.push(getterStubName);
        prototype[getterStubName] = f;
        funcs.push(f);
        f.$stubName = getterStubName;
        f.$callName = null;
      }
      var isReflectable = array.length > unmangledNameIndex;
      if (isReflectable) {
        funcs[0].$reflectable = 1;
        funcs[0].$reflectionInfo = array;
        for (var i = 1; i < funcs.length; i++) {
          funcs[i].$reflectable = 2;
          funcs[i].$reflectionInfo = array;
        }
        var mangledNames = isStatic ? init.mangledGlobalNames : init.mangledNames;
        var unmangledName = array[unmangledNameIndex];
        var reflectionName = unmangledName;
        if (getterStubName)
          mangledNames[getterStubName] = reflectionName;
        if (isSetter)
          reflectionName += "=";
        else if (!isGetter)
          reflectionName += ":" + (requiredParameterCount + optionalParameterCount);
        mangledNames[name] = reflectionName;
        funcs[0].$reflectionName = reflectionName;
        for (var i = unmangledNameIndex + 1; i < array.length; i++)
          array[i] = array[i] + metadataOffset;
        funcs[0].$metadataIndex = unmangledNameIndex + 1;
        if (optionalParameterCount)
          prototype[unmangledName + "*"] = funcs[applyTrampolineIndex];
      }
    }
    Function.prototype.call$1 = function(a) {
      return this(a);
    };
    Function.prototype.call$2 = function(a, b) {
      return this(a, b);
    };
    Function.prototype.call$0 = function() {
      return this();
    };
    Function.prototype.call$3 = function(a, b, c) {
      return this(a, b, c);
    };
    Function.prototype.call$4 = function(a, b, c, d) {
      return this(a, b, c, d);
    };
    function tearOffGetter(funcs, applyTrampolineIndex, reflectionInfo, name, isIntercepted) {
      return isIntercepted ? new Function("funcs", "applyTrampolineIndex", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "(x) {" + "if (c === null) c = " + "H.closureFromTearOff" + "(" + "this, funcs, applyTrampolineIndex, reflectionInfo, false, [x], name);" + "return new c(this, funcs[0], x, name);" + "}")(funcs, applyTrampolineIndex, reflectionInfo, name, H, null) : new Function("funcs", "applyTrampolineIndex", "reflectionInfo", "name", "H", "c", "return function tearOff_" + name + functionCounter++ + "() {" + "if (c === null) c = " + "H.closureFromTearOff" + "(" + "this, funcs, applyTrampolineIndex, reflectionInfo, false, [], name);" + "return new c(this, funcs[0], null, name);" + "}")(funcs, applyTrampolineIndex, reflectionInfo, name, H, null);
    }
    function tearOff(funcs, applyTrampolineIndex, reflectionInfo, isStatic, name, isIntercepted) {
      var cache;
      return isStatic ? function() {
        if (cache === void 0)
          cache = H.closureFromTearOff(this, funcs, applyTrampolineIndex, reflectionInfo, true, [], name).prototype;
        return cache;
      } : tearOffGetter(funcs, applyTrampolineIndex, reflectionInfo, name, isIntercepted);
    }
    var functionCounter = 0;
    if (!init.libraries)
      init.libraries = [];
    if (!init.mangledNames)
      init.mangledNames = map();
    if (!init.mangledGlobalNames)
      init.mangledGlobalNames = map();
    if (!init.statics)
      init.statics = map();
    if (!init.typeInformation)
      init.typeInformation = map();
    var libraries = init.libraries;
    var mangledNames = init.mangledNames;
    var mangledGlobalNames = init.mangledGlobalNames;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var length = programData.length;
    var processedClasses = map();
    processedClasses.collected = map();
    processedClasses.pending = map();
    processedClasses.constructorsList = [];
    processedClasses.combinedConstructorFunction = "function $reflectable(fn){fn.$reflectable=1;return fn};\n" + "var $desc;\n";
    for (var i = 0; i < length; i++) {
      var data = programData[i];
      var name = data[0];
      var uri = data[1];
      var metadata = data[2];
      var globalObject = data[3];
      var descriptor = data[4];
      var isRoot = !!data[5];
      var fields = descriptor && descriptor["^"];
      if (fields instanceof Array)
        fields = fields[0];
      var classes = [];
      var functions = [];
      processStatics(descriptor, processedClasses);
      libraries.push([name, uri, classes, functions, metadata, fields, isRoot, globalObject]);
    }
    finishClasses(processedClasses);
  }
  Isolate.functionThatReturnsNull = function() {
  };
  var dart = [["_foreign_helper", "dart:_foreign_helper",, H, {
    "^": "",
    JS_CONST: {
      "^": "Object;code>"
    }
  }], ["_interceptors", "dart:_interceptors",, J, {
    "^": "",
    getInterceptor: function(object) {
      return void 0;
    },
    makeDispatchRecord: function(interceptor, proto, extension, indexability) {
      return {i: interceptor, p: proto, e: extension, x: indexability};
    },
    getNativeInterceptor: function(object) {
      var record, proto, objectProto, $constructor, interceptor;
      record = object[init.dispatchPropertyName];
      if (record == null)
        if ($.initNativeDispatchFlag == null) {
          H.initNativeDispatch();
          record = object[init.dispatchPropertyName];
        }
      if (record != null) {
        proto = record.p;
        if (false === proto)
          return record.i;
        if (true === proto)
          return object;
        objectProto = Object.getPrototypeOf(object);
        if (proto === objectProto)
          return record.i;
        if (record.e === objectProto)
          throw H.wrapException(P.UnimplementedError$("Return interceptor for " + H.S(proto(object, record))));
      }
      $constructor = object.constructor;
      interceptor = $constructor == null ? null : $constructor[$.$get$JS_INTEROP_INTERCEPTOR_TAG()];
      if (interceptor != null)
        return interceptor;
      interceptor = H.lookupAndCacheInterceptor(object);
      if (interceptor != null)
        return interceptor;
      if (typeof object == "function")
        return C.JavaScriptFunction_methods;
      proto = Object.getPrototypeOf(object);
      if (proto == null)
        return C.PlainJavaScriptObject_methods;
      if (proto === Object.prototype)
        return C.PlainJavaScriptObject_methods;
      if (typeof $constructor == "function") {
        Object.defineProperty($constructor, $.$get$JS_INTEROP_INTERCEPTOR_TAG(), {value: C.UnknownJavaScriptObject_methods, enumerable: false, writable: true, configurable: true});
        return C.UnknownJavaScriptObject_methods;
      }
      return C.UnknownJavaScriptObject_methods;
    },
    Interceptor: {
      "^": "Object;",
      $eq: function(receiver, other) {
        return receiver === other;
      },
      get$hashCode: function(receiver) {
        return H.Primitives_objectHashCode(receiver);
      },
      toString$0: function(receiver) {
        return "Instance of '" + H.Primitives_objectTypeName(receiver) + "'";
      },
      noSuchMethod$1: ["super$Interceptor$noSuchMethod", function(receiver, invocation) {
        throw H.wrapException(P.NoSuchMethodError$(receiver, invocation.get$memberName(), invocation.get$positionalArguments(), invocation.get$namedArguments(), null));
      }, null, "get$noSuchMethod", 5, 0, null, 22],
      "%": "ArrayBuffer"
    },
    JSBool: {
      "^": "Interceptor;",
      toString$0: function(receiver) {
        return String(receiver);
      },
      get$hashCode: function(receiver) {
        return receiver ? 519018 : 218159;
      },
      $isbool: 1
    },
    JSNull: {
      "^": "Interceptor;",
      $eq: function(receiver, other) {
        return null == other;
      },
      toString$0: function(receiver) {
        return "null";
      },
      get$hashCode: function(receiver) {
        return 0;
      },
      noSuchMethod$1: [function(receiver, invocation) {
        return this.super$Interceptor$noSuchMethod(receiver, invocation);
      }, null, "get$noSuchMethod", 5, 0, null, 22],
      $isNull: 1
    },
    JavaScriptObject: {
      "^": "Interceptor;",
      get$hashCode: function(receiver) {
        return 0;
      },
      toString$0: ["super$JavaScriptObject$toString", function(receiver) {
        return String(receiver);
      }],
      get$isTTY: function(obj) {
        return obj.isTTY;
      },
      get$write: function(obj) {
        return obj.write;
      },
      write$1: function(receiver, p0) {
        return receiver.write(p0);
      },
      createInterface$1: function(receiver, p0) {
        return receiver.createInterface(p0);
      },
      on$2: function(receiver, p0, p1) {
        return receiver.on(p0, p1);
      },
      get$close: function(obj) {
        return obj.close;
      },
      close$0: function(receiver) {
        return receiver.close();
      },
      get$pause: function(obj) {
        return obj.pause;
      },
      pause$0: function(receiver) {
        return receiver.pause();
      },
      setPrompt$1: function(receiver, p0) {
        return receiver.setPrompt(p0);
      },
      readFileSync$2: function(receiver, p0, p1) {
        return receiver.readFileSync(p0, p1);
      },
      writeFileSync$2: function(receiver, p0, p1) {
        return receiver.writeFileSync(p0, p1);
      },
      mkdirSync$1: function(receiver, p0) {
        return receiver.mkdirSync(p0);
      },
      statSync$1: function(receiver, p0) {
        return receiver.statSync(p0);
      },
      unlinkSync$1: function(receiver, p0) {
        return receiver.unlinkSync(p0);
      },
      readdirSync$1: function(receiver, p0) {
        return receiver.readdirSync(p0);
      },
      isFile$0: function(receiver) {
        return receiver.isFile();
      },
      isDirectory$0: function(receiver) {
        return receiver.isDirectory();
      },
      get$mtime: function(obj) {
        return obj.mtime;
      },
      getTime$0: function(receiver) {
        return receiver.getTime();
      },
      get$message: function(obj) {
        return obj.message;
      },
      message$1: function(receiver, p0) {
        return receiver.message(p0);
      },
      get$code: function(obj) {
        return obj.code;
      },
      get$syscall: function(obj) {
        return obj.syscall;
      },
      get$path: function(obj) {
        return obj.path;
      },
      get$platform: function(obj) {
        return obj.platform;
      },
      cwd$0: function(receiver) {
        return receiver.cwd();
      },
      watch$2: function(receiver, p0, p1) {
        return receiver.watch(p0, p1);
      },
      set$run_: function(obj, v) {
        return obj.run_ = v;
      },
      set$render: function(obj, v) {
        return obj.render = v;
      },
      set$renderSync: function(obj, v) {
        return obj.renderSync = v;
      },
      set$info: function(obj, v) {
        return obj.info = v;
      },
      set$types: function(obj, v) {
        return obj.types = v;
      },
      call$1: function(receiver, p0) {
        return receiver.call(p0);
      },
      get$current: function(obj) {
        return obj.current;
      },
      yield$0: function(receiver) {
        return receiver.yield();
      },
      run$1: function(receiver, p0) {
        return receiver.run(p0);
      },
      run$0: function(receiver) {
        return receiver.run();
      },
      call$2: function(receiver, p0, p1) {
        return receiver.call(p0, p1);
      },
      call$0: function(receiver) {
        return receiver.call();
      },
      call$3: function(receiver, p0, p1, p2) {
        return receiver.call(p0, p1, p2);
      },
      apply$2: function(receiver, p0, p1) {
        return receiver.apply(p0, p1);
      },
      get$file: function(obj) {
        return obj.file;
      },
      get$contents: function(obj) {
        return obj.contents;
      },
      get$options: function(obj) {
        return obj.options;
      },
      get$data: function(obj) {
        return obj.data;
      },
      get$includePaths: function(obj) {
        return obj.includePaths;
      },
      get$indentType: function(obj) {
        return obj.indentType;
      },
      get$indentWidth: function(obj) {
        return obj.indentWidth;
      },
      get$linefeed: function(obj) {
        return obj.linefeed;
      },
      set$context: function(obj, v) {
        return obj.context = v;
      },
      get$result: function(obj) {
        return obj.result;
      },
      get$importer: function(obj) {
        return obj.importer;
      },
      get$functions: function(obj) {
        return obj.functions;
      },
      get$indentedSyntax: function(obj) {
        return obj.indentedSyntax;
      },
      get$omitSourceMapUrl: function(obj) {
        return obj.omitSourceMapUrl;
      },
      get$outFile: function(obj) {
        return obj.outFile;
      },
      get$outputStyle: function(obj) {
        return obj.outputStyle;
      },
      get$fiber: function(obj) {
        return obj.fiber;
      },
      get$sourceMap: function(obj) {
        return obj.sourceMap;
      },
      get$sourceMapContents: function(obj) {
        return obj.sourceMapContents;
      },
      get$sourceMapEmbed: function(obj) {
        return obj.sourceMapEmbed;
      },
      get$sourceMapRoot: function(obj) {
        return obj.sourceMapRoot;
      },
      get$css: function(obj) {
        return obj.css;
      },
      map$1: function(receiver, p0) {
        return receiver.map(p0);
      },
      get$start: function(obj) {
        return obj.start;
      },
      get$end: function(obj) {
        return obj.end;
      },
      get$includedFiles: function(obj) {
        return obj.includedFiles;
      },
      get$dartValue: function(obj) {
        return obj.dartValue;
      },
      set$dartValue: function(obj, v) {
        return obj.dartValue = v;
      },
      $is_SystemError: 1,
      $isJSError: 1,
      $isFunction: 1,
      $isFiber: 1,
      $isFunction: 1,
      $isJSFunction: 1,
      $isNodeImporterResult: 1,
      $isRenderOptions: 1,
      $isRenderResult: 1,
      $is_NodeSassColor: 1,
      $is_NodeSassList: 1,
      $is_NodeSassMap: 1,
      $is_NodeSassNumber: 1,
      $is_NodeSassString: 1
    },
    PlainJavaScriptObject: {
      "^": "JavaScriptObject;"
    },
    UnknownJavaScriptObject: {
      "^": "JavaScriptObject;"
    },
    JavaScriptFunction: {
      "^": "JavaScriptObject;",
      toString$0: function(receiver) {
        var dartClosure = receiver[$.$get$DART_CLOSURE_PROPERTY_NAME()];
        if (dartClosure == null)
          return this.super$JavaScriptObject$toString(receiver);
        return "JavaScript function for " + H.S(J.toString$0$(dartClosure));
      },
      $signature: function() {
        return {func: 1, opt: [,,,,,,,,,,,,,,,,]};
      },
      $isFunction: 1
    },
    JSArray: {
      "^": "Interceptor;$ti",
      cast$0: function(receiver) {
        return new H.CastList(receiver, [null, null]);
      },
      add$1: function(receiver, value) {
        if (!!receiver.fixed$length)
          H.throwExpression(P.UnsupportedError$("add"));
        receiver.push(value);
      },
      removeAt$1: function(receiver, index) {
        var t1;
        if (!!receiver.fixed$length)
          H.throwExpression(P.UnsupportedError$("removeAt"));
        t1 = receiver.length;
        if (index >= t1)
          throw H.wrapException(P.RangeError$value(index, null, null));
        return receiver.splice(index, 1)[0];
      },
      insert$2: function(receiver, index, value) {
        var t1;
        if (!!receiver.fixed$length)
          H.throwExpression(P.UnsupportedError$("insert"));
        t1 = receiver.length;
        if (index > t1)
          throw H.wrapException(P.RangeError$value(index, null, null));
        receiver.splice(index, 0, value);
      },
      insertAll$2: function(receiver, index, iterable) {
        var t1, insertionLength, end;
        if (!!receiver.fixed$length)
          H.throwExpression(P.UnsupportedError$("insertAll"));
        P.RangeError_checkValueInInterval(index, 0, receiver.length, "index", null);
        t1 = J.getInterceptor(iterable);
        if (!t1.$isEfficientLengthIterable)
          iterable = t1.toList$0(iterable);
        insertionLength = J.get$length$asx(iterable);
        t1 = receiver.length;
        if (typeof insertionLength !== "number")
          return H.iae(insertionLength);
        this.set$length(receiver, t1 + insertionLength);
        end = index + insertionLength;
        this.setRange$4(receiver, end, receiver.length, receiver, index);
        this.setRange$3(receiver, index, end, iterable);
      },
      removeLast$0: function(receiver) {
        if (!!receiver.fixed$length)
          H.throwExpression(P.UnsupportedError$("removeLast"));
        if (receiver.length === 0)
          throw H.wrapException(H.diagnoseIndexError(receiver, -1));
        return receiver.pop();
      },
      remove$1: function(receiver, element) {
        var i;
        if (!!receiver.fixed$length)
          H.throwExpression(P.UnsupportedError$("remove"));
        for (i = 0; i < receiver.length; ++i)
          if (J.$eq$(receiver[i], element) === true) {
            receiver.splice(i, 1);
            return true;
          }
        return false;
      },
      _removeWhere$2: function(receiver, test, removeMatching) {
        var retained, end, i, element, t1;
        retained = [];
        end = receiver.length;
        for (i = 0; i < end; ++i) {
          element = receiver[i];
          if (test.call$1(element) !== true)
            retained.push(element);
          if (receiver.length !== end)
            throw H.wrapException(P.ConcurrentModificationError$(receiver));
        }
        t1 = retained.length;
        if (t1 === end)
          return;
        this.set$length(receiver, t1);
        for (i = 0; i < retained.length; ++i)
          receiver[i] = retained[i];
      },
      where$1: function(receiver, f) {
        return new H.WhereIterable(receiver, f, [H.getTypeArgumentByIndex(receiver, 0)]);
      },
      expand$1: function(receiver, f) {
        return new H.ExpandIterable(receiver, f, [H.getTypeArgumentByIndex(receiver, 0), null]);
      },
      addAll$1: function(receiver, collection) {
        var t1;
        if (!!receiver.fixed$length)
          H.throwExpression(P.UnsupportedError$("addAll"));
        for (t1 = J.get$iterator$ax(collection); t1.moveNext$0();)
          receiver.push(t1.get$current(t1));
      },
      clear$0: function(receiver) {
        this.set$length(receiver, 0);
      },
      forEach$1: function(receiver, f) {
        var end, i;
        end = receiver.length;
        for (i = 0; i < end; ++i) {
          f.call$1(receiver[i]);
          if (receiver.length !== end)
            throw H.wrapException(P.ConcurrentModificationError$(receiver));
        }
      },
      map$1: function(receiver, f) {
        return new H.MappedListIterable(receiver, f, [H.getTypeArgumentByIndex(receiver, 0), null]);
      },
      join$1: function(receiver, separator) {
        var t1, list, i, t2;
        t1 = receiver.length;
        list = new Array(t1);
        list.fixed$length = Array;
        for (i = 0; i < receiver.length; ++i) {
          t2 = H.S(receiver[i]);
          if (i >= t1)
            return H.ioore(list, i);
          list[i] = t2;
        }
        return list.join(separator);
      },
      join$0: function($receiver) {
        return this.join$1($receiver, "");
      },
      take$1: function(receiver, n) {
        return H.SubListIterable$(receiver, 0, n, H.getTypeArgumentByIndex(receiver, 0));
      },
      skip$1: function(receiver, n) {
        return H.SubListIterable$(receiver, n, null, H.getTypeArgumentByIndex(receiver, 0));
      },
      fold$2: function(receiver, initialValue, combine) {
        var $length, value, i;
        $length = receiver.length;
        for (value = initialValue, i = 0; i < $length; ++i) {
          value = combine.call$2(value, receiver[i]);
          if (receiver.length !== $length)
            throw H.wrapException(P.ConcurrentModificationError$(receiver));
        }
        return value;
      },
      lastWhere$2$orElse: function(receiver, test, orElse) {
        var $length, i, element;
        $length = receiver.length;
        for (i = $length - 1; i >= 0; --i) {
          element = receiver[i];
          if (test.call$1(element) === true)
            return element;
          if ($length !== receiver.length)
            throw H.wrapException(P.ConcurrentModificationError$(receiver));
        }
        if (orElse != null)
          return orElse.call$0();
        throw H.wrapException(H.IterableElementError_noElement());
      },
      elementAt$1: function(receiver, index) {
        if (index >>> 0 !== index || index >= receiver.length)
          return H.ioore(receiver, index);
        return receiver[index];
      },
      sublist$2: function(receiver, start, end) {
        if (start == null)
          H.throwExpression(H.argumentErrorValue(start));
        if (typeof start !== "number" || Math.floor(start) !== start)
          throw H.wrapException(H.argumentErrorValue(start));
        if (start < 0 || start > receiver.length)
          throw H.wrapException(P.RangeError$range(start, 0, receiver.length, "start", null));
        if (end == null)
          end = receiver.length;
        else {
          if (typeof end !== "number" || Math.floor(end) !== end)
            throw H.wrapException(H.argumentErrorValue(end));
          if (end < start || end > receiver.length)
            throw H.wrapException(P.RangeError$range(end, start, receiver.length, "end", null));
        }
        if (start === end)
          return H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(receiver, 0)]);
        return H.setRuntimeTypeInfo(receiver.slice(start, end), [H.getTypeArgumentByIndex(receiver, 0)]);
      },
      sublist$1: function($receiver, start) {
        return this.sublist$2($receiver, start, null);
      },
      get$first: function(receiver) {
        if (receiver.length > 0)
          return receiver[0];
        throw H.wrapException(H.IterableElementError_noElement());
      },
      get$last: function(receiver) {
        var t1 = receiver.length;
        if (t1 > 0)
          return receiver[t1 - 1];
        throw H.wrapException(H.IterableElementError_noElement());
      },
      get$single: function(receiver) {
        var t1 = receiver.length;
        if (t1 === 1) {
          if (0 >= t1)
            return H.ioore(receiver, 0);
          return receiver[0];
        }
        if (t1 === 0)
          throw H.wrapException(H.IterableElementError_noElement());
        throw H.wrapException(H.IterableElementError_tooMany());
      },
      removeRange$2: function(receiver, start, end) {
        if (!!receiver.fixed$length)
          H.throwExpression(P.UnsupportedError$("removeRange"));
        P.RangeError_checkValidRange(start, end, receiver.length, null, null, null);
        if (typeof start !== "number")
          return H.iae(start);
        receiver.splice(start, end - start);
      },
      setRange$4: function(receiver, start, end, iterable, skipCount) {
        var $length, t1, t2, otherStart, otherList, t3, i, t4, element;
        if (!!receiver.immutable$list)
          H.throwExpression(P.UnsupportedError$("setRange"));
        P.RangeError_checkValidRange(start, end, receiver.length, null, null, null);
        $length = J.$sub$n(end, start);
        t1 = J.getInterceptor($length);
        if (t1.$eq($length, 0))
          return;
        if (J.$lt$n(skipCount, 0))
          H.throwExpression(P.RangeError$range(skipCount, 0, null, "skipCount", null));
        t2 = J.getInterceptor(iterable);
        if (!!t2.$isList) {
          otherStart = skipCount;
          otherList = iterable;
        } else {
          otherList = J.toList$1$growable$ax(t2.skip$1(iterable, skipCount), false);
          otherStart = 0;
        }
        t2 = J.getInterceptor$ansx(otherStart);
        t3 = J.getInterceptor$asx(otherList);
        if (J.$gt$n(t2.$add(otherStart, $length), t3.get$length(otherList)))
          throw H.wrapException(H.IterableElementError_tooFew());
        if (t2.$lt(otherStart, start))
          for (i = t1.$sub($length, 1), t1 = J.getInterceptor$ansx(start); t4 = J.getInterceptor$n(i), t4.$ge(i, 0); i = t4.$sub(i, 1)) {
            element = t3.$index(otherList, t2.$add(otherStart, i));
            receiver[t1.$add(start, i)] = element;
          }
        else {
          if (typeof $length !== "number")
            return H.iae($length);
          t1 = J.getInterceptor$ansx(start);
          i = 0;
          for (; i < $length; ++i) {
            element = t3.$index(otherList, t2.$add(otherStart, i));
            receiver[t1.$add(start, i)] = element;
          }
        }
      },
      setRange$3: function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      },
      fillRange$3: function(receiver, start, end, fillValue) {
        var i, t1;
        if (!!receiver.immutable$list)
          H.throwExpression(P.UnsupportedError$("fill range"));
        P.RangeError_checkValidRange(start, end, receiver.length, null, null, null);
        for (i = start; t1 = J.getInterceptor$n(i), t1.$lt(i, end); i = t1.$add(i, 1))
          receiver[i] = fillValue;
      },
      replaceRange$3: function(receiver, start, end, replacement) {
        var t1, removeLength, insertLength, t2, delta, insertEnd, newLength;
        if (!!receiver.fixed$length)
          H.throwExpression(P.UnsupportedError$("replaceRange"));
        P.RangeError_checkValidRange(start, end, receiver.length, null, null, null);
        t1 = J.getInterceptor(replacement);
        if (!t1.$isEfficientLengthIterable)
          replacement = t1.toList$0(replacement);
        removeLength = J.$sub$n(end, start);
        insertLength = J.get$length$asx(replacement);
        t1 = J.getInterceptor$n(removeLength);
        t2 = J.getInterceptor$ansx(start);
        if (t1.$ge(removeLength, insertLength)) {
          delta = t1.$sub(removeLength, insertLength);
          insertEnd = t2.$add(start, insertLength);
          t1 = receiver.length;
          if (typeof delta !== "number")
            return H.iae(delta);
          newLength = t1 - delta;
          this.setRange$3(receiver, start, insertEnd, replacement);
          if (delta !== 0) {
            this.setRange$4(receiver, insertEnd, newLength, receiver, end);
            this.set$length(receiver, newLength);
          }
        } else {
          delta = J.$sub$n(insertLength, removeLength);
          t1 = receiver.length;
          if (typeof delta !== "number")
            return H.iae(delta);
          newLength = t1 + delta;
          insertEnd = t2.$add(start, insertLength);
          this.set$length(receiver, newLength);
          this.setRange$4(receiver, insertEnd, newLength, receiver, end);
          this.setRange$3(receiver, start, insertEnd, replacement);
        }
      },
      any$1: function(receiver, test) {
        var end, i;
        end = receiver.length;
        for (i = 0; i < end; ++i) {
          if (test.call$1(receiver[i]) === true)
            return true;
          if (receiver.length !== end)
            throw H.wrapException(P.ConcurrentModificationError$(receiver));
        }
        return false;
      },
      every$1: function(receiver, test) {
        var end, i;
        end = receiver.length;
        for (i = 0; i < end; ++i) {
          if (test.call$1(receiver[i]) !== true)
            return false;
          if (receiver.length !== end)
            throw H.wrapException(P.ConcurrentModificationError$(receiver));
        }
        return true;
      },
      get$reversed: function(receiver) {
        return new H.ReversedListIterable(receiver, [H.getTypeArgumentByIndex(receiver, 0)]);
      },
      sort$1: function(receiver, compare) {
        if (!!receiver.immutable$list)
          H.throwExpression(P.UnsupportedError$("sort"));
        H.Sort_sort(receiver, compare == null ? J._interceptors_JSArray__compareAny$closure() : compare);
      },
      sort$0: function($receiver) {
        return this.sort$1($receiver, null);
      },
      indexOf$2: function(receiver, element, start) {
        var i;
        if (start >= receiver.length)
          return -1;
        if (start < 0)
          start = 0;
        for (i = start; i < receiver.length; ++i)
          if (J.$eq$(receiver[i], element) === true)
            return i;
        return -1;
      },
      indexOf$1: function($receiver, element) {
        return this.indexOf$2($receiver, element, 0);
      },
      lastIndexOf$2: function(receiver, element, startIndex) {
        var t1, i;
        if (startIndex == null)
          startIndex = receiver.length - 1;
        else {
          t1 = J.getInterceptor$n(startIndex);
          if (t1.$lt(startIndex, 0))
            return -1;
          if (t1.$ge(startIndex, receiver.length))
            startIndex = receiver.length - 1;
        }
        for (i = startIndex; J.$ge$n(i, 0); --i) {
          if (i >>> 0 !== i || i >= receiver.length)
            return H.ioore(receiver, i);
          if (J.$eq$(receiver[i], element) === true)
            return i;
        }
        return -1;
      },
      lastIndexOf$1: function($receiver, element) {
        return this.lastIndexOf$2($receiver, element, null);
      },
      contains$1: [function(receiver, other) {
        var i;
        for (i = 0; i < receiver.length; ++i)
          if (J.$eq$(receiver[i], other) === true)
            return true;
        return false;
      }, "call$1", "get$contains", 5, 0, 13],
      get$isEmpty: function(receiver) {
        return receiver.length === 0;
      },
      get$isNotEmpty: function(receiver) {
        return receiver.length !== 0;
      },
      toString$0: function(receiver) {
        return P.IterableBase_iterableToFullString(receiver, "[", "]");
      },
      toList$1$growable: function(receiver, growable) {
        var t1 = [H.getTypeArgumentByIndex(receiver, 0)];
        return growable ? H.setRuntimeTypeInfo(receiver.slice(0), t1) : J.JSArray_markFixedList(H.setRuntimeTypeInfo(receiver.slice(0), t1));
      },
      toList$0: function($receiver) {
        return this.toList$1$growable($receiver, true);
      },
      get$iterator: function(receiver) {
        return new J.ArrayIterator(receiver, receiver.length, 0, null, [H.getTypeArgumentByIndex(receiver, 0)]);
      },
      get$hashCode: function(receiver) {
        return H.Primitives_objectHashCode(receiver);
      },
      get$length: function(receiver) {
        return receiver.length;
      },
      set$length: function(receiver, newLength) {
        if (!!receiver.fixed$length)
          H.throwExpression(P.UnsupportedError$("set length"));
        if (typeof newLength !== "number" || Math.floor(newLength) !== newLength)
          throw H.wrapException(P.ArgumentError$value(newLength, "newLength", null));
        if (newLength < 0)
          throw H.wrapException(P.RangeError$range(newLength, 0, null, "newLength", null));
        receiver.length = newLength;
      },
      $index: function(receiver, index) {
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        if (index >= receiver.length || index < 0)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      },
      $indexSet: function(receiver, index, value) {
        if (!!receiver.immutable$list)
          H.throwExpression(P.UnsupportedError$("indexed set"));
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        if (index >= receiver.length || index < 0)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        receiver[index] = value;
      },
      $add: function(receiver, other) {
        var t1, t2, totalLength;
        t1 = receiver.length;
        t2 = J.get$length$asx(other);
        if (typeof t2 !== "number")
          return H.iae(t2);
        totalLength = t1 + t2;
        t2 = H.setRuntimeTypeInfo([], [H.getTypeArgumentByIndex(receiver, 0)]);
        this.set$length(t2, totalLength);
        this.setRange$3(t2, 0, receiver.length, receiver);
        this.setRange$3(t2, receiver.length, totalLength, other);
        return t2;
      },
      $isEfficientLengthIterable: 1,
      $isIterable: 1,
      $isList: 1,
      static: {
        JSArray_JSArray$fixed: function($length, $E) {
          if (typeof $length !== "number" || Math.floor($length) !== $length)
            throw H.wrapException(P.ArgumentError$value($length, "length", "is not an integer"));
          if ($length < 0 || $length > 4294967295)
            throw H.wrapException(P.RangeError$range($length, 0, 4294967295, "length", null));
          return J.JSArray_markFixedList(H.setRuntimeTypeInfo(new Array($length), [$E]));
        },
        JSArray_markFixedList: function(list) {
          list.fixed$length = Array;
          return list;
        },
        JSArray_markUnmodifiableList: function(list) {
          list.fixed$length = Array;
          list.immutable$list = Array;
          return list;
        },
        JSArray__compareAny: [function(a, b) {
          return J.compareTo$1$ns(a, b);
        }, "call$2", "_interceptors_JSArray__compareAny$closure", 8, 0, 85]
      }
    },
    JSUnmodifiableArray: {
      "^": "JSArray;$ti"
    },
    ArrayIterator: {
      "^": "Object;_iterable,_length,_index,_current,$ti",
      get$current: function(_) {
        return this._current;
      },
      moveNext$0: function() {
        var t1, $length, t2;
        t1 = this._iterable;
        $length = t1.length;
        if (this._length !== $length)
          throw H.wrapException(H.throwConcurrentModificationError(t1));
        t2 = this._index;
        if (t2 >= $length) {
          this._current = null;
          return false;
        }
        this._current = t1[t2];
        this._index = t2 + 1;
        return true;
      }
    },
    JSNumber: {
      "^": "Interceptor;",
      compareTo$1: function(receiver, b) {
        var bIsNegative;
        if (typeof b !== "number")
          throw H.wrapException(H.argumentErrorValue(b));
        if (receiver < b)
          return -1;
        else if (receiver > b)
          return 1;
        else if (receiver === b) {
          if (receiver === 0) {
            bIsNegative = this.get$isNegative(b);
            if (this.get$isNegative(receiver) === bIsNegative)
              return 0;
            if (this.get$isNegative(receiver))
              return -1;
            return 1;
          }
          return 0;
        } else if (isNaN(receiver)) {
          if (isNaN(b))
            return 0;
          return 1;
        } else
          return -1;
      },
      get$isNegative: function(receiver) {
        return receiver === 0 ? 1 / receiver < 0 : receiver < 0;
      },
      abs$0: function(receiver) {
        return Math.abs(receiver);
      },
      ceil$0: function(receiver) {
        var truncated, d;
        if (receiver >= 0) {
          if (receiver <= 2147483647) {
            truncated = receiver | 0;
            return receiver === truncated ? truncated : truncated + 1;
          }
        } else if (receiver >= -2147483648)
          return receiver | 0;
        d = Math.ceil(receiver);
        if (isFinite(d))
          return d;
        throw H.wrapException(P.UnsupportedError$("" + receiver + ".ceil()"));
      },
      floor$0: function(receiver) {
        var truncated, d;
        if (receiver >= 0) {
          if (receiver <= 2147483647)
            return receiver | 0;
        } else if (receiver >= -2147483648) {
          truncated = receiver | 0;
          return receiver === truncated ? truncated : truncated - 1;
        }
        d = Math.floor(receiver);
        if (isFinite(d))
          return d;
        throw H.wrapException(P.UnsupportedError$("" + receiver + ".floor()"));
      },
      round$0: function(receiver) {
        if (receiver > 0) {
          if (receiver !== 1 / 0)
            return Math.round(receiver);
        } else if (receiver > -1 / 0)
          return 0 - Math.round(0 - receiver);
        throw H.wrapException(P.UnsupportedError$("" + receiver + ".round()"));
      },
      clamp$2: function(receiver, lowerLimit, upperLimit) {
        if (C.JSInt_methods.compareTo$1(lowerLimit, upperLimit) > 0)
          throw H.wrapException(H.argumentErrorValue(lowerLimit));
        if (this.compareTo$1(receiver, lowerLimit) < 0)
          return lowerLimit;
        if (this.compareTo$1(receiver, upperLimit) > 0)
          return upperLimit;
        return receiver;
      },
      toRadixString$1: function(receiver, radix) {
        var result, match, t1, exponent;
        if (radix < 2 || radix > 36)
          throw H.wrapException(P.RangeError$range(radix, 2, 36, "radix", null));
        result = receiver.toString(radix);
        if (C.JSString_methods.codeUnitAt$1(result, result.length - 1) !== 41)
          return result;
        match = /^([\da-z]+)(?:\.([\da-z]+))?\(e\+(\d+)\)$/.exec(result);
        if (match == null)
          H.throwExpression(P.UnsupportedError$("Unexpected toString result: " + result));
        t1 = J.getInterceptor$asx(match);
        result = t1.$index(match, 1);
        exponent = +t1.$index(match, 3);
        if (t1.$index(match, 2) != null) {
          result += t1.$index(match, 2);
          exponent -= t1.$index(match, 2).length;
        }
        return result + C.JSString_methods.$mul("0", exponent);
      },
      toString$0: function(receiver) {
        if (receiver === 0 && 1 / receiver < 0)
          return "-0.0";
        else
          return "" + receiver;
      },
      get$hashCode: function(receiver) {
        return receiver & 0x1FFFFFFF;
      },
      $negate: function(receiver) {
        return -receiver;
      },
      $add: function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver + other;
      },
      $sub: function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver - other;
      },
      $div: function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver / other;
      },
      $mul: function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver * other;
      },
      $mod: function(receiver, other) {
        var result;
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        result = receiver % other;
        if (result === 0)
          return 0;
        if (result > 0)
          return result;
        if (other < 0)
          return result - other;
        else
          return result + other;
      },
      $tdiv: function(receiver, other) {
        if ((receiver | 0) === receiver)
          if (other >= 1 || false)
            return receiver / other | 0;
        return this._tdivSlow$1(receiver, other);
      },
      _tdivFast$1: function(receiver, other) {
        return (receiver | 0) === receiver ? receiver / other | 0 : this._tdivSlow$1(receiver, other);
      },
      _tdivSlow$1: function(receiver, other) {
        var quotient = receiver / other;
        if (quotient >= -2147483648 && quotient <= 2147483647)
          return quotient | 0;
        if (quotient > 0) {
          if (quotient !== 1 / 0)
            return Math.floor(quotient);
        } else if (quotient > -1 / 0)
          return Math.ceil(quotient);
        throw H.wrapException(P.UnsupportedError$("Result of truncating division is " + H.S(quotient) + ": " + H.S(receiver) + " ~/ " + other));
      },
      $shl: function(receiver, other) {
        if (other < 0)
          throw H.wrapException(H.argumentErrorValue(other));
        return other > 31 ? 0 : receiver << other >>> 0;
      },
      $shr: function(receiver, other) {
        var t1;
        if (other < 0)
          throw H.wrapException(H.argumentErrorValue(other));
        if (receiver > 0)
          t1 = this._shrBothPositive$1(receiver, other);
        else {
          t1 = other > 31 ? 31 : other;
          t1 = receiver >> t1 >>> 0;
        }
        return t1;
      },
      _shrOtherPositive$1: function(receiver, other) {
        var t1;
        if (receiver > 0)
          t1 = this._shrBothPositive$1(receiver, other);
        else {
          t1 = other > 31 ? 31 : other;
          t1 = receiver >> t1 >>> 0;
        }
        return t1;
      },
      _shrReceiverPositive$1: function(receiver, other) {
        if (other < 0)
          throw H.wrapException(H.argumentErrorValue(other));
        return this._shrBothPositive$1(receiver, other);
      },
      _shrBothPositive$1: function(receiver, other) {
        return other > 31 ? 0 : receiver >>> other;
      },
      $and: function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return (receiver & other) >>> 0;
      },
      $lt: function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver < other;
      },
      $gt: function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver > other;
      },
      $le: function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver <= other;
      },
      $ge: function(receiver, other) {
        if (typeof other !== "number")
          throw H.wrapException(H.argumentErrorValue(other));
        return receiver >= other;
      },
      $isdouble: 1,
      $isnum: 1
    },
    JSInt: {
      "^": "JSNumber;",
      abs$0: function(receiver) {
        return Math.abs(receiver);
      },
      $negate: function(receiver) {
        return -receiver;
      },
      $isint: 1
    },
    JSDouble: {
      "^": "JSNumber;"
    },
    JSString: {
      "^": "Interceptor;",
      codeUnitAt$1: function(receiver, index) {
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        if (index < 0)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        if (index >= receiver.length)
          H.throwExpression(H.diagnoseIndexError(receiver, index));
        return receiver.charCodeAt(index);
      },
      _codeUnitAt$1: function(receiver, index) {
        if (index >= receiver.length)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        return receiver.charCodeAt(index);
      },
      allMatches$2: function(receiver, string, start) {
        var t1;
        if (typeof string !== "string")
          H.throwExpression(H.argumentErrorValue(string));
        t1 = string.length;
        if (start > t1)
          throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
        return new H._StringAllMatchesIterable(string, receiver, start);
      },
      allMatches$1: function($receiver, string) {
        return this.allMatches$2($receiver, string, 0);
      },
      matchAsPrefix$2: function(receiver, string, start) {
        var t1, t2, t3, i;
        t1 = J.getInterceptor$n(start);
        if (t1.$lt(start, 0) || t1.$gt(start, J.get$length$asx(string)))
          throw H.wrapException(P.RangeError$range(start, 0, J.get$length$asx(string), null, null));
        t2 = receiver.length;
        t3 = J.getInterceptor$asx(string);
        if (J.$gt$n(t1.$add(start, t2), t3.get$length(string)))
          return;
        for (i = 0; i < t2; ++i)
          if (t3.codeUnitAt$1(string, t1.$add(start, i)) !== this._codeUnitAt$1(receiver, i))
            return;
        return new H.StringMatch(start, string, receiver);
      },
      $add: function(receiver, other) {
        if (typeof other !== "string")
          throw H.wrapException(P.ArgumentError$value(other, null, null));
        return receiver + other;
      },
      endsWith$1: function(receiver, other) {
        var otherLength, t1;
        otherLength = other.length;
        t1 = receiver.length;
        if (otherLength > t1)
          return false;
        return other === this.substring$1(receiver, t1 - otherLength);
      },
      replaceAll$2: function(receiver, from, to) {
        return H.stringReplaceAllUnchecked(receiver, from, to);
      },
      replaceFirst$3: function(receiver, from, to, startIndex) {
        P.RangeError_checkValueInInterval(startIndex, 0, receiver.length, "startIndex", null);
        return H.stringReplaceFirstUnchecked(receiver, from, to, startIndex);
      },
      replaceFirst$2: function($receiver, from, to) {
        return this.replaceFirst$3($receiver, from, to, 0);
      },
      split$1: function(receiver, pattern) {
        var t1 = H.setRuntimeTypeInfo(receiver.split(pattern), [P.String]);
        return t1;
      },
      replaceRange$3: function(receiver, start, end, replacement) {
        if (typeof replacement !== "string")
          H.throwExpression(H.argumentErrorValue(replacement));
        if (typeof start !== "number" || Math.floor(start) !== start)
          H.throwExpression(H.argumentErrorValue(start));
        end = P.RangeError_checkValidRange(start, end, receiver.length, null, null, null);
        if (typeof end !== "number" || Math.floor(end) !== end)
          H.throwExpression(H.argumentErrorValue(end));
        return H.stringReplaceRangeUnchecked(receiver, start, end, replacement);
      },
      startsWith$2: function(receiver, pattern, index) {
        var t1, endIndex;
        if (typeof index !== "number" || Math.floor(index) !== index)
          H.throwExpression(H.argumentErrorValue(index));
        t1 = J.getInterceptor$n(index);
        if (t1.$lt(index, 0) || t1.$gt(index, receiver.length))
          throw H.wrapException(P.RangeError$range(index, 0, receiver.length, null, null));
        if (typeof pattern === "string") {
          endIndex = t1.$add(index, pattern.length);
          if (J.$gt$n(endIndex, receiver.length))
            return false;
          return pattern === receiver.substring(index, endIndex);
        }
        return J.matchAsPrefix$2$s(pattern, receiver, index) != null;
      },
      startsWith$1: function($receiver, pattern) {
        return this.startsWith$2($receiver, pattern, 0);
      },
      substring$2: function(receiver, startIndex, endIndex) {
        var t1;
        if (typeof startIndex !== "number" || Math.floor(startIndex) !== startIndex)
          H.throwExpression(H.argumentErrorValue(startIndex));
        if (endIndex == null)
          endIndex = receiver.length;
        if (typeof endIndex !== "number" || Math.floor(endIndex) !== endIndex)
          H.throwExpression(H.argumentErrorValue(endIndex));
        t1 = J.getInterceptor$n(startIndex);
        if (t1.$lt(startIndex, 0))
          throw H.wrapException(P.RangeError$value(startIndex, null, null));
        if (t1.$gt(startIndex, endIndex))
          throw H.wrapException(P.RangeError$value(startIndex, null, null));
        if (J.$gt$n(endIndex, receiver.length))
          throw H.wrapException(P.RangeError$value(endIndex, null, null));
        return receiver.substring(startIndex, endIndex);
      },
      substring$1: function($receiver, startIndex) {
        return this.substring$2($receiver, startIndex, null);
      },
      toLowerCase$0: function(receiver) {
        return receiver.toLowerCase();
      },
      trim$0: function(receiver) {
        var result, endIndex, startIndex, t1, endIndex0;
        result = receiver.trim();
        endIndex = result.length;
        if (endIndex === 0)
          return result;
        if (this._codeUnitAt$1(result, 0) === 133) {
          startIndex = J.JSString__skipLeadingWhitespace(result, 1);
          if (startIndex === endIndex)
            return "";
        } else
          startIndex = 0;
        t1 = endIndex - 1;
        endIndex0 = this.codeUnitAt$1(result, t1) === 133 ? J.JSString__skipTrailingWhitespace(result, t1) : endIndex;
        if (startIndex === 0 && endIndex0 === endIndex)
          return result;
        return result.substring(startIndex, endIndex0);
      },
      trimLeft$0: function(receiver) {
        var result, startIndex;
        if (typeof receiver.trimLeft != "undefined") {
          result = receiver.trimLeft();
          if (result.length === 0)
            return result;
          startIndex = this._codeUnitAt$1(result, 0) === 133 ? J.JSString__skipLeadingWhitespace(result, 1) : 0;
        } else {
          startIndex = J.JSString__skipLeadingWhitespace(receiver, 0);
          result = receiver;
        }
        if (startIndex === 0)
          return result;
        if (startIndex === result.length)
          return "";
        return result.substring(startIndex);
      },
      trimRight$0: function(receiver) {
        var result, endIndex, t1;
        if (typeof receiver.trimRight != "undefined") {
          result = receiver.trimRight();
          endIndex = result.length;
          if (endIndex === 0)
            return result;
          t1 = endIndex - 1;
          if (this.codeUnitAt$1(result, t1) === 133)
            endIndex = J.JSString__skipTrailingWhitespace(result, t1);
        } else {
          endIndex = J.JSString__skipTrailingWhitespace(receiver, receiver.length);
          result = receiver;
        }
        if (endIndex === result.length)
          return result;
        if (endIndex === 0)
          return "";
        return result.substring(0, endIndex);
      },
      $mul: function(receiver, times) {
        var s, result;
        if (typeof times !== "number")
          return H.iae(times);
        if (0 >= times)
          return "";
        if (times === 1 || receiver.length === 0)
          return receiver;
        if (times !== times >>> 0)
          throw H.wrapException(C.C_OutOfMemoryError);
        for (s = receiver, result = ""; true;) {
          if ((times & 1) === 1)
            result = s + result;
          times = times >>> 1;
          if (times === 0)
            break;
          s += s;
        }
        return result;
      },
      padLeft$2: function(receiver, width, padding) {
        var delta = width - receiver.length;
        if (delta <= 0)
          return receiver;
        return this.$mul(padding, delta) + receiver;
      },
      padRight$2: function(receiver, width, padding) {
        var delta = J.$sub$n(width, receiver.length);
        if (J.$le$n(delta, 0))
          return receiver;
        return receiver + this.$mul(padding, delta);
      },
      padRight$1: function($receiver, width) {
        return this.padRight$2($receiver, width, " ");
      },
      get$codeUnits: function(receiver) {
        return new H.CodeUnits(receiver);
      },
      get$runes: function(receiver) {
        return new P.Runes(receiver);
      },
      indexOf$2: function(receiver, pattern, start) {
        var t1, match, t2, i;
        if (pattern == null)
          H.throwExpression(H.argumentErrorValue(pattern));
        if (start < 0 || start > receiver.length)
          throw H.wrapException(P.RangeError$range(start, 0, receiver.length, null, null));
        if (typeof pattern === "string")
          return receiver.indexOf(pattern, start);
        t1 = J.getInterceptor(pattern);
        if (!!t1.$isJSSyntaxRegExp) {
          match = pattern._execGlobal$2(receiver, start);
          return match == null ? -1 : match._match.index;
        }
        for (t2 = receiver.length, i = start; i <= t2; ++i)
          if (t1.matchAsPrefix$2(pattern, receiver, i) != null)
            return i;
        return -1;
      },
      indexOf$1: function($receiver, pattern) {
        return this.indexOf$2($receiver, pattern, 0);
      },
      lastIndexOf$2: function(receiver, pattern, start) {
        var t1, t2, i;
        if (pattern == null)
          H.throwExpression(H.argumentErrorValue(pattern));
        if (start == null)
          start = receiver.length;
        else if (typeof start !== "number" || Math.floor(start) !== start)
          throw H.wrapException(H.argumentErrorValue(start));
        else if (start < 0 || start > receiver.length)
          throw H.wrapException(P.RangeError$range(start, 0, receiver.length, null, null));
        if (typeof pattern === "string") {
          t1 = pattern.length;
          t2 = receiver.length;
          if (start + t1 > t2)
            start = t2 - t1;
          return receiver.lastIndexOf(pattern, start);
        }
        for (t1 = J.getInterceptor$s(pattern), i = start; i >= 0; --i)
          if (t1.matchAsPrefix$2(pattern, receiver, i) != null)
            return i;
        return -1;
      },
      lastIndexOf$1: function($receiver, pattern) {
        return this.lastIndexOf$2($receiver, pattern, null);
      },
      contains$2: function(receiver, other, startIndex) {
        if (other == null)
          H.throwExpression(H.argumentErrorValue(other));
        if (startIndex > receiver.length)
          throw H.wrapException(P.RangeError$range(startIndex, 0, receiver.length, null, null));
        return H.stringContainsUnchecked(receiver, other, startIndex);
      },
      contains$1: function($receiver, other) {
        return this.contains$2($receiver, other, 0);
      },
      get$isEmpty: function(receiver) {
        return receiver.length === 0;
      },
      get$isNotEmpty: function(receiver) {
        return receiver.length !== 0;
      },
      compareTo$1: function(receiver, other) {
        var t1;
        if (typeof other !== "string")
          throw H.wrapException(H.argumentErrorValue(other));
        if (receiver === other)
          t1 = 0;
        else
          t1 = receiver < other ? -1 : 1;
        return t1;
      },
      toString$0: function(receiver) {
        return receiver;
      },
      get$hashCode: function(receiver) {
        var t1, hash, i;
        for (t1 = receiver.length, hash = 0, i = 0; i < t1; ++i) {
          hash = 536870911 & hash + receiver.charCodeAt(i);
          hash = 536870911 & hash + ((524287 & hash) << 10);
          hash ^= hash >> 6;
        }
        hash = 536870911 & hash + ((67108863 & hash) << 3);
        hash ^= hash >> 11;
        return 536870911 & hash + ((16383 & hash) << 15);
      },
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        if (index >= receiver.length || index < 0)
          throw H.wrapException(H.diagnoseIndexError(receiver, index));
        return receiver[index];
      },
      $isString: 1,
      static: {
        JSString__isWhitespace: function(codeUnit) {
          if (codeUnit < 256)
            switch (codeUnit) {
              case 9:
              case 10:
              case 11:
              case 12:
              case 13:
              case 32:
              case 133:
              case 160:
                return true;
              default:
                return false;
            }
          switch (codeUnit) {
            case 5760:
            case 8192:
            case 8193:
            case 8194:
            case 8195:
            case 8196:
            case 8197:
            case 8198:
            case 8199:
            case 8200:
            case 8201:
            case 8202:
            case 8232:
            case 8233:
            case 8239:
            case 8287:
            case 12288:
            case 65279:
              return true;
            default:
              return false;
          }
        },
        JSString__skipLeadingWhitespace: function(string, index) {
          var t1, codeUnit;
          for (t1 = string.length; index < t1;) {
            codeUnit = C.JSString_methods._codeUnitAt$1(string, index);
            if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
              break;
            ++index;
          }
          return index;
        },
        JSString__skipTrailingWhitespace: function(string, index) {
          var index0, codeUnit;
          for (; index > 0; index = index0) {
            index0 = index - 1;
            codeUnit = C.JSString_methods.codeUnitAt$1(string, index0);
            if (codeUnit !== 32 && codeUnit !== 13 && !J.JSString__isWhitespace(codeUnit))
              break;
          }
          return index;
        }
      }
    }
  }], ["dart._internal", "dart:_internal",, H, {
    "^": "",
    hexDigitValue: function(char) {
      var digit, letter;
      digit = char ^ 48;
      if (digit <= 9)
        return digit;
      letter = char | 32;
      if (97 <= letter && letter <= 102)
        return letter - 87;
      return -1;
    },
    _checkCount: function(count) {
      if (typeof count !== "number" || Math.floor(count) !== count)
        throw H.wrapException(P.ArgumentError$value(count, "count", "is not an integer"));
      if (count < 0)
        H.throwExpression(P.RangeError$range(count, 0, null, "count", null));
      return count;
    },
    IterableElementError_noElement: function() {
      return new P.StateError("No element");
    },
    IterableElementError_tooMany: function() {
      return new P.StateError("Too many elements");
    },
    IterableElementError_tooFew: function() {
      return new P.StateError("Too few elements");
    },
    Sort_sort: function(a, compare) {
      H.Sort__doSort(a, 0, J.$sub$n(J.get$length$asx(a), 1), compare);
    },
    Sort__doSort: function(a, left, right, compare) {
      if (J.$le$n(J.$sub$n(right, left), 32))
        H.Sort__insertionSort(a, left, right, compare);
      else
        H.Sort__dualPivotQuicksort(a, left, right, compare);
    },
    Sort__insertionSort: function(a, left, right, compare) {
      var i, t1, t2, el, j, t3;
      for (i = J.$add$ansx(left, 1), t1 = J.getInterceptor$asx(a); t2 = J.getInterceptor$n(i), t2.$le(i, right); i = t2.$add(i, 1)) {
        el = t1.$index(a, i);
        j = i;
        while (true) {
          t3 = J.getInterceptor$n(j);
          if (!(t3.$gt(j, left) && J.$gt$n(compare.call$2(t1.$index(a, t3.$sub(j, 1)), el), 0)))
            break;
          t1.$indexSet(a, j, t1.$index(a, t3.$sub(j, 1)));
          j = t3.$sub(j, 1);
        }
        t1.$indexSet(a, j, el);
      }
    },
    Sort__dualPivotQuicksort: function(a, left, right, compare) {
      var t1, sixth, t2, index1, index5, index3, t3, index2, index4, el1, el2, el3, el4, el5, t0, less, great, k, ak, comp, t4, t5, less0, great0;
      t1 = J.getInterceptor$n(right);
      sixth = J.$tdiv$n(J.$add$ansx(t1.$sub(right, left), 1), 6);
      t2 = J.getInterceptor$ansx(left);
      index1 = t2.$add(left, sixth);
      index5 = t1.$sub(right, sixth);
      index3 = J.$tdiv$n(t2.$add(left, right), 2);
      t3 = J.getInterceptor$n(index3);
      index2 = t3.$sub(index3, sixth);
      index4 = t3.$add(index3, sixth);
      t3 = J.getInterceptor$asx(a);
      el1 = t3.$index(a, index1);
      el2 = t3.$index(a, index2);
      el3 = t3.$index(a, index3);
      el4 = t3.$index(a, index4);
      el5 = t3.$index(a, index5);
      if (J.$gt$n(compare.call$2(el1, el2), 0)) {
        t0 = el2;
        el2 = el1;
        el1 = t0;
      }
      if (J.$gt$n(compare.call$2(el4, el5), 0)) {
        t0 = el5;
        el5 = el4;
        el4 = t0;
      }
      if (J.$gt$n(compare.call$2(el1, el3), 0)) {
        t0 = el3;
        el3 = el1;
        el1 = t0;
      }
      if (J.$gt$n(compare.call$2(el2, el3), 0)) {
        t0 = el3;
        el3 = el2;
        el2 = t0;
      }
      if (J.$gt$n(compare.call$2(el1, el4), 0)) {
        t0 = el4;
        el4 = el1;
        el1 = t0;
      }
      if (J.$gt$n(compare.call$2(el3, el4), 0)) {
        t0 = el4;
        el4 = el3;
        el3 = t0;
      }
      if (J.$gt$n(compare.call$2(el2, el5), 0)) {
        t0 = el5;
        el5 = el2;
        el2 = t0;
      }
      if (J.$gt$n(compare.call$2(el2, el3), 0)) {
        t0 = el3;
        el3 = el2;
        el2 = t0;
      }
      if (J.$gt$n(compare.call$2(el4, el5), 0)) {
        t0 = el5;
        el5 = el4;
        el4 = t0;
      }
      t3.$indexSet(a, index1, el1);
      t3.$indexSet(a, index3, el3);
      t3.$indexSet(a, index5, el5);
      t3.$indexSet(a, index2, t3.$index(a, left));
      t3.$indexSet(a, index4, t3.$index(a, right));
      less = t2.$add(left, 1);
      great = t1.$sub(right, 1);
      t1 = J.$eq$(compare.call$2(el2, el4), 0) === true;
      if (t1)
        for (k = less; t2 = J.getInterceptor$n(k), t2.$le(k, great); k = t2.$add(k, 1)) {
          ak = t3.$index(a, k);
          comp = compare.call$2(ak, el2);
          t4 = J.getInterceptor(comp);
          if (t4.$eq(comp, 0) === true)
            continue;
          if (t4.$lt(comp, 0)) {
            if (!t2.$eq(k, less)) {
              t3.$indexSet(a, k, t3.$index(a, less));
              t3.$indexSet(a, less, ak);
            }
            less = J.$add$ansx(less, 1);
          } else
            for (; true;) {
              comp = compare.call$2(t3.$index(a, great), el2);
              t4 = J.getInterceptor$n(comp);
              if (t4.$gt(comp, 0)) {
                great = J.$sub$n(great, 1);
                continue;
              } else {
                t5 = J.getInterceptor$n(great);
                if (t4.$lt(comp, 0)) {
                  t3.$indexSet(a, k, t3.$index(a, less));
                  less0 = J.$add$ansx(less, 1);
                  t3.$indexSet(a, less, t3.$index(a, great));
                  great0 = t5.$sub(great, 1);
                  t3.$indexSet(a, great, ak);
                  great = great0;
                  less = less0;
                  break;
                } else {
                  t3.$indexSet(a, k, t3.$index(a, great));
                  great0 = t5.$sub(great, 1);
                  t3.$indexSet(a, great, ak);
                  great = great0;
                  break;
                }
              }
            }
        }
      else
        for (k = less; t2 = J.getInterceptor$n(k), t2.$le(k, great); k = t2.$add(k, 1)) {
          ak = t3.$index(a, k);
          if (J.$lt$n(compare.call$2(ak, el2), 0)) {
            if (!t2.$eq(k, less)) {
              t3.$indexSet(a, k, t3.$index(a, less));
              t3.$indexSet(a, less, ak);
            }
            less = J.$add$ansx(less, 1);
          } else if (J.$gt$n(compare.call$2(ak, el4), 0))
            for (; true;)
              if (J.$gt$n(compare.call$2(t3.$index(a, great), el4), 0)) {
                great = J.$sub$n(great, 1);
                if (J.$lt$n(great, k))
                  break;
                continue;
              } else {
                t4 = J.getInterceptor$n(great);
                if (J.$lt$n(compare.call$2(t3.$index(a, great), el2), 0)) {
                  t3.$indexSet(a, k, t3.$index(a, less));
                  less0 = J.$add$ansx(less, 1);
                  t3.$indexSet(a, less, t3.$index(a, great));
                  great0 = t4.$sub(great, 1);
                  t3.$indexSet(a, great, ak);
                  great = great0;
                  less = less0;
                } else {
                  t3.$indexSet(a, k, t3.$index(a, great));
                  great0 = t4.$sub(great, 1);
                  t3.$indexSet(a, great, ak);
                  great = great0;
                }
                break;
              }
        }
      t2 = J.getInterceptor$n(less);
      t3.$indexSet(a, left, t3.$index(a, t2.$sub(less, 1)));
      t3.$indexSet(a, t2.$sub(less, 1), el2);
      t4 = J.getInterceptor$ansx(great);
      t3.$indexSet(a, right, t3.$index(a, t4.$add(great, 1)));
      t3.$indexSet(a, t4.$add(great, 1), el4);
      H.Sort__doSort(a, left, t2.$sub(less, 2), compare);
      H.Sort__doSort(a, t4.$add(great, 2), right, compare);
      if (t1)
        return;
      if (t2.$lt(less, index1) && t4.$gt(great, index5)) {
        for (; J.$eq$(compare.call$2(t3.$index(a, less), el2), 0) === true;)
          less = J.$add$ansx(less, 1);
        for (; J.$eq$(compare.call$2(t3.$index(a, great), el4), 0) === true;)
          great = J.$sub$n(great, 1);
        for (k = less; t1 = J.getInterceptor$n(k), t1.$le(k, great); k = t1.$add(k, 1)) {
          ak = t3.$index(a, k);
          if (J.$eq$(compare.call$2(ak, el2), 0) === true) {
            if (!t1.$eq(k, less)) {
              t3.$indexSet(a, k, t3.$index(a, less));
              t3.$indexSet(a, less, ak);
            }
            less = J.$add$ansx(less, 1);
          } else if (J.$eq$(compare.call$2(ak, el4), 0) === true)
            for (; true;)
              if (J.$eq$(compare.call$2(t3.$index(a, great), el4), 0) === true) {
                great = J.$sub$n(great, 1);
                if (J.$lt$n(great, k))
                  break;
                continue;
              } else {
                t2 = J.getInterceptor$n(great);
                if (J.$lt$n(compare.call$2(t3.$index(a, great), el2), 0)) {
                  t3.$indexSet(a, k, t3.$index(a, less));
                  less0 = J.$add$ansx(less, 1);
                  t3.$indexSet(a, less, t3.$index(a, great));
                  great0 = t2.$sub(great, 1);
                  t3.$indexSet(a, great, ak);
                  great = great0;
                  less = less0;
                } else {
                  t3.$indexSet(a, k, t3.$index(a, great));
                  great0 = t2.$sub(great, 1);
                  t3.$indexSet(a, great, ak);
                  great = great0;
                }
                break;
              }
        }
        H.Sort__doSort(a, less, great, compare);
      } else
        H.Sort__doSort(a, less, great, compare);
    },
    _CastIterableBase: {
      "^": "Iterable;$ti",
      get$iterator: function(_) {
        return new H.CastIterator(J.get$iterator$ax(this.get$_source()), this.$ti);
      },
      get$length: function(_) {
        return J.get$length$asx(this.get$_source());
      },
      get$isEmpty: function(_) {
        return J.get$isEmpty$asx(this.get$_source());
      },
      get$isNotEmpty: function(_) {
        return J.get$isNotEmpty$asx(this.get$_source());
      },
      skip$1: function(_, count) {
        return H.CastIterable_CastIterable(J.skip$1$ax(this.get$_source(), count), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
      },
      take$1: function(_, count) {
        return H.CastIterable_CastIterable(J.take$1$ax(this.get$_source(), count), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
      },
      elementAt$1: function(_, index) {
        return H.subtypeOfRuntimeTypeCast(J.elementAt$1$ax(this.get$_source(), index), H.getTypeArgumentByIndex(this, 1));
      },
      get$first: function(_) {
        return H.subtypeOfRuntimeTypeCast(J.get$first$ax(this.get$_source()), H.getTypeArgumentByIndex(this, 1));
      },
      get$last: function(_) {
        return H.subtypeOfRuntimeTypeCast(J.get$last$ax(this.get$_source()), H.getTypeArgumentByIndex(this, 1));
      },
      get$single: function(_) {
        return H.subtypeOfRuntimeTypeCast(J.get$single$ax(this.get$_source()), H.getTypeArgumentByIndex(this, 1));
      },
      contains$1: function(_, other) {
        return J.contains$1$asx(this.get$_source(), other);
      },
      toString$0: function(_) {
        return J.toString$0$(this.get$_source());
      },
      $asIterable: function($S, $T) {
        return [$T];
      }
    },
    CastIterator: {
      "^": "Object;_source,$ti",
      moveNext$0: function() {
        return this._source.moveNext$0();
      },
      get$current: function(_) {
        var t1 = this._source;
        return H.subtypeOfRuntimeTypeCast(t1.get$current(t1), H.getTypeArgumentByIndex(this, 1));
      }
    },
    CastIterable: {
      "^": "_CastIterableBase;_source<,$ti",
      static: {
        CastIterable_CastIterable: function(source, $S, $T) {
          var t1 = H.checkSubtypeV1(source, "$isEfficientLengthIterable", [$S], "$asEfficientLengthIterable");
          if (t1)
            return new H._EfficientLengthCastIterable(source, [$S, $T]);
          return new H.CastIterable(source, [$S, $T]);
        }
      }
    },
    _EfficientLengthCastIterable: {
      "^": "CastIterable;_source,$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function($S, $T) {
        return [$T];
      }
    },
    _CastListBase: {
      "^": "__CastListBase__CastIterableBase_ListMixin;$ti",
      $index: function(_, index) {
        return H.subtypeOfRuntimeTypeCast(J.$index$asx(this._source, index), H.getTypeArgumentByIndex(this, 1));
      },
      $indexSet: function(_, index, value) {
        J.$indexSet$ax(this._source, index, H.subtypeOfRuntimeTypeCast(value, H.getTypeArgumentByIndex(this, 0)));
      },
      set$length: function(_, $length) {
        J.set$length$asx(this._source, $length);
      },
      add$1: function(_, value) {
        J.add$1$ax(this._source, H.subtypeOfRuntimeTypeCast(value, H.getTypeArgumentByIndex(this, 0)));
      },
      remove$1: function(_, value) {
        return J.remove$1$ax(this._source, value);
      },
      setRange$4: function(_, start, end, iterable, skipCount) {
        J.setRange$4$ax(this._source, start, end, H.CastIterable_CastIterable(iterable, H.getTypeArgumentByIndex(this, 1), H.getTypeArgumentByIndex(this, 0)), skipCount);
      },
      setRange$3: function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      },
      fillRange$3: function(_, start, end, fillValue) {
        J.fillRange$3$ax(this._source, start, end, H.subtypeOfRuntimeTypeCast(fillValue, H.getTypeArgumentByIndex(this, 0)));
      },
      replaceRange$3: function(_, start, end, replacement) {
        J.replaceRange$3$asx(this._source, start, end, H.CastIterable_CastIterable(replacement, H.getTypeArgumentByIndex(this, 1), H.getTypeArgumentByIndex(this, 0)));
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function($S, $T) {
        return [$T];
      },
      $asListMixin: function($S, $T) {
        return [$T];
      },
      $isList: 1,
      $asList: function($S, $T) {
        return [$T];
      }
    },
    CastList: {
      "^": "_CastListBase;_source<,$ti",
      cast$0: function(_) {
        return new H.CastList(this._source, [H.getTypeArgumentByIndex(this, 0), null]);
      }
    },
    CodeUnits: {
      "^": "UnmodifiableListBase;__internal$_string",
      get$length: function(_) {
        return this.__internal$_string.length;
      },
      $index: function(_, i) {
        return C.JSString_methods.codeUnitAt$1(this.__internal$_string, i);
      },
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asUnmodifiableListMixin: function() {
        return [P.int];
      },
      $asUnmodifiableListBase: function() {
        return [P.int];
      },
      $asListBase: function() {
        return [P.int];
      },
      $asListMixin: function() {
        return [P.int];
      },
      $asIterable: function() {
        return [P.int];
      },
      $asList: function() {
        return [P.int];
      },
      $as_ListBase_Object_ListMixin: function() {
        return [P.int];
      }
    },
    EfficientLengthIterable: {
      "^": "Iterable;$ti"
    },
    ListIterable: {
      "^": "EfficientLengthIterable;$ti",
      get$iterator: function(_) {
        return new H.ListIterator(this, this.get$length(this), 0, null, [H.getRuntimeTypeArgument(this, "ListIterable", 0)]);
      },
      forEach$1: function(_, action) {
        var $length, i;
        $length = this.get$length(this);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          action.call$1(this.elementAt$1(0, i));
          if ($length !== this.get$length(this))
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
      },
      get$isEmpty: function(_) {
        return J.$eq$(this.get$length(this), 0);
      },
      get$first: function(_) {
        if (J.$eq$(this.get$length(this), 0) === true)
          throw H.wrapException(H.IterableElementError_noElement());
        return this.elementAt$1(0, 0);
      },
      get$last: function(_) {
        if (J.$eq$(this.get$length(this), 0) === true)
          throw H.wrapException(H.IterableElementError_noElement());
        return this.elementAt$1(0, J.$sub$n(this.get$length(this), 1));
      },
      get$single: function(_) {
        if (J.$eq$(this.get$length(this), 0) === true)
          throw H.wrapException(H.IterableElementError_noElement());
        if (J.$gt$n(this.get$length(this), 1))
          throw H.wrapException(H.IterableElementError_tooMany());
        return this.elementAt$1(0, 0);
      },
      contains$1: function(_, element) {
        var $length, i;
        $length = this.get$length(this);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          if (J.$eq$(this.elementAt$1(0, i), element) === true)
            return true;
          if ($length !== this.get$length(this))
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
        return false;
      },
      every$1: function(_, test) {
        var $length, i;
        $length = this.get$length(this);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          if (test.call$1(this.elementAt$1(0, i)) !== true)
            return false;
          if ($length !== this.get$length(this))
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
        return true;
      },
      any$1: function(_, test) {
        var $length, i;
        $length = this.get$length(this);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          if (test.call$1(this.elementAt$1(0, i)) === true)
            return true;
          if ($length !== this.get$length(this))
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
        return false;
      },
      firstWhere$2$orElse: function(_, test, orElse) {
        var $length, i, element;
        $length = this.get$length(this);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          element = this.elementAt$1(0, i);
          if (test.call$1(element) === true)
            return element;
          if ($length !== this.get$length(this))
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
        return orElse.call$0();
      },
      join$1: function(_, separator) {
        var $length, t1, first, i;
        $length = this.get$length(this);
        if (separator.length !== 0) {
          t1 = J.getInterceptor($length);
          if (t1.$eq($length, 0) === true)
            return "";
          first = H.S(this.elementAt$1(0, 0));
          if (t1.$eq($length, this.get$length(this)) !== true)
            throw H.wrapException(P.ConcurrentModificationError$(this));
          if (typeof $length !== "number")
            return H.iae($length);
          t1 = first;
          i = 1;
          for (; i < $length; ++i) {
            t1 = t1 + separator + H.S(this.elementAt$1(0, i));
            if ($length !== this.get$length(this))
              throw H.wrapException(P.ConcurrentModificationError$(this));
          }
          return t1.charCodeAt(0) == 0 ? t1 : t1;
        } else {
          if (typeof $length !== "number")
            return H.iae($length);
          i = 0;
          t1 = "";
          for (; i < $length; ++i) {
            t1 += H.S(this.elementAt$1(0, i));
            if ($length !== this.get$length(this))
              throw H.wrapException(P.ConcurrentModificationError$(this));
          }
          return t1.charCodeAt(0) == 0 ? t1 : t1;
        }
      },
      join$0: function($receiver) {
        return this.join$1($receiver, "");
      },
      where$1: function(_, test) {
        return this.super$Iterable$where(0, test);
      },
      map$1: function(_, f) {
        return new H.MappedListIterable(this, f, [H.getRuntimeTypeArgument(this, "ListIterable", 0), null]);
      },
      reduce$1: function(_, combine) {
        var $length, value, i;
        $length = this.get$length(this);
        if (J.$eq$($length, 0) === true)
          throw H.wrapException(H.IterableElementError_noElement());
        value = this.elementAt$1(0, 0);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 1;
        for (; i < $length; ++i) {
          value = combine.call$2(value, this.elementAt$1(0, i));
          if ($length !== this.get$length(this))
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
        return value;
      },
      fold$2: function(_, initialValue, combine) {
        var $length, value, i;
        $length = this.get$length(this);
        if (typeof $length !== "number")
          return H.iae($length);
        value = initialValue;
        i = 0;
        for (; i < $length; ++i) {
          value = combine.call$2(value, this.elementAt$1(0, i));
          if ($length !== this.get$length(this))
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
        return value;
      },
      skip$1: function(_, count) {
        return H.SubListIterable$(this, count, null, H.getRuntimeTypeArgument(this, "ListIterable", 0));
      },
      take$1: function(_, count) {
        return H.SubListIterable$(this, 0, count, H.getRuntimeTypeArgument(this, "ListIterable", 0));
      },
      toList$1$growable: function(_, growable) {
        var t1, result, t2, i;
        t1 = H.getRuntimeTypeArgument(this, "ListIterable", 0);
        if (growable) {
          result = H.setRuntimeTypeInfo([], [t1]);
          C.JSArray_methods.set$length(result, this.get$length(this));
        } else {
          t2 = this.get$length(this);
          if (typeof t2 !== "number")
            return H.iae(t2);
          t2 = new Array(t2);
          t2.fixed$length = Array;
          result = H.setRuntimeTypeInfo(t2, [t1]);
        }
        i = 0;
        while (true) {
          t1 = this.get$length(this);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          t1 = this.elementAt$1(0, i);
          if (i >= result.length)
            return H.ioore(result, i);
          result[i] = t1;
          ++i;
        }
        return result;
      },
      toList$0: function($receiver) {
        return this.toList$1$growable($receiver, true);
      }
    },
    SubListIterable: {
      "^": "ListIterable;__internal$_iterable,_start,_endOrLength,$ti",
      SubListIterable$3: function(_iterable, _start, _endOrLength, $E) {
        var t1, t2, t3;
        t1 = this._start;
        t2 = J.getInterceptor$n(t1);
        if (t2.$lt(t1, 0))
          H.throwExpression(P.RangeError$range(t1, 0, null, "start", null));
        t3 = this._endOrLength;
        if (t3 != null) {
          if (J.$lt$n(t3, 0))
            H.throwExpression(P.RangeError$range(t3, 0, null, "end", null));
          if (t2.$gt(t1, t3))
            throw H.wrapException(P.RangeError$range(t1, 0, t3, "start", null));
        }
      },
      get$_endIndex: function() {
        var $length, t1;
        $length = J.get$length$asx(this.__internal$_iterable);
        t1 = this._endOrLength;
        if (t1 == null || J.$gt$n(t1, $length))
          return $length;
        return t1;
      },
      get$_startIndex: function() {
        var $length, t1;
        $length = J.get$length$asx(this.__internal$_iterable);
        t1 = this._start;
        if (J.$gt$n(t1, $length))
          return $length;
        return t1;
      },
      get$length: function(_) {
        var $length, t1, t2;
        $length = J.get$length$asx(this.__internal$_iterable);
        t1 = this._start;
        if (J.$ge$n(t1, $length))
          return 0;
        t2 = this._endOrLength;
        if (t2 == null || J.$ge$n(t2, $length))
          return J.$sub$n($length, t1);
        return J.$sub$n(t2, t1);
      },
      elementAt$1: function(_, index) {
        var realIndex = J.$add$ansx(this.get$_startIndex(), index);
        if (J.$lt$n(index, 0) || J.$ge$n(realIndex, this.get$_endIndex()))
          throw H.wrapException(P.IndexError$(index, this, "index", null, null));
        return J.elementAt$1$ax(this.__internal$_iterable, realIndex);
      },
      skip$1: function(_, count) {
        var newStart, t1;
        if (J.$lt$n(count, 0))
          H.throwExpression(P.RangeError$range(count, 0, null, "count", null));
        newStart = J.$add$ansx(this._start, count);
        t1 = this._endOrLength;
        if (t1 != null && J.$ge$n(newStart, t1))
          return new H.EmptyIterable(this.$ti);
        return H.SubListIterable$(this.__internal$_iterable, newStart, t1, H.getTypeArgumentByIndex(this, 0));
      },
      take$1: function(_, count) {
        var t1, t2, newEnd;
        if (J.$lt$n(count, 0))
          H.throwExpression(P.RangeError$range(count, 0, null, "count", null));
        t1 = this._endOrLength;
        t2 = this._start;
        if (t1 == null)
          return H.SubListIterable$(this.__internal$_iterable, t2, J.$add$ansx(t2, count), H.getTypeArgumentByIndex(this, 0));
        else {
          newEnd = J.$add$ansx(t2, count);
          if (J.$lt$n(t1, newEnd))
            return this;
          return H.SubListIterable$(this.__internal$_iterable, t2, newEnd, H.getTypeArgumentByIndex(this, 0));
        }
      },
      toList$1$growable: function(_, growable) {
        var start, t1, t2, end, end0, $length, t3, result, t4, i;
        start = this._start;
        t1 = this.__internal$_iterable;
        t2 = J.getInterceptor$asx(t1);
        end = t2.get$length(t1);
        end0 = this._endOrLength;
        if (end0 != null && J.$lt$n(end0, end))
          end = end0;
        $length = J.$sub$n(end, start);
        if (J.$lt$n($length, 0))
          $length = 0;
        t3 = this.$ti;
        if (growable) {
          result = H.setRuntimeTypeInfo([], t3);
          C.JSArray_methods.set$length(result, $length);
        } else {
          if (typeof $length !== "number")
            return H.iae($length);
          t4 = new Array($length);
          t4.fixed$length = Array;
          result = H.setRuntimeTypeInfo(t4, t3);
        }
        if (typeof $length !== "number")
          return H.iae($length);
        t3 = J.getInterceptor$ansx(start);
        i = 0;
        for (; i < $length; ++i) {
          t4 = t2.elementAt$1(t1, t3.$add(start, i));
          if (i >= result.length)
            return H.ioore(result, i);
          result[i] = t4;
          if (J.$lt$n(t2.get$length(t1), end))
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
        return result;
      },
      toList$0: function($receiver) {
        return this.toList$1$growable($receiver, true);
      },
      static: {
        SubListIterable$: function(_iterable, _start, _endOrLength, $E) {
          var t1 = new H.SubListIterable(_iterable, _start, _endOrLength, [$E]);
          t1.SubListIterable$3(_iterable, _start, _endOrLength, $E);
          return t1;
        }
      }
    },
    ListIterator: {
      "^": "Object;__internal$_iterable,__internal$_length,__internal$_index,__internal$_current,$ti",
      get$current: function(_) {
        return this.__internal$_current;
      },
      moveNext$0: function() {
        var t1, t2, $length, t3;
        t1 = this.__internal$_iterable;
        t2 = J.getInterceptor$asx(t1);
        $length = t2.get$length(t1);
        if (J.$eq$(this.__internal$_length, $length) !== true)
          throw H.wrapException(P.ConcurrentModificationError$(t1));
        t3 = this.__internal$_index;
        if (typeof $length !== "number")
          return H.iae($length);
        if (t3 >= $length) {
          this.__internal$_current = null;
          return false;
        }
        this.__internal$_current = t2.elementAt$1(t1, t3);
        ++this.__internal$_index;
        return true;
      }
    },
    MappedIterable: {
      "^": "Iterable;__internal$_iterable,_f,$ti",
      get$iterator: function(_) {
        return new H.MappedIterator(null, J.get$iterator$ax(this.__internal$_iterable), this._f, this.$ti);
      },
      get$length: function(_) {
        return J.get$length$asx(this.__internal$_iterable);
      },
      get$isEmpty: function(_) {
        return J.get$isEmpty$asx(this.__internal$_iterable);
      },
      get$first: function(_) {
        return this._f.call$1(J.get$first$ax(this.__internal$_iterable));
      },
      get$last: function(_) {
        return this._f.call$1(J.get$last$ax(this.__internal$_iterable));
      },
      get$single: function(_) {
        return this._f.call$1(J.get$single$ax(this.__internal$_iterable));
      },
      elementAt$1: function(_, index) {
        return this._f.call$1(J.elementAt$1$ax(this.__internal$_iterable, index));
      },
      $asIterable: function($S, $T) {
        return [$T];
      },
      static: {
        MappedIterable_MappedIterable: function(iterable, $function, $S, $T) {
          if (!!J.getInterceptor(iterable).$isEfficientLengthIterable)
            return new H.EfficientLengthMappedIterable(iterable, $function, [$S, $T]);
          return new H.MappedIterable(iterable, $function, [$S, $T]);
        }
      }
    },
    EfficientLengthMappedIterable: {
      "^": "MappedIterable;__internal$_iterable,_f,$ti",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function($S, $T) {
        return [$T];
      }
    },
    MappedIterator: {
      "^": "Iterator;__internal$_current,_iterator,_f,$ti",
      moveNext$0: function() {
        var t1 = this._iterator;
        if (t1.moveNext$0()) {
          this.__internal$_current = this._f.call$1(t1.get$current(t1));
          return true;
        }
        this.__internal$_current = null;
        return false;
      },
      get$current: function(_) {
        return this.__internal$_current;
      },
      $asIterator: function($S, $T) {
        return [$T];
      }
    },
    MappedListIterable: {
      "^": "ListIterable;_source,_f,$ti",
      get$length: function(_) {
        return J.get$length$asx(this._source);
      },
      elementAt$1: function(_, index) {
        return this._f.call$1(J.elementAt$1$ax(this._source, index));
      },
      $asEfficientLengthIterable: function($S, $T) {
        return [$T];
      },
      $asListIterable: function($S, $T) {
        return [$T];
      },
      $asIterable: function($S, $T) {
        return [$T];
      }
    },
    WhereIterable: {
      "^": "Iterable;__internal$_iterable,_f,$ti",
      get$iterator: function(_) {
        return new H.WhereIterator(J.get$iterator$ax(this.__internal$_iterable), this._f, this.$ti);
      },
      map$1: function(_, f) {
        return new H.MappedIterable(this, f, [H.getTypeArgumentByIndex(this, 0), null]);
      }
    },
    WhereIterator: {
      "^": "Iterator;_iterator,_f,$ti",
      moveNext$0: function() {
        var t1, t2;
        for (t1 = this._iterator, t2 = this._f; t1.moveNext$0();)
          if (t2.call$1(t1.get$current(t1)) === true)
            return true;
        return false;
      },
      get$current: function(_) {
        var t1 = this._iterator;
        return t1.get$current(t1);
      }
    },
    ExpandIterable: {
      "^": "Iterable;__internal$_iterable,_f,$ti",
      get$iterator: function(_) {
        return new H.ExpandIterator(J.get$iterator$ax(this.__internal$_iterable), this._f, C.C_EmptyIterator, null, this.$ti);
      },
      $asIterable: function($S, $T) {
        return [$T];
      }
    },
    ExpandIterator: {
      "^": "Object;_iterator,_f,_currentExpansion,__internal$_current,$ti",
      get$current: function(_) {
        return this.__internal$_current;
      },
      moveNext$0: function() {
        var t1, t2, t3;
        t1 = this._currentExpansion;
        if (t1 == null)
          return false;
        for (t2 = this._iterator, t3 = this._f; !t1.moveNext$0();) {
          this.__internal$_current = null;
          if (t2.moveNext$0()) {
            this._currentExpansion = null;
            t1 = J.get$iterator$ax(t3.call$1(t2.get$current(t2)));
            this._currentExpansion = t1;
          } else
            return false;
        }
        t1 = this._currentExpansion;
        this.__internal$_current = t1.get$current(t1);
        return true;
      }
    },
    TakeIterable: {
      "^": "Iterable;__internal$_iterable,_takeCount,$ti",
      get$iterator: function(_) {
        return new H.TakeIterator(J.get$iterator$ax(this.__internal$_iterable), this._takeCount, this.$ti);
      },
      static: {
        TakeIterable_TakeIterable: function(iterable, takeCount, $E) {
          if (typeof takeCount !== "number" || Math.floor(takeCount) !== takeCount || takeCount < 0)
            throw H.wrapException(P.ArgumentError$(takeCount));
          if (!!J.getInterceptor(iterable).$isEfficientLengthIterable)
            return new H.EfficientLengthTakeIterable(iterable, takeCount, [$E]);
          return new H.TakeIterable(iterable, takeCount, [$E]);
        }
      }
    },
    EfficientLengthTakeIterable: {
      "^": "TakeIterable;__internal$_iterable,_takeCount,$ti",
      get$length: function(_) {
        var iterableLength, t1;
        iterableLength = J.get$length$asx(this.__internal$_iterable);
        t1 = this._takeCount;
        if (J.$gt$n(iterableLength, t1))
          return t1;
        return iterableLength;
      },
      $isEfficientLengthIterable: 1
    },
    TakeIterator: {
      "^": "Iterator;_iterator,_remaining,$ti",
      moveNext$0: function() {
        var t1 = J.$sub$n(this._remaining, 1);
        this._remaining = t1;
        if (J.$ge$n(t1, 0))
          return this._iterator.moveNext$0();
        this._remaining = -1;
        return false;
      },
      get$current: function(_) {
        var t1;
        if (J.$lt$n(this._remaining, 0))
          return;
        t1 = this._iterator;
        return t1.get$current(t1);
      }
    },
    SkipIterable: {
      "^": "Iterable;__internal$_iterable,_skipCount,$ti",
      skip$1: function(_, count) {
        return new H.SkipIterable(this.__internal$_iterable, this._skipCount + H._checkCount(count), this.$ti);
      },
      get$iterator: function(_) {
        return new H.SkipIterator(J.get$iterator$ax(this.__internal$_iterable), this._skipCount, this.$ti);
      },
      static: {
        SkipIterable_SkipIterable: function(iterable, count, $E) {
          if (!!J.getInterceptor(iterable).$isEfficientLengthIterable)
            return new H.EfficientLengthSkipIterable(iterable, H._checkCount(count), [$E]);
          return new H.SkipIterable(iterable, H._checkCount(count), [$E]);
        }
      }
    },
    EfficientLengthSkipIterable: {
      "^": "SkipIterable;__internal$_iterable,_skipCount,$ti",
      get$length: function(_) {
        var $length = J.$sub$n(J.get$length$asx(this.__internal$_iterable), this._skipCount);
        if (J.$ge$n($length, 0))
          return $length;
        return 0;
      },
      skip$1: function(_, count) {
        return new H.EfficientLengthSkipIterable(this.__internal$_iterable, this._skipCount + H._checkCount(count), this.$ti);
      },
      $isEfficientLengthIterable: 1
    },
    SkipIterator: {
      "^": "Iterator;_iterator,_skipCount,$ti",
      moveNext$0: function() {
        var t1, i;
        for (t1 = this._iterator, i = 0; i < this._skipCount; ++i)
          t1.moveNext$0();
        this._skipCount = 0;
        return t1.moveNext$0();
      },
      get$current: function(_) {
        var t1 = this._iterator;
        return t1.get$current(t1);
      }
    },
    SkipWhileIterable: {
      "^": "Iterable;__internal$_iterable,_f,$ti",
      get$iterator: function(_) {
        return new H.SkipWhileIterator(J.get$iterator$ax(this.__internal$_iterable), this._f, false, this.$ti);
      }
    },
    SkipWhileIterator: {
      "^": "Iterator;_iterator,_f,_hasSkipped,$ti",
      moveNext$0: function() {
        var t1, t2;
        if (!this._hasSkipped) {
          this._hasSkipped = true;
          for (t1 = this._iterator, t2 = this._f; t1.moveNext$0();)
            if (t2.call$1(t1.get$current(t1)) !== true)
              return true;
        }
        return this._iterator.moveNext$0();
      },
      get$current: function(_) {
        var t1 = this._iterator;
        return t1.get$current(t1);
      }
    },
    EmptyIterable: {
      "^": "EfficientLengthIterable;$ti",
      get$iterator: function(_) {
        return C.C_EmptyIterator;
      },
      forEach$1: function(_, action) {
      },
      get$isEmpty: function(_) {
        return true;
      },
      get$length: function(_) {
        return 0;
      },
      get$first: function(_) {
        throw H.wrapException(H.IterableElementError_noElement());
      },
      get$last: function(_) {
        throw H.wrapException(H.IterableElementError_noElement());
      },
      get$single: function(_) {
        throw H.wrapException(H.IterableElementError_noElement());
      },
      elementAt$1: function(_, index) {
        throw H.wrapException(P.RangeError$range(index, 0, 0, "index", null));
      },
      contains$1: function(_, element) {
        return false;
      },
      every$1: function(_, test) {
        return true;
      },
      any$1: function(_, test) {
        return false;
      },
      join$1: function(_, separator) {
        return "";
      },
      join$0: function($receiver) {
        return this.join$1($receiver, "");
      },
      where$1: function(_, test) {
        return this;
      },
      map$1: function(_, f) {
        return new H.EmptyIterable([null]);
      },
      skip$1: function(_, count) {
        if (J.$lt$n(count, 0))
          H.throwExpression(P.RangeError$range(count, 0, null, "count", null));
        return this;
      },
      take$1: function(_, count) {
        if (J.$lt$n(count, 0))
          H.throwExpression(P.RangeError$range(count, 0, null, "count", null));
        return this;
      },
      toList$1$growable: function(_, growable) {
        var t1, t2;
        t1 = this.$ti;
        if (growable)
          t1 = H.setRuntimeTypeInfo([], t1);
        else {
          t2 = new Array(0);
          t2.fixed$length = Array;
          t1 = H.setRuntimeTypeInfo(t2, t1);
        }
        return t1;
      },
      toList$0: function($receiver) {
        return this.toList$1$growable($receiver, true);
      }
    },
    EmptyIterator: {
      "^": "Object;$ti",
      moveNext$0: function() {
        return false;
      },
      get$current: function(_) {
        return;
      }
    },
    FixedLengthListMixin: {
      "^": "Object;$ti",
      set$length: function(receiver, newLength) {
        throw H.wrapException(P.UnsupportedError$("Cannot change the length of a fixed-length list"));
      },
      add$1: function(receiver, value) {
        throw H.wrapException(P.UnsupportedError$("Cannot add to a fixed-length list"));
      },
      remove$1: function(receiver, element) {
        throw H.wrapException(P.UnsupportedError$("Cannot remove from a fixed-length list"));
      },
      replaceRange$3: function(receiver, start, end, iterable) {
        throw H.wrapException(P.UnsupportedError$("Cannot remove from a fixed-length list"));
      }
    },
    UnmodifiableListMixin: {
      "^": "Object;$ti",
      $indexSet: function(_, index, value) {
        throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
      },
      set$length: function(_, newLength) {
        throw H.wrapException(P.UnsupportedError$("Cannot change the length of an unmodifiable list"));
      },
      add$1: function(_, value) {
        throw H.wrapException(P.UnsupportedError$("Cannot add to an unmodifiable list"));
      },
      remove$1: function(_, element) {
        throw H.wrapException(P.UnsupportedError$("Cannot remove from an unmodifiable list"));
      },
      setRange$4: function(_, start, end, iterable, skipCount) {
        throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
      },
      setRange$3: function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      },
      replaceRange$3: function(_, start, end, iterable) {
        throw H.wrapException(P.UnsupportedError$("Cannot remove from an unmodifiable list"));
      },
      fillRange$3: function(_, start, end, fillValue) {
        throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable list"));
      }
    },
    UnmodifiableListBase: {
      "^": "ListBase+UnmodifiableListMixin;$ti"
    },
    ReversedListIterable: {
      "^": "ListIterable;_source,$ti",
      get$length: function(_) {
        return J.get$length$asx(this._source);
      },
      elementAt$1: function(_, index) {
        var t1, t2;
        t1 = this._source;
        t2 = J.getInterceptor$asx(t1);
        return t2.elementAt$1(t1, J.$sub$n(J.$sub$n(t2.get$length(t1), 1), index));
      }
    },
    Symbol: {
      "^": "Object;__internal$_name<",
      get$hashCode: function(_) {
        var hash = this._hashCode;
        if (hash != null)
          return hash;
        hash = 536870911 & 664597 * J.get$hashCode$(this.__internal$_name);
        this._hashCode = hash;
        return hash;
      },
      toString$0: function(_) {
        return 'Symbol("' + H.S(this.__internal$_name) + '")';
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        return other instanceof H.Symbol && J.$eq$(this.__internal$_name, other.__internal$_name) === true;
      },
      $isSymbol0: 1
    },
    __CastListBase__CastIterableBase_ListMixin: {
      "^": "_CastIterableBase+ListMixin;$ti"
    }
  }], ["_js_helper", "dart:_js_helper",, H, {
    "^": "",
    ConstantMap_ConstantMap$from: function(other, $K, $V) {
      var keys, allStrings, t1, _i, k, object, containsProto, protoValue, $length, v;
      keys = P.List_List$from(other.get$keys(), true, $K);
      t1 = keys.length;
      _i = 0;
      while (true) {
        if (!(_i < t1)) {
          allStrings = true;
          break;
        }
        k = keys[_i];
        if (typeof k !== "string") {
          allStrings = false;
          break;
        }
        ++_i;
      }
      if (allStrings) {
        object = {};
        for (containsProto = false, protoValue = null, $length = 0, _i = 0; _i < keys.length; keys.length === t1 || (0, H.throwConcurrentModificationError)(keys), ++_i) {
          k = keys[_i];
          v = other.$index(0, k);
          if (J.$eq$(k, "__proto__") !== true) {
            if (!object.hasOwnProperty(k))
              ++$length;
            object[k] = v;
          } else {
            protoValue = v;
            containsProto = true;
          }
        }
        if (containsProto)
          return new H.ConstantProtoMap(protoValue, $length + 1, object, keys, [$K, $V]);
        return new H.ConstantStringMap($length, object, keys, [$K, $V]);
      }
      return new H.ConstantMapView(P.LinkedHashMap_LinkedHashMap$from(other, null, null), [$K, $V]);
    },
    ConstantMap__throwUnmodifiable: function() {
      throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable Map"));
    },
    getType: [function(index) {
      return init.types[index];
    }, null, null, 4, 0, null, 10],
    isJsIndexable: function(object, record) {
      var result;
      if (record != null) {
        result = record.x;
        if (result != null)
          return result;
      }
      return !!J.getInterceptor(object).$isJavaScriptIndexingBehavior;
    },
    S: function(value) {
      var res;
      if (typeof value === "string")
        return value;
      if (typeof value === "number") {
        if (value !== 0)
          return "" + value;
      } else if (true === value)
        return "true";
      else if (false === value)
        return "false";
      else if (value == null)
        return "null";
      res = J.toString$0$(value);
      if (typeof res !== "string")
        throw H.wrapException(H.argumentErrorValue(value));
      return res;
    },
    Primitives_objectHashCode: function(object) {
      var hash = object.$identityHash;
      if (hash == null) {
        hash = Math.random() * 0x3fffffff | 0;
        object.$identityHash = hash;
      }
      return hash;
    },
    Primitives_parseInt: function(source, radix) {
      var match, decimalMatch, maxCharCode, digitsPart, t1, i;
      if (typeof source !== "string")
        H.throwExpression(H.argumentErrorValue(source));
      match = /^\s*[+-]?((0x[a-f0-9]+)|(\d+)|([a-z0-9]+))\s*$/i.exec(source);
      if (match == null)
        return;
      if (3 >= match.length)
        return H.ioore(match, 3);
      decimalMatch = match[3];
      if (radix == null) {
        if (decimalMatch != null)
          return parseInt(source, 10);
        if (match[2] != null)
          return parseInt(source, 16);
        return;
      }
      if (radix < 2 || radix > 36)
        throw H.wrapException(P.RangeError$range(radix, 2, 36, "radix", null));
      if (radix === 10 && decimalMatch != null)
        return parseInt(source, 10);
      if (radix < 10 || decimalMatch == null) {
        maxCharCode = radix <= 10 ? 47 + radix : 86 + radix;
        digitsPart = match[1];
        for (t1 = digitsPart.length, i = 0; i < t1; ++i)
          if ((C.JSString_methods._codeUnitAt$1(digitsPart, i) | 32) > maxCharCode)
            return;
      }
      return parseInt(source, radix);
    },
    Primitives_objectTypeName: function(object) {
      var interceptor, interceptorConstructor, interceptorConstructorName, $name, dispatchName, objectConstructor, match, decompiledName, t1;
      interceptor = J.getInterceptor(object);
      interceptorConstructor = interceptor.constructor;
      if (typeof interceptorConstructor == "function") {
        interceptorConstructorName = interceptorConstructor.name;
        $name = typeof interceptorConstructorName === "string" ? interceptorConstructorName : null;
      } else
        $name = null;
      if ($name == null || interceptor === C.Interceptor_methods || !!J.getInterceptor(object).$isUnknownJavaScriptObject) {
        dispatchName = C.JS_CONST_u2C(object);
        if (dispatchName === "Object") {
          objectConstructor = object.constructor;
          if (typeof objectConstructor == "function") {
            match = String(objectConstructor).match(/^\s*function\s*([\w$]*)\s*\(/);
            decompiledName = match == null ? null : match[1];
            if (typeof decompiledName === "string" && /^\w+$/.test(decompiledName))
              $name = decompiledName;
          }
          if ($name == null)
            $name = dispatchName;
        } else
          $name = dispatchName;
      }
      $name = $name;
      if ($name.length > 1 && C.JSString_methods._codeUnitAt$1($name, 0) === 36)
        $name = C.JSString_methods.substring$1($name, 1);
      t1 = H.joinArgumentsV1(H.getRuntimeTypeInfo(object), 0, null);
      return function(str, names) {
        return str.replace(/[^<,> ]+/g, function(m) {
          return names[m] || m;
        });
      }($name + t1, init.mangledGlobalNames);
    },
    Primitives_currentUri: function() {
      if (!!self.location)
        return self.location.href;
      return;
    },
    Primitives__fromCharCodeApply: function(array) {
      var end, result, i, i0, chunkEnd;
      end = array.length;
      if (end <= 500)
        return String.fromCharCode.apply(null, array);
      for (result = "", i = 0; i < end; i = i0) {
        i0 = i + 500;
        chunkEnd = i0 < end ? i0 : end;
        result += String.fromCharCode.apply(null, array.slice(i, chunkEnd));
      }
      return result;
    },
    Primitives_stringFromCodePoints: function(codePoints) {
      var a, t1, _i, i;
      a = H.setRuntimeTypeInfo([], [P.int]);
      for (t1 = codePoints.length, _i = 0; _i < codePoints.length; codePoints.length === t1 || (0, H.throwConcurrentModificationError)(codePoints), ++_i) {
        i = codePoints[_i];
        if (typeof i !== "number" || Math.floor(i) !== i)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i <= 65535)
          a.push(i);
        else if (i <= 1114111) {
          a.push(55296 + (C.JSInt_methods._shrOtherPositive$1(i - 65536, 10) & 1023));
          a.push(56320 + (i & 1023));
        } else
          throw H.wrapException(H.argumentErrorValue(i));
      }
      return H.Primitives__fromCharCodeApply(a);
    },
    Primitives_stringFromCharCodes: function(charCodes) {
      var t1, _i, i;
      for (t1 = charCodes.length, _i = 0; _i < t1; ++_i) {
        i = charCodes[_i];
        if (typeof i !== "number" || Math.floor(i) !== i)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i < 0)
          throw H.wrapException(H.argumentErrorValue(i));
        if (i > 65535)
          return H.Primitives_stringFromCodePoints(charCodes);
      }
      return H.Primitives__fromCharCodeApply(charCodes);
    },
    Primitives_stringFromNativeUint8List: function(charCodes, start, end) {
      var t1, i, result, i0, chunkEnd;
      t1 = J.getInterceptor$n(end);
      if (t1.$le(end, 500) && start === 0 && t1.$eq(end, charCodes.length) === true)
        return String.fromCharCode.apply(null, charCodes);
      if (typeof end !== "number")
        return H.iae(end);
      i = start;
      result = "";
      for (; i < end; i = i0) {
        i0 = i + 500;
        if (i0 < end)
          chunkEnd = i0;
        else
          chunkEnd = end;
        result += String.fromCharCode.apply(null, charCodes.subarray(i, chunkEnd));
      }
      return result;
    },
    Primitives_stringFromCharCode: function(charCode) {
      var bits;
      if (typeof charCode !== "number")
        return H.iae(charCode);
      if (0 <= charCode) {
        if (charCode <= 65535)
          return String.fromCharCode(charCode);
        if (charCode <= 1114111) {
          bits = charCode - 65536;
          return String.fromCharCode((55296 | C.JSNumber_methods._shrOtherPositive$1(bits, 10)) >>> 0, 56320 | bits & 1023);
        }
      }
      throw H.wrapException(P.RangeError$range(charCode, 0, 1114111, null, null));
    },
    Primitives_lazyAsJsDate: function(receiver) {
      if (receiver.date === void 0)
        receiver.date = new Date(receiver._core$_value);
      return receiver.date;
    },
    Primitives_getYear: function(receiver) {
      var t1 = H.Primitives_lazyAsJsDate(receiver).getFullYear() + 0;
      return t1;
    },
    Primitives_getMonth: function(receiver) {
      var t1 = H.Primitives_lazyAsJsDate(receiver).getMonth() + 1;
      return t1;
    },
    Primitives_getDay: function(receiver) {
      var t1 = H.Primitives_lazyAsJsDate(receiver).getDate() + 0;
      return t1;
    },
    Primitives_getHours: function(receiver) {
      var t1 = H.Primitives_lazyAsJsDate(receiver).getHours() + 0;
      return t1;
    },
    Primitives_getMinutes: function(receiver) {
      var t1 = H.Primitives_lazyAsJsDate(receiver).getMinutes() + 0;
      return t1;
    },
    Primitives_getSeconds: function(receiver) {
      var t1 = H.Primitives_lazyAsJsDate(receiver).getSeconds() + 0;
      return t1;
    },
    Primitives_getMilliseconds: function(receiver) {
      var t1 = H.Primitives_lazyAsJsDate(receiver).getMilliseconds() + 0;
      return t1;
    },
    Primitives_functionNoSuchMethod: function($function, positionalArguments, namedArguments) {
      var t1, $arguments, namedArgumentList, t2;
      t1 = {};
      t1.argumentCount = 0;
      $arguments = [];
      namedArgumentList = [];
      if (positionalArguments != null) {
        t2 = J.get$length$asx(positionalArguments);
        if (typeof t2 !== "number")
          return H.iae(t2);
        t1.argumentCount = 0 + t2;
        C.JSArray_methods.addAll$1($arguments, positionalArguments);
      }
      t1.names = "";
      if (namedArguments != null && !namedArguments.get$isEmpty(namedArguments))
        namedArguments.forEach$1(0, new H.Primitives_functionNoSuchMethod_closure(t1, namedArgumentList, $arguments));
      return J.noSuchMethod$1$($function, new H.JSInvocationMirror(C.Symbol_call, "call" + "$" + H.S(t1.argumentCount) + t1.names, 0, null, $arguments, namedArgumentList, 0, null));
    },
    Primitives_applyFunctionWithPositionalArguments: function($function, positionalArguments) {
      var $arguments, t1;
      if (positionalArguments != null)
        $arguments = positionalArguments instanceof Array ? positionalArguments : P.List_List$from(positionalArguments, true, null);
      else
        $arguments = [];
      t1 = $arguments.length;
      if (t1 === 0) {
        if (!!$function.call$0)
          return $function.call$0();
      } else if (t1 === 1) {
        if (!!$function.call$1)
          return $function.call$1($arguments[0]);
      } else if (t1 === 2) {
        if (!!$function.call$2)
          return $function.call$2($arguments[0], $arguments[1]);
      } else if (t1 === 3) {
        if (!!$function.call$3)
          return $function.call$3($arguments[0], $arguments[1], $arguments[2]);
      } else if (t1 === 4) {
        if (!!$function.call$4)
          return $function.call$4($arguments[0], $arguments[1], $arguments[2], $arguments[3]);
      } else if (t1 === 5)
        if (!!$function.call$5)
          return $function.call$5($arguments[0], $arguments[1], $arguments[2], $arguments[3], $arguments[4]);
      return H.Primitives__genericApplyFunctionWithPositionalArguments($function, $arguments);
    },
    Primitives__genericApplyFunctionWithPositionalArguments: function($function, $arguments) {
      var argumentCount, jsFunction, info, requiredArgumentCount, maxArgumentCount, pos;
      argumentCount = $arguments.length;
      jsFunction = $function["call" + "$" + argumentCount];
      if (jsFunction == null) {
        jsFunction = J.getInterceptor($function)["call*"];
        if (jsFunction == null)
          return H.Primitives_functionNoSuchMethod($function, $arguments, null);
        info = H.ReflectionInfo_ReflectionInfo(jsFunction);
        requiredArgumentCount = info.requiredParameterCount;
        maxArgumentCount = requiredArgumentCount + info.optionalParameterCount;
        if (info.areOptionalParametersNamed || requiredArgumentCount > argumentCount || maxArgumentCount < argumentCount)
          return H.Primitives_functionNoSuchMethod($function, $arguments, null);
        $arguments = P.List_List$from($arguments, true, null);
        for (pos = argumentCount; pos < maxArgumentCount; ++pos)
          C.JSArray_methods.add$1($arguments, init.metadata[info.defaultValue$1(pos)]);
      }
      return jsFunction.apply($function, $arguments);
    },
    iae: function(argument) {
      throw H.wrapException(H.argumentErrorValue(argument));
    },
    ioore: function(receiver, index) {
      if (receiver == null)
        J.get$length$asx(receiver);
      throw H.wrapException(H.diagnoseIndexError(receiver, index));
    },
    diagnoseIndexError: function(indexable, index) {
      var $length, t1;
      if (typeof index !== "number" || Math.floor(index) !== index)
        return new P.ArgumentError(true, index, "index", null);
      $length = J.get$length$asx(indexable);
      if (!(index < 0)) {
        if (typeof $length !== "number")
          return H.iae($length);
        t1 = index >= $length;
      } else
        t1 = true;
      if (t1)
        return P.IndexError$(index, indexable, "index", null, $length);
      return P.RangeError$value(index, "index", null);
    },
    diagnoseRangeError: function(start, end, $length) {
      if (typeof start !== "number" || Math.floor(start) !== start)
        return new P.ArgumentError(true, start, "start", null);
      if (start < 0 || start > $length)
        return new P.RangeError(0, $length, true, start, "start", "Invalid value");
      if (end != null) {
        if (typeof end !== "number" || Math.floor(end) !== end)
          return new P.ArgumentError(true, end, "end", null);
        if (end < start || end > $length)
          return new P.RangeError(start, $length, true, end, "end", "Invalid value");
      }
      return new P.ArgumentError(true, end, "end", null);
    },
    argumentErrorValue: function(object) {
      return new P.ArgumentError(true, object, null, null);
    },
    checkNum: function(value) {
      if (typeof value !== "number")
        throw H.wrapException(H.argumentErrorValue(value));
      return value;
    },
    wrapException: function(ex) {
      var wrapper;
      if (ex == null)
        ex = new P.NullThrownError();
      wrapper = new Error();
      wrapper.dartException = ex;
      if ("defineProperty" in Object) {
        Object.defineProperty(wrapper, "message", {get: H.toStringWrapper});
        wrapper.name = "";
      } else
        wrapper.toString = H.toStringWrapper;
      return wrapper;
    },
    toStringWrapper: [function() {
      return J.toString$0$(this.dartException);
    }, null, null, 0, 0, null],
    throwExpression: function(ex) {
      throw H.wrapException(ex);
    },
    throwConcurrentModificationError: function(collection) {
      throw H.wrapException(P.ConcurrentModificationError$(collection));
    },
    unwrapException: function(ex) {
      var t1, message, number, ieErrorCode, nsme, notClosure, nullCall, nullLiteralCall, undefCall, undefLiteralCall, nullProperty, undefProperty, undefLiteralProperty, match, t2;
      t1 = new H.unwrapException_saveStackTrace(ex);
      if (ex == null)
        return;
      if (ex instanceof H.ExceptionAndStackTrace)
        return t1.call$1(ex.dartException);
      if (typeof ex !== "object")
        return ex;
      if ("dartException" in ex)
        return t1.call$1(ex.dartException);
      else if (!("message" in ex))
        return ex;
      message = ex.message;
      if ("number" in ex && typeof ex.number == "number") {
        number = ex.number;
        ieErrorCode = number & 65535;
        if ((C.JSInt_methods._shrOtherPositive$1(number, 16) & 8191) === 10)
          switch (ieErrorCode) {
            case 438:
              return t1.call$1(H.JsNoSuchMethodError$(H.S(message) + " (Error " + ieErrorCode + ")", null));
            case 445:
            case 5007:
              return t1.call$1(H.NullError$(H.S(message) + " (Error " + ieErrorCode + ")", null));
          }
      }
      if (ex instanceof TypeError) {
        nsme = $.$get$TypeErrorDecoder_noSuchMethodPattern();
        notClosure = $.$get$TypeErrorDecoder_notClosurePattern();
        nullCall = $.$get$TypeErrorDecoder_nullCallPattern();
        nullLiteralCall = $.$get$TypeErrorDecoder_nullLiteralCallPattern();
        undefCall = $.$get$TypeErrorDecoder_undefinedCallPattern();
        undefLiteralCall = $.$get$TypeErrorDecoder_undefinedLiteralCallPattern();
        nullProperty = $.$get$TypeErrorDecoder_nullPropertyPattern();
        $.$get$TypeErrorDecoder_nullLiteralPropertyPattern();
        undefProperty = $.$get$TypeErrorDecoder_undefinedPropertyPattern();
        undefLiteralProperty = $.$get$TypeErrorDecoder_undefinedLiteralPropertyPattern();
        match = nsme.matchTypeError$1(message);
        if (match != null)
          return t1.call$1(H.JsNoSuchMethodError$(message, match));
        else {
          match = notClosure.matchTypeError$1(message);
          if (match != null) {
            match.method = "call";
            return t1.call$1(H.JsNoSuchMethodError$(message, match));
          } else {
            match = nullCall.matchTypeError$1(message);
            if (match == null) {
              match = nullLiteralCall.matchTypeError$1(message);
              if (match == null) {
                match = undefCall.matchTypeError$1(message);
                if (match == null) {
                  match = undefLiteralCall.matchTypeError$1(message);
                  if (match == null) {
                    match = nullProperty.matchTypeError$1(message);
                    if (match == null) {
                      match = nullLiteralCall.matchTypeError$1(message);
                      if (match == null) {
                        match = undefProperty.matchTypeError$1(message);
                        if (match == null) {
                          match = undefLiteralProperty.matchTypeError$1(message);
                          t2 = match != null;
                        } else
                          t2 = true;
                      } else
                        t2 = true;
                    } else
                      t2 = true;
                  } else
                    t2 = true;
                } else
                  t2 = true;
              } else
                t2 = true;
            } else
              t2 = true;
            if (t2)
              return t1.call$1(H.NullError$(message, match));
          }
        }
        return t1.call$1(new H.UnknownJsTypeError(typeof message === "string" ? message : ""));
      }
      if (ex instanceof RangeError) {
        if (typeof message === "string" && message.indexOf("call stack") !== -1)
          return new P.StackOverflowError();
        message = function(ex) {
          try {
            return String(ex);
          } catch (e) {
          }
          return null;
        }(ex);
        return t1.call$1(new P.ArgumentError(false, null, null, typeof message === "string" ? message.replace(/^RangeError:\s*/, "") : message));
      }
      if (typeof InternalError == "function" && ex instanceof InternalError)
        if (typeof message === "string" && message === "too much recursion")
          return new P.StackOverflowError();
      return ex;
    },
    getTraceFromException: function(exception) {
      var trace;
      if (exception instanceof H.ExceptionAndStackTrace)
        return exception.stackTrace;
      if (exception == null)
        return new H._StackTrace(exception, null);
      trace = exception.$cachedTrace;
      if (trace != null)
        return trace;
      return exception.$cachedTrace = new H._StackTrace(exception, null);
    },
    objectHashCode: function(object) {
      if (object == null || typeof object != 'object')
        return J.get$hashCode$(object);
      else
        return H.Primitives_objectHashCode(object);
    },
    fillLiteralMap: function(keyValuePairs, result) {
      var $length, index, index0, index1;
      $length = keyValuePairs.length;
      for (index = 0; index < $length; index = index1) {
        index0 = index + 1;
        index1 = index0 + 1;
        result.$indexSet(0, keyValuePairs[index], keyValuePairs[index0]);
      }
      return result;
    },
    invokeClosure: [function(closure, numberOfArguments, arg1, arg2, arg3, arg4) {
      switch (numberOfArguments) {
        case 0:
          return closure.call$0();
        case 1:
          return closure.call$1(arg1);
        case 2:
          return closure.call$2(arg1, arg2);
        case 3:
          return closure.call$3(arg1, arg2, arg3);
        case 4:
          return closure.call$4(arg1, arg2, arg3, arg4);
      }
      throw H.wrapException(new P._Exception("Unsupported number of arguments for wrapped closure"));
    }, null, null, 24, 0, null, 64, 82, 49, 46, 51, 53],
    convertDartClosureToJS: function(closure, arity) {
      var $function;
      if (closure == null)
        return;
      $function = closure.$identity;
      if (!!$function)
        return $function;
      $function = function(closure, arity, invoke) {
        return function(a1, a2, a3, a4) {
          return invoke(closure, arity, a1, a2, a3, a4);
        };
      }(closure, arity, H.invokeClosure);
      closure.$identity = $function;
      return $function;
    },
    Closure_fromTearOff: function(receiver, functions, applyTrampolineIndex, reflectionInfo, isStatic, jsArguments, propertyName) {
      var $function, callName, functionType, $prototype, $constructor, t1, isIntercepted, trampoline, signatureFunction, getReceiver, applyTrampoline, i, stub, stubCallName;
      $function = functions[0];
      callName = $function.$callName;
      if (!!J.getInterceptor(reflectionInfo).$isList) {
        $function.$reflectionInfo = reflectionInfo;
        functionType = H.ReflectionInfo_ReflectionInfo($function).functionType;
      } else
        functionType = reflectionInfo;
      $prototype = isStatic ? Object.create(new H.StaticClosure().constructor.prototype) : Object.create(new H.BoundClosure(null, null, null, null).constructor.prototype);
      $prototype.$initialize = $prototype.constructor;
      if (isStatic)
        $constructor = function() {
          this.$initialize();
        };
      else {
        t1 = $.Closure_functionCounter;
        $.Closure_functionCounter = J.$add$ansx(t1, 1);
        $constructor = new Function("a,b,c,d" + t1, "this.$initialize(a,b,c,d" + t1 + ")");
      }
      $prototype.constructor = $constructor;
      $constructor.prototype = $prototype;
      if (!isStatic) {
        isIntercepted = jsArguments.length == 1 && true;
        trampoline = H.Closure_forwardCallTo(receiver, $function, isIntercepted);
        trampoline.$reflectionInfo = reflectionInfo;
      } else {
        $prototype.$static_name = propertyName;
        trampoline = $function;
        isIntercepted = false;
      }
      if (typeof functionType == "number")
        signatureFunction = function(getType, t) {
          return function() {
            return getType(t);
          };
        }(H.getType, functionType);
      else if (typeof functionType == "function")
        if (isStatic)
          signatureFunction = functionType;
        else {
          getReceiver = isIntercepted ? H.BoundClosure_receiverOf : H.BoundClosure_selfOf;
          signatureFunction = function(f, r) {
            return function() {
              return f.apply({$receiver: r(this)}, arguments);
            };
          }(functionType, getReceiver);
        }
      else
        throw H.wrapException("Error in reflectionInfo.");
      $prototype.$signature = signatureFunction;
      $prototype[callName] = trampoline;
      for (t1 = functions.length, applyTrampoline = trampoline, i = 1; i < t1; ++i) {
        stub = functions[i];
        stubCallName = stub.$callName;
        if (stubCallName != null) {
          stub = isStatic ? stub : H.Closure_forwardCallTo(receiver, stub, isIntercepted);
          $prototype[stubCallName] = stub;
        }
        if (i === applyTrampolineIndex) {
          stub.$reflectionInfo = reflectionInfo;
          applyTrampoline = stub;
        }
      }
      $prototype["call*"] = applyTrampoline;
      $prototype.$requiredArgCount = $function.$requiredArgCount;
      $prototype.$defaultValues = $function.$defaultValues;
      return $constructor;
    },
    Closure_cspForwardCall: function(arity, isSuperCall, stubName, $function) {
      var getSelf = H.BoundClosure_selfOf;
      switch (isSuperCall ? -1 : arity) {
        case 0:
          return function(n, S) {
            return function() {
              return S(this)[n]();
            };
          }(stubName, getSelf);
        case 1:
          return function(n, S) {
            return function(a) {
              return S(this)[n](a);
            };
          }(stubName, getSelf);
        case 2:
          return function(n, S) {
            return function(a, b) {
              return S(this)[n](a, b);
            };
          }(stubName, getSelf);
        case 3:
          return function(n, S) {
            return function(a, b, c) {
              return S(this)[n](a, b, c);
            };
          }(stubName, getSelf);
        case 4:
          return function(n, S) {
            return function(a, b, c, d) {
              return S(this)[n](a, b, c, d);
            };
          }(stubName, getSelf);
        case 5:
          return function(n, S) {
            return function(a, b, c, d, e) {
              return S(this)[n](a, b, c, d, e);
            };
          }(stubName, getSelf);
        default:
          return function(f, s) {
            return function() {
              return f.apply(s(this), arguments);
            };
          }($function, getSelf);
      }
    },
    Closure_forwardCallTo: function(receiver, $function, isIntercepted) {
      var stubName, arity, lookedUpFunction, t1, t2, selfName, $arguments;
      if (isIntercepted)
        return H.Closure_forwardInterceptedCallTo(receiver, $function);
      stubName = $function.$stubName;
      arity = $function.length;
      lookedUpFunction = receiver[stubName];
      t1 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
      t2 = !t1 || arity >= 27;
      if (t2)
        return H.Closure_cspForwardCall(arity, !t1, stubName, $function);
      if (arity === 0) {
        t1 = $.Closure_functionCounter;
        $.Closure_functionCounter = J.$add$ansx(t1, 1);
        selfName = "self" + H.S(t1);
        t1 = "return function(){var " + selfName + " = this.";
        t2 = $.BoundClosure_selfFieldNameCache;
        if (t2 == null) {
          t2 = H.BoundClosure_computeFieldNamed("self");
          $.BoundClosure_selfFieldNameCache = t2;
        }
        return new Function(t1 + H.S(t2) + ";return " + selfName + "." + H.S(stubName) + "();}")();
      }
      $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity).join(",");
      t1 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ansx(t1, 1);
      $arguments += H.S(t1);
      t1 = "return function(" + $arguments + "){return this.";
      t2 = $.BoundClosure_selfFieldNameCache;
      if (t2 == null) {
        t2 = H.BoundClosure_computeFieldNamed("self");
        $.BoundClosure_selfFieldNameCache = t2;
      }
      return new Function(t1 + H.S(t2) + "." + H.S(stubName) + "(" + $arguments + ");}")();
    },
    Closure_cspForwardInterceptedCall: function(arity, isSuperCall, $name, $function) {
      var getSelf, getReceiver;
      getSelf = H.BoundClosure_selfOf;
      getReceiver = H.BoundClosure_receiverOf;
      switch (isSuperCall ? -1 : arity) {
        case 0:
          throw H.wrapException(H.RuntimeError$("Intercepted function with no arguments."));
        case 1:
          return function(n, s, r) {
            return function() {
              return s(this)[n](r(this));
            };
          }($name, getSelf, getReceiver);
        case 2:
          return function(n, s, r) {
            return function(a) {
              return s(this)[n](r(this), a);
            };
          }($name, getSelf, getReceiver);
        case 3:
          return function(n, s, r) {
            return function(a, b) {
              return s(this)[n](r(this), a, b);
            };
          }($name, getSelf, getReceiver);
        case 4:
          return function(n, s, r) {
            return function(a, b, c) {
              return s(this)[n](r(this), a, b, c);
            };
          }($name, getSelf, getReceiver);
        case 5:
          return function(n, s, r) {
            return function(a, b, c, d) {
              return s(this)[n](r(this), a, b, c, d);
            };
          }($name, getSelf, getReceiver);
        case 6:
          return function(n, s, r) {
            return function(a, b, c, d, e) {
              return s(this)[n](r(this), a, b, c, d, e);
            };
          }($name, getSelf, getReceiver);
        default:
          return function(f, s, r, a) {
            return function() {
              a = [r(this)];
              Array.prototype.push.apply(a, arguments);
              return f.apply(s(this), a);
            };
          }($function, getSelf, getReceiver);
      }
    },
    Closure_forwardInterceptedCallTo: function(receiver, $function) {
      var t1, t2, stubName, arity, lookedUpFunction, t3, t4, $arguments;
      t1 = $.BoundClosure_selfFieldNameCache;
      if (t1 == null) {
        t1 = H.BoundClosure_computeFieldNamed("self");
        $.BoundClosure_selfFieldNameCache = t1;
      }
      t2 = $.BoundClosure_receiverFieldNameCache;
      if (t2 == null) {
        t2 = H.BoundClosure_computeFieldNamed("receiver");
        $.BoundClosure_receiverFieldNameCache = t2;
      }
      stubName = $function.$stubName;
      arity = $function.length;
      lookedUpFunction = receiver[stubName];
      t3 = $function == null ? lookedUpFunction == null : $function === lookedUpFunction;
      t4 = !t3 || arity >= 28;
      if (t4)
        return H.Closure_cspForwardInterceptedCall(arity, !t3, stubName, $function);
      if (arity === 1) {
        t1 = "return function(){return this." + H.S(t1) + "." + H.S(stubName) + "(this." + H.S(t2) + ");";
        t2 = $.Closure_functionCounter;
        $.Closure_functionCounter = J.$add$ansx(t2, 1);
        return new Function(t1 + H.S(t2) + "}")();
      }
      $arguments = "abcdefghijklmnopqrstuvwxyz".split("").splice(0, arity - 1).join(",");
      t1 = "return function(" + $arguments + "){return this." + H.S(t1) + "." + H.S(stubName) + "(this." + H.S(t2) + ", " + $arguments + ");";
      t2 = $.Closure_functionCounter;
      $.Closure_functionCounter = J.$add$ansx(t2, 1);
      return new Function(t1 + H.S(t2) + "}")();
    },
    closureFromTearOff: function(receiver, functions, applyTrampolineIndex, reflectionInfo, isStatic, jsArguments, $name) {
      var t1, t2;
      t1 = J.JSArray_markFixedList(functions);
      t2 = !!J.getInterceptor(reflectionInfo).$isList ? J.JSArray_markFixedList(reflectionInfo) : reflectionInfo;
      return H.Closure_fromTearOff(receiver, t1, applyTrampolineIndex, t2, !!isStatic, jsArguments, $name);
    },
    stringTypeCast: function(value) {
      if (typeof value === "string" || value == null)
        return value;
      throw H.wrapException(H.CastErrorImplementation$(value, "String"));
    },
    boolTypeCast: function(value) {
      if (typeof value === "boolean" || value == null)
        return value;
      throw H.wrapException(H.CastErrorImplementation$(value, "bool"));
    },
    intTypeCast: function(value) {
      if (typeof value === "number" && Math.floor(value) === value || value == null)
        return value;
      throw H.wrapException(H.CastErrorImplementation$(value, "int"));
    },
    propertyTypeCastError: function(value, property) {
      var t1 = J.getInterceptor$asx(property);
      throw H.wrapException(H.CastErrorImplementation$(value, t1.substring$2(property, 3, t1.get$length(property))));
    },
    interceptedTypeCast: function(value, property) {
      var t1;
      if (value != null)
        t1 = (typeof value === "object" || typeof value === "function") && J.getInterceptor(value)[property];
      else
        t1 = true;
      if (t1)
        return value;
      H.propertyTypeCastError(value, property);
    },
    listTypeCast: function(value) {
      if (!!J.getInterceptor(value).$isList || value == null)
        return value;
      throw H.wrapException(H.CastErrorImplementation$(value, "List"));
    },
    extractFunctionTypeObjectFromInternal: function(o) {
      var signature;
      if ("$signature" in o) {
        signature = o.$signature;
        if (typeof signature == "number")
          return init.types[signature];
        else
          return o.$signature();
      }
      return;
    },
    functionTypeTest: function(value, functionTypeRti) {
      var functionTypeObject, t1;
      if (value == null)
        return false;
      if (typeof value == "function")
        return true;
      functionTypeObject = H.extractFunctionTypeObjectFromInternal(J.getInterceptor(value));
      if (functionTypeObject == null)
        return false;
      t1 = H.isFunctionSubtypeV1(functionTypeObject, functionTypeRti);
      return t1;
    },
    functionTypeCast: function(value, functionTypeRti) {
      if (value == null)
        return value;
      if (H.functionTypeTest(value, functionTypeRti))
        return value;
      throw H.wrapException(H.CastErrorImplementation$(value, H.runtimeTypeToString(functionTypeRti, null)));
    },
    _typeDescription: function(value) {
      var functionTypeObject;
      if (value instanceof H.Closure) {
        functionTypeObject = H.extractFunctionTypeObjectFromInternal(J.getInterceptor(value));
        if (functionTypeObject != null)
          return H.runtimeTypeToString(functionTypeObject, null);
        return "Closure";
      }
      return H.Primitives_objectTypeName(value);
    },
    throwCyclicInit: function(staticName) {
      throw H.wrapException(new P.CyclicInitializationError(staticName));
    },
    getIsolateAffinityTag: function($name) {
      return init.getIsolateTag($name);
    },
    setRuntimeTypeInfo: function(target, rti) {
      target.$ti = rti;
      return target;
    },
    getRuntimeTypeInfo: function(target) {
      if (target == null)
        return;
      return target.$ti;
    },
    getRuntimeTypeArguments: function(interceptor, object, substitutionName) {
      return H.substitute(interceptor["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(object));
    },
    getRuntimeTypeArgumentIntercepted: function(interceptor, target, substitutionName, index) {
      var $arguments = H.substitute(interceptor["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(target));
      return $arguments == null ? null : $arguments[index];
    },
    getRuntimeTypeArgument: function(target, substitutionName, index) {
      var $arguments = H.substitute(target["$as" + H.S(substitutionName)], H.getRuntimeTypeInfo(target));
      return $arguments == null ? null : $arguments[index];
    },
    getTypeArgumentByIndex: function(target, index) {
      var rti = H.getRuntimeTypeInfo(target);
      return rti == null ? null : rti[index];
    },
    runtimeTypeToString: function(rti, onTypeVariable) {
      var t1 = H.runtimeTypeToStringV1(rti, onTypeVariable);
      return t1;
    },
    runtimeTypeToStringV1: function(rti, onTypeVariable) {
      var typedefInfo;
      if (rti == null)
        return "dynamic";
      if (typeof rti === "object" && rti !== null && rti.constructor === Array)
        return rti[0].builtin$cls + H.joinArgumentsV1(rti, 1, onTypeVariable);
      if (typeof rti == "function")
        return rti.builtin$cls;
      if (typeof rti === "number" && Math.floor(rti) === rti)
        return H.S(rti);
      if (typeof rti.func != "undefined") {
        typedefInfo = rti.typedef;
        if (typedefInfo != null)
          return H.runtimeTypeToStringV1(typedefInfo, onTypeVariable);
        return H._functionRtiToStringV1(rti, onTypeVariable);
      }
      return "unknown-reified-type";
    },
    _functionRtiToStringV1: function(rti, onTypeVariable) {
      var returnTypeText, $arguments, t1, argumentsText, sep, _i, argument, optionalArguments, namedArguments, t2, $name;
      returnTypeText = !!rti.v ? "void" : H.runtimeTypeToStringV1(rti.ret, onTypeVariable);
      if ("args" in rti) {
        $arguments = rti.args;
        for (t1 = $arguments.length, argumentsText = "", sep = "", _i = 0; _i < t1; ++_i, sep = ", ") {
          argument = $arguments[_i];
          argumentsText = argumentsText + sep + H.runtimeTypeToStringV1(argument, onTypeVariable);
        }
      } else {
        argumentsText = "";
        sep = "";
      }
      if ("opt" in rti) {
        optionalArguments = rti.opt;
        argumentsText += sep + "[";
        for (t1 = optionalArguments.length, sep = "", _i = 0; _i < t1; ++_i, sep = ", ") {
          argument = optionalArguments[_i];
          argumentsText = argumentsText + sep + H.runtimeTypeToStringV1(argument, onTypeVariable);
        }
        argumentsText += "]";
      }
      if ("named" in rti) {
        namedArguments = rti.named;
        argumentsText += sep + "{";
        for (t1 = H.extractKeys(namedArguments), t2 = t1.length, sep = "", _i = 0; _i < t2; ++_i, sep = ", ") {
          $name = t1[_i];
          argumentsText = argumentsText + sep + H.runtimeTypeToStringV1(namedArguments[$name], onTypeVariable) + (" " + H.S($name));
        }
        argumentsText += "}";
      }
      return "(" + argumentsText + ") => " + returnTypeText;
    },
    joinArgumentsV1: function(types, startIndex, onTypeVariable) {
      var buffer, index, firstArgument, allDynamic, t1, argument;
      if (types == null)
        return "";
      buffer = new P.StringBuffer("");
      for (index = startIndex, firstArgument = true, allDynamic = true, t1 = ""; index < types.length; ++index) {
        if (firstArgument)
          firstArgument = false;
        else
          buffer._contents = t1 + ", ";
        argument = types[index];
        if (argument != null)
          allDynamic = false;
        t1 = buffer._contents += H.runtimeTypeToStringV1(argument, onTypeVariable);
      }
      return allDynamic ? "" : "<" + buffer.toString$0(0) + ">";
    },
    getRuntimeTypeString: function(object) {
      var functionRti, className, t1;
      if (object instanceof H.Closure) {
        functionRti = H.extractFunctionTypeObjectFromInternal(J.getInterceptor(object));
        if (functionRti != null)
          return H.runtimeTypeToString(functionRti, null);
      }
      className = J.getInterceptor(object).constructor.builtin$cls;
      if (object == null)
        return className;
      t1 = H.joinArgumentsV1(object.$ti, 0, null);
      return className + t1;
    },
    substitute: function(substitution, $arguments) {
      if (substitution == null)
        return $arguments;
      substitution = substitution.apply(null, $arguments);
      if (substitution == null)
        return;
      if (typeof substitution === "object" && substitution !== null && substitution.constructor === Array)
        return substitution;
      if (typeof substitution == "function")
        return substitution.apply(null, $arguments);
      return $arguments;
    },
    checkSubtypeV1: function(object, isField, checks, asField) {
      var $arguments, interceptor;
      if (object == null)
        return false;
      $arguments = H.getRuntimeTypeInfo(object);
      interceptor = J.getInterceptor(object);
      if (interceptor[isField] == null)
        return false;
      return H.areSubtypesV1(H.substitute(interceptor[asField], $arguments), checks);
    },
    subtypeCast: function(object, isField, checks, asField) {
      var t1, t2;
      if (object == null)
        return object;
      t1 = H.checkSubtypeV1(object, isField, checks, asField);
      if (t1)
        return object;
      t1 = isField.substring(3);
      t2 = H.joinArgumentsV1(checks, 0, null);
      throw H.wrapException(H.CastErrorImplementation$(object, function(str, names) {
        return str.replace(/[^<,> ]+/g, function(m) {
          return names[m] || m;
        });
      }(t1 + t2, init.mangledGlobalNames)));
    },
    areSubtypesV1: function(s, t) {
      var len, i;
      if (s == null || t == null)
        return true;
      len = s.length;
      for (i = 0; i < len; ++i)
        if (!H.isSubtypeV1(s[i], t[i]))
          return false;
      return true;
    },
    computeSignature: function(signature, context, contextName) {
      return signature.apply(context, H.substitute(J.getInterceptor(context)["$as" + H.S(contextName)], H.getRuntimeTypeInfo(context)));
    },
    checkSubtypeOfRuntimeType: function(o, t) {
      var t1, type, rti;
      if (o == null) {
        t1 = t == null || t.builtin$cls === "Object" || t.builtin$cls === "Null";
        return t1;
      }
      t1 = t == null || t.builtin$cls === "Object";
      if (t1)
        return true;
      if (typeof t == "object")
        if ('func' in t)
          return H.functionTypeTest(o, t);
      type = J.getInterceptor(o).constructor;
      rti = H.getRuntimeTypeInfo(o);
      if (rti != null) {
        rti = rti.slice();
        rti.splice(0, 0, type);
        type = rti;
      }
      t1 = H.isSubtypeV1(type, t);
      return t1;
    },
    subtypeOfRuntimeTypeCast: function(object, type) {
      if (object != null && !H.checkSubtypeOfRuntimeType(object, type))
        throw H.wrapException(H.CastErrorImplementation$(object, H.runtimeTypeToString(type, null)));
      return object;
    },
    isSubtypeV1: function(s, t) {
      var t1, typeOfS, t2, typeOfT, typeOfTString, substitution;
      if (s === t)
        return true;
      if (s == null || t == null)
        return true;
      if (typeof s === "number")
        return false;
      if (typeof t === "number")
        return false;
      if (s.builtin$cls === "Null")
        return true;
      if ('func' in t)
        return H.isFunctionSubtypeV1(s, t);
      if ('func' in s)
        return t.builtin$cls === "Function" || t.builtin$cls === "Object";
      t1 = typeof s === "object" && s !== null && s.constructor === Array;
      typeOfS = t1 ? s[0] : s;
      t2 = typeof t === "object" && t !== null && t.constructor === Array;
      typeOfT = t2 ? t[0] : t;
      if (typeOfT !== typeOfS) {
        typeOfTString = H.runtimeTypeToString(typeOfT, null);
        if (!('$is' + typeOfTString in typeOfS.prototype))
          return false;
        substitution = typeOfS.prototype["$as" + typeOfTString];
      } else
        substitution = null;
      if (!t1 && substitution == null || !t2)
        return true;
      t1 = t1 ? s.slice(1) : null;
      t2 = t.slice(1);
      return H.areSubtypesV1(H.substitute(substitution, t1), t2);
    },
    areAssignableV1: function(s, t, allowShorter) {
      var t1, sLength, tLength, i, t2;
      t1 = t == null;
      if (t1 && s == null)
        return true;
      if (t1)
        return allowShorter;
      if (s == null)
        return false;
      sLength = s.length;
      tLength = t.length;
      if (allowShorter) {
        if (sLength < tLength)
          return false;
      } else if (sLength !== tLength)
        return false;
      for (i = 0; i < tLength; ++i) {
        t1 = s[i];
        t2 = t[i];
        if (!(H.isSubtypeV1(t1, t2) || H.isSubtypeV1(t2, t1)))
          return false;
      }
      return true;
    },
    areAssignableMapsV1: function(s, t) {
      var names, t1, i, $name, tType, sType;
      if (t == null)
        return true;
      if (s == null)
        return false;
      names = J.JSArray_markFixedList(Object.getOwnPropertyNames(t));
      for (t1 = names.length, i = 0; i < t1; ++i) {
        $name = names[i];
        if (!Object.hasOwnProperty.call(s, $name))
          return false;
        tType = t[$name];
        sType = s[$name];
        if (!(H.isSubtypeV1(tType, sType) || H.isSubtypeV1(sType, tType)))
          return false;
      }
      return true;
    },
    isFunctionSubtypeV1: function(s, t) {
      var sReturnType, tReturnType, sParameterTypes, tParameterTypes, sOptionalParameterTypes, tOptionalParameterTypes, sParametersLen, tParametersLen, sOptionalParametersLen, tOptionalParametersLen, pos, t1, t2, tPos, sPos;
      if (!('func' in s))
        return false;
      if ("v" in s) {
        if (!("v" in t) && "ret" in t)
          return false;
      } else if (!("v" in t)) {
        sReturnType = s.ret;
        tReturnType = t.ret;
        if (!(H.isSubtypeV1(sReturnType, tReturnType) || H.isSubtypeV1(tReturnType, sReturnType)))
          return false;
      }
      sParameterTypes = s.args;
      tParameterTypes = t.args;
      sOptionalParameterTypes = s.opt;
      tOptionalParameterTypes = t.opt;
      sParametersLen = sParameterTypes != null ? sParameterTypes.length : 0;
      tParametersLen = tParameterTypes != null ? tParameterTypes.length : 0;
      sOptionalParametersLen = sOptionalParameterTypes != null ? sOptionalParameterTypes.length : 0;
      tOptionalParametersLen = tOptionalParameterTypes != null ? tOptionalParameterTypes.length : 0;
      if (sParametersLen > tParametersLen)
        return false;
      if (sParametersLen + sOptionalParametersLen < tParametersLen + tOptionalParametersLen)
        return false;
      if (sParametersLen === tParametersLen) {
        if (!H.areAssignableV1(sParameterTypes, tParameterTypes, false))
          return false;
        if (!H.areAssignableV1(sOptionalParameterTypes, tOptionalParameterTypes, true))
          return false;
      } else {
        for (pos = 0; pos < sParametersLen; ++pos) {
          t1 = sParameterTypes[pos];
          t2 = tParameterTypes[pos];
          if (!(H.isSubtypeV1(t1, t2) || H.isSubtypeV1(t2, t1)))
            return false;
        }
        for (tPos = pos, sPos = 0; tPos < tParametersLen; ++sPos, ++tPos) {
          t1 = sOptionalParameterTypes[sPos];
          t2 = tParameterTypes[tPos];
          if (!(H.isSubtypeV1(t1, t2) || H.isSubtypeV1(t2, t1)))
            return false;
        }
        for (tPos = 0; tPos < tOptionalParametersLen; ++sPos, ++tPos) {
          t1 = sOptionalParameterTypes[sPos];
          t2 = tOptionalParameterTypes[tPos];
          if (!(H.isSubtypeV1(t1, t2) || H.isSubtypeV1(t2, t1)))
            return false;
        }
      }
      return H.areAssignableMapsV1(s.named, t.named);
    },
    defineProperty: function(obj, property, value) {
      Object.defineProperty(obj, property, {value: value, enumerable: false, writable: true, configurable: true});
    },
    lookupAndCacheInterceptor: function(obj) {
      var tag, record, interceptor, interceptorClass, mark, t1;
      tag = $.getTagFunction.call$1(obj);
      record = $.dispatchRecordsForInstanceTags[tag];
      if (record != null) {
        Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
        return record.i;
      }
      interceptor = $.interceptorsForUncacheableTags[tag];
      if (interceptor != null)
        return interceptor;
      interceptorClass = init.interceptorsByTag[tag];
      if (interceptorClass == null) {
        tag = $.alternateTagFunction.call$2(obj, tag);
        if (tag != null) {
          record = $.dispatchRecordsForInstanceTags[tag];
          if (record != null) {
            Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
            return record.i;
          }
          interceptor = $.interceptorsForUncacheableTags[tag];
          if (interceptor != null)
            return interceptor;
          interceptorClass = init.interceptorsByTag[tag];
        }
      }
      if (interceptorClass == null)
        return;
      interceptor = interceptorClass.prototype;
      mark = tag[0];
      if (mark === "!") {
        record = H.makeLeafDispatchRecord(interceptor);
        $.dispatchRecordsForInstanceTags[tag] = record;
        Object.defineProperty(obj, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
        return record.i;
      }
      if (mark === "~") {
        $.interceptorsForUncacheableTags[tag] = interceptor;
        return interceptor;
      }
      if (mark === "-") {
        t1 = H.makeLeafDispatchRecord(interceptor);
        Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
        return t1.i;
      }
      if (mark === "+")
        return H.patchInteriorProto(obj, interceptor);
      if (mark === "*")
        throw H.wrapException(P.UnimplementedError$(tag));
      if (init.leafTags[tag] === true) {
        t1 = H.makeLeafDispatchRecord(interceptor);
        Object.defineProperty(Object.getPrototypeOf(obj), init.dispatchPropertyName, {value: t1, enumerable: false, writable: true, configurable: true});
        return t1.i;
      } else
        return H.patchInteriorProto(obj, interceptor);
    },
    patchInteriorProto: function(obj, interceptor) {
      var proto = Object.getPrototypeOf(obj);
      Object.defineProperty(proto, init.dispatchPropertyName, {value: J.makeDispatchRecord(interceptor, proto, null, null), enumerable: false, writable: true, configurable: true});
      return interceptor;
    },
    makeLeafDispatchRecord: function(interceptor) {
      return J.makeDispatchRecord(interceptor, false, null, !!interceptor.$isJavaScriptIndexingBehavior);
    },
    makeDefaultDispatchRecord: function(tag, interceptorClass, proto) {
      var interceptor = interceptorClass.prototype;
      if (init.leafTags[tag] === true)
        return H.makeLeafDispatchRecord(interceptor);
      else
        return J.makeDispatchRecord(interceptor, proto, null, null);
    },
    initNativeDispatch: function() {
      if (true === $.initNativeDispatchFlag)
        return;
      $.initNativeDispatchFlag = true;
      H.initNativeDispatchContinue();
    },
    initNativeDispatchContinue: function() {
      var map, tags, fun, i, tag, proto, record, interceptorClass;
      $.dispatchRecordsForInstanceTags = Object.create(null);
      $.interceptorsForUncacheableTags = Object.create(null);
      H.initHooks();
      map = init.interceptorsByTag;
      tags = Object.getOwnPropertyNames(map);
      if (typeof window != "undefined") {
        window;
        fun = function() {
        };
        for (i = 0; i < tags.length; ++i) {
          tag = tags[i];
          proto = $.prototypeForTagFunction.call$1(tag);
          if (proto != null) {
            record = H.makeDefaultDispatchRecord(tag, map[tag], proto);
            if (record != null) {
              Object.defineProperty(proto, init.dispatchPropertyName, {value: record, enumerable: false, writable: true, configurable: true});
              fun.prototype = proto;
            }
          }
        }
      }
      for (i = 0; i < tags.length; ++i) {
        tag = tags[i];
        if (/^[A-Za-z_]/.test(tag)) {
          interceptorClass = map[tag];
          map["!" + tag] = interceptorClass;
          map["~" + tag] = interceptorClass;
          map["-" + tag] = interceptorClass;
          map["+" + tag] = interceptorClass;
          map["*" + tag] = interceptorClass;
        }
      }
    },
    initHooks: function() {
      var hooks, transformers, i, transformer, getTag, getUnknownTag, prototypeForTag;
      hooks = C.JS_CONST_bDt();
      hooks = H.applyHooksTransformer(C.JS_CONST_0, H.applyHooksTransformer(C.JS_CONST_rr7, H.applyHooksTransformer(C.JS_CONST_Fs4, H.applyHooksTransformer(C.JS_CONST_Fs4, H.applyHooksTransformer(C.JS_CONST_gkc, H.applyHooksTransformer(C.JS_CONST_4hp, H.applyHooksTransformer(C.JS_CONST_QJm(C.JS_CONST_u2C), hooks)))))));
      if (typeof dartNativeDispatchHooksTransformer != "undefined") {
        transformers = dartNativeDispatchHooksTransformer;
        if (typeof transformers == "function")
          transformers = [transformers];
        if (transformers.constructor == Array)
          for (i = 0; i < transformers.length; ++i) {
            transformer = transformers[i];
            if (typeof transformer == "function")
              hooks = transformer(hooks) || hooks;
          }
      }
      getTag = hooks.getTag;
      getUnknownTag = hooks.getUnknownTag;
      prototypeForTag = hooks.prototypeForTag;
      $.getTagFunction = new H.initHooks_closure(getTag);
      $.alternateTagFunction = new H.initHooks_closure0(getUnknownTag);
      $.prototypeForTagFunction = new H.initHooks_closure1(prototypeForTag);
    },
    applyHooksTransformer: function(transformer, hooks) {
      return transformer(hooks) || hooks;
    },
    stringContainsUnchecked: function(receiver, other, startIndex) {
      var t1, t2;
      if (typeof other === "string")
        return receiver.indexOf(other, startIndex) >= 0;
      else {
        t1 = J.getInterceptor(other);
        if (!!t1.$isJSSyntaxRegExp) {
          t1 = C.JSString_methods.substring$1(receiver, startIndex);
          t2 = other._nativeRegExp;
          return t2.test(t1);
        } else {
          t1 = t1.allMatches$1(other, C.JSString_methods.substring$1(receiver, startIndex));
          return !t1.get$isEmpty(t1);
        }
      }
    },
    stringReplaceFirstRE: function(receiver, regexp, replacement, startIndex) {
      var match, t1, start;
      match = regexp._execGlobal$2(receiver, startIndex);
      if (match == null)
        return receiver;
      t1 = match._match;
      start = t1.index;
      return H.stringReplaceRangeUnchecked(receiver, start, start + t1[0].length, replacement);
    },
    stringReplaceAllUnchecked: function(receiver, pattern, replacement) {
      var $length, t1, i, nativeRegexp;
      if (typeof pattern === "string")
        if (pattern === "")
          if (receiver === "")
            return replacement;
          else {
            $length = receiver.length;
            for (t1 = replacement, i = 0; i < $length; ++i)
              t1 = t1 + receiver[i] + replacement;
            return t1.charCodeAt(0) == 0 ? t1 : t1;
          }
        else
          return receiver.replace(new RegExp(pattern.replace(/[[\]{}()*+?.\\^$|]/g, "\\$&"), 'g'), replacement.replace(/\$/g, "$$$$"));
      else if (pattern instanceof H.JSSyntaxRegExp) {
        nativeRegexp = pattern.get$_nativeGlobalVersion();
        nativeRegexp.lastIndex = 0;
        return receiver.replace(nativeRegexp, replacement.replace(/\$/g, "$$$$"));
      } else {
        if (pattern == null)
          H.throwExpression(H.argumentErrorValue(pattern));
        throw H.wrapException("String.replaceAll(Pattern) UNIMPLEMENTED");
      }
    },
    stringReplaceFirstUnchecked: function(receiver, pattern, replacement, startIndex) {
      var index, t1, matches, match;
      if (typeof pattern === "string") {
        index = receiver.indexOf(pattern, startIndex);
        if (index < 0)
          return receiver;
        return H.stringReplaceRangeUnchecked(receiver, index, index + pattern.length, replacement);
      }
      t1 = J.getInterceptor(pattern);
      if (!!t1.$isJSSyntaxRegExp)
        return startIndex === 0 ? receiver.replace(pattern._nativeRegExp, replacement.replace(/\$/g, "$$$$")) : H.stringReplaceFirstRE(receiver, pattern, replacement, startIndex);
      if (pattern == null)
        H.throwExpression(H.argumentErrorValue(pattern));
      t1 = t1.allMatches$2(pattern, receiver, startIndex);
      matches = t1.get$iterator(t1);
      if (!matches.moveNext$0())
        return receiver;
      match = matches.get$current(matches);
      return C.JSString_methods.replaceRange$3(receiver, match.get$start(match), match.get$end(match), replacement);
    },
    stringReplaceRangeUnchecked: function(receiver, start, end, replacement) {
      var prefix, suffix;
      prefix = receiver.substring(0, start);
      suffix = receiver.substring(end);
      return prefix + H.S(replacement) + suffix;
    },
    ConstantMapView: {
      "^": "UnmodifiableMapView;_collection$_map,$ti"
    },
    ConstantMap: {
      "^": "Object;$ti",
      get$isEmpty: function(_) {
        return this.get$length(this) === 0;
      },
      get$isNotEmpty: function(_) {
        return this.get$length(this) !== 0;
      },
      toString$0: function(_) {
        return P.MapBase_mapToString(this);
      },
      $indexSet: function(_, key, val) {
        return H.ConstantMap__throwUnmodifiable();
      },
      putIfAbsent$2: function(key, ifAbsent) {
        return H.ConstantMap__throwUnmodifiable();
      },
      remove$1: function(_, key) {
        return H.ConstantMap__throwUnmodifiable();
      },
      map$1: function(_, transform) {
        var result = P.LinkedHashMap__makeEmpty();
        this.forEach$1(0, new H.ConstantMap_map_closure(this, transform, result));
        return result;
      },
      update$3$ifAbsent: function(key, update, ifAbsent) {
        H.ConstantMap__throwUnmodifiable();
      },
      update$2: function(key, update) {
        return this.update$3$ifAbsent(key, update, null);
      },
      $isMap: 1
    },
    ConstantMap_map_closure: {
      "^": "Closure;$this,transform,result",
      call$2: function(key, value) {
        var entry = this.transform.call$2(key, value);
        this.result.$indexSet(0, entry.get$key(), entry.get$value());
      },
      $signature: function() {
        var t1 = this.$this;
        return {func: 1, args: [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]};
      }
    },
    ConstantStringMap: {
      "^": "ConstantMap;__js_helper$_length,_jsObject,_keys,$ti",
      get$length: function(_) {
        return this.__js_helper$_length;
      },
      containsKey$1: function(key) {
        if (typeof key !== "string")
          return false;
        if ("__proto__" === key)
          return false;
        return this._jsObject.hasOwnProperty(key);
      },
      $index: function(_, key) {
        if (!this.containsKey$1(key))
          return;
        return this._fetch$1(key);
      },
      _fetch$1: function(key) {
        return this._jsObject[key];
      },
      forEach$1: function(_, f) {
        var keys, t1, i, key;
        keys = this._keys;
        for (t1 = keys.length, i = 0; i < t1; ++i) {
          key = keys[i];
          f.call$2(key, this._fetch$1(key));
        }
      },
      get$keys: function() {
        return new H._ConstantMapKeyIterable(this, [H.getTypeArgumentByIndex(this, 0)]);
      },
      get$values: function() {
        return H.MappedIterable_MappedIterable(this._keys, new H.ConstantStringMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
      }
    },
    ConstantStringMap_values_closure: {
      "^": "Closure:0;$this",
      call$1: [function(key) {
        return this.$this._fetch$1(key);
      }, null, null, 4, 0, null, 39, "call"]
    },
    ConstantProtoMap: {
      "^": "ConstantStringMap;_protoValue,__js_helper$_length,_jsObject,_keys,$ti",
      containsKey$1: function(key) {
        if (typeof key !== "string")
          return false;
        if ("__proto__" === key)
          return true;
        return this._jsObject.hasOwnProperty(key);
      },
      _fetch$1: function(key) {
        return "__proto__" === key ? this._protoValue : this._jsObject[key];
      }
    },
    _ConstantMapKeyIterable: {
      "^": "Iterable;_map,$ti",
      get$iterator: function(_) {
        var t1 = this._map._keys;
        return new J.ArrayIterator(t1, t1.length, 0, null, [H.getTypeArgumentByIndex(t1, 0)]);
      },
      get$length: function(_) {
        return this._map._keys.length;
      }
    },
    JSInvocationMirror: {
      "^": "Object;__js_helper$_memberName,_internalName,_kind,_typeArguments,__js_helper$_arguments,_namedArgumentNames,_typeArgumentCount,_namedIndices",
      get$memberName: function() {
        var t1 = this.__js_helper$_memberName;
        return t1;
      },
      get$positionalArguments: function() {
        var t1, argumentCount, list, index;
        if (this._kind === 1)
          return C.List_empty;
        t1 = this.__js_helper$_arguments;
        argumentCount = t1.length - this._namedArgumentNames.length - this._typeArgumentCount;
        if (argumentCount === 0)
          return C.List_empty;
        list = [];
        for (index = 0; index < argumentCount; ++index) {
          if (index >= t1.length)
            return H.ioore(t1, index);
          list.push(t1[index]);
        }
        return J.JSArray_markUnmodifiableList(list);
      },
      get$namedArguments: function() {
        var t1, namedArgumentCount, t2, namedArgumentsStartIndex, t3, map, i, t4, t5;
        if (this._kind !== 0)
          return C.Map_empty;
        t1 = this._namedArgumentNames;
        namedArgumentCount = t1.length;
        t2 = this.__js_helper$_arguments;
        namedArgumentsStartIndex = t2.length - namedArgumentCount - this._typeArgumentCount;
        if (namedArgumentCount === 0)
          return C.Map_empty;
        t3 = P.Symbol0;
        map = new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t3, null]);
        for (i = 0; i < namedArgumentCount; ++i) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          t4 = t1[i];
          t5 = namedArgumentsStartIndex + i;
          if (t5 < 0 || t5 >= t2.length)
            return H.ioore(t2, t5);
          map.$indexSet(0, new H.Symbol(t4), t2[t5]);
        }
        return new H.ConstantMapView(map, [t3, null]);
      }
    },
    ReflectionInfo: {
      "^": "Object;jsFunction,data>,isAccessor,requiredParameterCount,optionalParameterCount,areOptionalParametersNamed,functionType,cachedSortedIndices",
      defaultValue$1: [function(parameter) {
        var t1 = this.requiredParameterCount;
        if (typeof parameter !== "number")
          return parameter.$lt();
        if (parameter < t1)
          return;
        return this.data[3 + parameter - t1];
      }, "call$1", "get$defaultValue", 4, 0, 99],
      static: {
        ReflectionInfo_ReflectionInfo: function(jsFunction) {
          var data, requiredParametersInfo, optionalParametersInfo;
          data = jsFunction.$reflectionInfo;
          if (data == null)
            return;
          data = J.JSArray_markFixedList(data);
          requiredParametersInfo = data[0];
          optionalParametersInfo = data[1];
          return new H.ReflectionInfo(jsFunction, data, (requiredParametersInfo & 2) === 2, requiredParametersInfo >> 2, optionalParametersInfo >> 1, (optionalParametersInfo & 1) === 1, data[2], null);
        }
      }
    },
    Primitives_functionNoSuchMethod_closure: {
      "^": "Closure:22;_box_0,namedArgumentList,$arguments",
      call$2: function($name, argument) {
        var t1 = this._box_0;
        t1.names = t1.names + "$" + H.S($name);
        this.namedArgumentList.push($name);
        this.$arguments.push(argument);
        ++t1.argumentCount;
      }
    },
    TypeErrorDecoder: {
      "^": "Object;_pattern,__js_helper$_arguments,_argumentsExpr,_expr,_method,__js_helper$_receiver",
      matchTypeError$1: function(message) {
        var match, result, t1;
        match = new RegExp(this._pattern).exec(message);
        if (match == null)
          return;
        result = Object.create(null);
        t1 = this.__js_helper$_arguments;
        if (t1 !== -1)
          result.arguments = match[t1 + 1];
        t1 = this._argumentsExpr;
        if (t1 !== -1)
          result.argumentsExpr = match[t1 + 1];
        t1 = this._expr;
        if (t1 !== -1)
          result.expr = match[t1 + 1];
        t1 = this._method;
        if (t1 !== -1)
          result.method = match[t1 + 1];
        t1 = this.__js_helper$_receiver;
        if (t1 !== -1)
          result.receiver = match[t1 + 1];
        return result;
      },
      static: {
        TypeErrorDecoder_extractPattern: function(message) {
          var match, $arguments, argumentsExpr, expr, method, receiver;
          message = message.replace(String({}), '$receiver$').replace(/[[\]{}()*+?.\\^$|]/g, "\\$&");
          match = message.match(/\\\$[a-zA-Z]+\\\$/g);
          if (match == null)
            match = [];
          $arguments = match.indexOf("\\$arguments\\$");
          argumentsExpr = match.indexOf("\\$argumentsExpr\\$");
          expr = match.indexOf("\\$expr\\$");
          method = match.indexOf("\\$method\\$");
          receiver = match.indexOf("\\$receiver\\$");
          return new H.TypeErrorDecoder(message.replace(new RegExp('\\\\\\$arguments\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$argumentsExpr\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$expr\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$method\\\\\\$', 'g'), '((?:x|[^x])*)').replace(new RegExp('\\\\\\$receiver\\\\\\$', 'g'), '((?:x|[^x])*)'), $arguments, argumentsExpr, expr, method, receiver);
        },
        TypeErrorDecoder_provokeCallErrorOn: function(expression) {
          return function($expr$) {
            var $argumentsExpr$ = '$arguments$';
            try {
              $expr$.$method$($argumentsExpr$);
            } catch (e) {
              return e.message;
            }
          }(expression);
        },
        TypeErrorDecoder_provokePropertyErrorOn: function(expression) {
          return function($expr$) {
            try {
              $expr$.$method$;
            } catch (e) {
              return e.message;
            }
          }(expression);
        }
      }
    },
    NullError: {
      "^": "Error;_message,_method",
      toString$0: function(_) {
        var t1 = this._method;
        if (t1 == null)
          return "NullError: " + H.S(this._message);
        return "NullError: method not found: '" + H.S(t1) + "' on null";
      },
      static: {
        NullError$: function(_message, match) {
          return new H.NullError(_message, match == null ? null : match.method);
        }
      }
    },
    JsNoSuchMethodError: {
      "^": "Error;_message,_method,__js_helper$_receiver",
      toString$0: function(_) {
        var t1, t2;
        t1 = this._method;
        if (t1 == null)
          return "NoSuchMethodError: " + H.S(this._message);
        t2 = this.__js_helper$_receiver;
        if (t2 == null)
          return "NoSuchMethodError: method not found: '" + t1 + "' (" + H.S(this._message) + ")";
        return "NoSuchMethodError: method not found: '" + t1 + "' on '" + t2 + "' (" + H.S(this._message) + ")";
      },
      static: {
        JsNoSuchMethodError$: function(_message, match) {
          var t1, t2;
          t1 = match == null;
          t2 = t1 ? null : match.method;
          return new H.JsNoSuchMethodError(_message, t2, t1 ? null : match.receiver);
        }
      }
    },
    UnknownJsTypeError: {
      "^": "Error;_message",
      toString$0: function(_) {
        var t1 = this._message;
        return t1.length === 0 ? "Error" : "Error: " + t1;
      }
    },
    ExceptionAndStackTrace: {
      "^": "Object;dartException,stackTrace<"
    },
    unwrapException_saveStackTrace: {
      "^": "Closure:0;ex",
      call$1: function(error) {
        if (!!J.getInterceptor(error).$isError)
          if (error.$thrownJsError == null)
            error.$thrownJsError = this.ex;
        return error;
      }
    },
    _StackTrace: {
      "^": "Object;__js_helper$_exception,_trace",
      toString$0: function(_) {
        var t1, trace;
        t1 = this._trace;
        if (t1 != null)
          return t1;
        t1 = this.__js_helper$_exception;
        trace = t1 !== null && typeof t1 === "object" ? t1.stack : null;
        t1 = trace == null ? "" : trace;
        this._trace = t1;
        return t1;
      },
      $isStackTrace: 1
    },
    Closure: {
      "^": "Object;",
      toString$0: function(_) {
        return "Closure '" + H.Primitives_objectTypeName(this).trim() + "'";
      },
      get$$call: function() {
        return this;
      },
      $isFunction: 1,
      get$$call: function() {
        return this;
      }
    },
    TearOffClosure: {
      "^": "Closure;"
    },
    StaticClosure: {
      "^": "TearOffClosure;",
      toString$0: function(_) {
        var $name = this.$static_name;
        if ($name == null)
          return "Closure of unknown static method";
        return "Closure '" + $name + "'";
      }
    },
    BoundClosure: {
      "^": "TearOffClosure;_self,_target,__js_helper$_receiver,__js_helper$_name",
      $eq: function(_, other) {
        if (other == null)
          return false;
        if (this === other)
          return true;
        if (!(other instanceof H.BoundClosure))
          return false;
        return this._self === other._self && this._target === other._target && this.__js_helper$_receiver === other.__js_helper$_receiver;
      },
      get$hashCode: function(_) {
        var t1, receiverHashCode;
        t1 = this.__js_helper$_receiver;
        if (t1 == null)
          receiverHashCode = H.Primitives_objectHashCode(this._self);
        else
          receiverHashCode = typeof t1 !== "object" ? J.get$hashCode$(t1) : H.Primitives_objectHashCode(t1);
        return (receiverHashCode ^ H.Primitives_objectHashCode(this._target)) >>> 0;
      },
      toString$0: function(_) {
        var receiver = this.__js_helper$_receiver;
        if (receiver == null)
          receiver = this._self;
        return "Closure '" + H.S(this.__js_helper$_name) + "' of " + ("Instance of '" + H.Primitives_objectTypeName(receiver) + "'");
      },
      static: {
        BoundClosure_selfOf: function(closure) {
          return closure._self;
        },
        BoundClosure_receiverOf: function(closure) {
          return closure.__js_helper$_receiver;
        },
        BoundClosure_computeFieldNamed: function(fieldName) {
          var template, names, t1, i, $name;
          template = new H.BoundClosure("self", "target", "receiver", "name");
          names = J.JSArray_markFixedList(Object.getOwnPropertyNames(template));
          for (t1 = names.length, i = 0; i < t1; ++i) {
            $name = names[i];
            if (template[$name] === fieldName)
              return $name;
          }
        }
      }
    },
    CastErrorImplementation: {
      "^": "Error;message>",
      toString$0: function(_) {
        return this.message;
      },
      $isCastError: 1,
      static: {
        CastErrorImplementation$: function(value, type) {
          return new H.CastErrorImplementation("CastError: " + H.S(P.Error_safeToString(value)) + ": type '" + H._typeDescription(value) + "' is not a subtype of type '" + type + "'");
        }
      }
    },
    RuntimeError: {
      "^": "Error;message>",
      toString$0: function(_) {
        return "RuntimeError: " + H.S(this.message);
      },
      static: {
        RuntimeError$: function(message) {
          return new H.RuntimeError(message);
        }
      }
    },
    TypeImpl: {
      "^": "Object;_typeName,_unmangledName",
      toString$0: function(_) {
        var t1, unmangledName;
        t1 = this._unmangledName;
        if (t1 != null)
          return t1;
        unmangledName = function(str, names) {
          return str.replace(/[^<,> ]+/g, function(m) {
            return names[m] || m;
          });
        }(this._typeName, init.mangledGlobalNames);
        this._unmangledName = unmangledName;
        return unmangledName;
      },
      get$hashCode: function(_) {
        return J.get$hashCode$(this._typeName);
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        return other instanceof H.TypeImpl && J.$eq$(this._typeName, other._typeName) === true;
      }
    },
    JsLinkedHashMap: {
      "^": "MapBase;__js_helper$_length,_strings,_nums,_rest,_first,_last,_modifications,$ti",
      get$length: function(_) {
        return this.__js_helper$_length;
      },
      get$isEmpty: function(_) {
        return this.__js_helper$_length === 0;
      },
      get$isNotEmpty: function(_) {
        return !this.get$isEmpty(this);
      },
      get$keys: function() {
        return new H.LinkedHashMapKeyIterable(this, [H.getTypeArgumentByIndex(this, 0)]);
      },
      get$values: function() {
        return H.MappedIterable_MappedIterable(this.get$keys(), new H.JsLinkedHashMap_values_closure(this), H.getTypeArgumentByIndex(this, 0), H.getTypeArgumentByIndex(this, 1));
      },
      containsKey$1: [function(key) {
        var strings, nums;
        if (typeof key === "string") {
          strings = this._strings;
          if (strings == null)
            return false;
          return this._containsTableEntry$2(strings, key);
        } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
          nums = this._nums;
          if (nums == null)
            return false;
          return this._containsTableEntry$2(nums, key);
        } else
          return this.internalContainsKey$1(key);
      }, "call$1", "get$containsKey", 4, 0, 13],
      internalContainsKey$1: ["super$JsLinkedHashMap$internalContainsKey", function(key) {
        var rest = this._rest;
        if (rest == null)
          return false;
        return this.internalFindBucketIndex$2(this._getTableBucket$2(rest, this.internalComputeHashCode$1(key)), key) >= 0;
      }],
      addAll$1: function(_, other) {
        J.forEach$1$ax(other, new H.JsLinkedHashMap_addAll_closure(this));
      },
      $index: function(_, key) {
        var strings, cell, t1, nums;
        if (typeof key === "string") {
          strings = this._strings;
          if (strings == null)
            return;
          cell = this._getTableCell$2(strings, key);
          t1 = cell == null ? null : cell.get$hashMapCellValue();
          return t1;
        } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
          nums = this._nums;
          if (nums == null)
            return;
          cell = this._getTableCell$2(nums, key);
          t1 = cell == null ? null : cell.get$hashMapCellValue();
          return t1;
        } else
          return this.internalGet$1(key);
      },
      internalGet$1: ["super$JsLinkedHashMap$internalGet", function(key) {
        var rest, bucket, index;
        rest = this._rest;
        if (rest == null)
          return;
        bucket = this._getTableBucket$2(rest, this.internalComputeHashCode$1(key));
        index = this.internalFindBucketIndex$2(bucket, key);
        if (index < 0)
          return;
        return bucket[index].get$hashMapCellValue();
      }],
      $indexSet: function(_, key, value) {
        var strings, nums;
        if (typeof key === "string") {
          strings = this._strings;
          if (strings == null) {
            strings = this._newHashTable$0();
            this._strings = strings;
          }
          this._addHashTableEntry$3(strings, key, value);
        } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
          nums = this._nums;
          if (nums == null) {
            nums = this._newHashTable$0();
            this._nums = nums;
          }
          this._addHashTableEntry$3(nums, key, value);
        } else
          this.internalSet$2(key, value);
      },
      internalSet$2: ["super$JsLinkedHashMap$internalSet", function(key, value) {
        var rest, hash, bucket, index;
        rest = this._rest;
        if (rest == null) {
          rest = this._newHashTable$0();
          this._rest = rest;
        }
        hash = this.internalComputeHashCode$1(key);
        bucket = this._getTableBucket$2(rest, hash);
        if (bucket == null)
          this._setTableEntry$3(rest, hash, [this._newLinkedCell$2(key, value)]);
        else {
          index = this.internalFindBucketIndex$2(bucket, key);
          if (index >= 0)
            bucket[index].set$hashMapCellValue(value);
          else
            bucket.push(this._newLinkedCell$2(key, value));
        }
      }],
      putIfAbsent$2: function(key, ifAbsent) {
        var value;
        if (this.containsKey$1(key))
          return this.$index(0, key);
        value = ifAbsent.call$0();
        this.$indexSet(0, key, value);
        return value;
      },
      remove$1: function(_, key) {
        if (typeof key === "string")
          return this._removeHashTableEntry$2(this._strings, key);
        else if (typeof key === "number" && (key & 0x3ffffff) === key)
          return this._removeHashTableEntry$2(this._nums, key);
        else
          return this.internalRemove$1(key);
      },
      internalRemove$1: ["super$JsLinkedHashMap$internalRemove", function(key) {
        var rest, bucket, index, cell;
        rest = this._rest;
        if (rest == null)
          return;
        bucket = this._getTableBucket$2(rest, this.internalComputeHashCode$1(key));
        index = this.internalFindBucketIndex$2(bucket, key);
        if (index < 0)
          return;
        cell = bucket.splice(index, 1)[0];
        this._unlinkCell$1(cell);
        return cell.get$hashMapCellValue();
      }],
      clear$0: function(_) {
        if (this.__js_helper$_length > 0) {
          this._last = null;
          this._first = null;
          this._rest = null;
          this._nums = null;
          this._strings = null;
          this.__js_helper$_length = 0;
          this._modified$0();
        }
      },
      forEach$1: function(_, action) {
        var cell, modifications;
        cell = this._first;
        modifications = this._modifications;
        for (; cell != null;) {
          action.call$2(cell.hashMapCellKey, cell.hashMapCellValue);
          if (modifications !== this._modifications)
            throw H.wrapException(P.ConcurrentModificationError$(this));
          cell = cell._next;
        }
      },
      _addHashTableEntry$3: function(table, key, value) {
        var cell = this._getTableCell$2(table, key);
        if (cell == null)
          this._setTableEntry$3(table, key, this._newLinkedCell$2(key, value));
        else
          cell.set$hashMapCellValue(value);
      },
      _removeHashTableEntry$2: function(table, key) {
        var cell;
        if (table == null)
          return;
        cell = this._getTableCell$2(table, key);
        if (cell == null)
          return;
        this._unlinkCell$1(cell);
        this._deleteTableEntry$2(table, key);
        return cell.get$hashMapCellValue();
      },
      _modified$0: function() {
        this._modifications = this._modifications + 1 & 67108863;
      },
      _newLinkedCell$2: function(key, value) {
        var cell, last;
        cell = new H.LinkedHashMapCell(key, value, null, null);
        if (this._first == null) {
          this._last = cell;
          this._first = cell;
        } else {
          last = this._last;
          cell._previous = last;
          last._next = cell;
          this._last = cell;
        }
        ++this.__js_helper$_length;
        this._modified$0();
        return cell;
      },
      _unlinkCell$1: function(cell) {
        var previous, next;
        previous = cell.get$_previous();
        next = cell.get$_next();
        if (previous == null)
          this._first = next;
        else
          previous._next = next;
        if (next == null)
          this._last = previous;
        else
          next._previous = previous;
        --this.__js_helper$_length;
        this._modified$0();
      },
      internalComputeHashCode$1: function(key) {
        return J.get$hashCode$(key) & 0x3ffffff;
      },
      internalFindBucketIndex$2: function(bucket, key) {
        var $length, i;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; ++i)
          if (J.$eq$(bucket[i].get$hashMapCellKey(), key) === true)
            return i;
        return -1;
      },
      toString$0: function(_) {
        return P.MapBase_mapToString(this);
      },
      _getTableCell$2: function(table, key) {
        return table[key];
      },
      _getTableBucket$2: function(table, key) {
        return table[key];
      },
      _setTableEntry$3: function(table, key, value) {
        table[key] = value;
      },
      _deleteTableEntry$2: function(table, key) {
        delete table[key];
      },
      _containsTableEntry$2: function(table, key) {
        return this._getTableCell$2(table, key) != null;
      },
      _newHashTable$0: function() {
        var table = Object.create(null);
        this._setTableEntry$3(table, "<non-identifier-key>", table);
        this._deleteTableEntry$2(table, "<non-identifier-key>");
        return table;
      }
    },
    JsLinkedHashMap_values_closure: {
      "^": "Closure:0;$this",
      call$1: [function(each) {
        return this.$this.$index(0, each);
      }, null, null, 4, 0, null, 33, "call"]
    },
    JsLinkedHashMap_addAll_closure: {
      "^": "Closure;$this",
      call$2: function(key, value) {
        this.$this.$indexSet(0, key, value);
      },
      $signature: function() {
        var t1 = this.$this;
        return {func: 1, args: [H.getTypeArgumentByIndex(t1, 0), H.getTypeArgumentByIndex(t1, 1)]};
      }
    },
    LinkedHashMapCell: {
      "^": "Object;hashMapCellKey<,hashMapCellValue@,_next<,_previous<"
    },
    LinkedHashMapKeyIterable: {
      "^": "EfficientLengthIterable;_map,$ti",
      get$length: function(_) {
        return this._map.__js_helper$_length;
      },
      get$isEmpty: function(_) {
        return this._map.__js_helper$_length === 0;
      },
      get$iterator: function(_) {
        var t1, t2;
        t1 = this._map;
        t2 = new H.LinkedHashMapKeyIterator(t1, t1._modifications, null, null, this.$ti);
        t2._cell = t1._first;
        return t2;
      },
      contains$1: function(_, element) {
        return this._map.containsKey$1(element);
      },
      forEach$1: function(_, f) {
        var t1, cell, modifications;
        t1 = this._map;
        cell = t1._first;
        modifications = t1._modifications;
        for (; cell != null;) {
          f.call$1(cell.hashMapCellKey);
          if (modifications !== t1._modifications)
            throw H.wrapException(P.ConcurrentModificationError$(t1));
          cell = cell._next;
        }
      }
    },
    LinkedHashMapKeyIterator: {
      "^": "Object;_map,_modifications,_cell,__js_helper$_current,$ti",
      get$current: function(_) {
        return this.__js_helper$_current;
      },
      moveNext$0: function() {
        var t1 = this._map;
        if (this._modifications !== t1._modifications)
          throw H.wrapException(P.ConcurrentModificationError$(t1));
        else {
          t1 = this._cell;
          if (t1 == null) {
            this.__js_helper$_current = null;
            return false;
          } else {
            this.__js_helper$_current = t1.hashMapCellKey;
            this._cell = t1._next;
            return true;
          }
        }
      }
    },
    initHooks_closure: {
      "^": "Closure:0;getTag",
      call$1: function(o) {
        return this.getTag(o);
      }
    },
    initHooks_closure0: {
      "^": "Closure:42;getUnknownTag",
      call$2: function(o, tag) {
        return this.getUnknownTag(o, tag);
      }
    },
    initHooks_closure1: {
      "^": "Closure:14;prototypeForTag",
      call$1: function(tag) {
        return this.prototypeForTag(tag);
      }
    },
    JSSyntaxRegExp: {
      "^": "Object;pattern,_nativeRegExp,_nativeGlobalRegExp,_nativeAnchoredRegExp",
      toString$0: function(_) {
        return "RegExp/" + this.pattern + "/";
      },
      get$_nativeGlobalVersion: function() {
        var t1 = this._nativeGlobalRegExp;
        if (t1 != null)
          return t1;
        t1 = this._nativeRegExp;
        t1 = H.JSSyntaxRegExp_makeNative(this.pattern, t1.multiline, !t1.ignoreCase, true);
        this._nativeGlobalRegExp = t1;
        return t1;
      },
      get$_nativeAnchoredVersion: function() {
        var t1 = this._nativeAnchoredRegExp;
        if (t1 != null)
          return t1;
        t1 = this._nativeRegExp;
        t1 = H.JSSyntaxRegExp_makeNative(this.pattern + "|()", t1.multiline, !t1.ignoreCase, true);
        this._nativeAnchoredRegExp = t1;
        return t1;
      },
      firstMatch$1: function(string) {
        var m;
        if (typeof string !== "string")
          H.throwExpression(H.argumentErrorValue(string));
        m = this._nativeRegExp.exec(string);
        if (m == null)
          return;
        return new H._MatchImplementation(this, m);
      },
      allMatches$2: function(_, string, start) {
        if (start > string.length)
          throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
        return new H._AllMatchesIterable(this, string, start);
      },
      allMatches$1: function($receiver, string) {
        return this.allMatches$2($receiver, string, 0);
      },
      _execGlobal$2: function(string, start) {
        var regexp, match;
        regexp = this.get$_nativeGlobalVersion();
        regexp.lastIndex = start;
        match = regexp.exec(string);
        if (match == null)
          return;
        return new H._MatchImplementation(this, match);
      },
      _execAnchored$2: function(string, start) {
        var regexp, match;
        regexp = this.get$_nativeAnchoredVersion();
        regexp.lastIndex = start;
        match = regexp.exec(string);
        if (match == null)
          return;
        if (0 >= match.length)
          return H.ioore(match, -1);
        if (match.pop() != null)
          return;
        return new H._MatchImplementation(this, match);
      },
      matchAsPrefix$2: function(_, string, start) {
        var t1 = J.getInterceptor$n(start);
        if (t1.$lt(start, 0) || t1.$gt(start, string.length))
          throw H.wrapException(P.RangeError$range(start, 0, string.length, null, null));
        return this._execAnchored$2(string, start);
      },
      static: {
        JSSyntaxRegExp_makeNative: function(source, multiLine, caseSensitive, global) {
          var m, i, g, regexp;
          m = multiLine ? "m" : "";
          i = caseSensitive ? "" : "i";
          g = global ? "g" : "";
          regexp = function(source, modifiers) {
            try {
              return new RegExp(source, modifiers);
            } catch (e) {
              return e;
            }
          }(source, m + i + g);
          if (regexp instanceof RegExp)
            return regexp;
          throw H.wrapException(P.FormatException$("Illegal RegExp pattern (" + String(regexp) + ")", source, null));
        }
      }
    },
    _MatchImplementation: {
      "^": "Object;pattern,_match",
      get$start: function(_) {
        return this._match.index;
      },
      get$end: function(_) {
        var t1 = this._match;
        return t1.index + t1[0].length;
      },
      $index: function(_, index) {
        var t1 = this._match;
        if (index >>> 0 !== index || index >= t1.length)
          return H.ioore(t1, index);
        return t1[index];
      },
      $isMatch: 1
    },
    _AllMatchesIterable: {
      "^": "IterableBase;_re,_string,__js_helper$_start",
      get$iterator: function(_) {
        return new H._AllMatchesIterator(this._re, this._string, this.__js_helper$_start, null);
      },
      $asIterableBase: function() {
        return [P.Match];
      },
      $asIterable: function() {
        return [P.Match];
      }
    },
    _AllMatchesIterator: {
      "^": "Object;_regExp,_string,_nextIndex,__js_helper$_current",
      get$current: function(_) {
        return this.__js_helper$_current;
      },
      moveNext$0: function() {
        var t1, t2, match, nextIndex;
        t1 = this._string;
        if (t1 == null)
          return false;
        t2 = this._nextIndex;
        if (t2 <= t1.length) {
          match = this._regExp._execGlobal$2(t1, t2);
          if (match != null) {
            this.__js_helper$_current = match;
            t1 = match._match;
            t2 = t1.index;
            nextIndex = t2 + t1[0].length;
            this._nextIndex = t2 === nextIndex ? nextIndex + 1 : nextIndex;
            return true;
          }
        }
        this.__js_helper$_current = null;
        this._string = null;
        return false;
      }
    },
    StringMatch: {
      "^": "Object;start>,input,pattern",
      get$end: function(_) {
        return J.$add$ansx(this.start, this.pattern.length);
      },
      $index: function(_, g) {
        if (J.$eq$(g, 0) !== true)
          H.throwExpression(P.RangeError$value(g, null, null));
        return this.pattern;
      },
      $isMatch: 1
    },
    _StringAllMatchesIterable: {
      "^": "Iterable;_input,_pattern,__js_helper$_index",
      get$iterator: function(_) {
        return new H._StringAllMatchesIterator(this._input, this._pattern, this.__js_helper$_index, null);
      },
      get$first: function(_) {
        var t1, t2, index;
        t1 = this._input;
        t2 = this._pattern;
        index = t1.indexOf(t2, this.__js_helper$_index);
        if (index >= 0)
          return new H.StringMatch(index, t1, t2);
        throw H.wrapException(H.IterableElementError_noElement());
      },
      $asIterable: function() {
        return [P.Match];
      }
    },
    _StringAllMatchesIterator: {
      "^": "Object;_input,_pattern,__js_helper$_index,__js_helper$_current",
      moveNext$0: function() {
        var t1, t2, t3, t4, t5, index, end;
        t1 = this.__js_helper$_index;
        t2 = this._pattern;
        t3 = t2.length;
        t4 = this._input;
        t5 = t4.length;
        if (t1 + t3 > t5) {
          this.__js_helper$_current = null;
          return false;
        }
        index = t4.indexOf(t2, t1);
        if (index < 0) {
          this.__js_helper$_index = t5 + 1;
          this.__js_helper$_current = null;
          return false;
        }
        end = index + t3;
        this.__js_helper$_current = new H.StringMatch(index, t4, t2);
        this.__js_helper$_index = end === this.__js_helper$_index ? end + 1 : end;
        return true;
      },
      get$current: function(_) {
        return this.__js_helper$_current;
      }
    }
  }], ["dart._js_names", "dart:_js_names",, H, {
    "^": "",
    extractKeys: function(victim) {
      return J.JSArray_markFixedList(H.setRuntimeTypeInfo(victim ? Object.keys(victim) : [], [null]));
    }
  }], ["dart2js._js_primitives", "dart:_js_primitives",, H, {
    "^": "",
    printString: function(string) {
      if (typeof dartPrint == "function") {
        dartPrint(string);
        return;
      }
      if (typeof console == "object" && typeof console.log != "undefined") {
        console.log(string);
        return;
      }
      if (typeof window == "object")
        return;
      if (typeof print == "function") {
        print(string);
        return;
      }
      throw "Unable to print message: " + String(string);
    }
  }], ["dart.typed_data.implementation", "dart:_native_typed_data",, H, {
    "^": "",
    _ensureNativeList: function(list) {
      return list;
    },
    NativeInt8List__create1: function(arg) {
      return new Int8Array(arg);
    },
    NativeUint8List_NativeUint8List$view: function(buffer, offsetInBytes, $length) {
      var t1;
      if (typeof $length !== "number" || Math.floor($length) !== $length)
        H.throwExpression(P.ArgumentError$("Invalid view length " + H.S($length)));
      t1 = new Uint8Array(buffer, offsetInBytes, $length);
      return t1;
    },
    _checkValidIndex: function(index, list, $length) {
      if (index >>> 0 !== index || index >= $length)
        throw H.wrapException(H.diagnoseIndexError(list, index));
    },
    _checkValidRange: function(start, end, $length) {
      var t1;
      if (!(start >>> 0 !== start))
        if (end == null)
          t1 = J.$gt$n(start, $length);
        else
          t1 = end >>> 0 !== end || J.$gt$n(start, end) || J.$gt$n(end, $length);
      else
        t1 = true;
      if (t1)
        throw H.wrapException(H.diagnoseRangeError(start, end, $length));
      if (end == null)
        return $length;
      return end;
    },
    NativeTypedData: {
      "^": "Interceptor;",
      _invalidPosition$3: function(receiver, position, $length, $name) {
        if (typeof position !== "number" || Math.floor(position) !== position)
          throw H.wrapException(P.ArgumentError$value(position, $name, "Invalid list position"));
        else
          throw H.wrapException(P.RangeError$range(position, 0, $length, $name, null));
      },
      _checkPosition$3: function(receiver, position, $length, $name) {
        if (position >>> 0 !== position || position > $length)
          this._invalidPosition$3(receiver, position, $length, $name);
      },
      "%": "DataView;ArrayBufferView;NativeTypedArray|_NativeTypedArrayOfDouble_NativeTypedArray_ListMixin|_NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin|NativeTypedArrayOfDouble|_NativeTypedArrayOfInt_NativeTypedArray_ListMixin|_NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin|NativeTypedArrayOfInt"
    },
    NativeTypedArray: {
      "^": "NativeTypedData;",
      get$length: function(receiver) {
        return receiver.length;
      },
      _setRangeFast$4: function(receiver, start, end, source, skipCount) {
        var targetLength, count, sourceLength;
        targetLength = receiver.length;
        this._checkPosition$3(receiver, start, targetLength, "start");
        this._checkPosition$3(receiver, end, targetLength, "end");
        if (J.$gt$n(start, end))
          throw H.wrapException(P.RangeError$range(start, 0, end, null, null));
        count = J.$sub$n(end, start);
        if (J.$lt$n(skipCount, 0))
          throw H.wrapException(P.ArgumentError$(skipCount));
        sourceLength = source.length;
        if (typeof skipCount !== "number")
          return H.iae(skipCount);
        if (typeof count !== "number")
          return H.iae(count);
        if (sourceLength - skipCount < count)
          throw H.wrapException(P.StateError$("Not enough elements"));
        if (skipCount !== 0 || sourceLength !== count)
          source = source.subarray(skipCount, skipCount + count);
        receiver.set(source, start);
      },
      $isJavaScriptIndexingBehavior: 1,
      $asJavaScriptIndexingBehavior: Isolate.functionThatReturnsNull
    },
    NativeTypedArrayOfDouble: {
      "^": "_NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin;",
      $index: function(receiver, index) {
        H._checkValidIndex(index, receiver, receiver.length);
        return receiver[index];
      },
      $indexSet: function(receiver, index, value) {
        H._checkValidIndex(index, receiver, receiver.length);
        receiver[index] = value;
      },
      setRange$4: function(receiver, start, end, iterable, skipCount) {
        if (!!J.getInterceptor(iterable).$isNativeTypedArrayOfDouble) {
          this._setRangeFast$4(receiver, start, end, iterable, skipCount);
          return;
        }
        this.super$ListMixin$setRange(receiver, start, end, iterable, skipCount);
      },
      setRange$3: function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.double];
      },
      $asFixedLengthListMixin: function() {
        return [P.double];
      },
      $asListMixin: function() {
        return [P.double];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.double];
      },
      $isList: 1,
      $asList: function() {
        return [P.double];
      }
    },
    NativeTypedArrayOfInt: {
      "^": "_NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin;",
      $indexSet: function(receiver, index, value) {
        H._checkValidIndex(index, receiver, receiver.length);
        receiver[index] = value;
      },
      setRange$4: function(receiver, start, end, iterable, skipCount) {
        if (!!J.getInterceptor(iterable).$isNativeTypedArrayOfInt) {
          this._setRangeFast$4(receiver, start, end, iterable, skipCount);
          return;
        }
        this.super$ListMixin$setRange(receiver, start, end, iterable, skipCount);
      },
      setRange$3: function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      },
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $asFixedLengthListMixin: function() {
        return [P.int];
      },
      $asListMixin: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      $isList: 1,
      $asList: function() {
        return [P.int];
      }
    },
    NativeFloat32List: {
      "^": "NativeTypedArrayOfDouble;",
      sublist$2: function(receiver, start, end) {
        return new Float32Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
      },
      "%": "Float32Array"
    },
    NativeFloat64List: {
      "^": "NativeTypedArrayOfDouble;",
      sublist$2: function(receiver, start, end) {
        return new Float64Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
      },
      "%": "Float64Array"
    },
    NativeInt16List: {
      "^": "NativeTypedArrayOfInt;",
      $index: function(receiver, index) {
        H._checkValidIndex(index, receiver, receiver.length);
        return receiver[index];
      },
      sublist$2: function(receiver, start, end) {
        return new Int16Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
      },
      "%": "Int16Array"
    },
    NativeInt32List: {
      "^": "NativeTypedArrayOfInt;",
      $index: function(receiver, index) {
        H._checkValidIndex(index, receiver, receiver.length);
        return receiver[index];
      },
      sublist$2: function(receiver, start, end) {
        return new Int32Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
      },
      "%": "Int32Array"
    },
    NativeInt8List: {
      "^": "NativeTypedArrayOfInt;",
      $index: function(receiver, index) {
        H._checkValidIndex(index, receiver, receiver.length);
        return receiver[index];
      },
      sublist$2: function(receiver, start, end) {
        return new Int8Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
      },
      "%": "Int8Array"
    },
    NativeUint16List: {
      "^": "NativeTypedArrayOfInt;",
      $index: function(receiver, index) {
        H._checkValidIndex(index, receiver, receiver.length);
        return receiver[index];
      },
      sublist$2: function(receiver, start, end) {
        return new Uint16Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
      },
      "%": "Uint16Array"
    },
    NativeUint32List: {
      "^": "NativeTypedArrayOfInt;",
      $index: function(receiver, index) {
        H._checkValidIndex(index, receiver, receiver.length);
        return receiver[index];
      },
      sublist$2: function(receiver, start, end) {
        return new Uint32Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
      },
      "%": "Uint32Array"
    },
    NativeUint8ClampedList: {
      "^": "NativeTypedArrayOfInt;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        H._checkValidIndex(index, receiver, receiver.length);
        return receiver[index];
      },
      sublist$2: function(receiver, start, end) {
        return new Uint8ClampedArray(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
      },
      "%": "CanvasPixelArray|Uint8ClampedArray"
    },
    NativeUint8List: {
      "^": "NativeTypedArrayOfInt;",
      get$length: function(receiver) {
        return receiver.length;
      },
      $index: function(receiver, index) {
        H._checkValidIndex(index, receiver, receiver.length);
        return receiver[index];
      },
      sublist$2: function(receiver, start, end) {
        return new Uint8Array(receiver.subarray(start, H._checkValidRange(start, end, receiver.length)));
      },
      $isNativeUint8List: 1,
      $isUint8List: 1,
      "%": ";Uint8Array"
    },
    _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin: {
      "^": "NativeTypedArray+ListMixin;"
    },
    _NativeTypedArrayOfDouble_NativeTypedArray_ListMixin_FixedLengthListMixin: {
      "^": "_NativeTypedArrayOfDouble_NativeTypedArray_ListMixin+FixedLengthListMixin;"
    },
    _NativeTypedArrayOfInt_NativeTypedArray_ListMixin: {
      "^": "NativeTypedArray+ListMixin;"
    },
    _NativeTypedArrayOfInt_NativeTypedArray_ListMixin_FixedLengthListMixin: {
      "^": "_NativeTypedArrayOfInt_NativeTypedArray_ListMixin+FixedLengthListMixin;"
    }
  }], ["dart.async", "dart:async",, P, {
    "^": "",
    _AsyncRun__initializeScheduleImmediate: function() {
      var t1, div, span;
      t1 = {};
      if (self.scheduleImmediate != null)
        return P.async__AsyncRun__scheduleImmediateJsOverride$closure();
      if (self.MutationObserver != null && self.document != null) {
        div = self.document.createElement("div");
        span = self.document.createElement("span");
        t1.storedCallback = null;
        new self.MutationObserver(H.convertDartClosureToJS(new P._AsyncRun__initializeScheduleImmediate_internalCallback(t1), 1)).observe(div, {childList: true});
        return new P._AsyncRun__initializeScheduleImmediate_closure(t1, div, span);
      } else if (self.setImmediate != null)
        return P.async__AsyncRun__scheduleImmediateWithSetImmediate$closure();
      return P.async__AsyncRun__scheduleImmediateWithTimer$closure();
    },
    _AsyncRun__scheduleImmediateJsOverride: [function(callback) {
      self.scheduleImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateJsOverride_internalCallback(callback), 0));
    }, "call$1", "async__AsyncRun__scheduleImmediateJsOverride$closure", 4, 0, 19],
    _AsyncRun__scheduleImmediateWithSetImmediate: [function(callback) {
      self.setImmediate(H.convertDartClosureToJS(new P._AsyncRun__scheduleImmediateWithSetImmediate_internalCallback(callback), 0));
    }, "call$1", "async__AsyncRun__scheduleImmediateWithSetImmediate$closure", 4, 0, 19],
    _AsyncRun__scheduleImmediateWithTimer: [function(callback) {
      P.Timer__createTimer(C.Duration_0, callback);
    }, "call$1", "async__AsyncRun__scheduleImmediateWithTimer$closure", 4, 0, 19],
    Timer__createTimer: function(duration, callback) {
      var milliseconds = C.JSNumber_methods._tdivFast$1(duration._duration, 1000);
      return P._TimerImpl$(milliseconds < 0 ? 0 : milliseconds, callback);
    },
    _makeAsyncAwaitCompleter: function() {
      return new P._AsyncAwaitCompleter(new P._SyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]), false, [null]);
    },
    _asyncStartSync: function(bodyFunction, completer) {
      bodyFunction.call$2(0, null);
      completer.set$isSync(true);
      return completer.get$future();
    },
    _asyncAwait: function(object, bodyFunction) {
      P._awaitOnObject(object, bodyFunction);
    },
    _asyncReturn: function(object, completer) {
      completer.complete$1(object);
    },
    _asyncRethrow: function(object, completer) {
      completer.completeError$2(H.unwrapException(object), H.getTraceFromException(object));
    },
    _awaitOnObject: function(object, bodyFunction) {
      var thenCallback, errorCallback, t1, future;
      thenCallback = new P._awaitOnObject_closure(bodyFunction);
      errorCallback = new P._awaitOnObject_closure0(bodyFunction);
      t1 = J.getInterceptor(object);
      if (!!t1.$is_Future)
        object._thenNoZoneRegistration$2(thenCallback, errorCallback);
      else if (!!t1.$isFuture)
        object.then$2$onError(thenCallback, errorCallback);
      else {
        future = new P._Future(0, $.Zone__current, null, [null]);
        future._async$_state = 4;
        future._resultOrListeners = object;
        future._thenNoZoneRegistration$2(thenCallback, null);
      }
    },
    _wrapJsFunctionForAsync: function($function) {
      var $protected = function(fn, ERROR) {
        return function(errorCode, result) {
          while (true)
            try {
              fn(errorCode, result);
              break;
            } catch (error) {
              result = error;
              errorCode = ERROR;
            }
        };
      }($function, 1);
      return $.Zone__current.registerBinaryCallback$1(new P._wrapJsFunctionForAsync_closure($protected));
    },
    _asyncStarHelper: function(object, bodyFunctionOrErrorCode, controller) {
      var t1;
      if (bodyFunctionOrErrorCode === 0) {
        if (controller.get$isCanceled())
          controller.get$cancelationCompleter().complete$0();
        else
          J.close$0$x(controller);
        return;
      } else if (bodyFunctionOrErrorCode === 1) {
        if (controller.get$isCanceled())
          controller.get$cancelationCompleter().completeError$2(H.unwrapException(object), H.getTraceFromException(object));
        else {
          controller.addError$2(H.unwrapException(object), H.getTraceFromException(object));
          J.close$0$x(controller);
        }
        return;
      }
      if (object instanceof P._IterationMarker) {
        if (controller.get$isCanceled()) {
          bodyFunctionOrErrorCode.call$2(2, null);
          return;
        }
        t1 = object.state;
        if (t1 === 0) {
          J.add$1$ax(controller, object.value);
          P.scheduleMicrotask(new P._asyncStarHelper_closure(controller, bodyFunctionOrErrorCode));
          return;
        } else if (t1 === 1) {
          controller.addStream$1(object.value).then$1(new P._asyncStarHelper_closure0(controller, bodyFunctionOrErrorCode));
          return;
        }
      }
      P._awaitOnObject(object, bodyFunctionOrErrorCode);
    },
    _streamOfController: function(controller) {
      return controller.get$stream();
    },
    _makeAsyncStarStreamController: function(body) {
      return P._AsyncStarStreamController$(body, null);
    },
    _makeSyncStarIterable: function(body) {
      return new P._SyncStarIterable(body, [null]);
    },
    _invokeErrorHandler: function(errorHandler, error, stackTrace) {
      if (H.functionTypeTest(errorHandler, {func: 1, args: [P.Null, P.Null]}))
        return errorHandler.call$2(error, stackTrace);
      else
        return errorHandler.call$1(error);
    },
    Future_Future$error: function(error, stackTrace, $T) {
      var t1;
      if (error == null)
        error = new P.NullThrownError();
      t1 = $.Zone__current;
      if (t1 !== C.C__RootZone)
        t1.toString;
      t1 = new P._Future(0, t1, null, [$T]);
      t1._asyncCompleteError$2(error, stackTrace);
      return t1;
    },
    Future_wait: function(futures, cleanUp, eagerError) {
      var _box_0, result, handleError, future, pos, e, st, t1, values, exception;
      _box_0 = {};
      result = new P._Future(0, $.Zone__current, null, [P.List]);
      _box_0.values = null;
      _box_0.remaining = 0;
      _box_0.error = null;
      _box_0.stackTrace = null;
      handleError = new P.Future_wait_handleError(_box_0, cleanUp, false, result);
      try {
        for (t1 = J.get$iterator$ax(futures); t1.moveNext$0();) {
          future = t1.get$current(t1);
          pos = _box_0.remaining;
          future.then$2$onError(new P.Future_wait_closure(_box_0, pos, result, cleanUp, false), handleError);
          ++_box_0.remaining;
        }
        t1 = _box_0.remaining;
        if (t1 === 0) {
          t1 = new P._Future(0, $.Zone__current, null, [null]);
          t1._asyncComplete$1(C.List_empty);
          return t1;
        }
        values = new Array(t1);
        values.fixed$length = Array;
        _box_0.values = values;
      } catch (exception) {
        e = H.unwrapException(exception);
        st = H.getTraceFromException(exception);
        if (_box_0.remaining === 0 || false)
          return P.Future_Future$error(e, st, null);
        else {
          _box_0.error = e;
          _box_0.stackTrace = st;
        }
      }
      return result;
    },
    _completeWithErrorCallback: function(result, error, stackTrace) {
      $.Zone__current.toString;
      result._completeError$2(error, stackTrace);
    },
    _registerErrorHandler: function(errorHandler, zone) {
      if (H.functionTypeTest(errorHandler, {func: 1, args: [P.Object, P.StackTrace]}))
        return zone.registerBinaryCallback$1(errorHandler);
      if (H.functionTypeTest(errorHandler, {func: 1, args: [P.Object]})) {
        zone.toString;
        return errorHandler;
      }
      throw H.wrapException(P.ArgumentError$value(errorHandler, "onError", "Error handler must accept one Object or one Object and a StackTrace as arguments, and return a a valid result"));
    },
    _microtaskLoop: function() {
      var t1, t2;
      for (; t1 = $._nextCallback, t1 != null;) {
        $._lastPriorityCallback = null;
        t2 = t1.get$next();
        $._nextCallback = t2;
        if (t2 == null)
          $._lastCallback = null;
        t1.get$callback().call$0();
      }
    },
    _startMicrotaskLoop: [function() {
      $._isInCallbackLoop = true;
      try {
        P._microtaskLoop();
      } finally {
        $._lastPriorityCallback = null;
        $._isInCallbackLoop = false;
        if ($._nextCallback != null)
          $.$get$_AsyncRun__scheduleImmediateClosure().call$1(P.async___startMicrotaskLoop$closure());
      }
    }, "call$0", "async___startMicrotaskLoop$closure", 0, 0, 3],
    _scheduleAsyncCallback: function(callback) {
      var newEntry = new P._AsyncCallbackEntry(callback, null);
      if ($._nextCallback == null) {
        $._lastCallback = newEntry;
        $._nextCallback = newEntry;
        if (!$._isInCallbackLoop)
          $.$get$_AsyncRun__scheduleImmediateClosure().call$1(P.async___startMicrotaskLoop$closure());
      } else {
        $._lastCallback.next = newEntry;
        $._lastCallback = newEntry;
      }
    },
    _schedulePriorityAsyncCallback: function(callback) {
      var t1, entry, t2;
      t1 = $._nextCallback;
      if (t1 == null) {
        P._scheduleAsyncCallback(callback);
        $._lastPriorityCallback = $._lastCallback;
        return;
      }
      entry = new P._AsyncCallbackEntry(callback, null);
      t2 = $._lastPriorityCallback;
      if (t2 == null) {
        entry.next = t1;
        $._lastPriorityCallback = entry;
        $._nextCallback = entry;
      } else {
        entry.next = t2.next;
        t2.next = entry;
        $._lastPriorityCallback = entry;
        if (entry.next == null)
          $._lastCallback = entry;
      }
    },
    scheduleMicrotask: function(callback) {
      var currentZone = $.Zone__current;
      if (C.C__RootZone === currentZone) {
        P._rootScheduleMicrotask(null, null, C.C__RootZone, callback);
        return;
      }
      currentZone.toString;
      P._rootScheduleMicrotask(null, null, currentZone, currentZone.bindCallbackGuarded$1(callback));
    },
    Stream_Stream$fromFuture: function(future, $T) {
      var controller = P.StreamController_StreamController(null, null, null, null, true, $T);
      future.then$2$onError(new P.Stream_Stream$fromFuture_closure(controller), new P.Stream_Stream$fromFuture_closure0(controller));
      return new P._ControllerStream(controller, [H.getTypeArgumentByIndex(controller, 0)]);
    },
    StreamIterator_StreamIterator: function(stream, $T) {
      return new P._StreamIterator(null, stream, false, [$T]);
    },
    StreamController_StreamController: function(onCancel, onListen, onPause, onResume, sync, $T) {
      return sync ? new P._SyncStreamController(null, 0, null, onListen, onPause, onResume, onCancel, [$T]) : new P._AsyncStreamController(null, 0, null, onListen, onPause, onResume, onCancel, [$T]);
    },
    _runGuarded: function(notificationHandler) {
      var e, s, exception, t1;
      if (notificationHandler == null)
        return;
      try {
        notificationHandler.call$0();
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        t1 = $.Zone__current;
        t1.toString;
        P._rootHandleUncaughtError(null, null, t1, e, s);
      }
    },
    _nullDataHandler: [function(value) {
    }, "call$1", "async___nullDataHandler$closure", 4, 0, 20, 3],
    _nullErrorHandler: [function(error, stackTrace) {
      var t1 = $.Zone__current;
      t1.toString;
      P._rootHandleUncaughtError(null, null, t1, error, stackTrace);
    }, function(error) {
      return P._nullErrorHandler(error, null);
    }, "call$2", "call$1", "async___nullErrorHandler$closure", 4, 2, 9, 2, 4, 5],
    _nullDoneHandler: [function() {
    }, "call$0", "async___nullDoneHandler$closure", 0, 0, 3],
    _runUserCode: function(userCode, onSuccess, onError) {
      var e, s, replacement, error, stackTrace, exception, error0;
      try {
        onSuccess.call$1(userCode.call$0());
      } catch (exception) {
        e = H.unwrapException(exception);
        s = H.getTraceFromException(exception);
        $.Zone__current.toString;
        replacement = null;
        if (replacement == null)
          onError.call$2(e, s);
        else {
          error0 = replacement.get$error();
          error = error0;
          stackTrace = replacement.get$stackTrace();
          onError.call$2(error, stackTrace);
        }
      }
    },
    _cancelAndError: function(subscription, future, error, stackTrace) {
      var cancelFuture = subscription.cancel$0();
      if (!!J.getInterceptor(cancelFuture).$isFuture && cancelFuture !== $.$get$Future__nullFuture())
        cancelFuture.whenComplete$1(new P._cancelAndError_closure(future, error, stackTrace));
      else
        future._completeError$2(error, stackTrace);
    },
    _cancelAndErrorWithReplacement: function(subscription, future, error, stackTrace) {
      $.Zone__current.toString;
      P._cancelAndError(subscription, future, error, stackTrace);
    },
    _cancelAndErrorClosure: function(subscription, future) {
      return new P._cancelAndErrorClosure_closure(subscription, future);
    },
    _cancelAndValue: function(subscription, future, value) {
      var cancelFuture = subscription.cancel$0();
      if (!!J.getInterceptor(cancelFuture).$isFuture && cancelFuture !== $.$get$Future__nullFuture())
        cancelFuture.whenComplete$1(new P._cancelAndValue_closure(future, value));
      else
        future._complete$1(value);
    },
    _addErrorWithReplacement: function(sink, error, stackTrace) {
      $.Zone__current.toString;
      sink._addError$2(error, stackTrace);
    },
    Timer_Timer: function(duration, callback) {
      var t1 = $.Zone__current;
      if (t1 === C.C__RootZone) {
        t1.toString;
        return P.Timer__createTimer(duration, callback);
      }
      return P.Timer__createTimer(duration, t1.bindCallbackGuarded$1(callback));
    },
    _rootHandleUncaughtError: function($self, $parent, zone, error, stackTrace) {
      var t1 = {};
      t1.error = error;
      P._schedulePriorityAsyncCallback(new P._rootHandleUncaughtError_closure(t1, stackTrace));
    },
    _rootRun: function($self, $parent, zone, f) {
      var old, t1;
      t1 = $.Zone__current;
      if (t1 === zone)
        return f.call$0();
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$0();
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootRunUnary: function($self, $parent, zone, f, arg) {
      var old, t1;
      t1 = $.Zone__current;
      if (t1 === zone)
        return f.call$1(arg);
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$1(arg);
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootRunBinary: function($self, $parent, zone, f, arg1, arg2) {
      var old, t1;
      t1 = $.Zone__current;
      if (t1 === zone)
        return f.call$2(arg1, arg2);
      $.Zone__current = zone;
      old = t1;
      try {
        t1 = f.call$2(arg1, arg2);
        return t1;
      } finally {
        $.Zone__current = old;
      }
    },
    _rootScheduleMicrotask: function($self, $parent, zone, f) {
      var t1 = C.C__RootZone !== zone;
      if (t1) {
        if (t1) {
          zone.toString;
          t1 = false;
        } else
          t1 = true;
        f = !t1 ? zone.bindCallbackGuarded$1(f) : zone.bindCallback$1(f);
      }
      P._scheduleAsyncCallback(f);
    },
    _AsyncRun__initializeScheduleImmediate_internalCallback: {
      "^": "Closure:0;_box_0",
      call$1: [function(_) {
        var t1, f;
        t1 = this._box_0;
        f = t1.storedCallback;
        t1.storedCallback = null;
        f.call$0();
      }, null, null, 4, 0, null, 7, "call"]
    },
    _AsyncRun__initializeScheduleImmediate_closure: {
      "^": "Closure:35;_box_0,div,span",
      call$1: function(callback) {
        var t1, t2;
        this._box_0.storedCallback = callback;
        t1 = this.div;
        t2 = this.span;
        t1.firstChild ? t1.removeChild(t2) : t1.appendChild(t2);
      }
    },
    _AsyncRun__scheduleImmediateJsOverride_internalCallback: {
      "^": "Closure:1;callback",
      call$0: [function() {
        this.callback.call$0();
      }, null, null, 0, 0, null, "call"]
    },
    _AsyncRun__scheduleImmediateWithSetImmediate_internalCallback: {
      "^": "Closure:1;callback",
      call$0: [function() {
        this.callback.call$0();
      }, null, null, 0, 0, null, "call"]
    },
    _TimerImpl: {
      "^": "Object;_once,_handle,_tick",
      _TimerImpl$2: function(milliseconds, callback) {
        if (self.setTimeout != null)
          this._handle = self.setTimeout(H.convertDartClosureToJS(new P._TimerImpl_internalCallback(this, callback), 0), milliseconds);
        else
          throw H.wrapException(P.UnsupportedError$("`setTimeout()` not found."));
      },
      cancel$0: function() {
        if (self.setTimeout != null) {
          var t1 = this._handle;
          if (t1 == null)
            return;
          self.clearTimeout(t1);
          this._handle = null;
        } else
          throw H.wrapException(P.UnsupportedError$("Canceling a timer."));
      },
      static: {
        _TimerImpl$: function(milliseconds, callback) {
          var t1 = new P._TimerImpl(true, null, 0);
          t1._TimerImpl$2(milliseconds, callback);
          return t1;
        }
      }
    },
    _TimerImpl_internalCallback: {
      "^": "Closure:3;$this,callback",
      call$0: [function() {
        var t1 = this.$this;
        t1._handle = null;
        t1._tick = 1;
        this.callback.call$0();
      }, null, null, 0, 0, null, "call"]
    },
    _AsyncAwaitCompleter: {
      "^": "Object;_completer,isSync?,$ti",
      complete$1: function(value) {
        var t1;
        if (this.isSync)
          this._completer.complete$1(value);
        else {
          t1 = H.checkSubtypeV1(value, "$isFuture", this.$ti, "$asFuture");
          if (t1) {
            t1 = this._completer;
            value.then$2$onError(t1.get$complete(), t1.get$completeError());
          } else
            P.scheduleMicrotask(new P._AsyncAwaitCompleter_complete_closure(this, value));
        }
      },
      completeError$2: function(e, st) {
        if (this.isSync)
          this._completer.completeError$2(e, st);
        else
          P.scheduleMicrotask(new P._AsyncAwaitCompleter_completeError_closure(this, e, st));
      },
      get$future: function() {
        return this._completer.future;
      }
    },
    _AsyncAwaitCompleter_complete_closure: {
      "^": "Closure:1;$this,value",
      call$0: function() {
        this.$this._completer.complete$1(this.value);
      }
    },
    _AsyncAwaitCompleter_completeError_closure: {
      "^": "Closure:1;$this,e,st",
      call$0: function() {
        this.$this._completer.completeError$2(this.e, this.st);
      }
    },
    _awaitOnObject_closure: {
      "^": "Closure:0;bodyFunction",
      call$1: [function(result) {
        return this.bodyFunction.call$2(0, result);
      }, null, null, 4, 0, null, 15, "call"]
    },
    _awaitOnObject_closure0: {
      "^": "Closure:7;bodyFunction",
      call$2: [function(error, stackTrace) {
        this.bodyFunction.call$2(1, new H.ExceptionAndStackTrace(error, stackTrace));
      }, null, null, 8, 0, null, 4, 5, "call"]
    },
    _wrapJsFunctionForAsync_closure: {
      "^": "Closure:44;$protected",
      call$2: function(errorCode, result) {
        this.$protected(errorCode, result);
      }
    },
    _asyncStarHelper_closure: {
      "^": "Closure:1;controller,bodyFunctionOrErrorCode",
      call$0: function() {
        var t1 = this.controller;
        if (t1.get$isPaused()) {
          t1.set$isSuspended(true);
          return;
        }
        this.bodyFunctionOrErrorCode.call$2(null, 0);
      }
    },
    _asyncStarHelper_closure0: {
      "^": "Closure:0;controller,bodyFunctionOrErrorCode",
      call$1: [function(_) {
        var errorCode = this.controller.get$isCanceled() ? 2 : 0;
        this.bodyFunctionOrErrorCode.call$2(errorCode, null);
      }, null, null, 4, 0, null, 7, "call"]
    },
    _AsyncStarStreamController: {
      "^": "Object;controller,isSuspended?,cancelationCompleter<,$ti",
      get$stream: function() {
        var t1 = this.controller;
        t1.toString;
        return new P._ControllerStream(t1, [H.getTypeArgumentByIndex(t1, 0)]);
      },
      get$isPaused: function() {
        var t1 = this.controller;
        return (t1.get$_async$_state() & 1) !== 0 ? t1.get$_subscription().get$_isInputPaused() : (t1.get$_async$_state() & 2) === 0;
      },
      get$isCanceled: function() {
        return this.cancelationCompleter != null;
      },
      add$1: function(_, $event) {
        return this.controller.add$1(0, $event);
      },
      addStream$1: function(stream) {
        return this.controller.addStream$2$cancelOnError(stream, false);
      },
      addError$2: function(error, stackTrace) {
        return this.controller.addError$2(error, stackTrace);
      },
      close$0: function(_) {
        return this.controller.close$0(0);
      },
      _AsyncStarStreamController$1: function(body, $T) {
        var t1 = new P._AsyncStarStreamController__resumeBody(body);
        this.controller = P.StreamController_StreamController(new P._AsyncStarStreamController_closure(this, body), new P._AsyncStarStreamController_closure0(t1), null, new P._AsyncStarStreamController_closure1(this, t1), false, $T);
      },
      static: {
        _AsyncStarStreamController$: function(body, $T) {
          var t1 = new P._AsyncStarStreamController(null, false, null, [$T]);
          t1._AsyncStarStreamController$1(body, $T);
          return t1;
        }
      }
    },
    _AsyncStarStreamController__resumeBody: {
      "^": "Closure:1;body",
      call$0: function() {
        P.scheduleMicrotask(new P._AsyncStarStreamController__resumeBody_closure(this.body));
      }
    },
    _AsyncStarStreamController__resumeBody_closure: {
      "^": "Closure:1;body",
      call$0: function() {
        this.body.call$2(0, null);
      }
    },
    _AsyncStarStreamController_closure0: {
      "^": "Closure:1;_resumeBody",
      call$0: function() {
        this._resumeBody.call$0();
      }
    },
    _AsyncStarStreamController_closure1: {
      "^": "Closure:1;$this,_resumeBody",
      call$0: function() {
        var t1 = this.$this;
        if (t1.isSuspended) {
          t1.isSuspended = false;
          this._resumeBody.call$0();
        }
      }
    },
    _AsyncStarStreamController_closure: {
      "^": "Closure:1;$this,body",
      call$0: function() {
        var t1 = this.$this;
        if ((t1.controller.get$_async$_state() & 4) === 0) {
          t1.cancelationCompleter = new P._AsyncCompleter(new P._Future(0, $.Zone__current, null, [null]), [null]);
          if (t1.isSuspended) {
            t1.isSuspended = false;
            P.scheduleMicrotask(new P._AsyncStarStreamController__closure(this.body));
          }
          return t1.cancelationCompleter.future;
        }
      }
    },
    _AsyncStarStreamController__closure: {
      "^": "Closure:1;body",
      call$0: function() {
        this.body.call$2(2, null);
      }
    },
    _IterationMarker: {
      "^": "Object;value<,state",
      toString$0: function(_) {
        return "IterationMarker(" + this.state + ", " + H.S(this.value) + ")";
      },
      static: {
        _IterationMarker_yieldStar: function(values) {
          return new P._IterationMarker(values, 1);
        },
        _IterationMarker_endOfIteration: function() {
          return C._IterationMarker_null_2;
        },
        _IterationMarker_yieldSingle: function(value) {
          return new P._IterationMarker(value, 0);
        },
        _IterationMarker_uncaughtError: function(error) {
          return new P._IterationMarker(error, 3);
        }
      }
    },
    _SyncStarIterator: {
      "^": "Object;_body,_async$_current,_nestedIterator,_suspendedBodies,$ti",
      get$current: function(_) {
        var t1 = this._nestedIterator;
        if (t1 == null)
          return this._async$_current;
        return t1.get$current(t1);
      },
      moveNext$0: function() {
        var t1, value, state, inner;
        for (; true;) {
          t1 = this._nestedIterator;
          if (t1 != null)
            if (t1.moveNext$0())
              return true;
            else
              this._nestedIterator = null;
          value = function(body, SUCCESS, ERROR) {
            var errorValue, errorCode = SUCCESS;
            while (true)
              try {
                return body(errorCode, errorValue);
              } catch (error) {
                errorValue = error;
                errorCode = ERROR;
              }
          }(this._body, 0, 1);
          if (value instanceof P._IterationMarker) {
            state = value.state;
            if (state === 2) {
              t1 = this._suspendedBodies;
              if (t1 == null || t1.length === 0) {
                this._async$_current = null;
                return false;
              }
              if (0 >= t1.length)
                return H.ioore(t1, -1);
              this._body = t1.pop();
              continue;
            } else {
              t1 = value.value;
              if (state === 3)
                throw t1;
              else {
                inner = J.get$iterator$ax(t1);
                if (!!inner.$is_SyncStarIterator) {
                  t1 = this._suspendedBodies;
                  if (t1 == null) {
                    t1 = [];
                    this._suspendedBodies = t1;
                  }
                  t1.push(this._body);
                  this._body = inner._body;
                  continue;
                } else {
                  this._nestedIterator = inner;
                  continue;
                }
              }
            }
          } else {
            this._async$_current = value;
            return true;
          }
        }
        return false;
      }
    },
    _SyncStarIterable: {
      "^": "IterableBase;_outerHelper,$ti",
      get$iterator: function(_) {
        return new P._SyncStarIterator(this._outerHelper(), null, null, null, this.$ti);
      }
    },
    _BroadcastStream: {
      "^": "_ControllerStream;_async$_controller,$ti",
      get$isBroadcast: function() {
        return true;
      }
    },
    _BroadcastSubscription: {
      "^": "_ControllerSubscription;_eventState@,_async$_next@,_async$_previous@,_async$_controller,_onData,_onError,_onDone,_zone,_async$_state,_cancelFuture,_pending,$ti",
      _expectsEvent$1: function(eventId) {
        return (this._eventState & 1) === eventId;
      },
      _toggleEventId$0: function() {
        this._eventState ^= 1;
      },
      get$_isFiring: function() {
        return (this._eventState & 2) !== 0;
      },
      _setRemoveAfterFiring$0: function() {
        this._eventState |= 4;
      },
      get$_removeAfterFiring: function() {
        return (this._eventState & 4) !== 0;
      },
      _async$_onPause$0: [function() {
      }, "call$0", "get$_async$_onPause", 0, 0, 3],
      _async$_onResume$0: [function() {
      }, "call$0", "get$_async$_onResume", 0, 0, 3]
    },
    _BroadcastStreamController: {
      "^": "Object;onListen?,onCancel?,_async$_state<,$ti",
      set$onPause: function(onPauseHandler) {
        throw H.wrapException(P.UnsupportedError$("Broadcast stream controllers do not support pause callbacks"));
      },
      set$onResume: function(onResumeHandler) {
        throw H.wrapException(P.UnsupportedError$("Broadcast stream controllers do not support pause callbacks"));
      },
      get$stream: function() {
        return new P._BroadcastStream(this, this.$ti);
      },
      get$isPaused: function() {
        return false;
      },
      get$_mayAddEvent: function() {
        return this._async$_state < 4;
      },
      _ensureDoneFuture$0: function() {
        var t1 = this._doneFuture;
        if (t1 != null)
          return t1;
        t1 = new P._Future(0, $.Zone__current, null, [null]);
        this._doneFuture = t1;
        return t1;
      },
      _addListener$1: function(subscription) {
        var oldLast;
        subscription.set$_eventState(this._async$_state & 1);
        oldLast = this._lastSubscription;
        this._lastSubscription = subscription;
        subscription.set$_async$_next(null);
        subscription.set$_async$_previous(oldLast);
        if (oldLast == null)
          this._firstSubscription = subscription;
        else
          oldLast.set$_async$_next(subscription);
      },
      _removeListener$1: function(subscription) {
        var previous, next;
        previous = subscription.get$_async$_previous();
        next = subscription.get$_async$_next();
        if (previous == null)
          this._firstSubscription = next;
        else
          previous.set$_async$_next(next);
        if (next == null)
          this._lastSubscription = previous;
        else
          next.set$_async$_previous(previous);
        subscription.set$_async$_previous(subscription);
        subscription.set$_async$_next(subscription);
      },
      _subscribe$4: function(onData, onError, onDone, cancelOnError) {
        var t1, t2, subscription;
        if ((this._async$_state & 4) !== 0) {
          if (onDone == null)
            onDone = P.async___nullDoneHandler$closure();
          t1 = new P._DoneStreamSubscription($.Zone__current, 0, onDone, this.$ti);
          t1._schedule$0();
          return t1;
        }
        t1 = $.Zone__current;
        t2 = cancelOnError ? 1 : 0;
        subscription = new P._BroadcastSubscription(0, null, null, this, null, null, null, t1, t2, null, null, this.$ti);
        subscription._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, H.getTypeArgumentByIndex(this, 0));
        subscription._async$_previous = subscription;
        subscription._async$_next = subscription;
        this._addListener$1(subscription);
        t1 = this._firstSubscription;
        t2 = this._lastSubscription;
        if (t1 == null ? t2 == null : t1 === t2)
          P._runGuarded(this.onListen);
        return subscription;
      },
      _recordCancel$1: function(sub) {
        if (sub.get$_async$_next() === sub)
          return;
        if (sub.get$_isFiring())
          sub._setRemoveAfterFiring$0();
        else {
          this._removeListener$1(sub);
          if ((this._async$_state & 2) === 0 && this._firstSubscription == null)
            this._callOnCancel$0();
        }
        return;
      },
      _recordPause$1: function(subscription) {
      },
      _recordResume$1: function(subscription) {
      },
      _addEventError$0: ["super$_BroadcastStreamController$_addEventError", function() {
        if ((this._async$_state & 4) !== 0)
          return new P.StateError("Cannot add new events after calling close");
        return new P.StateError("Cannot add new events while doing an addStream");
      }],
      add$1: function(_, data) {
        if (!this.get$_mayAddEvent())
          throw H.wrapException(this._addEventError$0());
        this._sendData$1(data);
      },
      addError$2: function(error, stackTrace) {
        if (error == null)
          error = new P.NullThrownError();
        if (!this.get$_mayAddEvent())
          throw H.wrapException(this._addEventError$0());
        $.Zone__current.toString;
        this._sendError$2(error, stackTrace);
      },
      close$0: function(_) {
        var doneFuture;
        if ((this._async$_state & 4) !== 0)
          return this._doneFuture;
        if (!this.get$_mayAddEvent())
          throw H.wrapException(this._addEventError$0());
        this._async$_state |= 4;
        doneFuture = this._ensureDoneFuture$0();
        this._sendDone$0();
        return doneFuture;
      },
      addStream$2$cancelOnError: function(stream, cancelOnError) {
        var t1;
        if (!this.get$_mayAddEvent())
          throw H.wrapException(this._addEventError$0());
        this._async$_state |= 8;
        t1 = P._AddStreamState$(this, stream, false, null);
        this._addStreamState = t1;
        return t1.addStreamFuture;
      },
      addStream$1: function(stream) {
        return this.addStream$2$cancelOnError(stream, null);
      },
      _async$_add$1: [function(data) {
        this._sendData$1(data);
      }, "call$1", "get$_async$_add", 4, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_BroadcastStreamController");
      }, 16],
      _addError$2: [function(error, stackTrace) {
        this._sendError$2(error, stackTrace);
      }, "call$2", "get$_addError", 8, 0, 41, 4, 5],
      _close$0: [function() {
        var addState = this._addStreamState;
        this._addStreamState = null;
        this._async$_state &= 4294967287;
        addState.addStreamFuture._asyncComplete$1(null);
      }, "call$0", "get$_close", 0, 0, 3],
      _forEachListener$1: function(action) {
        var t1, subscription, id, next;
        t1 = this._async$_state;
        if ((t1 & 2) !== 0)
          throw H.wrapException(P.StateError$("Cannot fire new event. Controller is already firing an event"));
        subscription = this._firstSubscription;
        if (subscription == null)
          return;
        id = t1 & 1;
        this._async$_state = t1 ^ 3;
        for (; subscription != null;)
          if (subscription._expectsEvent$1(id)) {
            subscription.set$_eventState(subscription.get$_eventState() | 2);
            action.call$1(subscription);
            subscription._toggleEventId$0();
            next = subscription.get$_async$_next();
            if (subscription.get$_removeAfterFiring())
              this._removeListener$1(subscription);
            subscription.set$_eventState(subscription.get$_eventState() & 4294967293);
            subscription = next;
          } else
            subscription = subscription.get$_async$_next();
        this._async$_state &= 4294967293;
        if (this._firstSubscription == null)
          this._callOnCancel$0();
      },
      _callOnCancel$0: function() {
        if ((this._async$_state & 4) !== 0 && this._doneFuture._async$_state === 0)
          this._doneFuture._asyncComplete$1(null);
        P._runGuarded(this.onCancel);
      },
      $isEventSink: 1
    },
    _SyncBroadcastStreamController: {
      "^": "_BroadcastStreamController;onListen,onCancel,_async$_state,_firstSubscription,_lastSubscription,_addStreamState,_doneFuture,$ti",
      get$_mayAddEvent: function() {
        return P._BroadcastStreamController.prototype.get$_mayAddEvent.call(this) && (this._async$_state & 2) === 0;
      },
      _addEventError$0: function() {
        if ((this._async$_state & 2) !== 0)
          return new P.StateError("Cannot fire new event. Controller is already firing an event");
        return this.super$_BroadcastStreamController$_addEventError();
      },
      _sendData$1: function(data) {
        var t1 = this._firstSubscription;
        if (t1 == null)
          return;
        if (t1 === this._lastSubscription) {
          this._async$_state |= 2;
          t1._async$_add$1(data);
          this._async$_state &= 4294967293;
          if (this._firstSubscription == null)
            this._callOnCancel$0();
          return;
        }
        this._forEachListener$1(new P._SyncBroadcastStreamController__sendData_closure(this, data));
      },
      _sendError$2: function(error, stackTrace) {
        if (this._firstSubscription == null)
          return;
        this._forEachListener$1(new P._SyncBroadcastStreamController__sendError_closure(this, error, stackTrace));
      },
      _sendDone$0: function() {
        if (this._firstSubscription != null)
          this._forEachListener$1(new P._SyncBroadcastStreamController__sendDone_closure(this));
        else
          this._doneFuture._asyncComplete$1(null);
      }
    },
    _SyncBroadcastStreamController__sendData_closure: {
      "^": "Closure;$this,data",
      call$1: function(subscription) {
        subscription._async$_add$1(this.data);
      },
      $signature: function() {
        return {func: 1, args: [[P._BufferingStreamSubscription, H.getTypeArgumentByIndex(this.$this, 0)]]};
      }
    },
    _SyncBroadcastStreamController__sendError_closure: {
      "^": "Closure;$this,error,stackTrace",
      call$1: function(subscription) {
        subscription._addError$2(this.error, this.stackTrace);
      },
      $signature: function() {
        return {func: 1, args: [[P._BufferingStreamSubscription, H.getTypeArgumentByIndex(this.$this, 0)]]};
      }
    },
    _SyncBroadcastStreamController__sendDone_closure: {
      "^": "Closure;$this",
      call$1: function(subscription) {
        subscription._close$0();
      },
      $signature: function() {
        return {func: 1, args: [[P._BufferingStreamSubscription, H.getTypeArgumentByIndex(this.$this, 0)]]};
      }
    },
    Future: {
      "^": "Object;$ti"
    },
    Future_wait_handleError: {
      "^": "Closure:2;_box_0,cleanUp,eagerError,result",
      call$2: [function(theError, theStackTrace) {
        var t1, t2;
        t1 = this._box_0;
        t2 = --t1.remaining;
        if (t1.values != null) {
          t1.values = null;
          if (t1.remaining === 0 || this.eagerError)
            this.result._completeError$2(theError, theStackTrace);
          else {
            t1.error = theError;
            t1.stackTrace = theStackTrace;
          }
        } else if (t2 === 0 && !this.eagerError)
          this.result._completeError$2(t1.error, t1.stackTrace);
      }, null, null, 8, 0, null, 71, 80, "call"]
    },
    Future_wait_closure: {
      "^": "Closure;_box_0,pos,result,cleanUp,eagerError",
      call$1: [function(value) {
        var t1, t2, t3;
        t1 = this._box_0;
        t2 = --t1.remaining;
        t3 = t1.values;
        if (t3 != null) {
          t1 = this.pos;
          if (t1 < 0 || t1 >= t3.length)
            return H.ioore(t3, t1);
          t3[t1] = value;
          if (t2 === 0)
            this.result._completeWithValue$1(t3);
        } else if (t1.remaining === 0 && !this.eagerError)
          this.result._completeError$2(t1.error, t1.stackTrace);
      }, null, null, 4, 0, null, 3, "call"],
      $signature: function() {
        return {func: 1, args: [,]};
      }
    },
    Completer: {
      "^": "Object;$ti"
    },
    _Completer: {
      "^": "Object;future<,$ti",
      completeError$2: [function(error, stackTrace) {
        if (error == null)
          error = new P.NullThrownError();
        if (this.future._async$_state !== 0)
          throw H.wrapException(P.StateError$("Future already completed"));
        $.Zone__current.toString;
        this._completeError$2(error, stackTrace);
      }, function(error) {
        return this.completeError$2(error, null);
      }, "completeError$1", "call$2", "call$1", "get$completeError", 4, 2, 9, 2, 4, 5]
    },
    _AsyncCompleter: {
      "^": "_Completer;future,$ti",
      complete$1: [function(value) {
        var t1 = this.future;
        if (t1._async$_state !== 0)
          throw H.wrapException(P.StateError$("Future already completed"));
        t1._asyncComplete$1(value);
      }, function() {
        return this.complete$1(null);
      }, "complete$0", "call$1", "call$0", "get$complete", 0, 2, 25, 2, 3],
      _completeError$2: function(error, stackTrace) {
        this.future._asyncCompleteError$2(error, stackTrace);
      }
    },
    _SyncCompleter: {
      "^": "_Completer;future,$ti",
      complete$1: [function(value) {
        var t1 = this.future;
        if (t1._async$_state !== 0)
          throw H.wrapException(P.StateError$("Future already completed"));
        t1._complete$1(value);
      }, function() {
        return this.complete$1(null);
      }, "complete$0", "call$1", "call$0", "get$complete", 0, 2, 25, 2, 3],
      _completeError$2: function(error, stackTrace) {
        this.future._completeError$2(error, stackTrace);
      }
    },
    _FutureListener: {
      "^": "Object;_nextListener@,result>,state,callback<,errorCallback,$ti",
      get$_zone: function() {
        return this.result._zone;
      },
      get$handlesValue: function() {
        return (this.state & 1) !== 0;
      },
      get$handlesError: function() {
        return (this.state & 2) !== 0;
      },
      get$handlesComplete: function() {
        return this.state === 8;
      },
      get$hasErrorCallback: function() {
        return this.errorCallback != null;
      },
      handleValue$1: function(sourceResult) {
        return this.result._zone.runUnary$2(this.callback, sourceResult);
      },
      matchesErrorTest$1: function(asyncError) {
        if (this.state !== 6)
          return true;
        return this.result._zone.runUnary$2(this.callback, asyncError.get$error());
      },
      handleError$1: function(asyncError) {
        var errorCallback, t1;
        errorCallback = this.errorCallback;
        t1 = this.result._zone;
        if (H.functionTypeTest(errorCallback, {func: 1, args: [P.Object, P.StackTrace]}))
          return t1.runBinary$3(errorCallback, asyncError.get$error(), asyncError.get$stackTrace());
        else
          return t1.runUnary$2(errorCallback, asyncError.get$error());
      },
      handleWhenComplete$0: function() {
        return this.result._zone.run$1(0, this.callback);
      },
      callback$1: function(arg0) {
        return this.callback.call$1(arg0);
      }
    },
    _Future: {
      "^": "Object;_async$_state<,_zone<,_resultOrListeners<,$ti",
      get$_isChained: function() {
        return this._async$_state === 2;
      },
      get$_isComplete: function() {
        return this._async$_state >= 4;
      },
      get$_hasError: function() {
        return this._async$_state === 8;
      },
      _setChained$1: function(source) {
        this._async$_state = 2;
        this._resultOrListeners = source;
      },
      then$2$onError: function(f, onError) {
        var currentZone = $.Zone__current;
        if (currentZone !== C.C__RootZone) {
          currentZone.toString;
          if (onError != null)
            onError = P._registerErrorHandler(onError, currentZone);
        }
        return this._thenNoZoneRegistration$2(f, onError);
      },
      then$1: function(f) {
        return this.then$2$onError(f, null);
      },
      _thenNoZoneRegistration$2: function(f, onError) {
        var result, t1;
        result = new P._Future(0, $.Zone__current, null, [null]);
        t1 = onError == null ? 1 : 3;
        this._addListener$1(new P._FutureListener(null, result, t1, f, onError, [H.getTypeArgumentByIndex(this, 0), null]));
        return result;
      },
      whenComplete$1: function(action) {
        var t1, result;
        t1 = $.Zone__current;
        result = new P._Future(0, t1, null, this.$ti);
        if (t1 !== C.C__RootZone)
          t1.toString;
        t1 = H.getTypeArgumentByIndex(this, 0);
        this._addListener$1(new P._FutureListener(null, result, 8, action, null, [t1, t1]));
        return result;
      },
      _setPendingComplete$0: function() {
        this._async$_state = 1;
      },
      _clearPendingComplete$0: function() {
        this._async$_state = 0;
      },
      get$_error: function() {
        return this._resultOrListeners;
      },
      get$_chainSource: function() {
        return this._resultOrListeners;
      },
      _setValue$1: function(value) {
        this._async$_state = 4;
        this._resultOrListeners = value;
      },
      _setErrorObject$1: function(error) {
        this._async$_state = 8;
        this._resultOrListeners = error;
      },
      _cloneResult$1: function(source) {
        this._async$_state = source.get$_async$_state();
        this._resultOrListeners = source.get$_resultOrListeners();
      },
      _addListener$1: function(listener) {
        var t1, source;
        t1 = this._async$_state;
        if (t1 <= 1) {
          listener._nextListener = this._resultOrListeners;
          this._resultOrListeners = listener;
        } else {
          if (t1 === 2) {
            source = this._resultOrListeners;
            if (!source.get$_isComplete()) {
              source._addListener$1(listener);
              return;
            }
            this._async$_state = source.get$_async$_state();
            this._resultOrListeners = source.get$_resultOrListeners();
          }
          t1 = this._zone;
          t1.toString;
          P._rootScheduleMicrotask(null, null, t1, new P._Future__addListener_closure(this, listener));
        }
      },
      _prependListeners$1: function(listeners) {
        var _box_0, t1, existingListeners, cursor, source;
        _box_0 = {};
        _box_0.listeners = listeners;
        if (listeners == null)
          return;
        t1 = this._async$_state;
        if (t1 <= 1) {
          existingListeners = this._resultOrListeners;
          this._resultOrListeners = listeners;
          if (existingListeners != null) {
            for (cursor = listeners; cursor.get$_nextListener() != null;)
              cursor = cursor.get$_nextListener();
            cursor.set$_nextListener(existingListeners);
          }
        } else {
          if (t1 === 2) {
            source = this._resultOrListeners;
            if (!source.get$_isComplete()) {
              source._prependListeners$1(listeners);
              return;
            }
            this._async$_state = source.get$_async$_state();
            this._resultOrListeners = source.get$_resultOrListeners();
          }
          _box_0.listeners = this._reverseListeners$1(listeners);
          t1 = this._zone;
          t1.toString;
          P._rootScheduleMicrotask(null, null, t1, new P._Future__prependListeners_closure(_box_0, this));
        }
      },
      _removeListeners$0: function() {
        var current = this._resultOrListeners;
        this._resultOrListeners = null;
        return this._reverseListeners$1(current);
      },
      _reverseListeners$1: function(listeners) {
        var current, prev, next;
        for (current = listeners, prev = null; current != null; prev = current, current = next) {
          next = current.get$_nextListener();
          current.set$_nextListener(prev);
        }
        return prev;
      },
      _complete$1: function(value) {
        var t1, t2, listeners;
        t1 = this.$ti;
        t2 = H.checkSubtypeV1(value, "$isFuture", t1, "$asFuture");
        if (t2) {
          t1 = H.checkSubtypeV1(value, "$is_Future", t1, null);
          if (t1)
            P._Future__chainCoreFuture(value, this);
          else
            P._Future__chainForeignFuture(value, this);
        } else {
          listeners = this._removeListeners$0();
          this._async$_state = 4;
          this._resultOrListeners = value;
          P._Future__propagateToListeners(this, listeners);
        }
      },
      _completeWithValue$1: function(value) {
        var listeners = this._removeListeners$0();
        this._async$_state = 4;
        this._resultOrListeners = value;
        P._Future__propagateToListeners(this, listeners);
      },
      _completeError$2: [function(error, stackTrace) {
        var listeners = this._removeListeners$0();
        this._async$_state = 8;
        this._resultOrListeners = new P.AsyncError(error, stackTrace);
        P._Future__propagateToListeners(this, listeners);
      }, function(error) {
        return this._completeError$2(error, null);
      }, "_completeError$1", "call$2", "call$1", "get$_completeError", 4, 2, 9, 2, 4, 5],
      _asyncComplete$1: function(value) {
        var t1 = H.checkSubtypeV1(value, "$isFuture", this.$ti, "$asFuture");
        if (t1) {
          this._chainFuture$1(value);
          return;
        }
        this._async$_state = 1;
        t1 = this._zone;
        t1.toString;
        P._rootScheduleMicrotask(null, null, t1, new P._Future__asyncComplete_closure(this, value));
      },
      _chainFuture$1: function(value) {
        var t1 = H.checkSubtypeV1(value, "$is_Future", this.$ti, null);
        if (t1) {
          if (value._async$_state === 8) {
            this._async$_state = 1;
            t1 = this._zone;
            t1.toString;
            P._rootScheduleMicrotask(null, null, t1, new P._Future__chainFuture_closure(this, value));
          } else
            P._Future__chainCoreFuture(value, this);
          return;
        }
        P._Future__chainForeignFuture(value, this);
      },
      _asyncCompleteError$2: function(error, stackTrace) {
        var t1;
        this._async$_state = 1;
        t1 = this._zone;
        t1.toString;
        P._rootScheduleMicrotask(null, null, t1, new P._Future__asyncCompleteError_closure(this, error, stackTrace));
      },
      $isFuture: 1,
      static: {
        _Future$value: function(value, $T) {
          var t1 = new P._Future(0, $.Zone__current, null, [$T]);
          t1._async$_state = 4;
          t1._resultOrListeners = value;
          return t1;
        },
        _Future__chainForeignFuture: function(source, target) {
          var e, s, exception;
          target._setPendingComplete$0();
          try {
            source.then$2$onError(new P._Future__chainForeignFuture_closure(target), new P._Future__chainForeignFuture_closure0(target));
          } catch (exception) {
            e = H.unwrapException(exception);
            s = H.getTraceFromException(exception);
            P.scheduleMicrotask(new P._Future__chainForeignFuture_closure1(target, e, s));
          }
        },
        _Future__chainCoreFuture: function(source, target) {
          var listeners;
          for (; source.get$_isChained();)
            source = source.get$_chainSource();
          if (source.get$_isComplete()) {
            listeners = target._removeListeners$0();
            target._cloneResult$1(source);
            P._Future__propagateToListeners(target, listeners);
          } else {
            listeners = target.get$_resultOrListeners();
            target._setChained$1(source);
            source._prependListeners$1(listeners);
          }
        },
        _Future__propagateToListeners: function(source, listeners) {
          var _box_1, t1, _box_0, hasError, asyncError, t2, t3, listeners0, sourceResult, zone, oldZone, result;
          _box_1 = {};
          _box_1.source = source;
          for (t1 = source; true;) {
            _box_0 = {};
            hasError = t1.get$_hasError();
            if (listeners == null) {
              if (hasError) {
                asyncError = _box_1.source.get$_error();
                t1 = _box_1.source.get$_zone();
                t2 = asyncError.get$error();
                t3 = asyncError.get$stackTrace();
                t1.toString;
                P._rootHandleUncaughtError(null, null, t1, t2, t3);
              }
              return;
            }
            for (; listeners.get$_nextListener() != null; listeners = listeners0) {
              listeners0 = listeners.get$_nextListener();
              listeners.set$_nextListener(null);
              P._Future__propagateToListeners(_box_1.source, listeners);
            }
            sourceResult = _box_1.source.get$_resultOrListeners();
            _box_0.listenerHasError = hasError;
            _box_0.listenerValueOrError = sourceResult;
            t1 = !hasError;
            if (!t1 || listeners.get$handlesValue() || listeners.get$handlesComplete()) {
              zone = listeners.get$_zone();
              if (hasError) {
                t2 = _box_1.source.get$_zone();
                t2.toString;
                t2 = t2 == null ? zone == null : t2 === zone;
                if (!t2)
                  zone.toString;
                else
                  t2 = true;
                t2 = !t2;
              } else
                t2 = false;
              if (t2) {
                asyncError = _box_1.source.get$_error();
                t1 = _box_1.source.get$_zone();
                t2 = asyncError.get$error();
                t3 = asyncError.get$stackTrace();
                t1.toString;
                P._rootHandleUncaughtError(null, null, t1, t2, t3);
                return;
              }
              oldZone = $.Zone__current;
              if (oldZone == null ? zone != null : oldZone !== zone)
                $.Zone__current = zone;
              else
                oldZone = null;
              if (listeners.get$handlesComplete())
                new P._Future__propagateToListeners_handleWhenCompleteCallback(_box_1, _box_0, listeners, hasError).call$0();
              else if (t1) {
                if (listeners.get$handlesValue())
                  new P._Future__propagateToListeners_handleValueCallback(_box_0, listeners, sourceResult).call$0();
              } else if (listeners.get$handlesError())
                new P._Future__propagateToListeners_handleError(_box_1, _box_0, listeners).call$0();
              if (oldZone != null)
                $.Zone__current = oldZone;
              t1 = _box_0.listenerValueOrError;
              if (!!J.getInterceptor(t1).$isFuture) {
                result = J.get$result$x(listeners);
                if (t1._async$_state >= 4) {
                  listeners = result._removeListeners$0();
                  result._cloneResult$1(t1);
                  _box_1.source = t1;
                  continue;
                } else
                  P._Future__chainCoreFuture(t1, result);
                return;
              }
            }
            result = J.get$result$x(listeners);
            listeners = result._removeListeners$0();
            t1 = _box_0.listenerHasError;
            t2 = _box_0.listenerValueOrError;
            if (!t1)
              result._setValue$1(t2);
            else
              result._setErrorObject$1(t2);
            _box_1.source = result;
            t1 = result;
          }
        }
      }
    },
    _Future__addListener_closure: {
      "^": "Closure:1;$this,listener",
      call$0: function() {
        P._Future__propagateToListeners(this.$this, this.listener);
      }
    },
    _Future__prependListeners_closure: {
      "^": "Closure:1;_box_0,$this",
      call$0: function() {
        P._Future__propagateToListeners(this.$this, this._box_0.listeners);
      }
    },
    _Future__chainForeignFuture_closure: {
      "^": "Closure:0;target",
      call$1: function(value) {
        var t1 = this.target;
        t1._clearPendingComplete$0();
        t1._complete$1(value);
      }
    },
    _Future__chainForeignFuture_closure0: {
      "^": "Closure:100;target",
      call$2: [function(error, stackTrace) {
        this.target._completeError$2(error, stackTrace);
      }, function(error) {
        return this.call$2(error, null);
      }, "call$1", null, null, null, 4, 2, null, 2, 4, 5, "call"]
    },
    _Future__chainForeignFuture_closure1: {
      "^": "Closure:1;target,e,s",
      call$0: function() {
        this.target._completeError$2(this.e, this.s);
      }
    },
    _Future__asyncComplete_closure: {
      "^": "Closure:1;$this,value",
      call$0: function() {
        this.$this._completeWithValue$1(this.value);
      }
    },
    _Future__chainFuture_closure: {
      "^": "Closure:1;$this,value",
      call$0: function() {
        P._Future__chainCoreFuture(this.value, this.$this);
      }
    },
    _Future__asyncCompleteError_closure: {
      "^": "Closure:1;$this,error,stackTrace",
      call$0: function() {
        this.$this._completeError$2(this.error, this.stackTrace);
      }
    },
    _Future__propagateToListeners_handleWhenCompleteCallback: {
      "^": "Closure:3;_box_1,_box_0,listener,hasError",
      call$0: function() {
        var completeResult, e, s, exception, t1, t2, originalSource;
        completeResult = null;
        try {
          completeResult = this.listener.handleWhenComplete$0();
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          if (this.hasError) {
            t1 = this._box_1.source.get$_error().get$error();
            t2 = e;
            t2 = t1 == null ? t2 == null : t1 === t2;
            t1 = t2;
          } else
            t1 = false;
          t2 = this._box_0;
          if (t1)
            t2.listenerValueOrError = this._box_1.source.get$_error();
          else
            t2.listenerValueOrError = new P.AsyncError(e, s);
          t2.listenerHasError = true;
          return;
        }
        if (!!J.getInterceptor(completeResult).$isFuture) {
          if (completeResult instanceof P._Future && completeResult.get$_async$_state() >= 4) {
            if (completeResult.get$_async$_state() === 8) {
              t1 = this._box_0;
              t1.listenerValueOrError = completeResult.get$_resultOrListeners();
              t1.listenerHasError = true;
            }
            return;
          }
          originalSource = this._box_1.source;
          t1 = this._box_0;
          t1.listenerValueOrError = completeResult.then$1(new P._Future__propagateToListeners_handleWhenCompleteCallback_closure(originalSource));
          t1.listenerHasError = false;
        }
      }
    },
    _Future__propagateToListeners_handleWhenCompleteCallback_closure: {
      "^": "Closure:0;originalSource",
      call$1: function(_) {
        return this.originalSource;
      }
    },
    _Future__propagateToListeners_handleValueCallback: {
      "^": "Closure:3;_box_0,listener,sourceResult",
      call$0: function() {
        var e, s, exception, t1;
        try {
          this._box_0.listenerValueOrError = this.listener.handleValue$1(this.sourceResult);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          t1 = this._box_0;
          t1.listenerValueOrError = new P.AsyncError(e, s);
          t1.listenerHasError = true;
        }
      }
    },
    _Future__propagateToListeners_handleError: {
      "^": "Closure:3;_box_1,_box_0,listener",
      call$0: function() {
        var asyncError, e, s, t1, t2, exception, t3, t4;
        try {
          asyncError = this._box_1.source.get$_error();
          t1 = this.listener;
          if (t1.matchesErrorTest$1(asyncError) === true && t1.get$hasErrorCallback()) {
            t2 = this._box_0;
            t2.listenerValueOrError = t1.handleError$1(asyncError);
            t2.listenerHasError = false;
          }
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          t1 = this._box_1;
          t2 = t1.source.get$_error().get$error();
          t3 = e;
          t4 = this._box_0;
          if (t2 == null ? t3 == null : t2 === t3)
            t4.listenerValueOrError = t1.source.get$_error();
          else
            t4.listenerValueOrError = new P.AsyncError(e, s);
          t4.listenerHasError = true;
        }
      }
    },
    _AsyncCallbackEntry: {
      "^": "Object;callback<,next@",
      callback$1: function(arg0) {
        return this.callback.call$1(arg0);
      }
    },
    Stream: {
      "^": "Object;$ti",
      get$isBroadcast: function() {
        return false;
      },
      where$1: function(_, test) {
        return new P._WhereStream(test, this, [H.getRuntimeTypeArgument(this, "Stream", 0)]);
      },
      map$1: function(_, convert) {
        return new P._MapStream(convert, this, [H.getRuntimeTypeArgument(this, "Stream", 0), null]);
      },
      handleError$2$test: function(onError, test) {
        return new P._HandleErrorStream(onError, test, this, [H.getRuntimeTypeArgument(this, "Stream", 0)]);
      },
      handleError$1: function(onError) {
        return this.handleError$2$test(onError, null);
      },
      expand$1: function(_, convert) {
        return new P._ExpandStream(convert, this, [H.getRuntimeTypeArgument(this, "Stream", 0), null]);
      },
      join$1: function(_, separator) {
        var t1, result, buffer;
        t1 = {};
        result = new P._Future(0, $.Zone__current, null, [P.String]);
        buffer = new P.StringBuffer("");
        t1.subscription = null;
        t1.first = true;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_join_closure(t1, this, buffer, separator, result), true, new P.Stream_join_closure0(result, buffer), new P.Stream_join_closure1(result));
        return result;
      },
      join$0: function($receiver) {
        return this.join$1($receiver, "");
      },
      contains$1: function(_, needle) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [P.bool]);
        t1.subscription = null;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_contains_closure(t1, this, needle, future), true, new P.Stream_contains_closure0(future), future.get$_completeError());
        return future;
      },
      forEach$1: function(_, action) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [null]);
        t1.subscription = null;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_forEach_closure(t1, this, action, future), true, new P.Stream_forEach_closure0(future), future.get$_completeError());
        return future;
      },
      every$1: function(_, test) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [P.bool]);
        t1.subscription = null;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_every_closure(t1, this, test, future), true, new P.Stream_every_closure0(future), future.get$_completeError());
        return future;
      },
      any$1: function(_, test) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [P.bool]);
        t1.subscription = null;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_any_closure(t1, this, test, future), true, new P.Stream_any_closure0(future), future.get$_completeError());
        return future;
      },
      get$length: function(_) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [P.int]);
        t1.count = 0;
        this.listen$4$cancelOnError$onDone$onError(new P.Stream_length_closure(t1), true, new P.Stream_length_closure0(t1, future), future.get$_completeError());
        return future;
      },
      get$isEmpty: function(_) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [P.bool]);
        t1.subscription = null;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_isEmpty_closure(t1, future), true, new P.Stream_isEmpty_closure0(future), future.get$_completeError());
        return future;
      },
      toList$0: function(_) {
        var t1, result, future;
        t1 = H.getRuntimeTypeArgument(this, "Stream", 0);
        result = H.setRuntimeTypeInfo([], [t1]);
        future = new P._Future(0, $.Zone__current, null, [[P.List, t1]]);
        this.listen$4$cancelOnError$onDone$onError(new P.Stream_toList_closure(this, result), true, new P.Stream_toList_closure0(future, result), future.get$_completeError());
        return future;
      },
      take$1: function(_, count) {
        if (typeof count !== "number" || Math.floor(count) !== count)
          H.throwExpression(P.ArgumentError$(count));
        return new P._TakeStream(count, this, [H.getRuntimeTypeArgument(this, "Stream", 0)]);
      },
      skip$1: function(_, count) {
        if (typeof count !== "number" || Math.floor(count) !== count || count < 0)
          H.throwExpression(P.ArgumentError$(count));
        return new P._SkipStream(count, this, [H.getRuntimeTypeArgument(this, "Stream", 0)]);
      },
      get$first: function(_) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [H.getRuntimeTypeArgument(this, "Stream", 0)]);
        t1.subscription = null;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_first_closure(t1, this, future), true, new P.Stream_first_closure0(future), future.get$_completeError());
        return future;
      },
      get$last: function(_) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [H.getRuntimeTypeArgument(this, "Stream", 0)]);
        t1.result = null;
        t1.foundResult = false;
        this.listen$4$cancelOnError$onDone$onError(new P.Stream_last_closure(t1, this), true, new P.Stream_last_closure0(t1, future), future.get$_completeError());
        return future;
      },
      get$single: function(_) {
        var t1, future;
        t1 = {};
        future = new P._Future(0, $.Zone__current, null, [H.getRuntimeTypeArgument(this, "Stream", 0)]);
        t1.result = null;
        t1.foundResult = false;
        t1.subscription = null;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_single_closure(t1, this, future), true, new P.Stream_single_closure0(t1, future), future.get$_completeError());
        return future;
      },
      elementAt$1: function(_, index) {
        var t1, future;
        t1 = {};
        if (typeof index !== "number" || Math.floor(index) !== index || index < 0)
          throw H.wrapException(P.ArgumentError$(index));
        future = new P._Future(0, $.Zone__current, null, [H.getRuntimeTypeArgument(this, "Stream", 0)]);
        t1.subscription = null;
        t1.elementIndex = 0;
        t1.subscription = this.listen$4$cancelOnError$onDone$onError(new P.Stream_elementAt_closure(t1, this, index, future), true, new P.Stream_elementAt_closure0(t1, this, future, index), future.get$_completeError());
        return future;
      }
    },
    Stream_Stream$fromFuture_closure: {
      "^": "Closure:0;controller",
      call$1: [function(value) {
        var t1 = this.controller;
        t1._async$_add$1(value);
        t1._closeUnchecked$0();
      }, null, null, 4, 0, null, 3, "call"]
    },
    Stream_Stream$fromFuture_closure0: {
      "^": "Closure:2;controller",
      call$2: [function(error, stackTrace) {
        var t1 = this.controller;
        t1._addError$2(error, stackTrace);
        t1._closeUnchecked$0();
      }, null, null, 8, 0, null, 4, 5, "call"]
    },
    Stream_join_closure: {
      "^": "Closure;_box_0,$this,buffer,separator,result",
      call$1: [function(element) {
        var e, s, t1, exception;
        t1 = this._box_0;
        if (!t1.first)
          this.buffer._contents += this.separator;
        t1.first = false;
        try {
          this.buffer._contents += H.S(element);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          P._cancelAndErrorWithReplacement(t1.subscription, this.result, e, s);
        }
      }, null, null, 4, 0, null, 11, "call"],
      $signature: function() {
        return {func: 1, args: [H.getRuntimeTypeArgument(this.$this, "Stream", 0)]};
      }
    },
    Stream_join_closure1: {
      "^": "Closure:0;result",
      call$1: [function(e) {
        this.result._completeError$1(e);
      }, null, null, 4, 0, null, 20, "call"]
    },
    Stream_join_closure0: {
      "^": "Closure:1;result,buffer",
      call$0: [function() {
        var t1 = this.buffer._contents;
        this.result._complete$1(t1.charCodeAt(0) == 0 ? t1 : t1);
      }, null, null, 0, 0, null, "call"]
    },
    Stream_contains_closure: {
      "^": "Closure;_box_0,$this,needle,future",
      call$1: [function(element) {
        var t1, t2;
        t1 = this._box_0;
        t2 = this.future;
        P._runUserCode(new P.Stream_contains__closure(element, this.needle), new P.Stream_contains__closure0(t1, t2), P._cancelAndErrorClosure(t1.subscription, t2));
      }, null, null, 4, 0, null, 11, "call"],
      $signature: function() {
        return {func: 1, args: [H.getRuntimeTypeArgument(this.$this, "Stream", 0)]};
      }
    },
    Stream_contains__closure: {
      "^": "Closure:1;element,needle",
      call$0: function() {
        return J.$eq$(this.element, this.needle);
      }
    },
    Stream_contains__closure0: {
      "^": "Closure:17;_box_0,future",
      call$1: function(isMatch) {
        if (isMatch === true)
          P._cancelAndValue(this._box_0.subscription, this.future, true);
      }
    },
    Stream_contains_closure0: {
      "^": "Closure:1;future",
      call$0: [function() {
        this.future._complete$1(false);
      }, null, null, 0, 0, null, "call"]
    },
    Stream_forEach_closure: {
      "^": "Closure;_box_0,$this,action,future",
      call$1: [function(element) {
        P._runUserCode(new P.Stream_forEach__closure(this.action, element), new P.Stream_forEach__closure0(), P._cancelAndErrorClosure(this._box_0.subscription, this.future));
      }, null, null, 4, 0, null, 11, "call"],
      $signature: function() {
        return {func: 1, args: [H.getRuntimeTypeArgument(this.$this, "Stream", 0)]};
      }
    },
    Stream_forEach__closure: {
      "^": "Closure:1;action,element",
      call$0: function() {
        return this.action.call$1(this.element);
      }
    },
    Stream_forEach__closure0: {
      "^": "Closure:0;",
      call$1: function(_) {
      }
    },
    Stream_forEach_closure0: {
      "^": "Closure:1;future",
      call$0: [function() {
        this.future._complete$1(null);
      }, null, null, 0, 0, null, "call"]
    },
    Stream_every_closure: {
      "^": "Closure;_box_0,$this,test,future",
      call$1: [function(element) {
        var t1, t2;
        t1 = this._box_0;
        t2 = this.future;
        P._runUserCode(new P.Stream_every__closure(this.test, element), new P.Stream_every__closure0(t1, t2), P._cancelAndErrorClosure(t1.subscription, t2));
      }, null, null, 4, 0, null, 11, "call"],
      $signature: function() {
        return {func: 1, args: [H.getRuntimeTypeArgument(this.$this, "Stream", 0)]};
      }
    },
    Stream_every__closure: {
      "^": "Closure:1;test,element",
      call$0: function() {
        return this.test.call$1(this.element);
      }
    },
    Stream_every__closure0: {
      "^": "Closure:17;_box_0,future",
      call$1: function(isMatch) {
        if (isMatch !== true)
          P._cancelAndValue(this._box_0.subscription, this.future, false);
      }
    },
    Stream_every_closure0: {
      "^": "Closure:1;future",
      call$0: [function() {
        this.future._complete$1(true);
      }, null, null, 0, 0, null, "call"]
    },
    Stream_any_closure: {
      "^": "Closure;_box_0,$this,test,future",
      call$1: [function(element) {
        var t1, t2;
        t1 = this._box_0;
        t2 = this.future;
        P._runUserCode(new P.Stream_any__closure(this.test, element), new P.Stream_any__closure0(t1, t2), P._cancelAndErrorClosure(t1.subscription, t2));
      }, null, null, 4, 0, null, 11, "call"],
      $signature: function() {
        return {func: 1, args: [H.getRuntimeTypeArgument(this.$this, "Stream", 0)]};
      }
    },
    Stream_any__closure: {
      "^": "Closure:1;test,element",
      call$0: function() {
        return this.test.call$1(this.element);
      }
    },
    Stream_any__closure0: {
      "^": "Closure:17;_box_0,future",
      call$1: function(isMatch) {
        if (isMatch === true)
          P._cancelAndValue(this._box_0.subscription, this.future, true);
      }
    },
    Stream_any_closure0: {
      "^": "Closure:1;future",
      call$0: [function() {
        this.future._complete$1(false);
      }, null, null, 0, 0, null, "call"]
    },
    Stream_length_closure: {
      "^": "Closure:0;_box_0",
      call$1: [function(_) {
        ++this._box_0.count;
      }, null, null, 4, 0, null, 7, "call"]
    },
    Stream_length_closure0: {
      "^": "Closure:1;_box_0,future",
      call$0: [function() {
        this.future._complete$1(this._box_0.count);
      }, null, null, 0, 0, null, "call"]
    },
    Stream_isEmpty_closure: {
      "^": "Closure:0;_box_0,future",
      call$1: [function(_) {
        P._cancelAndValue(this._box_0.subscription, this.future, false);
      }, null, null, 4, 0, null, 7, "call"]
    },
    Stream_isEmpty_closure0: {
      "^": "Closure:1;future",
      call$0: [function() {
        this.future._complete$1(true);
      }, null, null, 0, 0, null, "call"]
    },
    Stream_toList_closure: {
      "^": "Closure;$this,result",
      call$1: [function(data) {
        this.result.push(data);
      }, null, null, 4, 0, null, 16, "call"],
      $signature: function() {
        return {func: 1, args: [H.getRuntimeTypeArgument(this.$this, "Stream", 0)]};
      }
    },
    Stream_toList_closure0: {
      "^": "Closure:1;future,result",
      call$0: [function() {
        this.future._complete$1(this.result);
      }, null, null, 0, 0, null, "call"]
    },
    Stream_first_closure: {
      "^": "Closure;_box_0,$this,future",
      call$1: [function(value) {
        P._cancelAndValue(this._box_0.subscription, this.future, value);
      }, null, null, 4, 0, null, 3, "call"],
      $signature: function() {
        return {func: 1, args: [H.getRuntimeTypeArgument(this.$this, "Stream", 0)]};
      }
    },
    Stream_first_closure0: {
      "^": "Closure:1;future",
      call$0: [function() {
        var e, s, t1, exception;
        try {
          t1 = H.IterableElementError_noElement();
          throw H.wrapException(t1);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          P._completeWithErrorCallback(this.future, e, s);
        }
      }, null, null, 0, 0, null, "call"]
    },
    Stream_last_closure: {
      "^": "Closure;_box_0,$this",
      call$1: [function(value) {
        var t1 = this._box_0;
        t1.foundResult = true;
        t1.result = value;
      }, null, null, 4, 0, null, 3, "call"],
      $signature: function() {
        return {func: 1, args: [H.getRuntimeTypeArgument(this.$this, "Stream", 0)]};
      }
    },
    Stream_last_closure0: {
      "^": "Closure:1;_box_0,future",
      call$0: [function() {
        var e, s, t1, exception;
        t1 = this._box_0;
        if (t1.foundResult) {
          this.future._complete$1(t1.result);
          return;
        }
        try {
          t1 = H.IterableElementError_noElement();
          throw H.wrapException(t1);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          P._completeWithErrorCallback(this.future, e, s);
        }
      }, null, null, 0, 0, null, "call"]
    },
    Stream_single_closure: {
      "^": "Closure;_box_0,$this,future",
      call$1: [function(value) {
        var e, s, t1, t2, exception;
        t1 = this._box_0;
        if (t1.foundResult) {
          try {
            t2 = H.IterableElementError_tooMany();
            throw H.wrapException(t2);
          } catch (exception) {
            e = H.unwrapException(exception);
            s = H.getTraceFromException(exception);
            P._cancelAndErrorWithReplacement(t1.subscription, this.future, e, s);
          }
          return;
        }
        t1.foundResult = true;
        t1.result = value;
      }, null, null, 4, 0, null, 3, "call"],
      $signature: function() {
        return {func: 1, args: [H.getRuntimeTypeArgument(this.$this, "Stream", 0)]};
      }
    },
    Stream_single_closure0: {
      "^": "Closure:1;_box_0,future",
      call$0: [function() {
        var e, s, t1, exception;
        t1 = this._box_0;
        if (t1.foundResult) {
          this.future._complete$1(t1.result);
          return;
        }
        try {
          t1 = H.IterableElementError_noElement();
          throw H.wrapException(t1);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          P._completeWithErrorCallback(this.future, e, s);
        }
      }, null, null, 0, 0, null, "call"]
    },
    Stream_elementAt_closure: {
      "^": "Closure;_box_0,$this,index,future",
      call$1: [function(value) {
        var t1 = this._box_0;
        if (J.$eq$(this.index, t1.elementIndex) === true) {
          P._cancelAndValue(t1.subscription, this.future, value);
          return;
        }
        ++t1.elementIndex;
      }, null, null, 4, 0, null, 3, "call"],
      $signature: function() {
        return {func: 1, args: [H.getRuntimeTypeArgument(this.$this, "Stream", 0)]};
      }
    },
    Stream_elementAt_closure0: {
      "^": "Closure:1;_box_0,$this,future,index",
      call$0: [function() {
        this.future._completeError$1(P.IndexError$(this.index, this.$this, "index", null, this._box_0.elementIndex));
      }, null, null, 0, 0, null, "call"]
    },
    StreamSubscription: {
      "^": "Object;$ti"
    },
    EventSink: {
      "^": "Object;$ti"
    },
    StreamTransformerBase: {
      "^": "Object;$ti"
    },
    StreamIterator: {
      "^": "Object;$ti"
    },
    StreamController: {
      "^": "Object;$ti",
      $isEventSink: 1
    },
    _StreamController: {
      "^": "Object;_async$_state<,onListen?,onPause?,onResume?,onCancel?,$ti",
      get$stream: function() {
        return new P._ControllerStream(this, this.$ti);
      },
      get$isPaused: function() {
        var t1 = this._async$_state;
        return (t1 & 1) !== 0 ? this.get$_subscription().get$_isInputPaused() : (t1 & 2) === 0;
      },
      get$_pendingEvents: function() {
        if ((this._async$_state & 8) === 0)
          return this._varData;
        return this._varData.get$varData();
      },
      _ensurePendingEvents$0: function() {
        var t1, state;
        if ((this._async$_state & 8) === 0) {
          t1 = this._varData;
          if (t1 == null) {
            t1 = new P._StreamImplEvents(null, null, 0, this.$ti);
            this._varData = t1;
          }
          return t1;
        }
        state = this._varData;
        if (state.get$varData() == null)
          state.set$varData(new P._StreamImplEvents(null, null, 0, this.$ti));
        return state.get$varData();
      },
      get$_subscription: function() {
        if ((this._async$_state & 8) !== 0)
          return this._varData.get$varData();
        return this._varData;
      },
      _badEventState$0: function() {
        if ((this._async$_state & 4) !== 0)
          return new P.StateError("Cannot add event after closing");
        return new P.StateError("Cannot add event while adding a stream");
      },
      addStream$2$cancelOnError: function(source, cancelOnError) {
        var t1, t2, t3, t4;
        t1 = this._async$_state;
        if (t1 >= 4)
          throw H.wrapException(this._badEventState$0());
        if ((t1 & 2) !== 0) {
          t1 = new P._Future(0, $.Zone__current, null, [null]);
          t1._asyncComplete$1(null);
          return t1;
        }
        t1 = this._varData;
        t2 = cancelOnError == null ? false : cancelOnError;
        t3 = new P._Future(0, $.Zone__current, null, [null]);
        t4 = t2 ? P._AddStreamState_makeErrorHandler(this) : this.get$_addError();
        t4 = source.listen$4$cancelOnError$onDone$onError(this.get$_async$_add(), t2, this.get$_close(), t4);
        t2 = this._async$_state;
        if ((t2 & 1) !== 0 ? this.get$_subscription().get$_isInputPaused() : (t2 & 2) === 0)
          t4.pause$0(0);
        this._varData = new P._StreamControllerAddStreamState(t1, t3, t4, this.$ti);
        this._async$_state |= 8;
        return t3;
      },
      addStream$1: function(source) {
        return this.addStream$2$cancelOnError(source, null);
      },
      _ensureDoneFuture$0: function() {
        var t1 = this._doneFuture;
        if (t1 == null) {
          t1 = (this._async$_state & 2) !== 0 ? $.$get$Future__nullFuture() : new P._Future(0, $.Zone__current, null, [null]);
          this._doneFuture = t1;
        }
        return t1;
      },
      add$1: [function(_, value) {
        if (this._async$_state >= 4)
          throw H.wrapException(this._badEventState$0());
        this._async$_add$1(value);
      }, "call$1", "get$add", 5, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_StreamController");
      }, 3],
      addError$2: [function(error, stackTrace) {
        if (this._async$_state >= 4)
          throw H.wrapException(this._badEventState$0());
        if (error == null)
          error = new P.NullThrownError();
        $.Zone__current.toString;
        this._addError$2(error, stackTrace);
      }, function(error) {
        return this.addError$2(error, null);
      }, "addError$1", "call$2", "call$1", "get$addError", 4, 2, 9, 2, 4, 5],
      close$0: [function(_) {
        var t1 = this._async$_state;
        if ((t1 & 4) !== 0)
          return this._ensureDoneFuture$0();
        if (t1 >= 4)
          throw H.wrapException(this._badEventState$0());
        this._closeUnchecked$0();
        return this._ensureDoneFuture$0();
      }, "call$0", "get$close", 1, 0, 4],
      _closeUnchecked$0: function() {
        var t1 = this._async$_state |= 4;
        if ((t1 & 1) !== 0)
          this._sendDone$0();
        else if ((t1 & 3) === 0)
          this._ensurePendingEvents$0().add$1(0, C.C__DelayedDone);
      },
      _async$_add$1: [function(value) {
        var t1 = this._async$_state;
        if ((t1 & 1) !== 0)
          this._sendData$1(value);
        else if ((t1 & 3) === 0)
          this._ensurePendingEvents$0().add$1(0, new P._DelayedData(value, null, this.$ti));
      }, "call$1", "get$_async$_add", 4, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_StreamController");
      }, 3],
      _addError$2: [function(error, stackTrace) {
        var t1 = this._async$_state;
        if ((t1 & 1) !== 0)
          this._sendError$2(error, stackTrace);
        else if ((t1 & 3) === 0)
          this._ensurePendingEvents$0().add$1(0, new P._DelayedError(error, stackTrace, null));
      }, "call$2", "get$_addError", 8, 0, 41, 4, 5],
      _close$0: [function() {
        var addState = this._varData;
        this._varData = addState.get$varData();
        this._async$_state &= 4294967287;
        addState.complete$0();
      }, "call$0", "get$_close", 0, 0, 3],
      _subscribe$4: function(onData, onError, onDone, cancelOnError) {
        var t1, t2, subscription, pendingEvents, addState;
        if ((this._async$_state & 3) !== 0)
          throw H.wrapException(P.StateError$("Stream has already been listened to."));
        t1 = $.Zone__current;
        t2 = cancelOnError ? 1 : 0;
        subscription = new P._ControllerSubscription(this, null, null, null, t1, t2, null, null, this.$ti);
        subscription._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, H.getTypeArgumentByIndex(this, 0));
        pendingEvents = this.get$_pendingEvents();
        t2 = this._async$_state |= 1;
        if ((t2 & 8) !== 0) {
          addState = this._varData;
          addState.set$varData(subscription);
          addState.resume$0();
        } else
          this._varData = subscription;
        subscription._setPendingEvents$1(pendingEvents);
        subscription._guardCallback$1(new P._StreamController__subscribe_closure(this));
        return subscription;
      },
      _recordCancel$1: function(subscription) {
        var result, e, s, t1, exception, result0;
        result = null;
        if ((this._async$_state & 8) !== 0)
          result = this._varData.cancel$0();
        this._varData = null;
        this._async$_state = this._async$_state & 4294967286 | 2;
        t1 = this.onCancel;
        if (t1 != null)
          if (result == null)
            try {
              result = t1.call$0();
            } catch (exception) {
              e = H.unwrapException(exception);
              s = H.getTraceFromException(exception);
              result0 = new P._Future(0, $.Zone__current, null, [null]);
              result0._asyncCompleteError$2(e, s);
              result = result0;
            }
          else
            result = result.whenComplete$1(t1);
        t1 = new P._StreamController__recordCancel_complete(this);
        if (result != null)
          result = result.whenComplete$1(t1);
        else
          t1.call$0();
        return result;
      },
      _recordPause$1: function(subscription) {
        if ((this._async$_state & 8) !== 0)
          this._varData.pause$0(0);
        P._runGuarded(this.onPause);
      },
      _recordResume$1: function(subscription) {
        if ((this._async$_state & 8) !== 0)
          this._varData.resume$0();
        P._runGuarded(this.onResume);
      },
      $isEventSink: 1
    },
    _StreamController__subscribe_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        P._runGuarded(this.$this.onListen);
      }
    },
    _StreamController__recordCancel_complete: {
      "^": "Closure:3;$this",
      call$0: function() {
        var t1 = this.$this._doneFuture;
        if (t1 != null && t1._async$_state === 0)
          t1._asyncComplete$1(null);
      }
    },
    _SyncStreamControllerDispatch: {
      "^": "Object;$ti",
      _sendData$1: function(data) {
        this.get$_subscription()._async$_add$1(data);
      },
      _sendError$2: function(error, stackTrace) {
        this.get$_subscription()._addError$2(error, stackTrace);
      },
      _sendDone$0: function() {
        this.get$_subscription()._close$0();
      }
    },
    _AsyncStreamControllerDispatch: {
      "^": "Object;$ti",
      _sendData$1: function(data) {
        this.get$_subscription()._addPending$1(new P._DelayedData(data, null, [H.getTypeArgumentByIndex(this, 0)]));
      },
      _sendError$2: function(error, stackTrace) {
        this.get$_subscription()._addPending$1(new P._DelayedError(error, stackTrace, null));
      },
      _sendDone$0: function() {
        this.get$_subscription()._addPending$1(C.C__DelayedDone);
      }
    },
    _AsyncStreamController: {
      "^": "_StreamController+_AsyncStreamControllerDispatch;_varData,_async$_state,_doneFuture,onListen,onPause,onResume,onCancel,$ti"
    },
    _SyncStreamController: {
      "^": "_StreamController+_SyncStreamControllerDispatch;_varData,_async$_state,_doneFuture,onListen,onPause,onResume,onCancel,$ti"
    },
    _ControllerStream: {
      "^": "_StreamImpl;_async$_controller,$ti",
      get$hashCode: function(_) {
        return (H.Primitives_objectHashCode(this._async$_controller) ^ 892482866) >>> 0;
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        if (this === other)
          return true;
        if (!(other instanceof P._ControllerStream))
          return false;
        return other._async$_controller === this._async$_controller;
      }
    },
    _ControllerSubscription: {
      "^": "_BufferingStreamSubscription;_async$_controller,_onData,_onError,_onDone,_zone,_async$_state,_cancelFuture,_pending,$ti",
      _async$_onCancel$0: function() {
        return this._async$_controller._recordCancel$1(this);
      },
      _async$_onPause$0: [function() {
        this._async$_controller._recordPause$1(this);
      }, "call$0", "get$_async$_onPause", 0, 0, 3],
      _async$_onResume$0: [function() {
        this._async$_controller._recordResume$1(this);
      }, "call$0", "get$_async$_onResume", 0, 0, 3]
    },
    _AddStreamState: {
      "^": "Object;addStreamFuture,addSubscription,$ti",
      pause$0: function(_) {
        this.addSubscription.pause$0(0);
      },
      resume$0: function() {
        this.addSubscription.resume$0();
      },
      cancel$0: function() {
        var cancel = this.addSubscription.cancel$0();
        if (cancel == null) {
          this.addStreamFuture._asyncComplete$1(null);
          return;
        }
        return cancel.whenComplete$1(new P._AddStreamState_cancel_closure(this));
      },
      complete$0: function() {
        this.addStreamFuture._asyncComplete$1(null);
      },
      static: {
        _AddStreamState$: function(controller, source, cancelOnError, $T) {
          var t1, t2, t3;
          t1 = $.Zone__current;
          t2 = controller.get$_async$_add();
          t3 = controller.get$_addError();
          return new P._AddStreamState(new P._Future(0, t1, null, [null]), source.listen$4$cancelOnError$onDone$onError(t2, false, controller.get$_close(), t3), [$T]);
        },
        _AddStreamState_makeErrorHandler: function(controller) {
          return new P._AddStreamState_makeErrorHandler_closure(controller);
        }
      }
    },
    _AddStreamState_makeErrorHandler_closure: {
      "^": "Closure:7;controller",
      call$2: [function(e, s) {
        var t1 = this.controller;
        t1._addError$2(e, s);
        t1._close$0();
      }, null, null, 8, 0, null, 20, 27, "call"]
    },
    _AddStreamState_cancel_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        this.$this.addStreamFuture._asyncComplete$1(null);
      }
    },
    _StreamControllerAddStreamState: {
      "^": "_AddStreamState;varData@,addStreamFuture,addSubscription,$ti"
    },
    _BufferingStreamSubscription: {
      "^": "Object;_zone<,_async$_state<,$ti",
      _BufferingStreamSubscription$4: function(onData, onError, onDone, cancelOnError, $T) {
        this.onData$1(onData);
        this.onError$1(onError);
        this.onDone$1(onDone);
      },
      _setPendingEvents$1: function(pendingEvents) {
        if (pendingEvents == null)
          return;
        this._pending = pendingEvents;
        if (!pendingEvents.get$isEmpty(pendingEvents)) {
          this._async$_state = (this._async$_state | 64) >>> 0;
          this._pending.schedule$1(this);
        }
      },
      onData$1: function(handleData) {
        if (handleData == null)
          handleData = P.async___nullDataHandler$closure();
        this._zone.toString;
        this._onData = handleData;
      },
      onError$1: function(handleError) {
        if (handleError == null)
          handleError = P.async___nullErrorHandler$closure();
        if (H.functionTypeTest(handleError, {func: 1, v: true, args: [P.Object, P.StackTrace]}))
          this._onError = this._zone.registerBinaryCallback$1(handleError);
        else if (H.functionTypeTest(handleError, {func: 1, v: true, args: [P.Object]})) {
          this._zone.toString;
          this._onError = handleError;
        } else
          throw H.wrapException(P.ArgumentError$("handleError callback must take either an Object (the error), or both an Object (the error) and a StackTrace."));
      },
      onDone$1: function(handleDone) {
        if (handleDone == null)
          handleDone = P.async___nullDoneHandler$closure();
        this._zone.toString;
        this._onDone = handleDone;
      },
      pause$1: [function(_, resumeSignal) {
        var t1 = this._async$_state;
        if ((t1 & 8) !== 0)
          return;
        this._async$_state = (t1 + 128 | 4) >>> 0;
        if (t1 < 128 && this._pending != null)
          this._pending.cancelSchedule$0();
        if ((t1 & 4) === 0 && (this._async$_state & 32) === 0)
          this._guardCallback$1(this.get$_async$_onPause());
      }, function($receiver) {
        return this.pause$1($receiver, null);
      }, "pause$0", "call$1", "call$0", "get$pause", 1, 2, 18],
      resume$0: [function() {
        var t1 = this._async$_state;
        if ((t1 & 8) !== 0)
          return;
        if (t1 >= 128) {
          t1 -= 128;
          this._async$_state = t1;
          if (t1 < 128) {
            if ((t1 & 64) !== 0) {
              t1 = this._pending;
              t1 = !t1.get$isEmpty(t1);
            } else
              t1 = false;
            if (t1)
              this._pending.schedule$1(this);
            else {
              t1 = (this._async$_state & 4294967291) >>> 0;
              this._async$_state = t1;
              if ((t1 & 32) === 0)
                this._guardCallback$1(this.get$_async$_onResume());
            }
          }
        }
      }, "call$0", "get$resume", 0, 0, 3],
      cancel$0: function() {
        var t1 = (this._async$_state & 4294967279) >>> 0;
        this._async$_state = t1;
        if ((t1 & 8) === 0)
          this._cancel$0();
        t1 = this._cancelFuture;
        return t1 == null ? $.$get$Future__nullFuture() : t1;
      },
      get$_isInputPaused: function() {
        return (this._async$_state & 4) !== 0;
      },
      get$isPaused: function() {
        return this._async$_state >= 128;
      },
      _cancel$0: function() {
        var t1 = (this._async$_state | 8) >>> 0;
        this._async$_state = t1;
        if ((t1 & 64) !== 0)
          this._pending.cancelSchedule$0();
        if ((this._async$_state & 32) === 0)
          this._pending = null;
        this._cancelFuture = this._async$_onCancel$0();
      },
      _async$_add$1: ["super$_BufferingStreamSubscription$_add", function(data) {
        var t1 = this._async$_state;
        if ((t1 & 8) !== 0)
          return;
        if (t1 < 32)
          this._sendData$1(data);
        else
          this._addPending$1(new P._DelayedData(data, null, [H.getRuntimeTypeArgument(this, "_BufferingStreamSubscription", 0)]));
      }],
      _addError$2: ["super$_BufferingStreamSubscription$_addError", function(error, stackTrace) {
        var t1 = this._async$_state;
        if ((t1 & 8) !== 0)
          return;
        if (t1 < 32)
          this._sendError$2(error, stackTrace);
        else
          this._addPending$1(new P._DelayedError(error, stackTrace, null));
      }],
      _close$0: function() {
        var t1 = this._async$_state;
        if ((t1 & 8) !== 0)
          return;
        t1 = (t1 | 2) >>> 0;
        this._async$_state = t1;
        if (t1 < 32)
          this._sendDone$0();
        else
          this._addPending$1(C.C__DelayedDone);
      },
      _async$_onPause$0: [function() {
      }, "call$0", "get$_async$_onPause", 0, 0, 3],
      _async$_onResume$0: [function() {
      }, "call$0", "get$_async$_onResume", 0, 0, 3],
      _async$_onCancel$0: function() {
        return;
      },
      _addPending$1: function($event) {
        var pending, t1;
        pending = this._pending;
        if (pending == null) {
          pending = new P._StreamImplEvents(null, null, 0, [H.getRuntimeTypeArgument(this, "_BufferingStreamSubscription", 0)]);
          this._pending = pending;
        }
        pending.add$1(0, $event);
        t1 = this._async$_state;
        if ((t1 & 64) === 0) {
          t1 = (t1 | 64) >>> 0;
          this._async$_state = t1;
          if (t1 < 128)
            this._pending.schedule$1(this);
        }
      },
      _sendData$1: function(data) {
        var t1 = this._async$_state;
        this._async$_state = (t1 | 32) >>> 0;
        this._zone.runUnaryGuarded$2(this._onData, data);
        this._async$_state = (this._async$_state & 4294967263) >>> 0;
        this._checkState$1((t1 & 4) !== 0);
      },
      _sendError$2: function(error, stackTrace) {
        var t1, t2;
        t1 = this._async$_state;
        t2 = new P._BufferingStreamSubscription__sendError_sendError(this, error, stackTrace);
        if ((t1 & 1) !== 0) {
          this._async$_state = (t1 | 16) >>> 0;
          this._cancel$0();
          t1 = this._cancelFuture;
          if (!!J.getInterceptor(t1).$isFuture && t1 !== $.$get$Future__nullFuture())
            t1.whenComplete$1(t2);
          else
            t2.call$0();
        } else {
          t2.call$0();
          this._checkState$1((t1 & 4) !== 0);
        }
      },
      _sendDone$0: function() {
        var t1, t2;
        t1 = new P._BufferingStreamSubscription__sendDone_sendDone(this);
        this._cancel$0();
        this._async$_state = (this._async$_state | 16) >>> 0;
        t2 = this._cancelFuture;
        if (!!J.getInterceptor(t2).$isFuture && t2 !== $.$get$Future__nullFuture())
          t2.whenComplete$1(t1);
        else
          t1.call$0();
      },
      _guardCallback$1: function(callback) {
        var t1 = this._async$_state;
        this._async$_state = (t1 | 32) >>> 0;
        callback.call$0();
        this._async$_state = (this._async$_state & 4294967263) >>> 0;
        this._checkState$1((t1 & 4) !== 0);
      },
      _checkState$1: function(wasInputPaused) {
        var t1, isInputPaused;
        if ((this._async$_state & 64) !== 0) {
          t1 = this._pending;
          t1 = t1.get$isEmpty(t1);
        } else
          t1 = false;
        if (t1) {
          t1 = (this._async$_state & 4294967231) >>> 0;
          this._async$_state = t1;
          if ((t1 & 4) !== 0)
            if (t1 < 128) {
              t1 = this._pending;
              t1 = t1 == null || t1.get$isEmpty(t1);
            } else
              t1 = false;
          else
            t1 = false;
          if (t1)
            this._async$_state = (this._async$_state & 4294967291) >>> 0;
        }
        for (; true; wasInputPaused = isInputPaused) {
          t1 = this._async$_state;
          if ((t1 & 8) !== 0) {
            this._pending = null;
            return;
          }
          isInputPaused = (t1 & 4) !== 0;
          if (wasInputPaused === isInputPaused)
            break;
          this._async$_state = (t1 ^ 32) >>> 0;
          if (isInputPaused)
            this._async$_onPause$0();
          else
            this._async$_onResume$0();
          this._async$_state = (this._async$_state & 4294967263) >>> 0;
        }
        t1 = this._async$_state;
        if ((t1 & 64) !== 0 && t1 < 128)
          this._pending.schedule$1(this);
      },
      $isStreamSubscription: 1
    },
    _BufferingStreamSubscription__sendError_sendError: {
      "^": "Closure:3;$this,error,stackTrace",
      call$0: function() {
        var t1, t2, onError, t3;
        t1 = this.$this;
        t2 = t1._async$_state;
        if ((t2 & 8) !== 0 && (t2 & 16) === 0)
          return;
        t1._async$_state = (t2 | 32) >>> 0;
        onError = t1._onError;
        t2 = t1._zone;
        t3 = this.error;
        if (H.functionTypeTest(onError, {func: 1, v: true, args: [P.Object, P.StackTrace]}))
          t2.runBinaryGuarded$3(onError, t3, this.stackTrace);
        else
          t2.runUnaryGuarded$2(t1._onError, t3);
        t1._async$_state = (t1._async$_state & 4294967263) >>> 0;
      }
    },
    _BufferingStreamSubscription__sendDone_sendDone: {
      "^": "Closure:3;$this",
      call$0: function() {
        var t1, t2;
        t1 = this.$this;
        t2 = t1._async$_state;
        if ((t2 & 16) === 0)
          return;
        t1._async$_state = (t2 | 42) >>> 0;
        t1._zone.runGuarded$1(t1._onDone);
        t1._async$_state = (t1._async$_state & 4294967263) >>> 0;
      }
    },
    _StreamImpl: {
      "^": "Stream;$ti",
      listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
        return this._async$_controller._subscribe$4(onData, onError, onDone, true === cancelOnError);
      },
      listen$3$onDone$onError: function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      },
      listen$1: function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }
    },
    _DelayedEvent: {
      "^": "Object;next@,$ti"
    },
    _DelayedData: {
      "^": "_DelayedEvent;value<,next,$ti",
      perform$1: function(dispatch) {
        dispatch._sendData$1(this.value);
      }
    },
    _DelayedError: {
      "^": "_DelayedEvent;error<,stackTrace<,next",
      perform$1: function(dispatch) {
        dispatch._sendError$2(this.error, this.stackTrace);
      },
      $as_DelayedEvent: Isolate.functionThatReturnsNull
    },
    _DelayedDone: {
      "^": "Object;",
      perform$1: function(dispatch) {
        dispatch._sendDone$0();
      },
      get$next: function() {
        return;
      },
      set$next: function(_) {
        throw H.wrapException(P.StateError$("No events after a done."));
      }
    },
    _PendingEvents: {
      "^": "Object;_async$_state<,$ti",
      schedule$1: function(dispatch) {
        var t1 = this._async$_state;
        if (t1 === 1)
          return;
        if (t1 >= 1) {
          this._async$_state = 1;
          return;
        }
        P.scheduleMicrotask(new P._PendingEvents_schedule_closure(this, dispatch));
        this._async$_state = 1;
      },
      cancelSchedule$0: function() {
        if (this._async$_state === 1)
          this._async$_state = 3;
      }
    },
    _PendingEvents_schedule_closure: {
      "^": "Closure:1;$this,dispatch",
      call$0: function() {
        var t1, oldState, $event, t2;
        t1 = this.$this;
        oldState = t1._async$_state;
        t1._async$_state = 0;
        if (oldState === 3)
          return;
        $event = t1.firstPendingEvent;
        t2 = $event.get$next();
        t1.firstPendingEvent = t2;
        if (t2 == null)
          t1.lastPendingEvent = null;
        $event.perform$1(this.dispatch);
      }
    },
    _StreamImplEvents: {
      "^": "_PendingEvents;firstPendingEvent,lastPendingEvent,_async$_state,$ti",
      get$isEmpty: function(_) {
        return this.lastPendingEvent == null;
      },
      add$1: function(_, $event) {
        var t1 = this.lastPendingEvent;
        if (t1 == null) {
          this.lastPendingEvent = $event;
          this.firstPendingEvent = $event;
        } else {
          t1.set$next($event);
          this.lastPendingEvent = $event;
        }
      }
    },
    _DoneStreamSubscription: {
      "^": "Object;_zone<,_async$_state<,_onDone,$ti",
      get$isPaused: function() {
        return this._async$_state >= 4;
      },
      _schedule$0: function() {
        if ((this._async$_state & 2) !== 0)
          return;
        var t1 = this._zone;
        t1.toString;
        P._rootScheduleMicrotask(null, null, t1, this.get$_sendDone());
        this._async$_state = (this._async$_state | 2) >>> 0;
      },
      onData$1: function(handleData) {
      },
      onError$1: function(handleError) {
      },
      onDone$1: function(handleDone) {
        this._onDone = handleDone;
      },
      pause$1: [function(_, resumeSignal) {
        this._async$_state += 4;
      }, function($receiver) {
        return this.pause$1($receiver, null);
      }, "pause$0", "call$1", "call$0", "get$pause", 1, 2, 18],
      resume$0: [function() {
        var t1 = this._async$_state;
        if (t1 >= 4) {
          t1 -= 4;
          this._async$_state = t1;
          if (t1 < 4 && (t1 & 1) === 0)
            this._schedule$0();
        }
      }, "call$0", "get$resume", 0, 0, 3],
      cancel$0: function() {
        return $.$get$Future__nullFuture();
      },
      _sendDone$0: [function() {
        var t1 = (this._async$_state & 4294967293) >>> 0;
        this._async$_state = t1;
        if (t1 >= 4)
          return;
        this._async$_state = (t1 | 1) >>> 0;
        t1 = this._onDone;
        if (t1 != null)
          this._zone.runGuarded$1(t1);
      }, "call$0", "get$_sendDone", 0, 0, 3],
      $isStreamSubscription: 1
    },
    _StreamIterator: {
      "^": "Object;_subscription,_stateData,_isPaused,$ti",
      get$current: function(_) {
        if (this._subscription != null && this._isPaused)
          return this._stateData;
        return;
      },
      moveNext$0: function() {
        var t1, future;
        t1 = this._subscription;
        if (t1 != null) {
          if (this._isPaused) {
            future = new P._Future(0, $.Zone__current, null, [P.bool]);
            this._stateData = future;
            this._isPaused = false;
            t1.resume$0();
            return future;
          }
          throw H.wrapException(P.StateError$("Already waiting for next."));
        }
        return this._initializeOrDone$0();
      },
      _initializeOrDone$0: function() {
        var stateData, future;
        stateData = this._stateData;
        if (stateData != null) {
          this._subscription = stateData.listen$4$cancelOnError$onDone$onError(this.get$_onData(), true, this.get$_onDone(), this.get$_onError());
          future = new P._Future(0, $.Zone__current, null, [P.bool]);
          this._stateData = future;
          return future;
        }
        return $.$get$Future__falseFuture();
      },
      cancel$0: function() {
        var subscription, stateData;
        subscription = this._subscription;
        stateData = this._stateData;
        this._stateData = null;
        if (subscription != null) {
          this._subscription = null;
          if (!this._isPaused)
            stateData._asyncComplete$1(false);
          return subscription.cancel$0();
        }
        return $.$get$Future__nullFuture();
      },
      _onData$1: [function(data) {
        var moveNextFuture, t1;
        moveNextFuture = this._stateData;
        this._stateData = data;
        this._isPaused = true;
        moveNextFuture._complete$1(true);
        t1 = this._subscription;
        if (t1 != null && this._isPaused)
          t1.pause$0(0);
      }, "call$1", "get$_onData", 4, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [T]};
        }, this.$receiver, "_StreamIterator");
      }, 16],
      _onError$2: [function(error, stackTrace) {
        var moveNextFuture = this._stateData;
        this._subscription = null;
        this._stateData = null;
        moveNextFuture._completeError$2(error, stackTrace);
      }, function(error) {
        return this._onError$2(error, null);
      }, "_onError$1", "call$2", "call$1", "get$_onError", 4, 2, 9, 2, 4, 5],
      _onDone$0: [function() {
        var moveNextFuture = this._stateData;
        this._subscription = null;
        this._stateData = null;
        moveNextFuture._complete$1(false);
      }, "call$0", "get$_onDone", 0, 0, 3]
    },
    _EmptyStream: {
      "^": "Stream;$ti",
      get$isBroadcast: function() {
        return true;
      },
      listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
        var t1 = new P._DoneStreamSubscription($.Zone__current, 0, onDone, this.$ti);
        t1._schedule$0();
        return t1;
      },
      listen$3$onDone$onError: function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      },
      listen$1: function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }
    },
    _cancelAndError_closure: {
      "^": "Closure:1;future,error,stackTrace",
      call$0: function() {
        return this.future._completeError$2(this.error, this.stackTrace);
      }
    },
    _cancelAndErrorClosure_closure: {
      "^": "Closure:7;subscription,future",
      call$2: function(error, stackTrace) {
        P._cancelAndError(this.subscription, this.future, error, stackTrace);
      }
    },
    _cancelAndValue_closure: {
      "^": "Closure:1;future,value",
      call$0: function() {
        return this.future._complete$1(this.value);
      }
    },
    _ForwardingStream: {
      "^": "Stream;$ti",
      get$isBroadcast: function() {
        return this._async$_source.get$isBroadcast();
      },
      listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
        return this._createSubscription$4(onData, onError, onDone, true === cancelOnError);
      },
      listen$3$onDone$onError: function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      },
      listen$1: function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      },
      _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
        return P._ForwardingStreamSubscription$(this, onData, onError, onDone, cancelOnError, H.getRuntimeTypeArgument(this, "_ForwardingStream", 0), H.getRuntimeTypeArgument(this, "_ForwardingStream", 1));
      },
      _handleData$2: function(data, sink) {
        sink._async$_add$1(data);
      },
      _handleError$3: function(error, stackTrace, sink) {
        sink._addError$2(error, stackTrace);
      },
      $asStream: function($S, $T) {
        return [$T];
      }
    },
    _ForwardingStreamSubscription: {
      "^": "_BufferingStreamSubscription;_stream,_subscription,_onData,_onError,_onDone,_zone,_async$_state,_cancelFuture,_pending,$ti",
      _ForwardingStreamSubscription$5: function(_stream, onData, onError, onDone, cancelOnError, $S, $T) {
        this._subscription = this._stream._async$_source.listen$3$onDone$onError(this.get$_handleData(), this.get$_handleDone(), this.get$_handleError());
      },
      _async$_add$1: function(data) {
        if ((this._async$_state & 2) !== 0)
          return;
        this.super$_BufferingStreamSubscription$_add(data);
      },
      _addError$2: function(error, stackTrace) {
        if ((this._async$_state & 2) !== 0)
          return;
        this.super$_BufferingStreamSubscription$_addError(error, stackTrace);
      },
      _async$_onPause$0: [function() {
        var t1 = this._subscription;
        if (t1 == null)
          return;
        t1.pause$0(0);
      }, "call$0", "get$_async$_onPause", 0, 0, 3],
      _async$_onResume$0: [function() {
        var t1 = this._subscription;
        if (t1 == null)
          return;
        t1.resume$0();
      }, "call$0", "get$_async$_onResume", 0, 0, 3],
      _async$_onCancel$0: function() {
        var t1 = this._subscription;
        if (t1 != null) {
          this._subscription = null;
          return t1.cancel$0();
        }
        return;
      },
      _handleData$1: [function(data) {
        this._stream._handleData$2(data, this);
      }, "call$1", "get$_handleData", 4, 0, function() {
        return H.computeSignature(function(S, T) {
          return {func: 1, v: true, args: [S]};
        }, this.$receiver, "_ForwardingStreamSubscription");
      }, 16],
      _handleError$2: [function(error, stackTrace) {
        this._stream._handleError$3(error, stackTrace, this);
      }, "call$2", "get$_handleError", 8, 0, 93, 4, 5],
      _handleDone$0: [function() {
        this._close$0();
      }, "call$0", "get$_handleDone", 0, 0, 3],
      $asStreamSubscription: function($S, $T) {
        return [$T];
      },
      $as_BufferingStreamSubscription: function($S, $T) {
        return [$T];
      },
      static: {
        _ForwardingStreamSubscription$: function(_stream, onData, onError, onDone, cancelOnError, $S, $T) {
          var t1, t2;
          t1 = $.Zone__current;
          t2 = cancelOnError ? 1 : 0;
          t2 = new P._ForwardingStreamSubscription(_stream, null, null, null, null, t1, t2, null, null, [$S, $T]);
          t2._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, $T);
          t2._ForwardingStreamSubscription$5(_stream, onData, onError, onDone, cancelOnError, $S, $T);
          return t2;
        }
      }
    },
    _WhereStream: {
      "^": "_ForwardingStream;_test,_async$_source,$ti",
      _handleData$2: function(inputEvent, sink) {
        var satisfies, e, s, exception;
        satisfies = null;
        try {
          satisfies = this._test.call$1(inputEvent);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          P._addErrorWithReplacement(sink, e, s);
          return;
        }
        if (satisfies === true)
          sink._async$_add$1(inputEvent);
      },
      $asStream: null,
      $as_ForwardingStream: function($T) {
        return [$T, $T];
      }
    },
    _MapStream: {
      "^": "_ForwardingStream;_transform,_async$_source,$ti",
      _handleData$2: function(inputEvent, sink) {
        var outputEvent, e, s, exception;
        outputEvent = null;
        try {
          outputEvent = this._transform.call$1(inputEvent);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          P._addErrorWithReplacement(sink, e, s);
          return;
        }
        sink._async$_add$1(outputEvent);
      }
    },
    _ExpandStream: {
      "^": "_ForwardingStream;_expand,_async$_source,$ti",
      _handleData$2: function(inputEvent, sink) {
        var value, e, s, t1, exception;
        try {
          for (t1 = J.get$iterator$ax(this._expand.call$1(inputEvent)); t1.moveNext$0();) {
            value = t1.get$current(t1);
            sink._async$_add$1(value);
          }
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          P._addErrorWithReplacement(sink, e, s);
        }
      }
    },
    _HandleErrorStream: {
      "^": "_ForwardingStream;_transform,_test,_async$_source,$ti",
      _handleError$3: function(error, stackTrace, sink) {
        var matches, e, s, exception, t1;
        matches = true;
        if (matches === true)
          try {
            P._invokeErrorHandler(this._transform, error, stackTrace);
          } catch (exception) {
            e = H.unwrapException(exception);
            s = H.getTraceFromException(exception);
            t1 = e;
            if (t1 == null ? error == null : t1 === error)
              sink._addError$2(error, stackTrace);
            else
              P._addErrorWithReplacement(sink, e, s);
            return;
          }
        else
          sink._addError$2(error, stackTrace);
      },
      $asStream: null,
      $as_ForwardingStream: function($T) {
        return [$T, $T];
      }
    },
    _TakeStream: {
      "^": "_ForwardingStream;_count,_async$_source,$ti",
      _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
        var t1, t2, t3, t4;
        t1 = this._count;
        if (J.$eq$(t1, 0)) {
          this._async$_source.listen$1(null).cancel$0();
          t1 = new P._DoneStreamSubscription($.Zone__current, 0, onDone, this.$ti);
          t1._schedule$0();
          return t1;
        }
        t2 = H.getTypeArgumentByIndex(this, 0);
        t3 = $.Zone__current;
        t4 = cancelOnError ? 1 : 0;
        t4 = new P._StateStreamSubscription(t1, this, null, null, null, null, t3, t4, null, null, this.$ti);
        t4._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, t2);
        t4._ForwardingStreamSubscription$5(this, onData, onError, onDone, cancelOnError, t2, t2);
        return t4;
      },
      _handleData$2: function(inputEvent, sink) {
        var count, t1;
        count = sink.get$_count();
        t1 = J.getInterceptor$n(count);
        if (t1.$gt(count, 0)) {
          sink._async$_add$1(inputEvent);
          count = t1.$sub(count, 1);
          sink.set$_count(count);
          if (J.$eq$(count, 0))
            sink._close$0();
        }
      },
      $asStream: null,
      $as_ForwardingStream: function($T) {
        return [$T, $T];
      }
    },
    _StateStreamSubscription: {
      "^": "_ForwardingStreamSubscription;_sharedState,_stream,_subscription,_onData,_onError,_onDone,_zone,_async$_state,_cancelFuture,_pending,$ti",
      get$_count: function() {
        return this._sharedState;
      },
      set$_count: function(count) {
        this._sharedState = count;
      },
      $asStreamSubscription: null,
      $as_BufferingStreamSubscription: null,
      $as_ForwardingStreamSubscription: function($T) {
        return [$T, $T];
      }
    },
    _SkipStream: {
      "^": "_ForwardingStream;_count,_async$_source,$ti",
      _createSubscription$4: function(onData, onError, onDone, cancelOnError) {
        var t1, t2, t3;
        t1 = H.getTypeArgumentByIndex(this, 0);
        t2 = $.Zone__current;
        t3 = cancelOnError ? 1 : 0;
        t3 = new P._StateStreamSubscription(this._count, this, null, null, null, null, t2, t3, null, null, this.$ti);
        t3._BufferingStreamSubscription$4(onData, onError, onDone, cancelOnError, t1);
        t3._ForwardingStreamSubscription$5(this, onData, onError, onDone, cancelOnError, t1, t1);
        return t3;
      },
      _handleData$2: function(inputEvent, sink) {
        var count, t1;
        count = sink.get$_count();
        t1 = J.getInterceptor$n(count);
        if (t1.$gt(count, 0)) {
          sink.set$_count(t1.$sub(count, 1));
          return;
        }
        sink._async$_add$1(inputEvent);
      },
      $asStream: null,
      $as_ForwardingStream: function($T) {
        return [$T, $T];
      }
    },
    Timer: {
      "^": "Object;"
    },
    AsyncError: {
      "^": "Object;error<,stackTrace<",
      toString$0: function(_) {
        return H.S(this.error);
      },
      $isError: 1
    },
    _Zone: {
      "^": "Object;"
    },
    _rootHandleUncaughtError_closure: {
      "^": "Closure:1;_box_0,stackTrace",
      call$0: function() {
        var t1, t2, error;
        t1 = this._box_0;
        t2 = t1.error;
        if (t2 == null) {
          error = new P.NullThrownError();
          t1.error = error;
          t1 = error;
        } else
          t1 = t2;
        t2 = this.stackTrace;
        if (t2 == null)
          throw H.wrapException(t1);
        error = H.wrapException(t1);
        error.stack = J.toString$0$(t2);
        throw error;
      }
    },
    _RootZone: {
      "^": "_Zone;",
      runGuarded$1: function(f) {
        var e, s, exception;
        try {
          if (C.C__RootZone === $.Zone__current) {
            f.call$0();
            return;
          }
          P._rootRun(null, null, this, f);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          P._rootHandleUncaughtError(null, null, this, e, s);
        }
      },
      runUnaryGuarded$2: function(f, arg) {
        var e, s, exception;
        try {
          if (C.C__RootZone === $.Zone__current) {
            f.call$1(arg);
            return;
          }
          P._rootRunUnary(null, null, this, f, arg);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          P._rootHandleUncaughtError(null, null, this, e, s);
        }
      },
      runBinaryGuarded$3: function(f, arg1, arg2) {
        var e, s, exception;
        try {
          if (C.C__RootZone === $.Zone__current) {
            f.call$2(arg1, arg2);
            return;
          }
          P._rootRunBinary(null, null, this, f, arg1, arg2);
        } catch (exception) {
          e = H.unwrapException(exception);
          s = H.getTraceFromException(exception);
          P._rootHandleUncaughtError(null, null, this, e, s);
        }
      },
      bindCallback$1: function(f) {
        return new P._RootZone_bindCallback_closure(this, f);
      },
      bindCallbackGuarded$1: function(f) {
        return new P._RootZone_bindCallbackGuarded_closure(this, f);
      },
      $index: function(_, key) {
        return;
      },
      run$1: function(_, f) {
        if ($.Zone__current === C.C__RootZone)
          return f.call$0();
        return P._rootRun(null, null, this, f);
      },
      runUnary$2: function(f, arg) {
        if ($.Zone__current === C.C__RootZone)
          return f.call$1(arg);
        return P._rootRunUnary(null, null, this, f, arg);
      },
      runBinary$3: function(f, arg1, arg2) {
        if ($.Zone__current === C.C__RootZone)
          return f.call$2(arg1, arg2);
        return P._rootRunBinary(null, null, this, f, arg1, arg2);
      },
      registerBinaryCallback$1: function(f) {
        return f;
      }
    },
    _RootZone_bindCallback_closure: {
      "^": "Closure:1;$this,f",
      call$0: function() {
        return this.$this.run$1(0, this.f);
      }
    },
    _RootZone_bindCallbackGuarded_closure: {
      "^": "Closure:1;$this,f",
      call$0: function() {
        return this.$this.runGuarded$1(this.f);
      }
    }
  }], ["dart.collection", "dart:collection",, P, {
    "^": "",
    HashMap_HashMap: function(equals, hashCode, isValidKey, $K, $V) {
      return new P._HashMap(0, null, null, null, null, [$K, $V]);
    },
    LinkedHashMap_LinkedHashMap: function(equals, hashCode, isValidKey, $K, $V) {
      if (isValidKey == null)
        if (hashCode == null) {
          if (equals == null)
            return new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [$K, $V]);
          hashCode = P.collection___defaultHashCode$closure();
        } else {
          if (P.core__identityHashCode$closure() === hashCode && P.core__identical$closure() === equals)
            return P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6($K, $V);
          if (equals == null)
            equals = P.collection___defaultEquals$closure();
        }
      else {
        if (hashCode == null)
          hashCode = P.collection___defaultHashCode$closure();
        if (equals == null)
          equals = P.collection___defaultEquals$closure();
      }
      return P._LinkedCustomHashMap$(equals, hashCode, isValidKey, $K, $V);
    },
    LinkedHashMap_LinkedHashMap$_empty: function($K, $V) {
      return new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [$K, $V]);
    },
    LinkedHashMap__makeEmpty: function() {
      return new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [null, null]);
    },
    LinkedHashMap__makeLiteral: function(keyValuePairs) {
      return H.fillLiteralMap(keyValuePairs, new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [null, null]));
    },
    LinkedHashSet_LinkedHashSet: function(equals, hashCode, isValidKey, $E) {
      if (hashCode == null) {
        if (equals == null)
          return new P._LinkedHashSet(0, null, null, null, null, null, 0, [$E]);
        hashCode = P.collection___defaultHashCode$closure();
      } else {
        if (P.core__identityHashCode$closure() === hashCode && P.core__identical$closure() === equals)
          return new P._LinkedIdentityHashSet(0, null, null, null, null, null, 0, [$E]);
        if (equals == null)
          equals = P.collection___defaultEquals$closure();
      }
      return P._LinkedCustomHashSet$(equals, hashCode, isValidKey, $E);
    },
    _defaultEquals: [function(a, b) {
      return J.$eq$(a, b);
    }, "call$2", "collection___defaultEquals$closure", 8, 0, 87],
    _defaultHashCode: [function(a) {
      return J.get$hashCode$(a);
    }, "call$1", "collection___defaultHashCode$closure", 4, 0, 88, 21],
    IterableBase_iterableToShortString: function(iterable, leftDelimiter, rightDelimiter) {
      var parts, t1;
      if (P._isToStringVisiting(iterable)) {
        if (leftDelimiter === "(" && rightDelimiter === ")")
          return "(...)";
        return leftDelimiter + "..." + rightDelimiter;
      }
      parts = [];
      t1 = $.$get$_toStringVisiting();
      t1.push(iterable);
      try {
        P._iterablePartsToStrings(iterable, parts);
      } finally {
        if (0 >= t1.length)
          return H.ioore(t1, -1);
        t1.pop();
      }
      t1 = P.StringBuffer__writeAll(leftDelimiter, parts, ", ") + rightDelimiter;
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    IterableBase_iterableToFullString: function(iterable, leftDelimiter, rightDelimiter) {
      var buffer, t1, t2;
      if (P._isToStringVisiting(iterable))
        return leftDelimiter + "..." + rightDelimiter;
      buffer = new P.StringBuffer(leftDelimiter);
      t1 = $.$get$_toStringVisiting();
      t1.push(iterable);
      try {
        t2 = buffer;
        t2.set$_contents(P.StringBuffer__writeAll(t2.get$_contents(), iterable, ", "));
      } finally {
        if (0 >= t1.length)
          return H.ioore(t1, -1);
        t1.pop();
      }
      t1 = buffer;
      t1.set$_contents(t1.get$_contents() + rightDelimiter);
      t1 = buffer.get$_contents();
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    _isToStringVisiting: function(o) {
      var i, t1;
      for (i = 0; t1 = $.$get$_toStringVisiting(), i < t1.length; ++i)
        if (o === t1[i])
          return true;
      return false;
    },
    _iterablePartsToStrings: function(iterable, parts) {
      var it, $length, count, next, ultimateString, penultimateString, penultimate, ultimate, ultimate0, elision;
      it = iterable.get$iterator(iterable);
      $length = 0;
      count = 0;
      while (true) {
        if (!($length < 80 || count < 3))
          break;
        if (!it.moveNext$0())
          return;
        next = H.S(it.get$current(it));
        parts.push(next);
        $length += next.length + 2;
        ++count;
      }
      if (!it.moveNext$0()) {
        if (count <= 5)
          return;
        if (0 >= parts.length)
          return H.ioore(parts, -1);
        ultimateString = parts.pop();
        if (0 >= parts.length)
          return H.ioore(parts, -1);
        penultimateString = parts.pop();
      } else {
        penultimate = it.get$current(it);
        ++count;
        if (!it.moveNext$0()) {
          if (count <= 4) {
            parts.push(H.S(penultimate));
            return;
          }
          ultimateString = H.S(penultimate);
          if (0 >= parts.length)
            return H.ioore(parts, -1);
          penultimateString = parts.pop();
          $length += ultimateString.length + 2;
        } else {
          ultimate = it.get$current(it);
          ++count;
          for (; it.moveNext$0(); penultimate = ultimate, ultimate = ultimate0) {
            ultimate0 = it.get$current(it);
            ++count;
            if (count > 100) {
              while (true) {
                if (!($length > 75 && count > 3))
                  break;
                if (0 >= parts.length)
                  return H.ioore(parts, -1);
                $length -= parts.pop().length + 2;
                --count;
              }
              parts.push("...");
              return;
            }
          }
          penultimateString = H.S(penultimate);
          ultimateString = H.S(ultimate);
          $length += ultimateString.length + penultimateString.length + 4;
        }
      }
      if (count > parts.length + 2) {
        $length += 5;
        elision = "...";
      } else
        elision = null;
      while (true) {
        if (!($length > 80 && parts.length > 3))
          break;
        if (0 >= parts.length)
          return H.ioore(parts, -1);
        $length -= parts.pop().length + 2;
        if (elision == null) {
          $length += 5;
          elision = "...";
        }
      }
      if (elision != null)
        parts.push(elision);
      parts.push(penultimateString);
      parts.push(ultimateString);
    },
    LinkedHashMap_LinkedHashMap$from: function(other, $K, $V) {
      var result = P.LinkedHashMap_LinkedHashMap(null, null, null, $K, $V);
      J.forEach$1$ax(other, new P.LinkedHashMap_LinkedHashMap$from_closure(result));
      return result;
    },
    LinkedHashSet_LinkedHashSet$from: function(elements, $E) {
      var result, t1;
      result = P.LinkedHashSet_LinkedHashSet(null, null, null, $E);
      for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
        result.add$1(0, t1.get$current(t1));
      return result;
    },
    MapBase_mapToString: function(m) {
      var t1, result, t2;
      t1 = {};
      if (P._isToStringVisiting(m))
        return "{...}";
      result = new P.StringBuffer("");
      try {
        $.$get$_toStringVisiting().push(m);
        t2 = result;
        t2.set$_contents(t2.get$_contents() + "{");
        t1.first = true;
        m.forEach$1(0, new P.MapBase_mapToString_closure(t1, result));
        t1 = result;
        t1.set$_contents(t1.get$_contents() + "}");
      } finally {
        t1 = $.$get$_toStringVisiting();
        if (0 >= t1.length)
          return H.ioore(t1, -1);
        t1.pop();
      }
      t1 = result.get$_contents();
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    MapBase__id: [function(x) {
      return x;
    }, "call$1", "collection_MapBase__id$closure", 4, 0, 0],
    MapBase__fillMapWithMappedIterable: function(map, iterable, key, value) {
      var t1, _i, element;
      for (t1 = iterable.length, _i = 0; _i < t1; ++_i) {
        element = iterable[_i];
        map.$indexSet(0, P.collection_MapBase__id$closure().call$1(element), value.call$1(element));
      }
    },
    MapBase__fillMapWithIterables: function(map, keys, values) {
      var keyIterator, valueIterator, hasNextKey, hasNextValue;
      keyIterator = keys.get$iterator(keys);
      valueIterator = values.get$iterator(values);
      hasNextKey = keyIterator.moveNext$0();
      hasNextValue = valueIterator.moveNext$0();
      while (true) {
        if (!(hasNextKey && hasNextValue))
          break;
        map.$indexSet(0, keyIterator.get$current(keyIterator), valueIterator.get$current(valueIterator));
        hasNextKey = keyIterator.moveNext$0();
        hasNextValue = valueIterator.moveNext$0();
      }
      if (hasNextKey || hasNextValue)
        throw H.wrapException(P.ArgumentError$("Iterables do not have same length."));
    },
    _HashMap: {
      "^": "MapBase;_collection$_length,_collection$_strings,_collection$_nums,_collection$_rest,_collection$_keys,$ti",
      get$length: function(_) {
        return this._collection$_length;
      },
      get$isEmpty: function(_) {
        return this._collection$_length === 0;
      },
      get$isNotEmpty: function(_) {
        return this._collection$_length !== 0;
      },
      get$keys: function() {
        return new P._HashMapKeyIterable(this, [H.getTypeArgumentByIndex(this, 0)]);
      },
      get$values: function() {
        var t1 = H.getTypeArgumentByIndex(this, 0);
        return H.MappedIterable_MappedIterable(new P._HashMapKeyIterable(this, [t1]), new P._HashMap_values_closure(this), t1, H.getTypeArgumentByIndex(this, 1));
      },
      containsKey$1: function(key) {
        var strings, nums;
        if (typeof key === "string" && key !== "__proto__") {
          strings = this._collection$_strings;
          return strings == null ? false : strings[key] != null;
        } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
          nums = this._collection$_nums;
          return nums == null ? false : nums[key] != null;
        } else
          return this._containsKey$1(key);
      },
      _containsKey$1: function(key) {
        var rest = this._collection$_rest;
        if (rest == null)
          return false;
        return this._findBucketIndex$2(rest[this._computeHashCode$1(key)], key) >= 0;
      },
      $index: function(_, key) {
        var strings, t1, nums;
        if (typeof key === "string" && key !== "__proto__") {
          strings = this._collection$_strings;
          t1 = strings == null ? null : P._HashMap__getTableEntry(strings, key);
          return t1;
        } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
          nums = this._collection$_nums;
          t1 = nums == null ? null : P._HashMap__getTableEntry(nums, key);
          return t1;
        } else
          return this._get$1(key);
      },
      _get$1: function(key) {
        var rest, bucket, index;
        rest = this._collection$_rest;
        if (rest == null)
          return;
        bucket = rest[this._computeHashCode$1(key)];
        index = this._findBucketIndex$2(bucket, key);
        return index < 0 ? null : bucket[index + 1];
      },
      $indexSet: function(_, key, value) {
        var strings, nums;
        if (typeof key === "string" && key !== "__proto__") {
          strings = this._collection$_strings;
          if (strings == null) {
            strings = P._HashMap__newHashTable();
            this._collection$_strings = strings;
          }
          this._collection$_addHashTableEntry$3(strings, key, value);
        } else if (typeof key === "number" && (key & 0x3ffffff) === key) {
          nums = this._collection$_nums;
          if (nums == null) {
            nums = P._HashMap__newHashTable();
            this._collection$_nums = nums;
          }
          this._collection$_addHashTableEntry$3(nums, key, value);
        } else
          this._set$2(key, value);
      },
      _set$2: function(key, value) {
        var rest, hash, bucket, index;
        rest = this._collection$_rest;
        if (rest == null) {
          rest = P._HashMap__newHashTable();
          this._collection$_rest = rest;
        }
        hash = this._computeHashCode$1(key);
        bucket = rest[hash];
        if (bucket == null) {
          P._HashMap__setTableEntry(rest, hash, [key, value]);
          ++this._collection$_length;
          this._collection$_keys = null;
        } else {
          index = this._findBucketIndex$2(bucket, key);
          if (index >= 0)
            bucket[index + 1] = value;
          else {
            bucket.push(key, value);
            ++this._collection$_length;
            this._collection$_keys = null;
          }
        }
      },
      remove$1: function(_, key) {
        if (typeof key === "string" && key !== "__proto__")
          return this._collection$_removeHashTableEntry$2(this._collection$_strings, key);
        else if (typeof key === "number" && (key & 0x3ffffff) === key)
          return this._collection$_removeHashTableEntry$2(this._collection$_nums, key);
        else
          return this._remove$1(key);
      },
      _remove$1: function(key) {
        var rest, bucket, index;
        rest = this._collection$_rest;
        if (rest == null)
          return;
        bucket = rest[this._computeHashCode$1(key)];
        index = this._findBucketIndex$2(bucket, key);
        if (index < 0)
          return;
        --this._collection$_length;
        this._collection$_keys = null;
        return bucket.splice(index, 2)[1];
      },
      forEach$1: function(_, action) {
        var keys, $length, i, key;
        keys = this._computeKeys$0();
        for ($length = keys.length, i = 0; i < $length; ++i) {
          key = keys[i];
          action.call$2(key, this.$index(0, key));
          if (keys !== this._collection$_keys)
            throw H.wrapException(P.ConcurrentModificationError$(this));
        }
      },
      _computeKeys$0: function() {
        var t1, result, strings, names, entries, index, i, nums, rest, bucket, $length, i0;
        t1 = this._collection$_keys;
        if (t1 != null)
          return t1;
        result = new Array(this._collection$_length);
        result.fixed$length = Array;
        strings = this._collection$_strings;
        if (strings != null) {
          names = Object.getOwnPropertyNames(strings);
          entries = names.length;
          for (index = 0, i = 0; i < entries; ++i) {
            result[index] = names[i];
            ++index;
          }
        } else
          index = 0;
        nums = this._collection$_nums;
        if (nums != null) {
          names = Object.getOwnPropertyNames(nums);
          entries = names.length;
          for (i = 0; i < entries; ++i) {
            result[index] = +names[i];
            ++index;
          }
        }
        rest = this._collection$_rest;
        if (rest != null) {
          names = Object.getOwnPropertyNames(rest);
          entries = names.length;
          for (i = 0; i < entries; ++i) {
            bucket = rest[names[i]];
            $length = bucket.length;
            for (i0 = 0; i0 < $length; i0 += 2) {
              result[index] = bucket[i0];
              ++index;
            }
          }
        }
        this._collection$_keys = result;
        return result;
      },
      _collection$_addHashTableEntry$3: function(table, key, value) {
        if (table[key] == null) {
          ++this._collection$_length;
          this._collection$_keys = null;
        }
        P._HashMap__setTableEntry(table, key, value);
      },
      _collection$_removeHashTableEntry$2: function(table, key) {
        var value;
        if (table != null && table[key] != null) {
          value = P._HashMap__getTableEntry(table, key);
          delete table[key];
          --this._collection$_length;
          this._collection$_keys = null;
          return value;
        } else
          return;
      },
      _computeHashCode$1: function(key) {
        return J.get$hashCode$(key) & 0x3ffffff;
      },
      _findBucketIndex$2: function(bucket, key) {
        var $length, i;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; i += 2)
          if (J.$eq$(bucket[i], key) === true)
            return i;
        return -1;
      },
      static: {
        _HashMap__getTableEntry: function(table, key) {
          var entry = table[key];
          return entry === table ? null : entry;
        },
        _HashMap__setTableEntry: function(table, key, value) {
          if (value == null)
            table[key] = table;
          else
            table[key] = value;
        },
        _HashMap__newHashTable: function() {
          var table = Object.create(null);
          P._HashMap__setTableEntry(table, "<non-identifier-key>", table);
          delete table["<non-identifier-key>"];
          return table;
        }
      }
    },
    _HashMap_values_closure: {
      "^": "Closure:0;$this",
      call$1: [function(each) {
        return this.$this.$index(0, each);
      }, null, null, 4, 0, null, 33, "call"]
    },
    _HashMapKeyIterable: {
      "^": "EfficientLengthIterable;_collection$_map,$ti",
      get$length: function(_) {
        return this._collection$_map._collection$_length;
      },
      get$isEmpty: function(_) {
        return this._collection$_map._collection$_length === 0;
      },
      get$iterator: function(_) {
        var t1 = this._collection$_map;
        return new P._HashMapKeyIterator(t1, t1._computeKeys$0(), 0, null, this.$ti);
      },
      contains$1: function(_, element) {
        return this._collection$_map.containsKey$1(element);
      },
      forEach$1: function(_, f) {
        var t1, keys, $length, i;
        t1 = this._collection$_map;
        keys = t1._computeKeys$0();
        for ($length = keys.length, i = 0; i < $length; ++i) {
          f.call$1(keys[i]);
          if (keys !== t1._collection$_keys)
            throw H.wrapException(P.ConcurrentModificationError$(t1));
        }
      }
    },
    _HashMapKeyIterator: {
      "^": "Object;_collection$_map,_collection$_keys,_offset,_collection$_current,$ti",
      get$current: function(_) {
        return this._collection$_current;
      },
      moveNext$0: function() {
        var keys, offset, t1;
        keys = this._collection$_keys;
        offset = this._offset;
        t1 = this._collection$_map;
        if (keys !== t1._collection$_keys)
          throw H.wrapException(P.ConcurrentModificationError$(t1));
        else if (offset >= keys.length) {
          this._collection$_current = null;
          return false;
        } else {
          this._collection$_current = keys[offset];
          this._offset = offset + 1;
          return true;
        }
      }
    },
    _LinkedIdentityHashMap: {
      "^": "JsLinkedHashMap;__js_helper$_length,_strings,_nums,_rest,_first,_last,_modifications,$ti",
      internalComputeHashCode$1: function(key) {
        return H.objectHashCode(key) & 0x3ffffff;
      },
      internalFindBucketIndex$2: function(bucket, key) {
        var $length, i, t1;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; ++i) {
          t1 = bucket[i].get$hashMapCellKey();
          if (t1 == null ? key == null : t1 === key)
            return i;
        }
        return -1;
      },
      static: {
        _LinkedIdentityHashMap__LinkedIdentityHashMap$es6: function($K, $V) {
          return new P._LinkedIdentityHashMap(0, null, null, null, null, null, 0, [$K, $V]);
        }
      }
    },
    _LinkedCustomHashMap: {
      "^": "JsLinkedHashMap;_equals,_hashCode,_validKey,__js_helper$_length,_strings,_nums,_rest,_first,_last,_modifications,$ti",
      $index: function(_, key) {
        if (this._validKey.call$1(key) !== true)
          return;
        return this.super$JsLinkedHashMap$internalGet(key);
      },
      $indexSet: function(_, key, value) {
        this.super$JsLinkedHashMap$internalSet(key, value);
      },
      containsKey$1: [function(key) {
        if (this._validKey.call$1(key) !== true)
          return false;
        return this.super$JsLinkedHashMap$internalContainsKey(key);
      }, "call$1", "get$containsKey", 4, 0, 13],
      remove$1: function(_, key) {
        if (this._validKey.call$1(key) !== true)
          return;
        return this.super$JsLinkedHashMap$internalRemove(key);
      },
      internalComputeHashCode$1: function(key) {
        return this._hashCode.call$1(key) & 0x3ffffff;
      },
      internalFindBucketIndex$2: function(bucket, key) {
        var $length, t1, i;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (t1 = this._equals, i = 0; i < $length; ++i)
          if (t1.call$2(bucket[i].get$hashMapCellKey(), key) === true)
            return i;
        return -1;
      },
      static: {
        _LinkedCustomHashMap$: function(_equals, _hashCode, validKey, $K, $V) {
          var t1 = validKey != null ? validKey : new P._LinkedCustomHashMap_closure($K);
          return new P._LinkedCustomHashMap(_equals, _hashCode, t1, 0, null, null, null, null, null, 0, [$K, $V]);
        }
      }
    },
    _LinkedCustomHashMap_closure: {
      "^": "Closure:0;K",
      call$1: function(v) {
        return H.checkSubtypeOfRuntimeType(v, this.K);
      }
    },
    _LinkedHashSet: {
      "^": "_HashSetBase;_collection$_length,_collection$_strings,_collection$_nums,_collection$_rest,_collection$_first,_collection$_last,_collection$_modifications,$ti",
      _newSet$0: function() {
        return new P._LinkedHashSet(0, null, null, null, null, null, 0, this.$ti);
      },
      get$iterator: function(_) {
        var t1 = new P._LinkedHashSetIterator(this, this._collection$_modifications, null, null, [null]);
        t1._collection$_cell = this._collection$_first;
        return t1;
      },
      get$length: function(_) {
        return this._collection$_length;
      },
      get$isEmpty: function(_) {
        return this._collection$_length === 0;
      },
      get$isNotEmpty: function(_) {
        return this._collection$_length !== 0;
      },
      contains$1: [function(_, object) {
        var strings, nums;
        if (typeof object === "string" && object !== "__proto__") {
          strings = this._collection$_strings;
          if (strings == null)
            return false;
          return strings[object] != null;
        } else if (typeof object === "number" && (object & 0x3ffffff) === object) {
          nums = this._collection$_nums;
          if (nums == null)
            return false;
          return nums[object] != null;
        } else
          return this._contains$1(object);
      }, "call$1", "get$contains", 5, 0, 13],
      _contains$1: ["super$_LinkedHashSet$_contains", function(object) {
        var rest = this._collection$_rest;
        if (rest == null)
          return false;
        return this._findBucketIndex$2(rest[this._computeHashCode$1(object)], object) >= 0;
      }],
      forEach$1: function(_, action) {
        var cell, modifications;
        cell = this._collection$_first;
        modifications = this._collection$_modifications;
        for (; cell != null;) {
          action.call$1(cell.get$_element());
          if (modifications !== this._collection$_modifications)
            throw H.wrapException(P.ConcurrentModificationError$(this));
          cell = cell.get$_collection$_next();
        }
      },
      get$first: function(_) {
        var t1 = this._collection$_first;
        if (t1 == null)
          throw H.wrapException(P.StateError$("No elements"));
        return t1.get$_element();
      },
      get$last: function(_) {
        var t1 = this._collection$_last;
        if (t1 == null)
          throw H.wrapException(P.StateError$("No elements"));
        return t1._element;
      },
      add$1: function(_, element) {
        var strings, nums;
        if (typeof element === "string" && element !== "__proto__") {
          strings = this._collection$_strings;
          if (strings == null) {
            strings = P._LinkedHashSet__newHashTable();
            this._collection$_strings = strings;
          }
          return this._collection$_addHashTableEntry$2(strings, element);
        } else if (typeof element === "number" && (element & 0x3ffffff) === element) {
          nums = this._collection$_nums;
          if (nums == null) {
            nums = P._LinkedHashSet__newHashTable();
            this._collection$_nums = nums;
          }
          return this._collection$_addHashTableEntry$2(nums, element);
        } else
          return this._add$1(element);
      },
      _add$1: ["super$_LinkedHashSet$_add", function(element) {
        var rest, hash, bucket;
        rest = this._collection$_rest;
        if (rest == null) {
          rest = P._LinkedHashSet__newHashTable();
          this._collection$_rest = rest;
        }
        hash = this._computeHashCode$1(element);
        bucket = rest[hash];
        if (bucket == null)
          rest[hash] = [this._collection$_newLinkedCell$1(element)];
        else {
          if (this._findBucketIndex$2(bucket, element) >= 0)
            return false;
          bucket.push(this._collection$_newLinkedCell$1(element));
        }
        return true;
      }],
      remove$1: function(_, object) {
        if (typeof object === "string" && object !== "__proto__")
          return this._collection$_removeHashTableEntry$2(this._collection$_strings, object);
        else if (typeof object === "number" && (object & 0x3ffffff) === object)
          return this._collection$_removeHashTableEntry$2(this._collection$_nums, object);
        else
          return this._remove$1(object);
      },
      _remove$1: ["super$_LinkedHashSet$_remove", function(object) {
        var rest, bucket, index;
        rest = this._collection$_rest;
        if (rest == null)
          return false;
        bucket = rest[this._computeHashCode$1(object)];
        index = this._findBucketIndex$2(bucket, object);
        if (index < 0)
          return false;
        this._collection$_unlinkCell$1(bucket.splice(index, 1)[0]);
        return true;
      }],
      _collection$_addHashTableEntry$2: function(table, element) {
        if (table[element] != null)
          return false;
        table[element] = this._collection$_newLinkedCell$1(element);
        return true;
      },
      _collection$_removeHashTableEntry$2: function(table, element) {
        var cell;
        if (table == null)
          return false;
        cell = table[element];
        if (cell == null)
          return false;
        this._collection$_unlinkCell$1(cell);
        delete table[element];
        return true;
      },
      _collection$_modified$0: function() {
        this._collection$_modifications = this._collection$_modifications + 1 & 67108863;
      },
      _collection$_newLinkedCell$1: function(element) {
        var cell, last;
        cell = new P._LinkedHashSetCell(element, null, null);
        if (this._collection$_first == null) {
          this._collection$_last = cell;
          this._collection$_first = cell;
        } else {
          last = this._collection$_last;
          cell._collection$_previous = last;
          last._collection$_next = cell;
          this._collection$_last = cell;
        }
        ++this._collection$_length;
        this._collection$_modified$0();
        return cell;
      },
      _collection$_unlinkCell$1: function(cell) {
        var previous, next;
        previous = cell.get$_collection$_previous();
        next = cell.get$_collection$_next();
        if (previous == null)
          this._collection$_first = next;
        else
          previous._collection$_next = next;
        if (next == null)
          this._collection$_last = previous;
        else
          next.set$_collection$_previous(previous);
        --this._collection$_length;
        this._collection$_modified$0();
      },
      _computeHashCode$1: function(element) {
        return J.get$hashCode$(element) & 0x3ffffff;
      },
      _findBucketIndex$2: function(bucket, element) {
        var $length, i;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; ++i)
          if (J.$eq$(bucket[i].get$_element(), element) === true)
            return i;
        return -1;
      },
      static: {
        _LinkedHashSet__newHashTable: function() {
          var table = Object.create(null);
          table["<non-identifier-key>"] = table;
          delete table["<non-identifier-key>"];
          return table;
        }
      }
    },
    _LinkedIdentityHashSet: {
      "^": "_LinkedHashSet;_collection$_length,_collection$_strings,_collection$_nums,_collection$_rest,_collection$_first,_collection$_last,_collection$_modifications,$ti",
      _newSet$0: function() {
        return new P._LinkedIdentityHashSet(0, null, null, null, null, null, 0, this.$ti);
      },
      _computeHashCode$1: function(key) {
        return H.objectHashCode(key) & 0x3ffffff;
      },
      _findBucketIndex$2: function(bucket, element) {
        var $length, i, t1;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; ++i) {
          t1 = bucket[i].get$_element();
          if (t1 == null ? element == null : t1 === element)
            return i;
        }
        return -1;
      }
    },
    _LinkedCustomHashSet: {
      "^": "_LinkedHashSet;_equality,_hasher,_validKey,_collection$_length,_collection$_strings,_collection$_nums,_collection$_rest,_collection$_first,_collection$_last,_collection$_modifications,$ti",
      _newSet$0: function() {
        return P._LinkedCustomHashSet$(this._equality, this._hasher, this._validKey, H.getTypeArgumentByIndex(this, 0));
      },
      _findBucketIndex$2: function(bucket, element) {
        var $length, i, t1;
        if (bucket == null)
          return -1;
        $length = bucket.length;
        for (i = 0; i < $length; ++i) {
          t1 = bucket[i].get$_element();
          if (this._equality.call$2(t1, element) === true)
            return i;
        }
        return -1;
      },
      _computeHashCode$1: function(element) {
        return this._hasher.call$1(element) & 0x3ffffff;
      },
      add$1: function(_, element) {
        return this.super$_LinkedHashSet$_add(element);
      },
      contains$1: function(_, object) {
        if (this._validKey.call$1(object) !== true)
          return false;
        return this.super$_LinkedHashSet$_contains(object);
      },
      remove$1: function(_, object) {
        if (this._validKey.call$1(object) !== true)
          return false;
        return this.super$_LinkedHashSet$_remove(object);
      },
      removeAll$1: function(elements) {
        var t1, element;
        for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();) {
          element = t1.get$current(t1);
          if (this._validKey.call$1(element) === true)
            this.super$_LinkedHashSet$_remove(element);
        }
      },
      static: {
        _LinkedCustomHashSet$: function(_equality, _hasher, validKey, $E) {
          var t1 = validKey != null ? validKey : new P._LinkedCustomHashSet_closure($E);
          return new P._LinkedCustomHashSet(_equality, _hasher, t1, 0, null, null, null, null, null, 0, [$E]);
        }
      }
    },
    _LinkedCustomHashSet_closure: {
      "^": "Closure:0;E",
      call$1: function(x) {
        return H.checkSubtypeOfRuntimeType(x, this.E);
      }
    },
    _LinkedHashSetCell: {
      "^": "Object;_element<,_collection$_next<,_collection$_previous@"
    },
    _LinkedHashSetIterator: {
      "^": "Object;_set,_collection$_modifications,_collection$_cell,_collection$_current,$ti",
      get$current: function(_) {
        return this._collection$_current;
      },
      moveNext$0: function() {
        var t1 = this._set;
        if (this._collection$_modifications !== t1._collection$_modifications)
          throw H.wrapException(P.ConcurrentModificationError$(t1));
        else {
          t1 = this._collection$_cell;
          if (t1 == null) {
            this._collection$_current = null;
            return false;
          } else {
            this._collection$_current = t1.get$_element();
            this._collection$_cell = this._collection$_cell.get$_collection$_next();
            return true;
          }
        }
      }
    },
    UnmodifiableListView: {
      "^": "UnmodifiableListBase;_collection$_source,$ti",
      cast$0: function(_) {
        return new P.UnmodifiableListView(J.cast$0$ax(this._collection$_source), [null]);
      },
      get$length: function(_) {
        return J.get$length$asx(this._collection$_source);
      },
      $index: function(_, index) {
        return J.elementAt$1$ax(this._collection$_source, index);
      },
      static: {
        UnmodifiableListView$: function(source, $E) {
          return new P.UnmodifiableListView(source, [$E]);
        }
      }
    },
    HashMap: {
      "^": "Object;$ti",
      $isMap: 1
    },
    _HashSetBase: {
      "^": "SetBase;$ti",
      difference$1: function(other) {
        var result, t1, element;
        result = this._newSet$0();
        for (t1 = new P._LinkedHashSetIterator(this, this._collection$_modifications, null, null, [null]), t1._collection$_cell = this._collection$_first; t1.moveNext$0();) {
          element = t1._collection$_current;
          if (!other.contains$1(0, element))
            result.add$1(0, element);
        }
        return result;
      }
    },
    IterableBase: {
      "^": "Iterable;$ti"
    },
    LinkedHashMap: {
      "^": "Object;$ti",
      $isMap: 1
    },
    LinkedHashMap_LinkedHashMap$from_closure: {
      "^": "Closure:2;result",
      call$2: function(k, v) {
        this.result.$indexSet(0, k, v);
      }
    },
    LinkedHashSet: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $isIterable: 1,
      $isSet: 1
    },
    ListBase: {
      "^": "_ListBase_Object_ListMixin;$ti",
      $isEfficientLengthIterable: 1,
      $isIterable: 1,
      $isList: 1
    },
    ListMixin: {
      "^": "Object;$ti",
      get$iterator: function(receiver) {
        return new H.ListIterator(receiver, this.get$length(receiver), 0, null, [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)]);
      },
      elementAt$1: function(receiver, index) {
        return this.$index(receiver, index);
      },
      forEach$1: function(receiver, action) {
        var $length, i;
        $length = this.get$length(receiver);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          action.call$1(this.$index(receiver, i));
          if ($length !== this.get$length(receiver))
            throw H.wrapException(P.ConcurrentModificationError$(receiver));
        }
      },
      get$isEmpty: function(receiver) {
        return J.$eq$(this.get$length(receiver), 0);
      },
      get$isNotEmpty: function(receiver) {
        return this.get$isEmpty(receiver) !== true;
      },
      get$first: function(receiver) {
        if (J.$eq$(this.get$length(receiver), 0) === true)
          throw H.wrapException(H.IterableElementError_noElement());
        return this.$index(receiver, 0);
      },
      get$last: function(receiver) {
        if (J.$eq$(this.get$length(receiver), 0) === true)
          throw H.wrapException(H.IterableElementError_noElement());
        return this.$index(receiver, J.$sub$n(this.get$length(receiver), 1));
      },
      get$single: function(receiver) {
        if (J.$eq$(this.get$length(receiver), 0) === true)
          throw H.wrapException(H.IterableElementError_noElement());
        if (J.$gt$n(this.get$length(receiver), 1))
          throw H.wrapException(H.IterableElementError_tooMany());
        return this.$index(receiver, 0);
      },
      contains$1: function(receiver, element) {
        var $length, i;
        $length = this.get$length(receiver);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          if (J.$eq$(this.$index(receiver, i), element) === true)
            return true;
          if ($length !== this.get$length(receiver))
            throw H.wrapException(P.ConcurrentModificationError$(receiver));
        }
        return false;
      },
      every$1: function(receiver, test) {
        var $length, i;
        $length = this.get$length(receiver);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          if (test.call$1(this.$index(receiver, i)) !== true)
            return false;
          if ($length !== this.get$length(receiver))
            throw H.wrapException(P.ConcurrentModificationError$(receiver));
        }
        return true;
      },
      any$1: function(receiver, test) {
        var $length, i;
        $length = this.get$length(receiver);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          if (test.call$1(this.$index(receiver, i)) === true)
            return true;
          if ($length !== this.get$length(receiver))
            throw H.wrapException(P.ConcurrentModificationError$(receiver));
        }
        return false;
      },
      join$1: function(receiver, separator) {
        var t1;
        if (J.$eq$(this.get$length(receiver), 0) === true)
          return "";
        t1 = P.StringBuffer__writeAll("", receiver, separator);
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      },
      join$0: function($receiver) {
        return this.join$1($receiver, "");
      },
      where$1: function(receiver, test) {
        return new H.WhereIterable(receiver, test, [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)]);
      },
      map$1: function(receiver, f) {
        return new H.MappedListIterable(receiver, f, [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0), null]);
      },
      expand$1: function(receiver, f) {
        return new H.ExpandIterable(receiver, f, [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0), null]);
      },
      skip$1: function(receiver, count) {
        return H.SubListIterable$(receiver, count, null, H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0));
      },
      take$1: function(receiver, count) {
        return H.SubListIterable$(receiver, 0, count, H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0));
      },
      toList$1$growable: function(receiver, growable) {
        var result, t1, i;
        if (growable) {
          result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)]);
          C.JSArray_methods.set$length(result, this.get$length(receiver));
        } else {
          t1 = this.get$length(receiver);
          if (typeof t1 !== "number")
            return H.iae(t1);
          t1 = new Array(t1);
          t1.fixed$length = Array;
          result = H.setRuntimeTypeInfo(t1, [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)]);
        }
        i = 0;
        while (true) {
          t1 = this.get$length(receiver);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          t1 = this.$index(receiver, i);
          if (i >= result.length)
            return H.ioore(result, i);
          result[i] = t1;
          ++i;
        }
        return result;
      },
      toList$0: function($receiver) {
        return this.toList$1$growable($receiver, true);
      },
      add$1: function(receiver, element) {
        var t1 = this.get$length(receiver);
        this.set$length(receiver, J.$add$ansx(t1, 1));
        this.$indexSet(receiver, t1, element);
      },
      remove$1: function(receiver, element) {
        var i, t1;
        i = 0;
        while (true) {
          t1 = this.get$length(receiver);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          if (J.$eq$(this.$index(receiver, i), element) === true) {
            this._closeGap$2(receiver, i, i + 1);
            return true;
          }
          ++i;
        }
        return false;
      },
      _closeGap$2: function(receiver, start, end) {
        var $length, size, i, t1;
        $length = this.get$length(receiver);
        size = J.$sub$n(end, start);
        for (i = end; t1 = J.getInterceptor$n(i), t1.$lt(i, $length); i = t1.$add(i, 1))
          this.$indexSet(receiver, t1.$sub(i, size), this.$index(receiver, i));
        this.set$length(receiver, J.$sub$n($length, size));
      },
      cast$0: function(receiver) {
        return new H.CastList(receiver, [null, null]);
      },
      $add: function(receiver, other) {
        var result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)]);
        C.JSArray_methods.set$length(result, J.$add$ansx(this.get$length(receiver), J.get$length$asx(other)));
        C.JSArray_methods.setRange$3(result, 0, this.get$length(receiver), receiver);
        C.JSArray_methods.setRange$3(result, this.get$length(receiver), result.length, other);
        return result;
      },
      sublist$2: function(receiver, start, end) {
        var listLength, $length, result, i, t1;
        listLength = this.get$length(receiver);
        if (end == null)
          end = listLength;
        P.RangeError_checkValidRange(start, end, listLength, null, null, null);
        $length = J.$sub$n(end, start);
        result = H.setRuntimeTypeInfo([], [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)]);
        C.JSArray_methods.set$length(result, $length);
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i) {
          t1 = this.$index(receiver, start + i);
          if (i >= result.length)
            return H.ioore(result, i);
          result[i] = t1;
        }
        return result;
      },
      fillRange$3: function(receiver, start, end, fill) {
        var i, t1;
        P.RangeError_checkValidRange(start, end, this.get$length(receiver), null, null, null);
        for (i = start; t1 = J.getInterceptor$n(i), t1.$lt(i, end); i = t1.$add(i, 1))
          this.$indexSet(receiver, i, fill);
      },
      setRange$4: ["super$ListMixin$setRange", function(receiver, start, end, iterable, skipCount) {
        var $length, t1, t2, otherStart, otherList, t3, i, t4;
        P.RangeError_checkValidRange(start, end, this.get$length(receiver), null, null, null);
        $length = J.$sub$n(end, start);
        t1 = J.getInterceptor($length);
        if (t1.$eq($length, 0))
          return;
        if (J.$lt$n(skipCount, 0))
          H.throwExpression(P.RangeError$range(skipCount, 0, null, "skipCount", null));
        t2 = H.checkSubtypeV1(iterable, "$isList", [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)], "$asList");
        if (t2) {
          otherStart = skipCount;
          otherList = iterable;
        } else {
          otherList = J.toList$1$growable$ax(J.skip$1$ax(iterable, skipCount), false);
          otherStart = 0;
        }
        t2 = J.getInterceptor$ansx(otherStart);
        t3 = J.getInterceptor$asx(otherList);
        if (J.$gt$n(t2.$add(otherStart, $length), t3.get$length(otherList)))
          throw H.wrapException(H.IterableElementError_tooFew());
        if (t2.$lt(otherStart, start))
          for (i = t1.$sub($length, 1), t1 = J.getInterceptor$ansx(start); t4 = J.getInterceptor$n(i), t4.$ge(i, 0); i = t4.$sub(i, 1))
            this.$indexSet(receiver, t1.$add(start, i), t3.$index(otherList, t2.$add(otherStart, i)));
        else {
          if (typeof $length !== "number")
            return H.iae($length);
          t1 = J.getInterceptor$ansx(start);
          i = 0;
          for (; i < $length; ++i)
            this.$indexSet(receiver, t1.$add(start, i), t3.$index(otherList, t2.$add(otherStart, i)));
        }
      }, function($receiver, start, end, iterable) {
        return this.setRange$4($receiver, start, end, iterable, 0);
      }, "setRange$3", null, null, "get$setRange", 13, 2, null],
      replaceRange$3: function(receiver, start, end, newContents) {
        var t1, removeLength, insertLength, t2, insertEnd, delta, newLength;
        P.RangeError_checkValidRange(start, end, this.get$length(receiver), null, null, null);
        t1 = J.getInterceptor(newContents);
        if (!t1.$isEfficientLengthIterable)
          newContents = t1.toList$0(newContents);
        removeLength = J.$sub$n(end, start);
        insertLength = J.get$length$asx(newContents);
        t1 = J.getInterceptor$n(removeLength);
        t2 = J.getInterceptor$ansx(start);
        if (t1.$ge(removeLength, insertLength)) {
          insertEnd = t2.$add(start, insertLength);
          this.setRange$3(receiver, start, insertEnd, newContents);
          if (t1.$gt(removeLength, insertLength))
            this._closeGap$2(receiver, insertEnd, end);
        } else {
          delta = J.$sub$n(insertLength, removeLength);
          newLength = J.$add$ansx(this.get$length(receiver), delta);
          insertEnd = t2.$add(start, insertLength);
          this.set$length(receiver, newLength);
          this.setRange$4(receiver, insertEnd, newLength, receiver, end);
          this.setRange$3(receiver, start, insertEnd, newContents);
        }
      },
      indexOf$2: function(receiver, element, start) {
        var i, t1;
        if (start < 0)
          start = 0;
        i = start;
        while (true) {
          t1 = this.get$length(receiver);
          if (typeof t1 !== "number")
            return H.iae(t1);
          if (!(i < t1))
            break;
          if (J.$eq$(this.$index(receiver, i), element) === true)
            return i;
          ++i;
        }
        return -1;
      },
      indexOf$1: function($receiver, element) {
        return this.indexOf$2($receiver, element, 0);
      },
      lastIndexOf$2: function(receiver, element, start) {
        var i, t1;
        if (start == null || J.$ge$n(start, this.get$length(receiver)))
          start = J.$sub$n(this.get$length(receiver), 1);
        for (i = start; t1 = J.getInterceptor$n(i), t1.$ge(i, 0); i = t1.$sub(i, 1))
          if (J.$eq$(this.$index(receiver, i), element) === true)
            return i;
        return -1;
      },
      lastIndexOf$1: function($receiver, element) {
        return this.lastIndexOf$2($receiver, element, null);
      },
      get$reversed: function(receiver) {
        return new H.ReversedListIterable(receiver, [H.getRuntimeTypeArgumentIntercepted(this, receiver, "ListMixin", 0)]);
      },
      toString$0: function(receiver) {
        return P.IterableBase_iterableToFullString(receiver, "[", "]");
      }
    },
    MapBase: {
      "^": "MapMixin;$ti"
    },
    MapBase_mapToString_closure: {
      "^": "Closure:2;_box_0,result",
      call$2: function(k, v) {
        var t1, t2;
        t1 = this._box_0;
        if (!t1.first)
          this.result._contents += ", ";
        t1.first = false;
        t1 = this.result;
        t2 = t1._contents += H.S(k);
        t1._contents = t2 + ": ";
        t1._contents += H.S(v);
      }
    },
    MapMixin: {
      "^": "Object;$ti",
      forEach$1: function(_, action) {
        var t1, key;
        for (t1 = this.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
          key = t1.get$current(t1);
          action.call$2(key, this.$index(0, key));
        }
      },
      update$3$ifAbsent: function(key, update, ifAbsent) {
        var t1;
        if (this.containsKey$1(key) === true) {
          t1 = update.call$1(this.$index(0, key));
          this.$indexSet(0, key, t1);
          return t1;
        }
        if (ifAbsent != null) {
          t1 = ifAbsent.call$0();
          this.$indexSet(0, key, t1);
          return t1;
        }
        throw H.wrapException(P.ArgumentError$value(key, "key", "Key not in map."));
      },
      update$2: function(key, update) {
        return this.update$3$ifAbsent(key, update, null);
      },
      map$1: function(_, transform) {
        var result, t1, key, entry;
        result = P.LinkedHashMap__makeEmpty();
        for (t1 = this.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
          key = t1.get$current(t1);
          entry = transform.call$2(key, this.$index(0, key));
          result.$indexSet(0, entry.get$key(), entry.get$value());
        }
        return result;
      },
      containsKey$1: function(key) {
        var t1 = this.get$keys();
        return t1.contains$1(t1, key);
      },
      get$length: function(_) {
        var t1 = this.get$keys();
        return t1.get$length(t1);
      },
      get$isEmpty: function(_) {
        var t1 = this.get$keys();
        return t1.get$isEmpty(t1);
      },
      get$isNotEmpty: function(_) {
        var t1 = this.get$keys();
        return t1.get$isNotEmpty(t1);
      },
      get$values: function() {
        return new P._MapBaseValueIterable(this, [H.getRuntimeTypeArgument(this, "MapMixin", 0), H.getRuntimeTypeArgument(this, "MapMixin", 1)]);
      },
      toString$0: function(_) {
        return P.MapBase_mapToString(this);
      },
      $isMap: 1
    },
    _MapBaseValueIterable: {
      "^": "EfficientLengthIterable;_collection$_map,$ti",
      get$length: function(_) {
        var t1 = this._collection$_map;
        return t1.get$length(t1);
      },
      get$isEmpty: function(_) {
        var t1 = this._collection$_map;
        return t1.get$isEmpty(t1);
      },
      get$isNotEmpty: function(_) {
        var t1 = this._collection$_map;
        return t1.get$isNotEmpty(t1);
      },
      get$first: function(_) {
        var t1, t2;
        t1 = this._collection$_map;
        t2 = t1.get$keys();
        return t1.$index(0, t2.get$first(t2));
      },
      get$single: function(_) {
        var t1, t2;
        t1 = this._collection$_map;
        t2 = t1.get$keys();
        return t1.$index(0, t2.get$single(t2));
      },
      get$last: function(_) {
        var t1, t2;
        t1 = this._collection$_map;
        t2 = t1.get$keys();
        return t1.$index(0, t2.get$last(t2));
      },
      get$iterator: function(_) {
        var t1, t2;
        t1 = this._collection$_map;
        t2 = t1.get$keys();
        return new P._MapBaseValueIterator(t2.get$iterator(t2), t1, null, this.$ti);
      },
      $asEfficientLengthIterable: function($K, $V) {
        return [$V];
      },
      $asIterable: function($K, $V) {
        return [$V];
      }
    },
    _MapBaseValueIterator: {
      "^": "Object;_collection$_keys,_collection$_map,_collection$_current,$ti",
      moveNext$0: function() {
        var t1 = this._collection$_keys;
        if (t1.moveNext$0()) {
          this._collection$_current = this._collection$_map.$index(0, t1.get$current(t1));
          return true;
        }
        this._collection$_current = null;
        return false;
      },
      get$current: function(_) {
        return this._collection$_current;
      }
    },
    _UnmodifiableMapMixin: {
      "^": "Object;$ti",
      $indexSet: function(_, key, value) {
        throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable map"));
      },
      remove$1: function(_, key) {
        throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable map"));
      },
      putIfAbsent$2: function(key, ifAbsent) {
        throw H.wrapException(P.UnsupportedError$("Cannot modify unmodifiable map"));
      }
    },
    MapView: {
      "^": "Object;$ti",
      $index: function(_, key) {
        return this._collection$_map.$index(0, key);
      },
      $indexSet: function(_, key, value) {
        this._collection$_map.$indexSet(0, key, value);
      },
      putIfAbsent$2: function(key, ifAbsent) {
        return this._collection$_map.putIfAbsent$2(key, ifAbsent);
      },
      containsKey$1: function(key) {
        return this._collection$_map.containsKey$1(key);
      },
      forEach$1: function(_, action) {
        this._collection$_map.forEach$1(0, action);
      },
      get$isEmpty: function(_) {
        var t1 = this._collection$_map;
        return t1.get$isEmpty(t1);
      },
      get$isNotEmpty: function(_) {
        var t1 = this._collection$_map;
        return t1.get$isNotEmpty(t1);
      },
      get$length: function(_) {
        var t1 = this._collection$_map;
        return t1.get$length(t1);
      },
      get$keys: function() {
        return this._collection$_map.get$keys();
      },
      remove$1: function(_, key) {
        return this._collection$_map.remove$1(0, key);
      },
      toString$0: function(_) {
        return this._collection$_map.toString$0(0);
      },
      get$values: function() {
        return this._collection$_map.get$values();
      },
      map$1: function(_, transform) {
        return this._collection$_map.map$1(0, transform);
      },
      update$3$ifAbsent: function(key, update, ifAbsent) {
        return this._collection$_map.update$3$ifAbsent(key, update, ifAbsent);
      },
      update$2: function(key, update) {
        return this.update$3$ifAbsent(key, update, null);
      },
      $isMap: 1
    },
    UnmodifiableMapView: {
      "^": "_UnmodifiableMapView_MapView__UnmodifiableMapMixin;_collection$_map,$ti"
    },
    ListQueue: {
      "^": "ListIterable;_collection$_table,_collection$_head,_collection$_tail,_modificationCount,$ti",
      ListQueue$1: function(initialCapacity, $E) {
        var t1;
        if (initialCapacity == null || J.$lt$n(initialCapacity, 8))
          initialCapacity = 8;
        else {
          t1 = J.getInterceptor$n(initialCapacity);
          if (t1.$and(initialCapacity, t1.$sub(initialCapacity, 1)) !== 0)
            initialCapacity = P.ListQueue__nextPowerOf2(initialCapacity);
        }
        if (typeof initialCapacity !== "number")
          return H.iae(initialCapacity);
        t1 = new Array(initialCapacity);
        t1.fixed$length = Array;
        this._collection$_table = H.setRuntimeTypeInfo(t1, [$E]);
      },
      get$iterator: function(_) {
        return new P._ListQueueIterator(this, this._collection$_tail, this._modificationCount, this._collection$_head, null, this.$ti);
      },
      forEach$1: function(_, f) {
        var modificationCount, i, t1;
        modificationCount = this._modificationCount;
        for (i = this._collection$_head; i !== this._collection$_tail; i = (i + 1 & this._collection$_table.length - 1) >>> 0) {
          t1 = this._collection$_table;
          if (i < 0 || i >= t1.length)
            return H.ioore(t1, i);
          f.call$1(t1[i]);
          if (modificationCount !== this._modificationCount)
            H.throwExpression(P.ConcurrentModificationError$(this));
        }
      },
      get$isEmpty: function(_) {
        return this._collection$_head === this._collection$_tail;
      },
      get$length: function(_) {
        return J.$and$n(J.$sub$n(this._collection$_tail, this._collection$_head), this._collection$_table.length - 1);
      },
      get$first: function(_) {
        var t1, t2;
        t1 = this._collection$_head;
        if (t1 === this._collection$_tail)
          throw H.wrapException(H.IterableElementError_noElement());
        t2 = this._collection$_table;
        if (t1 >= t2.length)
          return H.ioore(t2, t1);
        return t2[t1];
      },
      get$last: function(_) {
        var t1, t2;
        t1 = this._collection$_head;
        t2 = this._collection$_tail;
        if (t1 === t2)
          throw H.wrapException(H.IterableElementError_noElement());
        t1 = this._collection$_table;
        t2 = J.$and$n(J.$sub$n(t2, 1), this._collection$_table.length - 1);
        if (t2 >= t1.length)
          return H.ioore(t1, t2);
        return t1[t2];
      },
      get$single: function(_) {
        var t1, t2;
        if (this._collection$_head === this._collection$_tail)
          throw H.wrapException(H.IterableElementError_noElement());
        if (this.get$length(this) > 1)
          throw H.wrapException(H.IterableElementError_tooMany());
        t1 = this._collection$_table;
        t2 = this._collection$_head;
        if (t2 >= t1.length)
          return H.ioore(t1, t2);
        return t1[t2];
      },
      elementAt$1: function(_, index) {
        var t1, t2, t3;
        P.RangeError_checkValidIndex(index, this, null, null, null);
        t1 = this._collection$_table;
        t2 = this._collection$_head;
        if (typeof index !== "number")
          return H.iae(index);
        t3 = t1.length;
        t2 = (t2 + index & t3 - 1) >>> 0;
        if (t2 < 0 || t2 >= t3)
          return H.ioore(t1, t2);
        return t1[t2];
      },
      toList$1$growable: function(_, growable) {
        var t1, list, t2;
        t1 = this.$ti;
        if (growable) {
          list = H.setRuntimeTypeInfo([], t1);
          C.JSArray_methods.set$length(list, this.get$length(this));
        } else {
          t2 = new Array(this.get$length(this));
          t2.fixed$length = Array;
          list = H.setRuntimeTypeInfo(t2, t1);
        }
        this._writeToList$1(list);
        return list;
      },
      toList$0: function($receiver) {
        return this.toList$1$growable($receiver, true);
      },
      add$1: function(_, value) {
        this._add$1(value);
      },
      addAll$1: function(_, elements) {
        var t1, t2, addCount, $length, t3, t4, newCapacity, newTable, endSpace, preSpace;
        t1 = this.$ti;
        t2 = H.checkSubtypeV1(elements, "$isList", t1, "$asList");
        if (t2) {
          addCount = elements.get$length(elements);
          $length = this.get$length(this);
          if (typeof addCount !== "number")
            return H.iae(addCount);
          t2 = $length + addCount;
          t3 = this._collection$_table;
          t4 = t3.length;
          if (t2 >= t4) {
            newCapacity = P.ListQueue__nextPowerOf2(t2 + C.JSNumber_methods._shrOtherPositive$1(t2, 1));
            if (typeof newCapacity !== "number")
              return H.iae(newCapacity);
            t3 = new Array(newCapacity);
            t3.fixed$length = Array;
            newTable = H.setRuntimeTypeInfo(t3, t1);
            this._collection$_tail = this._writeToList$1(newTable);
            this._collection$_table = newTable;
            this._collection$_head = 0;
            C.JSArray_methods.setRange$4(newTable, $length, t2, elements, 0);
            this._collection$_tail = J.$add$ansx(this._collection$_tail, addCount);
          } else {
            t1 = this._collection$_tail;
            if (typeof t1 !== "number")
              return H.iae(t1);
            endSpace = t4 - t1;
            if (addCount < endSpace) {
              C.JSArray_methods.setRange$4(t3, t1, t1 + addCount, elements, 0);
              this._collection$_tail = J.$add$ansx(this._collection$_tail, addCount);
            } else {
              preSpace = addCount - endSpace;
              C.JSArray_methods.setRange$4(t3, t1, t1 + endSpace, elements, 0);
              C.JSArray_methods.setRange$4(this._collection$_table, 0, preSpace, elements, endSpace);
              this._collection$_tail = preSpace;
            }
          }
          ++this._modificationCount;
        } else
          for (t1 = elements.get$iterator(elements); t1.moveNext$0();)
            this._add$1(t1.get$current(t1));
      },
      remove$1: function(_, value) {
        var i, t1;
        for (i = this._collection$_head; i !== this._collection$_tail; i = (i + 1 & this._collection$_table.length - 1) >>> 0) {
          t1 = this._collection$_table;
          if (i < 0 || i >= t1.length)
            return H.ioore(t1, i);
          if (J.$eq$(t1[i], value) === true) {
            this._remove$1(i);
            ++this._modificationCount;
            return true;
          }
        }
        return false;
      },
      toString$0: function(_) {
        return P.IterableBase_iterableToFullString(this, "{", "}");
      },
      addFirst$1: function(value) {
        var t1, t2, t3;
        t1 = this._collection$_head;
        t2 = this._collection$_table;
        t3 = t2.length;
        t1 = (t1 - 1 & t3 - 1) >>> 0;
        this._collection$_head = t1;
        if (t1 < 0 || t1 >= t3)
          return H.ioore(t2, t1);
        t2[t1] = value;
        if (t1 === this._collection$_tail)
          this._grow$0();
        ++this._modificationCount;
      },
      removeFirst$0: function() {
        var t1, t2, t3, result;
        t1 = this._collection$_head;
        if (t1 === this._collection$_tail)
          throw H.wrapException(H.IterableElementError_noElement());
        ++this._modificationCount;
        t2 = this._collection$_table;
        t3 = t2.length;
        if (t1 >= t3)
          return H.ioore(t2, t1);
        result = t2[t1];
        t2[t1] = null;
        this._collection$_head = (t1 + 1 & t3 - 1) >>> 0;
        return result;
      },
      removeLast$0: function(_) {
        var t1, t2, result;
        t1 = this._collection$_head;
        t2 = this._collection$_tail;
        if (t1 === t2)
          throw H.wrapException(H.IterableElementError_noElement());
        ++this._modificationCount;
        t1 = J.$and$n(J.$sub$n(t2, 1), this._collection$_table.length - 1);
        this._collection$_tail = t1;
        t2 = this._collection$_table;
        if (t1 >= t2.length)
          return H.ioore(t2, t1);
        result = t2[t1];
        t2[t1] = null;
        return result;
      },
      _add$1: function(element) {
        var t1, t2;
        t1 = this._collection$_table;
        t2 = this._collection$_tail;
        if (t2 >>> 0 !== t2 || t2 >= t1.length)
          return H.ioore(t1, t2);
        t1[t2] = element;
        t2 = (t2 + 1 & this._collection$_table.length - 1) >>> 0;
        this._collection$_tail = t2;
        if (this._collection$_head === t2)
          this._grow$0();
        ++this._modificationCount;
      },
      _remove$1: function(offset) {
        var mask, t1, t2, t3, i, prevOffset, t4, nextOffset;
        mask = this._collection$_table.length - 1;
        if ((offset - this._collection$_head & mask) >>> 0 < J.$and$n(J.$sub$n(this._collection$_tail, offset), mask)) {
          for (t1 = this._collection$_head, t2 = this._collection$_table, t3 = t2.length, i = offset; i !== t1; i = prevOffset) {
            prevOffset = (i - 1 & mask) >>> 0;
            if (prevOffset < 0 || prevOffset >= t3)
              return H.ioore(t2, prevOffset);
            t4 = t2[prevOffset];
            if (i < 0 || i >= t3)
              return H.ioore(t2, i);
            t2[i] = t4;
          }
          if (t1 >= t3)
            return H.ioore(t2, t1);
          t2[t1] = null;
          this._collection$_head = (t1 + 1 & mask) >>> 0;
          return (offset + 1 & mask) >>> 0;
        } else {
          t1 = J.$and$n(J.$sub$n(this._collection$_tail, 1), mask);
          this._collection$_tail = t1;
          for (t2 = this._collection$_table, t3 = t2.length, i = offset; i !== t1; i = nextOffset) {
            nextOffset = (i + 1 & mask) >>> 0;
            if (nextOffset < 0 || nextOffset >= t3)
              return H.ioore(t2, nextOffset);
            t4 = t2[nextOffset];
            if (i < 0 || i >= t3)
              return H.ioore(t2, i);
            t2[i] = t4;
          }
          if (t1 >= t3)
            return H.ioore(t2, t1);
          t2[t1] = null;
          return offset;
        }
      },
      _grow$0: function() {
        var t1, newTable, t2, split;
        t1 = new Array(this._collection$_table.length * 2);
        t1.fixed$length = Array;
        newTable = H.setRuntimeTypeInfo(t1, this.$ti);
        t1 = this._collection$_table;
        t2 = this._collection$_head;
        split = t1.length - t2;
        C.JSArray_methods.setRange$4(newTable, 0, split, t1, t2);
        C.JSArray_methods.setRange$4(newTable, split, split + this._collection$_head, this._collection$_table, 0);
        this._collection$_head = 0;
        this._collection$_tail = this._collection$_table.length;
        this._collection$_table = newTable;
      },
      _writeToList$1: function(target) {
        var t1, t2, t3, $length, firstPartSize;
        t1 = this._collection$_head;
        t2 = this._collection$_tail;
        if (typeof t2 !== "number")
          return H.iae(t2);
        t3 = this._collection$_table;
        if (t1 <= t2) {
          $length = t2 - t1;
          C.JSArray_methods.setRange$4(target, 0, $length, t3, t1);
          return $length;
        } else {
          firstPartSize = t3.length - t1;
          C.JSArray_methods.setRange$4(target, 0, firstPartSize, t3, t1);
          t1 = this._collection$_tail;
          if (typeof t1 !== "number")
            return H.iae(t1);
          C.JSArray_methods.setRange$4(target, firstPartSize, firstPartSize + t1, this._collection$_table, 0);
          return J.$add$ansx(this._collection$_tail, firstPartSize);
        }
      },
      static: {
        ListQueue$: function(initialCapacity, $E) {
          var t1 = new P.ListQueue(null, 0, 0, 0, [$E]);
          t1.ListQueue$1(initialCapacity, $E);
          return t1;
        },
        ListQueue_ListQueue$from: function(elements, $E) {
          var t1, $length, queue, i, t2, t3, result;
          t1 = J.getInterceptor(elements);
          if (!!t1.$isList) {
            $length = t1.get$length(elements);
            queue = P.ListQueue$(J.$add$ansx($length, 1), $E);
            if (typeof $length !== "number")
              return H.iae($length);
            i = 0;
            for (; i < $length; ++i) {
              t2 = queue._collection$_table;
              t3 = t1.$index(elements, i);
              if (i >= t2.length)
                return H.ioore(t2, i);
              t2[i] = t3;
            }
            queue._collection$_tail = $length;
            return queue;
          } else {
            result = P.ListQueue$(!!t1.$isEfficientLengthIterable ? t1.get$length(elements) : 8, $E);
            for (t1 = t1.get$iterator(elements); t1.moveNext$0();)
              result._add$1(t1.get$current(t1));
            return result;
          }
        },
        ListQueue__nextPowerOf2: function(number) {
          var nextNumber;
          number = J.$shl$n(number, 1) - 1;
          for (; true; number = nextNumber) {
            nextNumber = (number & number - 1) >>> 0;
            if (nextNumber === 0)
              return number;
          }
        }
      }
    },
    _ListQueueIterator: {
      "^": "Object;_queue,_collection$_end,_modificationCount,_collection$_position,_collection$_current,$ti",
      get$current: function(_) {
        return this._collection$_current;
      },
      moveNext$0: function() {
        var t1, t2, t3;
        t1 = this._queue;
        if (this._modificationCount !== t1._modificationCount)
          H.throwExpression(P.ConcurrentModificationError$(t1));
        t2 = this._collection$_position;
        if (t2 === this._collection$_end) {
          this._collection$_current = null;
          return false;
        }
        t1 = t1._collection$_table;
        t3 = t1.length;
        if (t2 >= t3)
          return H.ioore(t1, t2);
        this._collection$_current = t1[t2];
        this._collection$_position = (t2 + 1 & t3 - 1) >>> 0;
        return true;
      }
    },
    SetMixin: {
      "^": "Object;$ti",
      get$isEmpty: function(_) {
        return this._collection$_length === 0;
      },
      get$isNotEmpty: function(_) {
        return this._collection$_length !== 0;
      },
      addAll$1: function(_, elements) {
        var t1;
        for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
          this.add$1(0, t1.get$current(t1));
      },
      removeAll$1: function(elements) {
        var t1;
        for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
          this.remove$1(0, t1.get$current(t1));
      },
      toList$1$growable: function(_, growable) {
        var t1, result, t2, i, element, i0;
        t1 = this.$ti;
        if (growable) {
          result = H.setRuntimeTypeInfo([], t1);
          C.JSArray_methods.set$length(result, this._collection$_length);
        } else {
          t2 = new Array(this._collection$_length);
          t2.fixed$length = Array;
          result = H.setRuntimeTypeInfo(t2, t1);
        }
        for (t1 = new P._LinkedHashSetIterator(this, this._collection$_modifications, null, null, [null]), t1._collection$_cell = this._collection$_first, i = 0; t1.moveNext$0(); i = i0) {
          element = t1._collection$_current;
          i0 = i + 1;
          if (i >= result.length)
            return H.ioore(result, i);
          result[i] = element;
        }
        return result;
      },
      toList$0: function($receiver) {
        return this.toList$1$growable($receiver, true);
      },
      map$1: function(_, f) {
        return new H.EfficientLengthMappedIterable(this, f, [H.getTypeArgumentByIndex(this, 0), null]);
      },
      get$single: function(_) {
        var it;
        if (this._collection$_length > 1)
          throw H.wrapException(H.IterableElementError_tooMany());
        it = new P._LinkedHashSetIterator(this, this._collection$_modifications, null, null, [null]);
        it._collection$_cell = this._collection$_first;
        if (!it.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        return it._collection$_current;
      },
      toString$0: function(_) {
        return P.IterableBase_iterableToFullString(this, "{", "}");
      },
      where$1: function(_, f) {
        return new H.WhereIterable(this, f, this.$ti);
      },
      expand$1: function(_, f) {
        return new H.ExpandIterable(this, f, [H.getTypeArgumentByIndex(this, 0), null]);
      },
      forEach$1: function(_, f) {
        var t1;
        for (t1 = new P._LinkedHashSetIterator(this, this._collection$_modifications, null, null, [null]), t1._collection$_cell = this._collection$_first; t1.moveNext$0();)
          f.call$1(t1._collection$_current);
      },
      every$1: function(_, f) {
        var t1;
        for (t1 = new P._LinkedHashSetIterator(this, this._collection$_modifications, null, null, [null]), t1._collection$_cell = this._collection$_first; t1.moveNext$0();)
          if (f.call$1(t1._collection$_current) !== true)
            return false;
        return true;
      },
      join$1: function(_, separator) {
        var iterator, t1;
        iterator = new P._LinkedHashSetIterator(this, this._collection$_modifications, null, null, [null]);
        iterator._collection$_cell = this._collection$_first;
        if (!iterator.moveNext$0())
          return "";
        if (separator === "") {
          t1 = "";
          do
            t1 += H.S(iterator._collection$_current);
          while (iterator.moveNext$0());
        } else {
          t1 = H.S(iterator._collection$_current);
          for (; iterator.moveNext$0();)
            t1 = t1 + separator + H.S(iterator._collection$_current);
        }
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      },
      join$0: function($receiver) {
        return this.join$1($receiver, "");
      },
      any$1: function(_, test) {
        var t1;
        for (t1 = new P._LinkedHashSetIterator(this, this._collection$_modifications, null, null, [null]), t1._collection$_cell = this._collection$_first; t1.moveNext$0();)
          if (test.call$1(t1._collection$_current) === true)
            return true;
        return false;
      },
      take$1: function(_, n) {
        return H.TakeIterable_TakeIterable(this, n, H.getTypeArgumentByIndex(this, 0));
      },
      skip$1: function(_, n) {
        return H.SkipIterable_SkipIterable(this, n, H.getTypeArgumentByIndex(this, 0));
      },
      get$first: function(_) {
        var it = new P._LinkedHashSetIterator(this, this._collection$_modifications, null, null, [null]);
        it._collection$_cell = this._collection$_first;
        if (!it.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        return it._collection$_current;
      },
      get$last: function(_) {
        var it, result;
        it = new P._LinkedHashSetIterator(this, this._collection$_modifications, null, null, [null]);
        it._collection$_cell = this._collection$_first;
        if (!it.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        do
          result = it._collection$_current;
        while (it.moveNext$0());
        return result;
      },
      elementAt$1: function(_, index) {
        var t1, elementIndex, element;
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(P.ArgumentError$notNull("index"));
        if (index < 0)
          H.throwExpression(P.RangeError$range(index, 0, null, "index", null));
        for (t1 = new P._LinkedHashSetIterator(this, this._collection$_modifications, null, null, [null]), t1._collection$_cell = this._collection$_first, elementIndex = 0; t1.moveNext$0();) {
          element = t1._collection$_current;
          if (index === elementIndex)
            return element;
          ++elementIndex;
        }
        throw H.wrapException(P.IndexError$(index, this, "index", null, elementIndex));
      },
      $isEfficientLengthIterable: 1,
      $isIterable: 1,
      $isSet: 1
    },
    SetBase: {
      "^": "SetMixin;$ti"
    },
    _ListBase_Object_ListMixin: {
      "^": "Object+ListMixin;$ti"
    },
    _UnmodifiableMapView_MapView__UnmodifiableMapMixin: {
      "^": "MapView+_UnmodifiableMapMixin;$ti"
    }
  }], ["dart.convert", "dart:convert",, P, {
    "^": "",
    _defaultToEncodable: [function(object) {
      return object.toJson$0();
    }, "call$1", "convert___defaultToEncodable$closure", 4, 0, 0, 28],
    AsciiCodec: {
      "^": "Encoding;_allowInvalid",
      get$name: function() {
        return "us-ascii";
      },
      encode$1: function(source) {
        return C.AsciiEncoder_127.convert$1(source);
      },
      get$encoder: function() {
        return C.AsciiEncoder_127;
      }
    },
    _UnicodeSubsetEncoder: {
      "^": "Converter;",
      convert$3: function(string, start, end) {
        var t1, stringLength, $length, t2, result, t3, i, codeUnit;
        t1 = J.getInterceptor$asx(string);
        stringLength = t1.get$length(string);
        P.RangeError_checkValidRange(start, end, stringLength, null, null, null);
        $length = J.$sub$n(stringLength, start);
        t2 = typeof $length === "number" && Math.floor($length) === $length ? $length : H.throwExpression(P.ArgumentError$("Invalid length " + H.S($length)));
        result = new Uint8Array(t2);
        if (typeof $length !== "number")
          return H.iae($length);
        t2 = result.length;
        t3 = ~this._subsetMask;
        i = 0;
        for (; i < $length; ++i) {
          codeUnit = t1.codeUnitAt$1(string, start + i);
          if ((codeUnit & t3) !== 0)
            throw H.wrapException(P.ArgumentError$("String contains invalid characters."));
          if (i >= t2)
            return H.ioore(result, i);
          result[i] = codeUnit;
        }
        return result;
      },
      convert$1: function(string) {
        return this.convert$3(string, 0, null);
      },
      $asStreamTransformerBase: function() {
        return [P.String, [P.List, P.int]];
      },
      $asConverter: function() {
        return [P.String, [P.List, P.int]];
      }
    },
    AsciiEncoder: {
      "^": "_UnicodeSubsetEncoder;_subsetMask"
    },
    Base64Codec: {
      "^": "Codec;_encoder",
      get$encoder: function() {
        return this._encoder;
      },
      normalize$3: function(source, start, end) {
        var t1, inverseAlphabet, i, sliceStart, buffer, firstPadding, firstPaddingSourceIndex, paddingCount, i0, char, i1, digit1, digit2, char0, value, t2, t3, endLength, $length;
        t1 = J.getInterceptor$asx(source);
        end = P.RangeError_checkValidRange(start, end, t1.get$length(source), null, null, null);
        inverseAlphabet = $.$get$_Base64Decoder__inverseAlphabet();
        if (typeof end !== "number")
          return H.iae(end);
        i = start;
        sliceStart = i;
        buffer = null;
        firstPadding = -1;
        firstPaddingSourceIndex = -1;
        paddingCount = 0;
        for (; i < end; i = i0) {
          i0 = i + 1;
          char = t1.codeUnitAt$1(source, i);
          if (char === 37) {
            i1 = i0 + 2;
            if (i1 <= end) {
              digit1 = H.hexDigitValue(t1.codeUnitAt$1(source, i0));
              digit2 = H.hexDigitValue(t1.codeUnitAt$1(source, i0 + 1));
              char0 = digit1 * 16 + digit2 - (digit2 & 256);
              if (char0 === 37)
                char0 = -1;
              i0 = i1;
            } else
              char0 = -1;
          } else
            char0 = char;
          if (0 <= char0 && char0 <= 127) {
            if (char0 < 0 || char0 >= inverseAlphabet.length)
              return H.ioore(inverseAlphabet, char0);
            value = inverseAlphabet[char0];
            if (value >= 0) {
              char0 = C.JSString_methods.codeUnitAt$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", value);
              if (char0 === char)
                continue;
              char = char0;
            } else {
              if (value === -1) {
                if (firstPadding < 0) {
                  t2 = buffer == null ? null : buffer._contents.length;
                  if (t2 == null)
                    t2 = 0;
                  firstPadding = t2 + (i - sliceStart);
                  firstPaddingSourceIndex = i;
                }
                ++paddingCount;
                if (char === 61)
                  continue;
              }
              char = char0;
            }
            if (value !== -2) {
              if (buffer == null)
                buffer = new P.StringBuffer("");
              buffer._contents += t1.substring$2(source, sliceStart, i);
              buffer._contents += H.Primitives_stringFromCharCode(char);
              sliceStart = i0;
              continue;
            }
          }
          throw H.wrapException(P.FormatException$("Invalid base64 data", source, i));
        }
        if (buffer != null) {
          t2 = buffer._contents += t1.substring$2(source, sliceStart, end);
          t3 = t2.length;
          if (firstPadding >= 0)
            P.Base64Codec__checkPadding(source, firstPaddingSourceIndex, end, firstPadding, paddingCount, t3);
          else {
            endLength = C.JSInt_methods.$mod(t3 - 1, 4) + 1;
            if (endLength === 1)
              throw H.wrapException(P.FormatException$("Invalid base64 encoding length ", source, end));
            for (; endLength < 4;) {
              t2 += "=";
              buffer._contents = t2;
              ++endLength;
            }
          }
          t2 = buffer._contents;
          return t1.replaceRange$3(source, start, end, t2.charCodeAt(0) == 0 ? t2 : t2);
        }
        $length = end - start;
        if (firstPadding >= 0)
          P.Base64Codec__checkPadding(source, firstPaddingSourceIndex, end, firstPadding, paddingCount, $length);
        else {
          endLength = C.JSNumber_methods.$mod($length, 4);
          if (endLength === 1)
            throw H.wrapException(P.FormatException$("Invalid base64 encoding length ", source, end));
          if (endLength > 1)
            source = t1.replaceRange$3(source, end, end, endLength === 2 ? "==" : "=");
        }
        return source;
      },
      $asCodec: function() {
        return [[P.List, P.int], P.String];
      },
      static: {
        Base64Codec__checkPadding: function(source, sourceIndex, sourceEnd, firstPadding, paddingCount, $length) {
          if (J.$mod$n($length, 4) !== 0)
            throw H.wrapException(P.FormatException$("Invalid base64 padding, padded length must be multiple of four, is " + H.S($length), source, sourceEnd));
          if (firstPadding + paddingCount !== $length)
            throw H.wrapException(P.FormatException$("Invalid base64 padding, '=' not at the end", source, sourceIndex));
          if (paddingCount > 2)
            throw H.wrapException(P.FormatException$("Invalid base64 padding, more than two '=' characters", source, sourceIndex));
        }
      }
    },
    Base64Encoder: {
      "^": "Converter;_urlSafe",
      convert$1: function(input) {
        var t1 = J.getInterceptor$asx(input);
        if (t1.get$isEmpty(input) === true)
          return "";
        return P.String_String$fromCharCodes(new P._Base64Encoder(0, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").encode$4(input, 0, t1.get$length(input), true), 0, null);
      },
      startChunkedConversion$1: function(sink) {
        var t1;
        if (!!sink.$isStringConversionSink) {
          t1 = sink.asUtf8Sink$1(false);
          return new P._Utf8Base64EncoderSink(t1, new P._Base64Encoder(0, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"));
        }
        return new P._AsciiBase64EncoderSink(sink, new P._BufferCachingBase64Encoder(null, 0, "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"));
      },
      $asStreamTransformerBase: function() {
        return [[P.List, P.int], P.String];
      },
      $asConverter: function() {
        return [[P.List, P.int], P.String];
      }
    },
    _Base64Encoder: {
      "^": "Object;_state,_alphabet",
      createBuffer$1: function(bufferLength) {
        return new Uint8Array(bufferLength);
      },
      encode$4: function(bytes, start, end, isLast) {
        var $length, t1, byteCount, fullChunks, bufferLength, output;
        $length = J.$sub$n(end, start);
        t1 = this._state;
        if (typeof $length !== "number")
          return H.iae($length);
        byteCount = (t1 & 3) + $length;
        fullChunks = C.JSNumber_methods._tdivFast$1(byteCount, 3);
        bufferLength = fullChunks * 4;
        if (isLast && byteCount - fullChunks * 3 > 0)
          bufferLength += 4;
        output = this.createBuffer$1(bufferLength);
        this._state = P._Base64Encoder_encodeChunk(this._alphabet, bytes, start, end, isLast, output, 0, this._state);
        if (bufferLength > 0)
          return output;
        return;
      },
      static: {
        _Base64Encoder_encodeChunk: function(alphabet, bytes, start, end, isLast, output, outputIndex, state) {
          var bits, expectedChars, t1, t2, i, byteOr, byte, outputIndex0, t3, outputIndex1;
          bits = state >>> 2;
          expectedChars = 3 - (state & 3);
          if (typeof end !== "number")
            return H.iae(end);
          t1 = J.getInterceptor$asx(bytes);
          t2 = output.length;
          i = start;
          byteOr = 0;
          for (; i < end; ++i) {
            byte = t1.$index(bytes, i);
            if (typeof byte !== "number")
              return H.iae(byte);
            byteOr = (byteOr | byte) >>> 0;
            bits = (bits << 8 | byte) & 16777215;
            --expectedChars;
            if (expectedChars === 0) {
              outputIndex0 = outputIndex + 1;
              t3 = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 18 & 63);
              if (outputIndex >= t2)
                return H.ioore(output, outputIndex);
              output[outputIndex] = t3;
              outputIndex = outputIndex0 + 1;
              t3 = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 12 & 63);
              if (outputIndex0 >= t2)
                return H.ioore(output, outputIndex0);
              output[outputIndex0] = t3;
              outputIndex0 = outputIndex + 1;
              t3 = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 6 & 63);
              if (outputIndex >= t2)
                return H.ioore(output, outputIndex);
              output[outputIndex] = t3;
              outputIndex = outputIndex0 + 1;
              t3 = C.JSString_methods._codeUnitAt$1(alphabet, bits & 63);
              if (outputIndex0 >= t2)
                return H.ioore(output, outputIndex0);
              output[outputIndex0] = t3;
              bits = 0;
              expectedChars = 3;
            }
          }
          if (byteOr >= 0 && byteOr <= 255) {
            if (isLast && expectedChars < 3) {
              outputIndex0 = outputIndex + 1;
              outputIndex1 = outputIndex0 + 1;
              if (3 - expectedChars === 1) {
                t1 = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 2 & 63);
                if (outputIndex >= t2)
                  return H.ioore(output, outputIndex);
                output[outputIndex] = t1;
                t1 = C.JSString_methods._codeUnitAt$1(alphabet, bits << 4 & 63);
                if (outputIndex0 >= t2)
                  return H.ioore(output, outputIndex0);
                output[outputIndex0] = t1;
                outputIndex = outputIndex1 + 1;
                if (outputIndex1 >= t2)
                  return H.ioore(output, outputIndex1);
                output[outputIndex1] = 61;
                if (outputIndex >= t2)
                  return H.ioore(output, outputIndex);
                output[outputIndex] = 61;
              } else {
                t1 = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 10 & 63);
                if (outputIndex >= t2)
                  return H.ioore(output, outputIndex);
                output[outputIndex] = t1;
                t1 = C.JSString_methods._codeUnitAt$1(alphabet, bits >>> 4 & 63);
                if (outputIndex0 >= t2)
                  return H.ioore(output, outputIndex0);
                output[outputIndex0] = t1;
                outputIndex = outputIndex1 + 1;
                t1 = C.JSString_methods._codeUnitAt$1(alphabet, bits << 2 & 63);
                if (outputIndex1 >= t2)
                  return H.ioore(output, outputIndex1);
                output[outputIndex1] = t1;
                if (outputIndex >= t2)
                  return H.ioore(output, outputIndex);
                output[outputIndex] = 61;
              }
              return 0;
            }
            return (bits << 2 | 3 - expectedChars) >>> 0;
          }
          for (i = start; i < end;) {
            byte = t1.$index(bytes, i);
            t2 = J.getInterceptor$n(byte);
            if (t2.$lt(byte, 0) || t2.$gt(byte, 255))
              break;
            ++i;
          }
          throw H.wrapException(P.ArgumentError$value(bytes, "Not a byte value at index " + i + ": 0x" + J.toRadixString$1$n(t1.$index(bytes, i), 16), null));
        }
      }
    },
    _BufferCachingBase64Encoder: {
      "^": "_Base64Encoder;bufferCache,_state,_alphabet",
      createBuffer$1: function(bufferLength) {
        var t1 = this.bufferCache;
        if (t1 == null || t1.length < bufferLength) {
          t1 = new Uint8Array(bufferLength);
          this.bufferCache = t1;
        }
        t1 = t1.buffer;
        t1.toString;
        return H.NativeUint8List_NativeUint8List$view(t1, 0, bufferLength);
      }
    },
    _Base64EncoderSink: {
      "^": "ByteConversionSinkBase;",
      add$1: function(_, source) {
        this._convert$_add$4(source, 0, J.get$length$asx(source), false);
      },
      close$0: function(_) {
        this._convert$_add$4(null, 0, 0, true);
      },
      addSlice$4: function(source, start, end, isLast) {
        if (end == null)
          throw H.wrapException(P.ArgumentError$notNull("end"));
        P.RangeError_checkValidRange(start, end, J.get$length$asx(source), null, null, null);
        this._convert$_add$4(source, start, end, isLast);
      }
    },
    _AsciiBase64EncoderSink: {
      "^": "_Base64EncoderSink;_sink,_encoder",
      _convert$_add$4: function(source, start, end, isLast) {
        var buffer = this._encoder.encode$4(source, start, end, isLast);
        if (buffer != null)
          this._sink.add$1(0, P.String_String$fromCharCodes(buffer, 0, null));
        if (isLast)
          this._sink.close$0(0);
      }
    },
    _Utf8Base64EncoderSink: {
      "^": "_Base64EncoderSink;_sink,_encoder",
      _convert$_add$4: function(source, start, end, isLast) {
        var buffer = this._encoder.encode$4(source, start, end, isLast);
        if (buffer != null)
          this._sink.addSlice$4(buffer, 0, buffer.length, isLast);
      }
    },
    ByteConversionSink: {
      "^": "ChunkedConversionSink;",
      $asChunkedConversionSink: function() {
        return [[P.List, P.int]];
      }
    },
    ByteConversionSinkBase: {
      "^": "ByteConversionSink;"
    },
    ChunkedConversionSink: {
      "^": "Object;$ti"
    },
    Codec: {
      "^": "Object;$ti",
      encode$1: function(input) {
        return this.get$encoder().convert$1(input);
      }
    },
    Converter: {
      "^": "StreamTransformerBase;$ti"
    },
    Encoding: {
      "^": "Codec;",
      $asCodec: function() {
        return [P.String, [P.List, P.int]];
      }
    },
    JsonUnsupportedObjectError: {
      "^": "Error;unsupportedObject,cause,partialResult",
      toString$0: function(_) {
        var safeString = P.Error_safeToString(this.unsupportedObject);
        return (this.cause != null ? "Converting object to an encodable object failed:" : "Converting object did not return an encodable object:") + " " + H.S(safeString);
      },
      static: {
        JsonUnsupportedObjectError$: function(unsupportedObject, cause, partialResult) {
          return new P.JsonUnsupportedObjectError(unsupportedObject, cause, partialResult);
        }
      }
    },
    JsonCyclicError: {
      "^": "JsonUnsupportedObjectError;unsupportedObject,cause,partialResult",
      toString$0: function(_) {
        return "Cyclic error in JSON stringify";
      }
    },
    JsonCodec: {
      "^": "Codec;_reviver,_toEncodable",
      encode$2$toEncodable: function(value, toEncodable) {
        var t1 = this.get$encoder();
        t1 = P._JsonStringStringifier_stringify(value, t1._toEncodable, t1.indent);
        return t1;
      },
      encode$1: function(value) {
        return this.encode$2$toEncodable(value, null);
      },
      get$encoder: function() {
        return C.JsonEncoder_null_null;
      },
      $asCodec: function() {
        return [P.Object, P.String];
      }
    },
    JsonEncoder: {
      "^": "Converter;indent,_toEncodable",
      convert$1: function(object) {
        return P._JsonStringStringifier_stringify(object, this._toEncodable, this.indent);
      },
      $asStreamTransformerBase: function() {
        return [P.Object, P.String];
      },
      $asConverter: function() {
        return [P.Object, P.String];
      }
    },
    _JsonStringifier: {
      "^": "Object;",
      writeStringContent$1: function(s) {
        var t1, $length, offset, i, charCode, t2;
        t1 = J.getInterceptor$asx(s);
        $length = t1.get$length(s);
        if (typeof $length !== "number")
          return H.iae($length);
        offset = 0;
        i = 0;
        for (; i < $length; ++i) {
          charCode = t1.codeUnitAt$1(s, i);
          if (charCode > 92)
            continue;
          if (charCode < 32) {
            if (i > offset)
              this.writeStringSlice$3(s, offset, i);
            offset = i + 1;
            this.writeCharCode$1(92);
            switch (charCode) {
              case 8:
                this.writeCharCode$1(98);
                break;
              case 9:
                this.writeCharCode$1(116);
                break;
              case 10:
                this.writeCharCode$1(110);
                break;
              case 12:
                this.writeCharCode$1(102);
                break;
              case 13:
                this.writeCharCode$1(114);
                break;
              default:
                this.writeCharCode$1(117);
                this.writeCharCode$1(48);
                this.writeCharCode$1(48);
                t2 = charCode >>> 4 & 15;
                this.writeCharCode$1(t2 < 10 ? 48 + t2 : 87 + t2);
                t2 = charCode & 15;
                this.writeCharCode$1(t2 < 10 ? 48 + t2 : 87 + t2);
                break;
            }
          } else if (charCode === 34 || charCode === 92) {
            if (i > offset)
              this.writeStringSlice$3(s, offset, i);
            offset = i + 1;
            this.writeCharCode$1(92);
            this.writeCharCode$1(charCode);
          }
        }
        if (offset === 0)
          this.writeString$1(s);
        else if (offset < $length)
          this.writeStringSlice$3(s, offset, $length);
      },
      _checkCycle$1: function(object) {
        var t1, t2, i, t3;
        for (t1 = this._seen, t2 = t1.length, i = 0; i < t2; ++i) {
          t3 = t1[i];
          if (object == null ? t3 == null : object === t3)
            throw H.wrapException(new P.JsonCyclicError(object, null, null));
        }
        t1.push(object);
      },
      writeObject$1: function(object) {
        var customJson, e, t1, exception;
        if (this.writeJsonValue$1(object))
          return;
        this._checkCycle$1(object);
        try {
          customJson = this._toEncodable.call$1(object);
          if (!this.writeJsonValue$1(customJson)) {
            t1 = P.JsonUnsupportedObjectError$(object, null, this.get$_partialResult());
            throw H.wrapException(t1);
          }
          t1 = this._seen;
          if (0 >= t1.length)
            return H.ioore(t1, -1);
          t1.pop();
        } catch (exception) {
          e = H.unwrapException(exception);
          t1 = P.JsonUnsupportedObjectError$(object, e, this.get$_partialResult());
          throw H.wrapException(t1);
        }
      },
      writeJsonValue$1: function(object) {
        var t1, success;
        if (typeof object === "number") {
          if (!isFinite(object))
            return false;
          this.writeNumber$1(object);
          return true;
        } else if (object === true) {
          this.writeString$1("true");
          return true;
        } else if (object === false) {
          this.writeString$1("false");
          return true;
        } else if (object == null) {
          this.writeString$1("null");
          return true;
        } else if (typeof object === "string") {
          this.writeString$1('"');
          this.writeStringContent$1(object);
          this.writeString$1('"');
          return true;
        } else {
          t1 = J.getInterceptor(object);
          if (!!t1.$isList) {
            this._checkCycle$1(object);
            this.writeList$1(object);
            t1 = this._seen;
            if (0 >= t1.length)
              return H.ioore(t1, -1);
            t1.pop();
            return true;
          } else if (!!t1.$isMap) {
            this._checkCycle$1(object);
            success = this.writeMap$1(object);
            t1 = this._seen;
            if (0 >= t1.length)
              return H.ioore(t1, -1);
            t1.pop();
            return success;
          } else
            return false;
        }
      },
      writeList$1: function(list) {
        var t1, i, t2;
        this.writeString$1("[");
        t1 = J.getInterceptor$asx(list);
        if (J.$gt$n(t1.get$length(list), 0)) {
          this.writeObject$1(t1.$index(list, 0));
          i = 1;
          while (true) {
            t2 = t1.get$length(list);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            this.writeString$1(",");
            this.writeObject$1(t1.$index(list, i));
            ++i;
          }
        }
        this.writeString$1("]");
      },
      writeMap$1: function(map) {
        var _box_0, t1, keyValueList, separator, i, t2;
        _box_0 = {};
        if (map.get$isEmpty(map) === true) {
          this.writeString$1("{}");
          return true;
        }
        t1 = J.$mul$ns(map.get$length(map), 2);
        if (typeof t1 !== "number")
          return H.iae(t1);
        keyValueList = new Array(t1);
        keyValueList.fixed$length = Array;
        _box_0.i = 0;
        _box_0.allStringKeys = true;
        map.forEach$1(0, new P._JsonStringifier_writeMap_closure(_box_0, keyValueList));
        if (!_box_0.allStringKeys)
          return false;
        this.writeString$1("{");
        for (t1 = keyValueList.length, separator = '"', i = 0; i < t1; i += 2, separator = ',"') {
          this.writeString$1(separator);
          this.writeStringContent$1(keyValueList[i]);
          this.writeString$1('":');
          t2 = i + 1;
          if (t2 >= t1)
            return H.ioore(keyValueList, t2);
          this.writeObject$1(keyValueList[t2]);
        }
        this.writeString$1("}");
        return true;
      }
    },
    _JsonStringifier_writeMap_closure: {
      "^": "Closure:2;_box_0,keyValueList",
      call$2: function(key, value) {
        var t1, t2, t3, i, t4;
        if (typeof key !== "string")
          this._box_0.allStringKeys = false;
        t1 = this.keyValueList;
        t2 = this._box_0;
        t3 = t2.i;
        i = t3 + 1;
        t2.i = i;
        t4 = t1.length;
        if (t3 >= t4)
          return H.ioore(t1, t3);
        t1[t3] = key;
        t2.i = i + 1;
        if (i >= t4)
          return H.ioore(t1, i);
        t1[i] = value;
      }
    },
    _JsonStringStringifier: {
      "^": "_JsonStringifier;_sink,_seen,_toEncodable",
      get$_partialResult: function() {
        var t1 = this._sink;
        return !!t1.$isStringBuffer ? t1.toString$0(0) : null;
      },
      writeNumber$1: function(number) {
        this._sink.write$1(0, C.JSNumber_methods.toString$0(number));
      },
      writeString$1: function(string) {
        this._sink.write$1(0, string);
      },
      writeStringSlice$3: function(string, start, end) {
        this._sink.write$1(0, J.substring$2$s(string, start, end));
      },
      writeCharCode$1: function(charCode) {
        this._sink.writeCharCode$1(charCode);
      },
      static: {
        _JsonStringStringifier_stringify: function(object, toEncodable, indent) {
          var output, t1;
          output = new P.StringBuffer("");
          P._JsonStringStringifier_printOn(object, output, toEncodable, indent);
          t1 = output._contents;
          return t1.charCodeAt(0) == 0 ? t1 : t1;
        },
        _JsonStringStringifier_printOn: function(object, output, toEncodable, indent) {
          var stringifier = new P._JsonStringStringifier(output, [], P.convert___defaultToEncodable$closure());
          stringifier.writeObject$1(object);
        }
      }
    },
    StringConversionSinkBase: {
      "^": "StringConversionSinkMixin;"
    },
    StringConversionSinkMixin: {
      "^": "Object;",
      add$1: function(_, str) {
        this.addSlice$4(str, 0, J.get$length$asx(str), false);
      },
      asUtf8Sink$1: function(allowMalformed) {
        var t1 = new P.StringBuffer("");
        return new P._Utf8ConversionSink(new P._Utf8Decoder(false, t1, true, 0, 0, 0), this, t1);
      },
      $isStringConversionSink: 1
    },
    _StringSinkConversionSink: {
      "^": "StringConversionSinkBase;_stringSink",
      close$0: function(_) {
      },
      addSlice$4: function(str, start, end, isLast) {
        var t1, t2, i;
        if (start !== 0 || J.$eq$(end, J.get$length$asx(str)) !== true) {
          if (typeof end !== "number")
            return H.iae(end);
          t1 = this._stringSink;
          t2 = J.getInterceptor$s(str);
          i = start;
          for (; i < end; ++i)
            t1._contents += H.Primitives_stringFromCharCode(t2.codeUnitAt$1(str, i));
        } else
          this._stringSink._contents += H.S(str);
        if (isLast)
          this.close$0(0);
      },
      add$1: function(_, str) {
        this._stringSink._contents += H.S(str);
      },
      asUtf8Sink$1: function(allowMalformed) {
        return new P._Utf8StringSinkAdapter(new P._Utf8Decoder(false, this._stringSink, true, 0, 0, 0), this);
      }
    },
    _StringCallbackSink: {
      "^": "_StringSinkConversionSink;_callback,_stringSink",
      close$0: function(_) {
        var buffer, t1;
        buffer = this._stringSink;
        t1 = buffer._contents;
        buffer._contents = "";
        this._callback.call$1(t1.charCodeAt(0) == 0 ? t1 : t1);
      },
      asUtf8Sink$1: function(allowMalformed) {
        return new P._Utf8StringSinkAdapter(new P._Utf8Decoder(false, this._stringSink, true, 0, 0, 0), this);
      }
    },
    _StringAdapterSink: {
      "^": "StringConversionSinkBase;_sink",
      add$1: function(_, str) {
        this._sink.add$1(0, str);
      },
      addSlice$4: function(str, start, end, isLast) {
        var t1, t2;
        t1 = start === 0 && J.$eq$(end, J.get$length$asx(str)) === true;
        t2 = this._sink;
        if (t1)
          t2.add$1(0, str);
        else
          t2.add$1(0, J.substring$2$s(str, start, end));
        if (isLast)
          t2.close$0(0);
      },
      close$0: function(_) {
        this._sink.close$0(0);
      }
    },
    _Utf8StringSinkAdapter: {
      "^": "ByteConversionSink;_decoder,_sink",
      close$0: function(_) {
        this._decoder.flush$0();
        this._sink.close$0(0);
      },
      add$1: function(_, chunk) {
        this._decoder.convert$3(chunk, 0, J.get$length$asx(chunk));
      },
      addSlice$4: function(codeUnits, startIndex, endIndex, isLast) {
        this._decoder.convert$3(codeUnits, startIndex, endIndex);
        if (isLast)
          this.close$0(0);
      }
    },
    _Utf8ConversionSink: {
      "^": "ByteConversionSink;_decoder,_chunkedSink,_convert$_buffer",
      close$0: function(_) {
        var t1, t2, t3, accumulated;
        this._decoder.flush$0();
        t1 = this._convert$_buffer;
        t2 = t1._contents;
        t3 = this._chunkedSink;
        if (t2.length !== 0) {
          accumulated = t2.charCodeAt(0) == 0 ? t2 : t2;
          t1._contents = "";
          t3.addSlice$4(accumulated, 0, accumulated.length, true);
        } else
          t3.close$0(0);
      },
      add$1: function(_, chunk) {
        this.addSlice$4(chunk, 0, J.get$length$asx(chunk), false);
      },
      addSlice$4: function(chunk, startIndex, endIndex, isLast) {
        var t1, t2, accumulated;
        this._decoder.convert$3(chunk, startIndex, endIndex);
        t1 = this._convert$_buffer;
        t2 = t1._contents;
        if (t2.length !== 0) {
          accumulated = t2.charCodeAt(0) == 0 ? t2 : t2;
          this._chunkedSink.addSlice$4(accumulated, 0, accumulated.length, isLast);
          t1._contents = "";
          return;
        }
        if (isLast)
          this.close$0(0);
      }
    },
    Utf8Codec: {
      "^": "Encoding;_allowMalformed",
      get$name: function() {
        return "utf-8";
      },
      get$encoder: function() {
        return C.C_Utf8Encoder;
      }
    },
    Utf8Encoder: {
      "^": "Converter;",
      convert$3: function(string, start, end) {
        var t1, stringLength, t2, $length, t3, encoder;
        t1 = J.getInterceptor$asx(string);
        stringLength = t1.get$length(string);
        P.RangeError_checkValidRange(start, end, stringLength, null, null, null);
        t2 = J.getInterceptor$n(stringLength);
        $length = t2.$sub(stringLength, start);
        t3 = J.getInterceptor($length);
        if (t3.$eq($length, 0))
          return new Uint8Array(0);
        t3 = t3.$mul($length, 3);
        t3 = typeof t3 === "number" && Math.floor(t3) === t3 ? t3 : H.throwExpression(P.ArgumentError$("Invalid length " + H.S(t3)));
        t3 = new Uint8Array(t3);
        encoder = new P._Utf8Encoder(0, 0, t3);
        if (encoder._fillBuffer$3(string, start, stringLength) !== stringLength)
          encoder._writeSurrogate$2(t1.codeUnitAt$1(string, t2.$sub(stringLength, 1)), 0);
        return C.NativeUint8List_methods.sublist$2(t3, 0, encoder._bufferIndex);
      },
      convert$1: function(string) {
        return this.convert$3(string, 0, null);
      },
      $asStreamTransformerBase: function() {
        return [P.String, [P.List, P.int]];
      },
      $asConverter: function() {
        return [P.String, [P.List, P.int]];
      }
    },
    _Utf8Encoder: {
      "^": "Object;_carry,_bufferIndex,_convert$_buffer",
      _writeSurrogate$2: function(leadingSurrogate, nextCodeUnit) {
        var t1, t2, t3, t4, rune;
        t1 = this._convert$_buffer;
        t2 = this._bufferIndex;
        t3 = t2 + 1;
        t4 = t1.length;
        if ((nextCodeUnit & 64512) === 56320) {
          rune = 65536 + ((leadingSurrogate & 1023) << 10) | nextCodeUnit & 1023;
          this._bufferIndex = t3;
          if (t2 >= t4)
            return H.ioore(t1, t2);
          t1[t2] = 240 | rune >>> 18;
          t2 = t3 + 1;
          this._bufferIndex = t2;
          if (t3 >= t4)
            return H.ioore(t1, t3);
          t1[t3] = 128 | rune >>> 12 & 63;
          t3 = t2 + 1;
          this._bufferIndex = t3;
          if (t2 >= t4)
            return H.ioore(t1, t2);
          t1[t2] = 128 | rune >>> 6 & 63;
          this._bufferIndex = t3 + 1;
          if (t3 >= t4)
            return H.ioore(t1, t3);
          t1[t3] = 128 | rune & 63;
          return true;
        } else {
          this._bufferIndex = t3;
          if (t2 >= t4)
            return H.ioore(t1, t2);
          t1[t2] = 224 | leadingSurrogate >>> 12;
          t2 = t3 + 1;
          this._bufferIndex = t2;
          if (t3 >= t4)
            return H.ioore(t1, t3);
          t1[t3] = 128 | leadingSurrogate >>> 6 & 63;
          this._bufferIndex = t2 + 1;
          if (t2 >= t4)
            return H.ioore(t1, t2);
          t1[t2] = 128 | leadingSurrogate & 63;
          return false;
        }
      },
      _fillBuffer$3: function(str, start, end) {
        var t1, t2, t3, stringIndex, codeUnit, t4, stringIndex0, t5;
        if (start !== end && (J.codeUnitAt$1$s(str, J.$sub$n(end, 1)) & 64512) === 55296)
          end = J.$sub$n(end, 1);
        if (typeof end !== "number")
          return H.iae(end);
        t1 = this._convert$_buffer;
        t2 = t1.length;
        t3 = J.getInterceptor$s(str);
        stringIndex = start;
        for (; stringIndex < end; ++stringIndex) {
          codeUnit = t3.codeUnitAt$1(str, stringIndex);
          if (codeUnit <= 127) {
            t4 = this._bufferIndex;
            if (t4 >= t2)
              break;
            this._bufferIndex = t4 + 1;
            t1[t4] = codeUnit;
          } else if ((codeUnit & 64512) === 55296) {
            if (this._bufferIndex + 3 >= t2)
              break;
            stringIndex0 = stringIndex + 1;
            if (this._writeSurrogate$2(codeUnit, t3.codeUnitAt$1(str, stringIndex0)))
              stringIndex = stringIndex0;
          } else if (codeUnit <= 2047) {
            t4 = this._bufferIndex;
            t5 = t4 + 1;
            if (t5 >= t2)
              break;
            this._bufferIndex = t5;
            if (t4 >= t2)
              return H.ioore(t1, t4);
            t1[t4] = 192 | codeUnit >>> 6;
            this._bufferIndex = t5 + 1;
            t1[t5] = 128 | codeUnit & 63;
          } else {
            t4 = this._bufferIndex;
            if (t4 + 2 >= t2)
              break;
            t5 = t4 + 1;
            this._bufferIndex = t5;
            if (t4 >= t2)
              return H.ioore(t1, t4);
            t1[t4] = 224 | codeUnit >>> 12;
            t4 = t5 + 1;
            this._bufferIndex = t4;
            if (t5 >= t2)
              return H.ioore(t1, t5);
            t1[t5] = 128 | codeUnit >>> 6 & 63;
            this._bufferIndex = t4 + 1;
            if (t4 >= t2)
              return H.ioore(t1, t4);
            t1[t4] = 128 | codeUnit & 63;
          }
        }
        return stringIndex;
      }
    },
    Utf8Decoder: {
      "^": "Converter;_allowMalformed",
      convert$3: function(codeUnits, start, end) {
        var result, $length, buffer, decoder, t1;
        result = P.Utf8Decoder__convertIntercepted(false, codeUnits, start, end);
        if (result != null)
          return result;
        $length = J.get$length$asx(codeUnits);
        P.RangeError_checkValidRange(start, end, $length, null, null, null);
        buffer = new P.StringBuffer("");
        decoder = new P._Utf8Decoder(false, buffer, true, 0, 0, 0);
        decoder.convert$3(codeUnits, start, $length);
        decoder.flush$2(codeUnits, $length);
        t1 = buffer._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      },
      convert$1: function(codeUnits) {
        return this.convert$3(codeUnits, 0, null);
      },
      startChunkedConversion$1: function(sink) {
        return (!!sink.$isStringConversionSink ? sink : new P._StringAdapterSink(sink)).asUtf8Sink$1(false);
      },
      $asStreamTransformerBase: function() {
        return [[P.List, P.int], P.String];
      },
      $asConverter: function() {
        return [[P.List, P.int], P.String];
      },
      static: {
        Utf8Decoder__convertIntercepted: function(allowMalformed, codeUnits, start, end) {
          if (codeUnits instanceof Uint8Array)
            return P.Utf8Decoder__convertInterceptedUint8List(false, codeUnits, start, end);
          return;
        },
        Utf8Decoder__convertInterceptedUint8List: function(allowMalformed, codeUnits, start, end) {
          var decoder, t1, $length;
          decoder = $.$get$Utf8Decoder__decoder();
          if (decoder == null)
            return;
          t1 = 0 === start;
          if (t1 && true)
            return P.Utf8Decoder__useTextDecoderChecked(decoder, codeUnits);
          $length = codeUnits.length;
          end = P.RangeError_checkValidRange(start, end, $length, null, null, null);
          if (t1 && J.$eq$(end, $length) === true)
            return P.Utf8Decoder__useTextDecoderChecked(decoder, codeUnits);
          return P.Utf8Decoder__useTextDecoderChecked(decoder, codeUnits.subarray(start, end));
        },
        Utf8Decoder__useTextDecoderChecked: function(decoder, codeUnits) {
          if (P.Utf8Decoder__unsafe(codeUnits))
            return;
          return P.Utf8Decoder__useTextDecoderUnchecked(decoder, codeUnits);
        },
        Utf8Decoder__useTextDecoderUnchecked: function(decoder, codeUnits) {
          var t1, exception;
          try {
            t1 = decoder.decode(codeUnits);
            return t1;
          } catch (exception) {
            H.unwrapException(exception);
          }
          return;
        },
        Utf8Decoder__unsafe: function(codeUnits) {
          var limit, i;
          limit = codeUnits.length - 2;
          for (i = 0; i < limit; ++i)
            if (codeUnits[i] === 237)
              if ((codeUnits[i + 1] & 224) === 160)
                return true;
          return false;
        },
        Utf8Decoder__makeDecoder: function() {
          var t1, exception;
          try {
            t1 = new TextDecoder("utf-8", {fatal: true});
            return t1;
          } catch (exception) {
            H.unwrapException(exception);
          }
          return;
        }
      }
    },
    _Utf8Decoder: {
      "^": "Object;_allowMalformed,_stringSink,_isFirstCharacter,_value,_expectedUnits,_extraUnits",
      close$0: function(_) {
        this.flush$0();
      },
      flush$2: function(source, offset) {
        var t1;
        if (this._expectedUnits > 0) {
          t1 = P.FormatException$("Unfinished UTF-8 octet sequence", source, offset);
          throw H.wrapException(t1);
        }
      },
      flush$0: function() {
        return this.flush$2(null, null);
      },
      convert$3: function(codeUnits, startIndex, endIndex) {
        var value, expectedUnits, extraUnits, scanOneByteCharacters, addSingleBytes, t1, t2, i, unit, t3, oneBytes, i0, i1, t4;
        value = this._value;
        expectedUnits = this._expectedUnits;
        extraUnits = this._extraUnits;
        this._value = 0;
        this._expectedUnits = 0;
        this._extraUnits = 0;
        scanOneByteCharacters = new P._Utf8Decoder_convert_scanOneByteCharacters(endIndex);
        addSingleBytes = new P._Utf8Decoder_convert_addSingleBytes(this, startIndex, endIndex, codeUnits);
        $label0$0:
          for (t1 = J.getInterceptor$asx(codeUnits), t2 = this._stringSink, i = startIndex; true; i = i1) {
            $label1$1:
              if (expectedUnits > 0) {
                do {
                  if (i === endIndex)
                    break $label0$0;
                  unit = t1.$index(codeUnits, i);
                  t3 = J.getInterceptor$n(unit);
                  if (t3.$and(unit, 192) !== 128) {
                    t3 = P.FormatException$("Bad UTF-8 encoding 0x" + t3.toRadixString$1(unit, 16), codeUnits, i);
                    throw H.wrapException(t3);
                  } else {
                    value = (value << 6 | t3.$and(unit, 63)) >>> 0;
                    --expectedUnits;
                    ++i;
                  }
                } while (expectedUnits > 0);
                t3 = extraUnits - 1;
                if (t3 < 0 || t3 >= 4)
                  return H.ioore(C.List_127_2047_65535_1114111, t3);
                if (value <= C.List_127_2047_65535_1114111[t3]) {
                  t3 = P.FormatException$("Overlong encoding of 0x" + C.JSInt_methods.toRadixString$1(value, 16), codeUnits, i - extraUnits - 1);
                  throw H.wrapException(t3);
                }
                if (value > 1114111) {
                  t3 = P.FormatException$("Character outside valid Unicode range: 0x" + C.JSInt_methods.toRadixString$1(value, 16), codeUnits, i - extraUnits - 1);
                  throw H.wrapException(t3);
                }
                if (!this._isFirstCharacter || value !== 65279)
                  t2._contents += H.Primitives_stringFromCharCode(value);
                this._isFirstCharacter = false;
              }
            if (typeof endIndex !== "number")
              return H.iae(endIndex);
            t3 = i < endIndex;
            for (; t3;) {
              oneBytes = scanOneByteCharacters.call$2(codeUnits, i);
              if (J.$gt$n(oneBytes, 0)) {
                this._isFirstCharacter = false;
                if (typeof oneBytes !== "number")
                  return H.iae(oneBytes);
                i0 = i + oneBytes;
                addSingleBytes.call$2(i, i0);
                if (i0 === endIndex)
                  break;
              } else
                i0 = i;
              i1 = i0 + 1;
              unit = t1.$index(codeUnits, i0);
              t4 = J.getInterceptor$in(unit);
              if (t4.$lt(unit, 0)) {
                t4 = P.FormatException$("Negative UTF-8 code unit: -0x" + J.toRadixString$1$n(t4.$negate(unit), 16), codeUnits, i1 - 1);
                throw H.wrapException(t4);
              } else {
                if (t4.$and(unit, 224) === 192) {
                  value = t4.$and(unit, 31);
                  expectedUnits = 1;
                  extraUnits = 1;
                  continue $label0$0;
                }
                if (t4.$and(unit, 240) === 224) {
                  value = t4.$and(unit, 15);
                  expectedUnits = 2;
                  extraUnits = 2;
                  continue $label0$0;
                }
                if (t4.$and(unit, 248) === 240 && t4.$lt(unit, 245)) {
                  value = t4.$and(unit, 7);
                  expectedUnits = 3;
                  extraUnits = 3;
                  continue $label0$0;
                }
                t4 = P.FormatException$("Bad UTF-8 encoding 0x" + t4.toRadixString$1(unit, 16), codeUnits, i1 - 1);
                throw H.wrapException(t4);
              }
            }
            break $label0$0;
          }
        if (expectedUnits > 0) {
          this._value = value;
          this._expectedUnits = expectedUnits;
          this._extraUnits = extraUnits;
        }
      }
    },
    _Utf8Decoder_convert_scanOneByteCharacters: {
      "^": "Closure:86;endIndex",
      call$2: function(units, from) {
        var to, t1, i, unit;
        to = this.endIndex;
        if (typeof to !== "number")
          return H.iae(to);
        t1 = J.getInterceptor$asx(units);
        i = from;
        for (; i < to; ++i) {
          unit = t1.$index(units, i);
          if (J.$and$n(unit, 127) !== unit)
            return i - from;
        }
        return to - from;
      }
    },
    _Utf8Decoder_convert_addSingleBytes: {
      "^": "Closure:79;$this,startIndex,endIndex,codeUnits",
      call$2: function(from, to) {
        this.$this._stringSink._contents += P.String_String$fromCharCodes(this.codeUnits, from, to);
      }
    }
  }], ["dart.core", "dart:core",, P, {
    "^": "",
    identityHashCode: [function(object) {
      return H.objectHashCode(object);
    }, "call$1", "core__identityHashCode$closure", 4, 0, 89, 28],
    Function_apply: function($function, positionalArguments, namedArguments) {
      var t1 = H.Primitives_applyFunctionWithPositionalArguments($function, positionalArguments);
      return t1;
    },
    int_parse: function(source, onError, radix) {
      var value = H.Primitives_parseInt(source, radix);
      if (value != null)
        return value;
      if (onError != null)
        return onError.call$1(source);
      throw H.wrapException(P.FormatException$(source, null, null));
    },
    Error__objectToString: function(object) {
      var t1 = J.getInterceptor(object);
      if (!!t1.$isClosure)
        return t1.toString$0(object);
      return "Instance of '" + H.Primitives_objectTypeName(object) + "'";
    },
    List_List$filled: function($length, fill, growable, $E) {
      var result, t1, i;
      result = J.JSArray_JSArray$fixed($length, $E);
      if ($length !== 0 && fill != null)
        for (t1 = result.length, i = 0; i < t1; ++i)
          result[i] = fill;
      return result;
    },
    List_List$from: function(elements, growable, $E) {
      var list, t1;
      list = H.setRuntimeTypeInfo([], [$E]);
      for (t1 = J.get$iterator$ax(elements); t1.moveNext$0();)
        list.push(t1.get$current(t1));
      if (growable)
        return list;
      return J.JSArray_markFixedList(list);
    },
    List_List$unmodifiable: function(elements, $E) {
      return J.JSArray_markUnmodifiableList(P.List_List$from(elements, false, $E));
    },
    String_String$fromCharCodes: function(charCodes, start, end) {
      var len;
      if (typeof charCodes === "object" && charCodes !== null && charCodes.constructor === Array) {
        len = charCodes.length;
        end = P.RangeError_checkValidRange(start, end, len, null, null, null);
        return H.Primitives_stringFromCharCodes(start > 0 || J.$lt$n(end, len) ? C.JSArray_methods.sublist$2(charCodes, start, end) : charCodes);
      }
      if (!!J.getInterceptor(charCodes).$isNativeUint8List)
        return H.Primitives_stringFromNativeUint8List(charCodes, start, P.RangeError_checkValidRange(start, end, charCodes.length, null, null, null));
      return P.String__stringFromIterable(charCodes, start, end);
    },
    String_String$fromCharCode: function(charCode) {
      return H.Primitives_stringFromCharCode(charCode);
    },
    String__stringFromIterable: function(charCodes, start, end) {
      var t1, it, i, list;
      if (start < 0)
        throw H.wrapException(P.RangeError$range(start, 0, J.get$length$asx(charCodes), null, null));
      t1 = end == null;
      if (!t1 && J.$lt$n(end, start))
        throw H.wrapException(P.RangeError$range(end, start, J.get$length$asx(charCodes), null, null));
      it = J.get$iterator$ax(charCodes);
      for (i = 0; i < start; ++i)
        if (!it.moveNext$0())
          throw H.wrapException(P.RangeError$range(start, 0, i, null, null));
      list = [];
      if (t1)
        for (; it.moveNext$0();)
          list.push(it.get$current(it));
      else {
        if (typeof end !== "number")
          return H.iae(end);
        i = start;
        for (; i < end; ++i) {
          if (!it.moveNext$0())
            throw H.wrapException(P.RangeError$range(end, start, i, null, null));
          list.push(it.get$current(it));
        }
      }
      return H.Primitives_stringFromCharCodes(list);
    },
    RegExp_RegExp: function(source, caseSensitive, multiLine) {
      return new H.JSSyntaxRegExp(source, H.JSSyntaxRegExp_makeNative(source, multiLine, true, false), null, null);
    },
    identical: [function(a, b) {
      return a == null ? b == null : a === b;
    }, "call$2", "core__identical$closure", 8, 0, 90, 21, 29],
    Uri_base: function() {
      var uri = H.Primitives_currentUri();
      if (uri != null)
        return P.Uri_parse(uri, 0, null);
      throw H.wrapException(P.UnsupportedError$("'Uri.base' is not supported"));
    },
    StackTrace_current: function() {
      var stackTrace, exception;
      if ($.$get$_hasErrorStackProperty() === true)
        return H.getTraceFromException(new Error());
      try {
        throw H.wrapException("");
      } catch (exception) {
        H.unwrapException(exception);
        stackTrace = H.getTraceFromException(exception);
        return stackTrace;
      }
    },
    Error_safeToString: function(object) {
      if (typeof object === "number" || typeof object === "boolean" || null == object)
        return J.toString$0$(object);
      if (typeof object === "string")
        return JSON.stringify(object);
      return P.Error__objectToString(object);
    },
    Iterable_Iterable$generate: function(count, generator, $E) {
      if (J.$le$n(count, 0))
        return new H.EmptyIterable([$E]);
      return new P._GeneratorIterable(count, generator, [$E]);
    },
    List_List$generate: function($length, generator, growable, $E) {
      var result, t1, i;
      if (growable) {
        result = H.setRuntimeTypeInfo([], [$E]);
        C.JSArray_methods.set$length(result, $length);
      } else {
        t1 = new Array($length);
        t1.fixed$length = Array;
        result = H.setRuntimeTypeInfo(t1, [$E]);
      }
      for (i = 0; i < $length; ++i) {
        t1 = generator.call$1(i);
        if (i >= result.length)
          return H.ioore(result, i);
        result[i] = t1;
      }
      return result;
    },
    print: function(object) {
      H.printString(H.S(object));
    },
    _combineSurrogatePair: function(start, end) {
      return 65536 + ((start & 1023) << 10) + (end & 1023);
    },
    Uri_Uri$dataFromString: function($content, base64, encoding, mimeType, parameters) {
      var buffer, indices, encodingName, t1;
      buffer = new P.StringBuffer("");
      indices = [-1];
      if (encoding == null)
        encodingName = null;
      else
        encodingName = "utf-8";
      if (encoding == null)
        encoding = C.AsciiCodec_false;
      P.UriData__writeUri(mimeType, encodingName, parameters, buffer, indices);
      indices.push(buffer._contents.length);
      buffer._contents += ",";
      P.UriData__uriEncodeBytes(C.List_CVk, encoding.encode$1($content), buffer);
      t1 = buffer._contents;
      return new P.UriData(t1.charCodeAt(0) == 0 ? t1 : t1, indices, null).get$uri();
    },
    Uri_parse: function(uri, start, end) {
      var t1, t2, t3, delta, t4, indices, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, t5, t6, isSimple, scheme, t7, t8, t9, schemeAuth;
      t1 = J.getInterceptor$asx(uri);
      end = t1.get$length(uri);
      t2 = start + 5;
      t3 = J.getInterceptor$n(end);
      if (t3.$ge(end, t2)) {
        delta = ((t1.codeUnitAt$1(uri, start + 4) ^ 58) * 3 | t1.codeUnitAt$1(uri, start) ^ 100 | t1.codeUnitAt$1(uri, start + 1) ^ 97 | t1.codeUnitAt$1(uri, start + 2) ^ 116 | t1.codeUnitAt$1(uri, start + 3) ^ 97) >>> 0;
        if (delta === 0)
          return P.UriData__parse(start > 0 || t3.$lt(end, t1.get$length(uri)) ? t1.substring$2(uri, start, end) : uri, 5, null).get$uri();
        else if (delta === 32)
          return P.UriData__parse(t1.substring$2(uri, t2, end), 0, null).get$uri();
      }
      t4 = new Array(8);
      t4.fixed$length = Array;
      indices = H.setRuntimeTypeInfo(t4, [P.int]);
      indices[0] = 0;
      t4 = start - 1;
      indices[1] = t4;
      indices[2] = t4;
      indices[7] = t4;
      indices[3] = start;
      indices[4] = start;
      indices[5] = end;
      indices[6] = end;
      if (P._scan(uri, start, end, 0, indices) >= 14)
        indices[7] = end;
      schemeEnd = indices[1];
      t4 = J.getInterceptor$n(schemeEnd);
      if (t4.$ge(schemeEnd, start))
        if (P._scan(uri, start, schemeEnd, 20, indices) === 20)
          indices[7] = schemeEnd;
      hostStart = J.$add$ansx(indices[2], 1);
      portStart = indices[3];
      pathStart = indices[4];
      queryStart = indices[5];
      fragmentStart = indices[6];
      t5 = J.getInterceptor$n(fragmentStart);
      if (t5.$lt(fragmentStart, queryStart))
        queryStart = fragmentStart;
      t6 = J.getInterceptor$n(pathStart);
      if (t6.$lt(pathStart, hostStart) || t6.$le(pathStart, schemeEnd))
        pathStart = queryStart;
      if (J.$lt$n(portStart, hostStart))
        portStart = pathStart;
      isSimple = J.$lt$n(indices[7], start);
      if (isSimple) {
        t6 = J.getInterceptor$n(hostStart);
        if (t6.$gt(hostStart, t4.$add(schemeEnd, 3))) {
          scheme = null;
          isSimple = false;
        } else {
          t7 = J.getInterceptor$n(portStart);
          if (t7.$gt(portStart, start) && J.$eq$(t7.$add(portStart, 1), pathStart)) {
            scheme = null;
            isSimple = false;
          } else {
            t8 = J.getInterceptor$n(queryStart);
            if (!(t8.$lt(queryStart, end) && t8.$eq(queryStart, J.$add$ansx(pathStart, 2)) === true && t1.startsWith$2(uri, "..", pathStart)))
              t9 = t8.$gt(queryStart, J.$add$ansx(pathStart, 2)) && t1.startsWith$2(uri, "/..", t8.$sub(queryStart, 3));
            else
              t9 = true;
            if (t9) {
              scheme = null;
              isSimple = false;
            } else {
              if (t4.$eq(schemeEnd, start + 4) === true)
                if (t1.startsWith$2(uri, "file", start)) {
                  if (t6.$le(hostStart, start)) {
                    if (!t1.startsWith$2(uri, "/", pathStart)) {
                      schemeAuth = "file:///";
                      delta = 3;
                    } else {
                      schemeAuth = "file://";
                      delta = 2;
                    }
                    uri = schemeAuth + t1.substring$2(uri, pathStart, end);
                    schemeEnd = t4.$sub(schemeEnd, start);
                    t1 = delta - start;
                    queryStart = t8.$add(queryStart, t1);
                    fragmentStart = t5.$add(fragmentStart, t1);
                    end = uri.length;
                    start = 0;
                    hostStart = 7;
                    portStart = 7;
                    pathStart = 7;
                  } else {
                    t2 = J.getInterceptor(pathStart);
                    if (t2.$eq(pathStart, queryStart) === true)
                      if (start === 0 && t3.$eq(end, t1.get$length(uri)) === true) {
                        uri = t1.replaceRange$3(uri, pathStart, queryStart, "/");
                        queryStart = t8.$add(queryStart, 1);
                        fragmentStart = t5.$add(fragmentStart, 1);
                        end = t3.$add(end, 1);
                      } else {
                        uri = t1.substring$2(uri, start, pathStart) + "/" + t1.substring$2(uri, queryStart, end);
                        schemeEnd = t4.$sub(schemeEnd, start);
                        hostStart = t6.$sub(hostStart, start);
                        portStart = t7.$sub(portStart, start);
                        pathStart = t2.$sub(pathStart, start);
                        t1 = 1 - start;
                        queryStart = t8.$add(queryStart, t1);
                        fragmentStart = t5.$add(fragmentStart, t1);
                        end = uri.length;
                        start = 0;
                      }
                  }
                  scheme = "file";
                } else if (t1.startsWith$2(uri, "http", start)) {
                  if (t7.$gt(portStart, start) && J.$eq$(t7.$add(portStart, 3), pathStart) && t1.startsWith$2(uri, "80", t7.$add(portStart, 1))) {
                    t2 = start === 0 && t3.$eq(end, t1.get$length(uri)) === true;
                    t9 = J.getInterceptor$n(pathStart);
                    if (t2) {
                      uri = t1.replaceRange$3(uri, portStart, pathStart, "");
                      pathStart = t9.$sub(pathStart, 3);
                      queryStart = t8.$sub(queryStart, 3);
                      fragmentStart = t5.$sub(fragmentStart, 3);
                      end = t3.$sub(end, 3);
                    } else {
                      uri = t1.substring$2(uri, start, portStart) + t1.substring$2(uri, pathStart, end);
                      schemeEnd = t4.$sub(schemeEnd, start);
                      hostStart = t6.$sub(hostStart, start);
                      portStart = t7.$sub(portStart, start);
                      t1 = 3 + start;
                      pathStart = t9.$sub(pathStart, t1);
                      queryStart = t8.$sub(queryStart, t1);
                      fragmentStart = t5.$sub(fragmentStart, t1);
                      end = uri.length;
                      start = 0;
                    }
                  }
                  scheme = "http";
                } else
                  scheme = null;
              else if (t4.$eq(schemeEnd, t2) === true && t1.startsWith$2(uri, "https", start)) {
                if (t7.$gt(portStart, start) && J.$eq$(t7.$add(portStart, 4), pathStart) && t1.startsWith$2(uri, "443", t7.$add(portStart, 1))) {
                  t2 = start === 0 && t3.$eq(end, t1.get$length(uri)) === true;
                  t9 = J.getInterceptor$n(pathStart);
                  if (t2) {
                    uri = t1.replaceRange$3(uri, portStart, pathStart, "");
                    pathStart = t9.$sub(pathStart, 4);
                    queryStart = t8.$sub(queryStart, 4);
                    fragmentStart = t5.$sub(fragmentStart, 4);
                    end = t3.$sub(end, 3);
                  } else {
                    uri = t1.substring$2(uri, start, portStart) + t1.substring$2(uri, pathStart, end);
                    schemeEnd = t4.$sub(schemeEnd, start);
                    hostStart = t6.$sub(hostStart, start);
                    portStart = t7.$sub(portStart, start);
                    t1 = 4 + start;
                    pathStart = t9.$sub(pathStart, t1);
                    queryStart = t8.$sub(queryStart, t1);
                    fragmentStart = t5.$sub(fragmentStart, t1);
                    end = uri.length;
                    start = 0;
                  }
                }
                scheme = "https";
              } else
                scheme = null;
              isSimple = true;
            }
          }
        }
      } else
        scheme = null;
      if (isSimple) {
        if (start > 0 || J.$lt$n(end, J.get$length$asx(uri))) {
          uri = J.substring$2$s(uri, start, end);
          schemeEnd = J.$sub$n(schemeEnd, start);
          hostStart = J.$sub$n(hostStart, start);
          portStart = J.$sub$n(portStart, start);
          pathStart = J.$sub$n(pathStart, start);
          queryStart = J.$sub$n(queryStart, start);
          fragmentStart = J.$sub$n(fragmentStart, start);
        }
        return new P._SimpleUri(uri, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme, null);
      }
      return P._Uri__Uri$notSimple(uri, start, end, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme);
    },
    Uri_decodeComponent: [function(encodedComponent) {
      return P._Uri__uriDecode(encodedComponent, 0, J.get$length$asx(encodedComponent), C.Utf8Codec_false, false);
    }, "call$1", "core_Uri_decodeComponent$closure", 4, 0, 33, 74],
    Uri__parseIPv4Address: function(host, start, end) {
      var error, result, t1, t2, i, partStart, partIndex, t3, char, part, partIndex0;
      error = new P.Uri__parseIPv4Address_error(host);
      result = new Uint8Array(4);
      for (t1 = result.length, t2 = J.getInterceptor$s(host), i = start, partStart = i, partIndex = 0; t3 = J.getInterceptor$n(i), t3.$lt(i, end); i = t3.$add(i, 1)) {
        char = t2.codeUnitAt$1(host, i);
        if (char !== 46) {
          if ((char ^ 48) > 9)
            error.call$2("invalid character", i);
        } else {
          if (partIndex === 3)
            error.call$2("IPv4 address should contain exactly 4 parts", i);
          part = P.int_parse(t2.substring$2(host, partStart, i), null, null);
          if (J.$gt$n(part, 255))
            error.call$2("each part must be in the range 0..255", partStart);
          partIndex0 = partIndex + 1;
          if (partIndex >= t1)
            return H.ioore(result, partIndex);
          result[partIndex] = part;
          partStart = t3.$add(i, 1);
          partIndex = partIndex0;
        }
      }
      if (partIndex !== 3)
        error.call$2("IPv4 address should contain exactly 4 parts", end);
      part = P.int_parse(t2.substring$2(host, partStart, end), null, null);
      if (J.$gt$n(part, 255))
        error.call$2("each part must be in the range 0..255", partStart);
      if (partIndex >= t1)
        return H.ioore(result, partIndex);
      result[partIndex] = part;
      return result;
    },
    Uri_parseIPv6Address: function(host, start, end) {
      var error, parseHex, t1, parts, i, partStart, wildcardSeen, seenDot, t2, char, atEnd, isLastWildcard, last, bytes, index, value, wildCardLength, j, t3;
      if (end == null)
        end = J.get$length$asx(host);
      error = new P.Uri_parseIPv6Address_error(host);
      parseHex = new P.Uri_parseIPv6Address_parseHex(error, host);
      t1 = J.getInterceptor$asx(host);
      if (J.$lt$n(t1.get$length(host), 2))
        error.call$1("address is too short");
      parts = [];
      for (i = start, partStart = i, wildcardSeen = false, seenDot = false; t2 = J.getInterceptor$n(i), t2.$lt(i, end); i = J.$add$ansx(i, 1)) {
        char = t1.codeUnitAt$1(host, i);
        if (char === 58) {
          if (t2.$eq(i, start)) {
            i = t2.$add(i, 1);
            if (t1.codeUnitAt$1(host, i) !== 58)
              error.call$2("invalid start colon.", i);
            partStart = i;
          }
          t2 = J.getInterceptor(i);
          if (t2.$eq(i, partStart)) {
            if (wildcardSeen)
              error.call$2("only one wildcard `::` is allowed", i);
            parts.push(-1);
            wildcardSeen = true;
          } else
            parts.push(parseHex.call$2(partStart, i));
          partStart = t2.$add(i, 1);
        } else if (char === 46)
          seenDot = true;
      }
      if (parts.length === 0)
        error.call$1("too few parts");
      atEnd = J.$eq$(partStart, end);
      isLastWildcard = J.$eq$(C.JSArray_methods.get$last(parts), -1);
      if (atEnd && isLastWildcard !== true)
        error.call$2("expected a part after last `:`", end);
      if (!atEnd)
        if (!seenDot)
          parts.push(parseHex.call$2(partStart, end));
        else {
          last = P.Uri__parseIPv4Address(host, partStart, end);
          t1 = J.$shl$n(last[0], 8);
          t2 = last[1];
          if (typeof t2 !== "number")
            return H.iae(t2);
          parts.push((t1 | t2) >>> 0);
          t2 = J.$shl$n(last[2], 8);
          t1 = last[3];
          if (typeof t1 !== "number")
            return H.iae(t1);
          parts.push((t2 | t1) >>> 0);
        }
      if (wildcardSeen) {
        if (parts.length > 7)
          error.call$1("an address with a wildcard must have less than 7 parts");
      } else if (parts.length !== 8)
        error.call$1("an address without a wildcard must contain exactly 8 parts");
      bytes = new Uint8Array(16);
      for (t1 = bytes.length, i = 0, index = 0; i < parts.length; ++i) {
        value = parts[i];
        t2 = J.getInterceptor(value);
        if (t2.$eq(value, -1) === true) {
          wildCardLength = 9 - parts.length;
          for (j = 0; j < wildCardLength; ++j) {
            if (index < 0 || index >= t1)
              return H.ioore(bytes, index);
            bytes[index] = 0;
            t2 = index + 1;
            if (t2 >= t1)
              return H.ioore(bytes, t2);
            bytes[t2] = 0;
            index += 2;
          }
        } else {
          t3 = t2.$shr(value, 8);
          if (index < 0 || index >= t1)
            return H.ioore(bytes, index);
          bytes[index] = t3;
          t3 = index + 1;
          t2 = t2.$and(value, 255);
          if (t3 >= t1)
            return H.ioore(bytes, t3);
          bytes[t3] = t2;
          index += 2;
        }
      }
      return bytes;
    },
    _createTables: function() {
      var tables, t1, t2, t3, b;
      tables = P.List_List$generate(22, new P._createTables_closure(), true, P.Uint8List);
      t1 = new P._createTables_build(tables);
      t2 = new P._createTables_setChars();
      t3 = new P._createTables_setRange();
      b = t1.call$2(0, 225);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 1);
      t2.call$3(b, ".", 14);
      t2.call$3(b, ":", 34);
      t2.call$3(b, "/", 3);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(14, 225);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 1);
      t2.call$3(b, ".", 15);
      t2.call$3(b, ":", 34);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(15, 225);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 1);
      t2.call$3(b, "%", 225);
      t2.call$3(b, ":", 34);
      t2.call$3(b, "/", 9);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(1, 225);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 1);
      t2.call$3(b, ":", 34);
      t2.call$3(b, "/", 10);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(2, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 139);
      t2.call$3(b, "/", 131);
      t2.call$3(b, ".", 146);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(3, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, "/", 68);
      t2.call$3(b, ".", 18);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(4, 229);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 5);
      t3.call$3(b, "AZ", 229);
      t2.call$3(b, ":", 102);
      t2.call$3(b, "@", 68);
      t2.call$3(b, "[", 232);
      t2.call$3(b, "/", 138);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(5, 229);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 5);
      t3.call$3(b, "AZ", 229);
      t2.call$3(b, ":", 102);
      t2.call$3(b, "@", 68);
      t2.call$3(b, "/", 138);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(6, 231);
      t3.call$3(b, "19", 7);
      t2.call$3(b, "@", 68);
      t2.call$3(b, "/", 138);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(7, 231);
      t3.call$3(b, "09", 7);
      t2.call$3(b, "@", 68);
      t2.call$3(b, "/", 138);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      t2.call$3(t1.call$2(8, 8), "]", 5);
      b = t1.call$2(9, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, ".", 16);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(16, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, ".", 17);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(17, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, "/", 9);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(10, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, ".", 18);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(18, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, ".", 19);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(19, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, "/", 234);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(11, 235);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 11);
      t2.call$3(b, "/", 10);
      t2.call$3(b, "?", 172);
      t2.call$3(b, "#", 205);
      b = t1.call$2(12, 236);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 12);
      t2.call$3(b, "?", 12);
      t2.call$3(b, "#", 205);
      b = t1.call$2(13, 237);
      t2.call$3(b, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-._~!$&'()*+,;=", 13);
      t2.call$3(b, "?", 13);
      t3.call$3(t1.call$2(20, 245), "az", 21);
      b = t1.call$2(21, 245);
      t3.call$3(b, "az", 21);
      t3.call$3(b, "09", 21);
      t2.call$3(b, "+-.", 21);
      return tables;
    },
    _scan: function(uri, start, end, state, indices) {
      var tables, t1, i, table, char, transition, t2;
      tables = $.$get$_scannerTables();
      if (typeof end !== "number")
        return H.iae(end);
      t1 = J.getInterceptor$s(uri);
      i = start;
      for (; i < end; ++i) {
        if (state < 0 || state >= tables.length)
          return H.ioore(tables, state);
        table = tables[state];
        char = t1.codeUnitAt$1(uri, i) ^ 96;
        transition = J.$index$asx(table, char > 95 ? 31 : char);
        t2 = J.getInterceptor$n(transition);
        state = t2.$and(transition, 31);
        t2 = t2.$shr(transition, 5);
        if (t2 >= 8)
          return H.ioore(indices, t2);
        indices[t2] = i;
      }
      return state;
    },
    NoSuchMethodError_toString_closure: {
      "^": "Closure:78;_box_0,sb",
      call$2: function(key, value) {
        var t1, t2, t3;
        t1 = this.sb;
        t2 = this._box_0;
        t1._contents += t2.comma;
        t3 = t1._contents += H.S(key.get$__internal$_name());
        t1._contents = t3 + ": ";
        t1._contents += H.S(P.Error_safeToString(value));
        t2.comma = ", ";
      }
    },
    bool: {
      "^": "Object;"
    },
    "+bool": 0,
    DateTime: {
      "^": "Object;_core$_value<,isUtc",
      add$1: function(_, duration) {
        return P.DateTime$_withValue(this._core$_value + duration.get$inMilliseconds(), false);
      },
      get$millisecondsSinceEpoch: function() {
        return this._core$_value;
      },
      DateTime$_withValue$2$isUtc: function(_value, isUtc) {
        var t1;
        if (!(Math.abs(this._core$_value) > 864e13))
          t1 = false;
        else
          t1 = true;
        if (t1)
          throw H.wrapException(P.ArgumentError$("DateTime is outside valid range: " + H.S(this.get$millisecondsSinceEpoch())));
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        if (!(other instanceof P.DateTime))
          return false;
        return this._core$_value === other._core$_value && true;
      },
      isAfter$1: function(other) {
        return this._core$_value > other.get$_core$_value();
      },
      compareTo$1: function(_, other) {
        return C.JSNumber_methods.compareTo$1(this._core$_value, other.get$_core$_value());
      },
      get$hashCode: function(_) {
        var t1 = this._core$_value;
        return (t1 ^ C.JSNumber_methods._shrOtherPositive$1(t1, 30)) & 1073741823;
      },
      toString$0: function(_) {
        var y, m, d, h, min, sec, ms, t1;
        y = P.DateTime__fourDigits(H.Primitives_getYear(this));
        m = P.DateTime__twoDigits(H.Primitives_getMonth(this));
        d = P.DateTime__twoDigits(H.Primitives_getDay(this));
        h = P.DateTime__twoDigits(H.Primitives_getHours(this));
        min = P.DateTime__twoDigits(H.Primitives_getMinutes(this));
        sec = P.DateTime__twoDigits(H.Primitives_getSeconds(this));
        ms = P.DateTime__threeDigits(H.Primitives_getMilliseconds(this));
        t1 = y + "-" + m + "-" + d + " " + h + ":" + min + ":" + sec + "." + ms;
        return t1;
      },
      static: {
        DateTime$_withValue: function(_value, isUtc) {
          var t1 = new P.DateTime(_value, false);
          t1.DateTime$_withValue$2$isUtc(_value, false);
          return t1;
        },
        DateTime__fourDigits: function(n) {
          var absN, sign;
          absN = Math.abs(n);
          sign = n < 0 ? "-" : "";
          if (absN >= 1000)
            return "" + n;
          if (absN >= 100)
            return sign + "0" + absN;
          if (absN >= 10)
            return sign + "00" + absN;
          return sign + "000" + absN;
        },
        DateTime__threeDigits: function(n) {
          if (n >= 100)
            return "" + n;
          if (n >= 10)
            return "0" + n;
          return "00" + n;
        },
        DateTime__twoDigits: function(n) {
          if (n >= 10)
            return "" + n;
          return "0" + n;
        }
      }
    },
    double: {
      "^": "num;"
    },
    "+double": 0,
    Duration: {
      "^": "Object;_duration<",
      $add: function(_, other) {
        return new P.Duration(this._duration + other.get$_duration());
      },
      $sub: function(_, other) {
        return new P.Duration(this._duration - other.get$_duration());
      },
      $mul: function(_, factor) {
        if (typeof factor !== "number")
          return H.iae(factor);
        return new P.Duration(C.JSNumber_methods.round$0(this._duration * factor));
      },
      $tdiv: function(_, quotient) {
        if (quotient === 0)
          throw H.wrapException(new P.IntegerDivisionByZeroException());
        return new P.Duration(C.JSNumber_methods.$tdiv(this._duration, quotient));
      },
      $lt: function(_, other) {
        return this._duration < other.get$_duration();
      },
      $gt: function(_, other) {
        return this._duration > other.get$_duration();
      },
      $le: function(_, other) {
        return this._duration <= other.get$_duration();
      },
      $ge: function(_, other) {
        return this._duration >= other.get$_duration();
      },
      get$inMilliseconds: function() {
        return C.JSNumber_methods._tdivFast$1(this._duration, 1000);
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        if (!(other instanceof P.Duration))
          return false;
        return this._duration === other._duration;
      },
      get$hashCode: function(_) {
        return this._duration & 0x1FFFFFFF;
      },
      compareTo$1: function(_, other) {
        return C.JSNumber_methods.compareTo$1(this._duration, other.get$_duration());
      },
      toString$0: function(_) {
        var t1, t2, twoDigitMinutes, twoDigitSeconds, sixDigitUs;
        t1 = new P.Duration_toString_twoDigits();
        t2 = this._duration;
        if (t2 < 0)
          return "-" + new P.Duration(0 - t2).toString$0(0);
        twoDigitMinutes = t1.call$1(C.JSNumber_methods._tdivFast$1(t2, 60000000) % 60);
        twoDigitSeconds = t1.call$1(C.JSNumber_methods._tdivFast$1(t2, 1000000) % 60);
        sixDigitUs = new P.Duration_toString_sixDigits().call$1(t2 % 1000000);
        return H.S(C.JSNumber_methods._tdivFast$1(t2, 3600000000)) + ":" + H.S(twoDigitMinutes) + ":" + H.S(twoDigitSeconds) + "." + H.S(sixDigitUs);
      },
      abs$0: function(_) {
        return new P.Duration(Math.abs(this._duration));
      },
      $negate: function(_) {
        return new P.Duration(0 - this._duration);
      },
      static: {
        Duration$: function(days, hours, microseconds, milliseconds, minutes, seconds) {
          return new P.Duration(864e8 * days + 3600000000 * hours + 60000000 * minutes + 1000000 * seconds + 1000 * milliseconds + microseconds);
        }
      }
    },
    Duration_toString_sixDigits: {
      "^": "Closure:28;",
      call$1: function(n) {
        if (n >= 100000)
          return H.S(n);
        if (n >= 10000)
          return "0" + H.S(n);
        if (n >= 1000)
          return "00" + H.S(n);
        if (n >= 100)
          return "000" + H.S(n);
        if (n >= 10)
          return "0000" + H.S(n);
        return "00000" + H.S(n);
      }
    },
    Duration_toString_twoDigits: {
      "^": "Closure:28;",
      call$1: function(n) {
        if (n >= 10)
          return "" + n;
        return "0" + n;
      }
    },
    Error: {
      "^": "Object;",
      get$stackTrace: function() {
        return H.getTraceFromException(this.$thrownJsError);
      }
    },
    NullThrownError: {
      "^": "Error;",
      toString$0: function(_) {
        return "Throw of null.";
      }
    },
    ArgumentError: {
      "^": "Error;_hasValue,invalidValue,name<,message>",
      get$_errorName: function() {
        return "Invalid argument" + (!this._hasValue ? "(s)" : "");
      },
      get$_errorExplanation: function() {
        return "";
      },
      toString$0: function(_) {
        var t1, nameString, message, prefix, explanation, errorValue;
        t1 = this.name;
        nameString = t1 != null ? " (" + t1 + ")" : "";
        t1 = this.message;
        message = t1 == null ? "" : ": " + H.S(t1);
        prefix = this.get$_errorName() + nameString + message;
        if (!this._hasValue)
          return prefix;
        explanation = this.get$_errorExplanation();
        errorValue = P.Error_safeToString(this.invalidValue);
        return prefix + explanation + ": " + H.S(errorValue);
      },
      static: {
        ArgumentError$: function(message) {
          return new P.ArgumentError(false, null, null, message);
        },
        ArgumentError$value: function(value, $name, message) {
          return new P.ArgumentError(true, value, $name, message);
        },
        ArgumentError$notNull: function($name) {
          return new P.ArgumentError(false, null, $name, "Must not be null");
        }
      }
    },
    RangeError: {
      "^": "ArgumentError;start>,end>,_hasValue,invalidValue,name,message",
      get$_errorName: function() {
        return "RangeError";
      },
      get$_errorExplanation: function() {
        var t1, explanation, t2, t3;
        t1 = this.start;
        if (t1 == null) {
          t1 = this.end;
          explanation = t1 != null ? ": Not less than or equal to " + H.S(t1) : "";
        } else {
          t2 = this.end;
          if (t2 == null)
            explanation = ": Not greater than or equal to " + H.S(t1);
          else {
            t3 = J.getInterceptor$n(t2);
            if (t3.$gt(t2, t1))
              explanation = ": Not in range " + H.S(t1) + ".." + H.S(t2) + ", inclusive";
            else
              explanation = t3.$lt(t2, t1) ? ": Valid value range is empty" : ": Only valid value is " + H.S(t1);
          }
        }
        return explanation;
      },
      static: {
        RangeError$: function(message) {
          return new P.RangeError(null, null, false, null, null, message);
        },
        RangeError$value: function(value, $name, message) {
          return new P.RangeError(null, null, true, value, $name, message != null ? message : "Value not in range");
        },
        RangeError$range: function(invalidValue, minValue, maxValue, $name, message) {
          return new P.RangeError(minValue, maxValue, true, invalidValue, $name, "Invalid value");
        },
        RangeError_checkValueInInterval: function(value, minValue, maxValue, $name, message) {
          var t1 = J.getInterceptor$n(value);
          if (t1.$lt(value, minValue) || t1.$gt(value, maxValue))
            throw H.wrapException(P.RangeError$range(value, minValue, maxValue, $name, message));
        },
        RangeError_checkValidIndex: function(index, indexable, $name, $length, message) {
          var t1;
          $length = J.get$length$asx(indexable);
          if (typeof index !== "number")
            return H.iae(index);
          if (!(0 > index)) {
            if (typeof $length !== "number")
              return H.iae($length);
            t1 = index >= $length;
          } else
            t1 = true;
          if (t1)
            throw H.wrapException(P.IndexError$(index, indexable, $name == null ? "index" : $name, message, $length));
        },
        RangeError_checkValidRange: function(start, end, $length, startName, endName, message) {
          var t1;
          if (typeof start !== "number")
            return H.iae(start);
          if (!(0 > start)) {
            if (typeof $length !== "number")
              return H.iae($length);
            t1 = start > $length;
          } else
            t1 = true;
          if (t1)
            throw H.wrapException(P.RangeError$range(start, 0, $length, "start", message));
          if (end != null) {
            if (typeof end !== "number")
              return H.iae(end);
            if (!(start > end)) {
              if (typeof $length !== "number")
                return H.iae($length);
              t1 = end > $length;
            } else
              t1 = true;
            if (t1)
              throw H.wrapException(P.RangeError$range(end, start, $length, "end", message));
            return end;
          }
          return $length;
        }
      }
    },
    IndexError: {
      "^": "ArgumentError;indexable,length>,_hasValue,invalidValue,name,message",
      get$start: function(_) {
        return 0;
      },
      get$end: function(_) {
        return J.$sub$n(this.length, 1);
      },
      get$_errorName: function() {
        return "RangeError";
      },
      get$_errorExplanation: function() {
        if (J.$lt$n(this.invalidValue, 0))
          return ": index must not be negative";
        var t1 = this.length;
        if (J.$eq$(t1, 0) === true)
          return ": no indices are valid";
        return ": index should be less than " + H.S(t1);
      },
      static: {
        IndexError$: function(invalidValue, indexable, $name, message, $length) {
          var t1 = $length != null ? $length : J.get$length$asx(indexable);
          return new P.IndexError(indexable, t1, true, invalidValue, $name, "Index out of range");
        }
      }
    },
    NoSuchMethodError: {
      "^": "Error;_receiver,_memberName,_arguments,_namedArguments,_existingArgumentNames",
      toString$0: function(_) {
        var _box_0, sb, t1, t2, _i, t3, t4, argument, memberName, receiverText, actualParameters;
        _box_0 = {};
        sb = new P.StringBuffer("");
        _box_0.comma = "";
        t1 = this._arguments;
        if (t1 != null)
          for (t2 = t1.length, _i = 0, t3 = "", t4 = ""; _i < t2; ++_i, t4 = ", ") {
            argument = t1[_i];
            sb._contents = t3 + t4;
            t3 = sb._contents += H.S(P.Error_safeToString(argument));
            _box_0.comma = ", ";
          }
        t1 = this._namedArguments;
        if (t1 != null)
          t1.forEach$1(0, new P.NoSuchMethodError_toString_closure(_box_0, sb));
        memberName = this._memberName.__internal$_name;
        receiverText = P.Error_safeToString(this._receiver);
        actualParameters = sb.toString$0(0);
        t1 = "NoSuchMethodError: method not found: '" + H.S(memberName) + "'\nReceiver: " + H.S(receiverText) + "\nArguments: [" + actualParameters + "]";
        return t1;
      },
      static: {
        NoSuchMethodError$: function(receiver, memberName, positionalArguments, namedArguments, existingArgumentNames) {
          return new P.NoSuchMethodError(receiver, memberName, positionalArguments, namedArguments, existingArgumentNames);
        }
      }
    },
    UnsupportedError: {
      "^": "Error;message>",
      toString$0: function(_) {
        return "Unsupported operation: " + this.message;
      },
      static: {
        UnsupportedError$: function(message) {
          return new P.UnsupportedError(message);
        }
      }
    },
    UnimplementedError: {
      "^": "Error;message>",
      toString$0: function(_) {
        var t1 = this.message;
        return t1 != null ? "UnimplementedError: " + H.S(t1) : "UnimplementedError";
      },
      static: {
        UnimplementedError$: function(message) {
          return new P.UnimplementedError(message);
        }
      }
    },
    StateError: {
      "^": "Error;message>",
      toString$0: function(_) {
        return "Bad state: " + this.message;
      },
      static: {
        StateError$: function(message) {
          return new P.StateError(message);
        }
      }
    },
    ConcurrentModificationError: {
      "^": "Error;modifiedObject",
      toString$0: function(_) {
        var t1 = this.modifiedObject;
        if (t1 == null)
          return "Concurrent modification during iteration.";
        return "Concurrent modification during iteration: " + H.S(P.Error_safeToString(t1)) + ".";
      },
      static: {
        ConcurrentModificationError$: function(modifiedObject) {
          return new P.ConcurrentModificationError(modifiedObject);
        }
      }
    },
    OutOfMemoryError: {
      "^": "Object;",
      toString$0: function(_) {
        return "Out of Memory";
      },
      get$stackTrace: function() {
        return;
      },
      $isError: 1
    },
    StackOverflowError: {
      "^": "Object;",
      toString$0: function(_) {
        return "Stack Overflow";
      },
      get$stackTrace: function() {
        return;
      },
      $isError: 1
    },
    CyclicInitializationError: {
      "^": "Error;variableName",
      toString$0: function(_) {
        var t1 = this.variableName;
        return t1 == null ? "Reading static variable during its initialization" : "Reading static variable '" + H.S(t1) + "' during its initialization";
      }
    },
    Exception: {
      "^": "Object;"
    },
    _Exception: {
      "^": "Object;message>",
      toString$0: function(_) {
        return "Exception: " + this.message;
      }
    },
    FormatException: {
      "^": "Object;message>,source<,offset<",
      toString$0: function(_) {
        var t1, report, offset, source, lineNum, lineStart, previousCharWasCR, i, char, lineEnd, end, start, prefix, postfix, slice;
        t1 = this.message;
        report = t1 != null && "" !== t1 ? "FormatException: " + H.S(t1) : "FormatException";
        offset = this.offset;
        source = this.source;
        if (typeof source !== "string")
          return offset != null ? report + (" (at offset " + H.S(offset) + ")") : report;
        if (offset != null) {
          t1 = J.getInterceptor$n(offset);
          t1 = t1.$lt(offset, 0) || t1.$gt(offset, source.length);
        } else
          t1 = false;
        if (t1)
          offset = null;
        if (offset == null) {
          if (source.length > 78)
            source = C.JSString_methods.substring$2(source, 0, 75) + "...";
          return report + "\n" + source;
        }
        if (typeof offset !== "number")
          return H.iae(offset);
        lineNum = 1;
        lineStart = 0;
        previousCharWasCR = false;
        i = 0;
        for (; i < offset; ++i) {
          char = C.JSString_methods._codeUnitAt$1(source, i);
          if (char === 10) {
            if (lineStart !== i || !previousCharWasCR)
              ++lineNum;
            lineStart = i + 1;
            previousCharWasCR = false;
          } else if (char === 13) {
            ++lineNum;
            lineStart = i + 1;
            previousCharWasCR = true;
          }
        }
        report = lineNum > 1 ? report + (" (at line " + lineNum + ", character " + H.S(offset - lineStart + 1) + ")\n") : report + (" (at character " + H.S(offset + 1) + ")\n");
        lineEnd = source.length;
        for (i = offset; i < source.length; ++i) {
          char = C.JSString_methods.codeUnitAt$1(source, i);
          if (char === 10 || char === 13) {
            lineEnd = i;
            break;
          }
        }
        if (lineEnd - lineStart > 78)
          if (offset - lineStart < 75) {
            end = lineStart + 75;
            start = lineStart;
            prefix = "";
            postfix = "...";
          } else {
            if (lineEnd - offset < 75) {
              start = lineEnd - 75;
              end = lineEnd;
              postfix = "";
            } else {
              start = offset - 36;
              end = offset + 36;
              postfix = "...";
            }
            prefix = "...";
          }
        else {
          end = lineEnd;
          start = lineStart;
          prefix = "";
          postfix = "";
        }
        slice = C.JSString_methods.substring$2(source, start, end);
        return report + prefix + slice + postfix + "\n" + C.JSString_methods.$mul(" ", offset - start + prefix.length) + "^\n";
      },
      static: {
        FormatException$: function(message, source, offset) {
          return new P.FormatException(message, source, offset);
        }
      }
    },
    IntegerDivisionByZeroException: {
      "^": "Object;",
      toString$0: function(_) {
        return "IntegerDivisionByZeroException";
      }
    },
    int: {
      "^": "num;"
    },
    "+int": 0,
    Iterable: {
      "^": "Object;$ti",
      cast$0: function(_) {
        return H.CastIterable_CastIterable(this, null, null);
      },
      map$1: function(_, f) {
        return H.MappedIterable_MappedIterable(this, f, H.getRuntimeTypeArgument(this, "Iterable", 0), null);
      },
      where$1: ["super$Iterable$where", function(_, test) {
        return new H.WhereIterable(this, test, [H.getRuntimeTypeArgument(this, "Iterable", 0)]);
      }],
      expand$1: function(_, f) {
        return new H.ExpandIterable(this, f, [H.getRuntimeTypeArgument(this, "Iterable", 0), null]);
      },
      contains$1: function(_, element) {
        var t1;
        for (t1 = this.get$iterator(this); t1.moveNext$0();)
          if (J.$eq$(t1.get$current(t1), element) === true)
            return true;
        return false;
      },
      forEach$1: function(_, f) {
        var t1;
        for (t1 = this.get$iterator(this); t1.moveNext$0();)
          f.call$1(t1.get$current(t1));
      },
      fold$2: function(_, initialValue, combine) {
        var t1, value;
        for (t1 = this.get$iterator(this), value = initialValue; t1.moveNext$0();)
          value = combine.call$2(value, t1.get$current(t1));
        return value;
      },
      every$1: function(_, test) {
        var t1;
        for (t1 = this.get$iterator(this); t1.moveNext$0();)
          if (test.call$1(t1.get$current(t1)) !== true)
            return false;
        return true;
      },
      join$1: function(_, separator) {
        var iterator, t1;
        iterator = this.get$iterator(this);
        if (!iterator.moveNext$0())
          return "";
        if (separator === "") {
          t1 = "";
          do
            t1 += H.S(iterator.get$current(iterator));
          while (iterator.moveNext$0());
        } else {
          t1 = H.S(iterator.get$current(iterator));
          for (; iterator.moveNext$0();)
            t1 = t1 + separator + H.S(iterator.get$current(iterator));
        }
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      },
      join$0: function($receiver) {
        return this.join$1($receiver, "");
      },
      any$1: function(_, test) {
        var t1;
        for (t1 = this.get$iterator(this); t1.moveNext$0();)
          if (test.call$1(t1.get$current(t1)) === true)
            return true;
        return false;
      },
      toList$1$growable: function(_, growable) {
        return P.List_List$from(this, growable, H.getRuntimeTypeArgument(this, "Iterable", 0));
      },
      toList$0: function($receiver) {
        return this.toList$1$growable($receiver, true);
      },
      get$length: function(_) {
        var it, count;
        it = this.get$iterator(this);
        for (count = 0; it.moveNext$0();)
          ++count;
        return count;
      },
      get$isEmpty: function(_) {
        return !this.get$iterator(this).moveNext$0();
      },
      get$isNotEmpty: function(_) {
        return this.get$isEmpty(this) !== true;
      },
      take$1: function(_, count) {
        return H.TakeIterable_TakeIterable(this, count, H.getRuntimeTypeArgument(this, "Iterable", 0));
      },
      skip$1: function(_, count) {
        return H.SkipIterable_SkipIterable(this, count, H.getRuntimeTypeArgument(this, "Iterable", 0));
      },
      skipWhile$1: ["super$Iterable$skipWhile", function(_, test) {
        return new H.SkipWhileIterable(this, test, [H.getRuntimeTypeArgument(this, "Iterable", 0)]);
      }],
      get$first: function(_) {
        var it = this.get$iterator(this);
        if (!it.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        return it.get$current(it);
      },
      get$last: function(_) {
        var it, result;
        it = this.get$iterator(this);
        if (!it.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        do
          result = it.get$current(it);
        while (it.moveNext$0());
        return result;
      },
      get$single: function(_) {
        var it, result;
        it = this.get$iterator(this);
        if (!it.moveNext$0())
          throw H.wrapException(H.IterableElementError_noElement());
        result = it.get$current(it);
        if (it.moveNext$0())
          throw H.wrapException(H.IterableElementError_tooMany());
        return result;
      },
      firstWhere$2$orElse: function(_, test, orElse) {
        var t1, element;
        for (t1 = this.get$iterator(this); t1.moveNext$0();) {
          element = t1.get$current(t1);
          if (test.call$1(element) === true)
            return element;
        }
        return orElse.call$0();
      },
      elementAt$1: function(_, index) {
        var t1, elementIndex, element;
        if (typeof index !== "number" || Math.floor(index) !== index)
          throw H.wrapException(P.ArgumentError$notNull("index"));
        if (index < 0)
          H.throwExpression(P.RangeError$range(index, 0, null, "index", null));
        for (t1 = this.get$iterator(this), elementIndex = 0; t1.moveNext$0();) {
          element = t1.get$current(t1);
          if (index === elementIndex)
            return element;
          ++elementIndex;
        }
        throw H.wrapException(P.IndexError$(index, this, "index", null, elementIndex));
      },
      toString$0: function(_) {
        return P.IterableBase_iterableToShortString(this, "(", ")");
      }
    },
    _GeneratorIterable: {
      "^": "ListIterable;length>,_generator,$ti",
      elementAt$1: function(_, index) {
        P.RangeError_checkValidIndex(index, this, null, null, null);
        return this._generator.call$1(index);
      }
    },
    Iterator: {
      "^": "Object;$ti"
    },
    List: {
      "^": "Object;$ti",
      $isEfficientLengthIterable: 1,
      $isIterable: 1
    },
    "+List": 0,
    Map: {
      "^": "Object;$ti"
    },
    Null: {
      "^": "Object;",
      get$hashCode: function(_) {
        return P.Object.prototype.get$hashCode.call(this, this);
      },
      toString$0: function(_) {
        return "null";
      }
    },
    "+Null": 0,
    num: {
      "^": "Object;"
    },
    "+num": 0,
    Object: {
      "^": ";",
      $eq: function(_, other) {
        return this === other;
      },
      get$hashCode: function(_) {
        return H.Primitives_objectHashCode(this);
      },
      toString$0: function(_) {
        return "Instance of '" + H.Primitives_objectTypeName(this) + "'";
      },
      noSuchMethod$1: [function(_, invocation) {
        throw H.wrapException(P.NoSuchMethodError$(this, invocation.get$memberName(), invocation.get$positionalArguments(), invocation.get$namedArguments(), null));
      }, null, "get$noSuchMethod", 5, 0, null, 22],
      toString: function() {
        return this.toString$0(this);
      }
    },
    Match: {
      "^": "Object;"
    },
    RegExp: {
      "^": "Object;"
    },
    Set: {
      "^": "EfficientLengthIterable;$ti"
    },
    StackTrace: {
      "^": "Object;"
    },
    _StringStackTrace: {
      "^": "Object;_stackTrace",
      toString$0: function(_) {
        return this._stackTrace;
      },
      $isStackTrace: 1
    },
    String: {
      "^": "Object;"
    },
    "+String": 0,
    Runes: {
      "^": "Iterable;string",
      get$iterator: function(_) {
        return new P.RuneIterator(this.string, 0, 0, null);
      },
      get$last: function(_) {
        var t1, t2, code, previousCode;
        t1 = this.string;
        t2 = t1.length;
        if (t2 === 0)
          throw H.wrapException(P.StateError$("No elements."));
        code = C.JSString_methods.codeUnitAt$1(t1, t2 - 1);
        if ((code & 64512) === 56320 && t2 > 1) {
          previousCode = C.JSString_methods.codeUnitAt$1(t1, t2 - 2);
          if ((previousCode & 64512) === 55296)
            return P._combineSurrogatePair(previousCode, code);
        }
        return code;
      },
      $asIterable: function() {
        return [P.int];
      }
    },
    RuneIterator: {
      "^": "Object;string,_core$_position,_nextPosition,_currentCodePoint",
      get$current: function(_) {
        return this._currentCodePoint;
      },
      moveNext$0: function() {
        var t1, t2, t3, codeUnit, nextPosition, nextCodeUnit;
        t1 = this._nextPosition;
        this._core$_position = t1;
        t2 = this.string;
        t3 = t2.length;
        if (t1 === t3) {
          this._currentCodePoint = null;
          return false;
        }
        codeUnit = C.JSString_methods._codeUnitAt$1(t2, t1);
        nextPosition = t1 + 1;
        if ((codeUnit & 64512) === 55296 && nextPosition < t3) {
          nextCodeUnit = C.JSString_methods._codeUnitAt$1(t2, nextPosition);
          if ((nextCodeUnit & 64512) === 56320) {
            this._nextPosition = nextPosition + 1;
            this._currentCodePoint = P._combineSurrogatePair(codeUnit, nextCodeUnit);
            return true;
          }
        }
        this._nextPosition = nextPosition;
        this._currentCodePoint = codeUnit;
        return true;
      }
    },
    StringBuffer: {
      "^": "Object;_contents@",
      get$length: function(_) {
        return this._contents.length;
      },
      write$1: function(_, obj) {
        this._contents += H.S(obj);
      },
      writeCharCode$1: function(charCode) {
        this._contents += H.Primitives_stringFromCharCode(charCode);
      },
      toString$0: function(_) {
        var t1 = this._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      },
      get$isEmpty: function(_) {
        return this._contents.length === 0;
      },
      get$isNotEmpty: function(_) {
        return this._contents.length !== 0;
      },
      static: {
        StringBuffer__writeAll: function(string, objects, separator) {
          var iterator = J.get$iterator$ax(objects);
          if (!iterator.moveNext$0())
            return string;
          if (separator.length === 0) {
            do
              string += H.S(iterator.get$current(iterator));
            while (iterator.moveNext$0());
          } else {
            string += H.S(iterator.get$current(iterator));
            for (; iterator.moveNext$0();)
              string = string + separator + H.S(iterator.get$current(iterator));
          }
          return string;
        }
      }
    },
    Symbol0: {
      "^": "Object;"
    },
    Uri: {
      "^": "Object;"
    },
    Uri__parseIPv4Address_error: {
      "^": "Closure:76;host",
      call$2: function(msg, position) {
        throw H.wrapException(P.FormatException$("Illegal IPv4 address, " + msg, this.host, position));
      }
    },
    Uri_parseIPv6Address_error: {
      "^": "Closure:74;host",
      call$2: function(msg, position) {
        throw H.wrapException(P.FormatException$("Illegal IPv6 address, " + msg, this.host, position));
      },
      call$1: function(msg) {
        return this.call$2(msg, null);
      }
    },
    Uri_parseIPv6Address_parseHex: {
      "^": "Closure:70;error,host",
      call$2: function(start, end) {
        var value, t1;
        if (J.$gt$n(J.$sub$n(end, start), 4))
          this.error.call$2("an IPv6 part can only contain a maximum of 4 hex digits", start);
        value = P.int_parse(J.substring$2$s(this.host, start, end), null, 16);
        t1 = J.getInterceptor$n(value);
        if (t1.$lt(value, 0) || t1.$gt(value, 65535))
          this.error.call$2("each part must be in the range of `0x0..0xFFFF`", start);
        return value;
      }
    },
    _Uri: {
      "^": "Object;scheme<,_userInfo,_host,_port,path>,_query,_fragment,_pathSegments,_text,_hashCodeCache,_queryParameters,_queryParameterLists",
      get$userInfo: function() {
        return this._userInfo;
      },
      get$host: function() {
        var t1 = this._host;
        if (t1 == null)
          return "";
        if (C.JSString_methods.startsWith$1(t1, "["))
          return C.JSString_methods.substring$2(t1, 1, t1.length - 1);
        return t1;
      },
      get$port: function() {
        var t1 = this._port;
        if (t1 == null)
          return P._Uri__defaultPort(this.scheme);
        return t1;
      },
      get$query: function() {
        var t1 = this._query;
        return t1 == null ? "" : t1;
      },
      get$fragment: function() {
        var t1 = this._fragment;
        return t1 == null ? "" : t1;
      },
      get$pathSegments: function() {
        var result, pathToSplit, t1;
        result = this._pathSegments;
        if (result != null)
          return result;
        pathToSplit = this.path;
        t1 = J.getInterceptor$asx(pathToSplit);
        if (t1.get$isNotEmpty(pathToSplit) && t1.codeUnitAt$1(pathToSplit, 0) === 47)
          pathToSplit = t1.substring$1(pathToSplit, 1);
        t1 = J.getInterceptor(pathToSplit);
        if (t1.$eq(pathToSplit, "") === true)
          result = C.List_empty0;
        else {
          t1 = t1.split$1(pathToSplit, "/");
          result = P.List_List$unmodifiable(new H.MappedListIterable(t1, P.core_Uri_decodeComponent$closure(), [H.getTypeArgumentByIndex(t1, 0), null]), P.String);
        }
        this._pathSegments = result;
        return result;
      },
      _mergePaths$2: function(base, reference) {
        var t1, backCount, refStart, t2, baseEnd, t3, newEnd, t4, delta, t5;
        for (t1 = J.getInterceptor$s(reference), backCount = 0, refStart = 0; t1.startsWith$2(reference, "../", refStart);) {
          refStart += 3;
          ++backCount;
        }
        t2 = J.getInterceptor$asx(base);
        baseEnd = t2.lastIndexOf$1(base, "/");
        while (true) {
          t3 = J.getInterceptor$n(baseEnd);
          if (!(t3.$gt(baseEnd, 0) && backCount > 0))
            break;
          newEnd = t2.lastIndexOf$2(base, "/", t3.$sub(baseEnd, 1));
          t4 = J.getInterceptor$n(newEnd);
          if (t4.$lt(newEnd, 0))
            break;
          delta = t3.$sub(baseEnd, newEnd);
          t5 = J.getInterceptor(delta);
          if (t5.$eq(delta, 2) || t5.$eq(delta, 3))
            if (t2.codeUnitAt$1(base, t4.$add(newEnd, 1)) === 46)
              t4 = t5.$eq(delta, 2) || t2.codeUnitAt$1(base, t4.$add(newEnd, 2)) === 46;
            else
              t4 = false;
          else
            t4 = false;
          if (t4)
            break;
          --backCount;
          baseEnd = newEnd;
        }
        return t2.replaceRange$3(base, t3.$add(baseEnd, 1), null, t1.substring$1(reference, refStart - 3 * backCount));
      },
      resolve$1: function(reference) {
        return this.resolveUri$1(P.Uri_parse(reference, 0, null));
      },
      resolveUri$1: function(reference) {
        var targetScheme, targetUserInfo, targetHost, targetPort, targetPath, targetQuery, t1, t2, t3, mergedPath;
        if (reference.get$scheme().length !== 0) {
          targetScheme = reference.get$scheme();
          if (reference.get$hasAuthority()) {
            targetUserInfo = reference.get$userInfo();
            targetHost = reference.get$host();
            targetPort = reference.get$hasPort() ? reference.get$port() : null;
          } else {
            targetUserInfo = "";
            targetHost = null;
            targetPort = null;
          }
          targetPath = P._Uri__removeDotSegments(J.get$path$x(reference));
          targetQuery = reference.get$hasQuery() ? reference.get$query() : null;
        } else {
          targetScheme = this.scheme;
          if (reference.get$hasAuthority()) {
            targetUserInfo = reference.get$userInfo();
            targetHost = reference.get$host();
            targetPort = P._Uri__makePort(reference.get$hasPort() ? reference.get$port() : null, targetScheme);
            targetPath = P._Uri__removeDotSegments(J.get$path$x(reference));
            targetQuery = reference.get$hasQuery() ? reference.get$query() : null;
          } else {
            targetUserInfo = this._userInfo;
            targetHost = this._host;
            targetPort = this._port;
            t1 = J.getInterceptor$x(reference);
            if (J.$eq$(t1.get$path(reference), "") === true) {
              targetPath = this.path;
              targetQuery = reference.get$hasQuery() ? reference.get$query() : this._query;
            } else {
              if (reference.get$hasAbsolutePath())
                targetPath = P._Uri__removeDotSegments(t1.get$path(reference));
              else {
                t2 = this.path;
                t3 = J.getInterceptor$asx(t2);
                if (t3.get$isEmpty(t2) === true)
                  if (targetHost == null)
                    targetPath = targetScheme.length === 0 ? t1.get$path(reference) : P._Uri__removeDotSegments(t1.get$path(reference));
                  else
                    targetPath = P._Uri__removeDotSegments(C.JSString_methods.$add("/", t1.get$path(reference)));
                else {
                  mergedPath = this._mergePaths$2(t2, t1.get$path(reference));
                  t1 = targetScheme.length === 0;
                  if (!t1 || targetHost != null || t3.startsWith$1(t2, "/"))
                    targetPath = P._Uri__removeDotSegments(mergedPath);
                  else
                    targetPath = P._Uri__normalizeRelativePath(mergedPath, !t1 || targetHost != null);
                }
              }
              targetQuery = reference.get$hasQuery() ? reference.get$query() : null;
            }
          }
        }
        return new P._Uri(targetScheme, targetUserInfo, targetHost, targetPort, targetPath, targetQuery, reference.get$hasFragment() ? reference.get$fragment() : null, null, null, null, null, null);
      },
      get$hasAuthority: function() {
        return this._host != null;
      },
      get$hasPort: function() {
        return this._port != null;
      },
      get$hasQuery: function() {
        return this._query != null;
      },
      get$hasFragment: function() {
        return this._fragment != null;
      },
      get$hasAbsolutePath: function() {
        return J.startsWith$1$s(this.path, "/");
      },
      toFilePath$1$windows: function(windows) {
        var t1, pathSegments;
        t1 = this.scheme;
        if (t1 !== "" && t1 !== "file")
          throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a " + H.S(t1) + " URI"));
        t1 = this._query;
        if ((t1 == null ? "" : t1) !== "")
          throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a URI with a query component"));
        t1 = this._fragment;
        if ((t1 == null ? "" : t1) !== "")
          throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a URI with a fragment component"));
        windows = $.$get$_Uri__isWindowsCached();
        if (windows === true)
          t1 = P._Uri__toWindowsFilePath(this);
        else {
          if (this._host != null && this.get$host() !== "")
            H.throwExpression(P.UnsupportedError$("Cannot extract a non-Windows file path from a file URI with an authority"));
          pathSegments = this.get$pathSegments();
          P._Uri__checkNonWindowsPathReservedCharacters(pathSegments, false);
          t1 = P.StringBuffer__writeAll(J.startsWith$1$s(this.path, "/") ? "/" : "", pathSegments, "/");
          t1 = t1.charCodeAt(0) == 0 ? t1 : t1;
        }
        return t1;
      },
      toFilePath$0: function() {
        return this.toFilePath$1$windows(null);
      },
      get$data: function(_) {
        return this.scheme === "data" ? P.UriData_UriData$fromUri(this) : null;
      },
      toString$0: function(_) {
        var t1, t2, t3, t4;
        t1 = this._text;
        if (t1 == null) {
          t1 = this.scheme;
          t2 = t1.length !== 0 ? H.S(t1) + ":" : "";
          t3 = this._host;
          t4 = t3 == null;
          if (!t4 || t1 === "file") {
            t1 = t2 + "//";
            t2 = this._userInfo;
            if (t2.length !== 0)
              t1 = t1 + H.S(t2) + "@";
            if (!t4)
              t1 += t3;
            t2 = this._port;
            if (t2 != null)
              t1 = t1 + ":" + H.S(t2);
          } else
            t1 = t2;
          t1 += H.S(this.path);
          t2 = this._query;
          if (t2 != null)
            t1 = t1 + "?" + H.S(t2);
          t2 = this._fragment;
          if (t2 != null)
            t1 = t1 + "#" + t2;
          t1 = t1.charCodeAt(0) == 0 ? t1 : t1;
          this._text = t1;
        }
        return t1;
      },
      $eq: function(_, other) {
        var t1, t2, t3;
        if (other == null)
          return false;
        if (this === other)
          return true;
        t1 = J.getInterceptor(other);
        if (!!t1.$isUri) {
          t2 = this.scheme;
          t3 = other.get$scheme();
          if (t2 == null ? t3 == null : t2 === t3)
            if (this._host != null === other.get$hasAuthority()) {
              t2 = this._userInfo;
              t3 = other.get$userInfo();
              if (t2 == null ? t3 == null : t2 === t3) {
                t2 = this.get$host();
                t3 = other.get$host();
                if (t2 == null ? t3 == null : t2 === t3)
                  if (J.$eq$(this.get$port(), other.get$port()) === true)
                    if (J.$eq$(this.path, t1.get$path(other)) === true) {
                      t1 = this._query;
                      t2 = t1 == null;
                      if (!t2 === other.get$hasQuery()) {
                        if (t2)
                          t1 = "";
                        if (t1 === other.get$query()) {
                          t1 = this._fragment;
                          t2 = t1 == null;
                          if (!t2 === other.get$hasFragment()) {
                            if (t2)
                              t1 = "";
                            t1 = t1 === other.get$fragment();
                          } else
                            t1 = false;
                        } else
                          t1 = false;
                      } else
                        t1 = false;
                    } else
                      t1 = false;
                  else
                    t1 = false;
                else
                  t1 = false;
              } else
                t1 = false;
            } else
              t1 = false;
          else
            t1 = false;
          return t1;
        }
        return false;
      },
      get$hashCode: function(_) {
        var t1 = this._hashCodeCache;
        if (t1 == null) {
          t1 = C.JSString_methods.get$hashCode(this.toString$0(0));
          this._hashCodeCache = t1;
        }
        return t1;
      },
      $isUri: 1,
      static: {
        _Uri__uriEncode: function(canonicalTable, text, encoding, spaceToPlus) {
          var t1, bytes, i, t2, byte, t3;
          if (encoding === C.Utf8Codec_false) {
            t1 = $.$get$_Uri__needsNoEncoding()._nativeRegExp;
            if (typeof text !== "string")
              H.throwExpression(H.argumentErrorValue(text));
            t1 = t1.test(text);
          } else
            t1 = false;
          if (t1)
            return text;
          bytes = encoding.get$encoder().convert$1(text);
          for (t1 = bytes.length, i = 0, t2 = ""; i < t1; ++i) {
            byte = bytes[i];
            if (byte < 128) {
              t3 = byte >>> 4;
              if (t3 >= 8)
                return H.ioore(canonicalTable, t3);
              t3 = (canonicalTable[t3] & 1 << (byte & 15)) !== 0;
            } else
              t3 = false;
            if (t3)
              t2 += H.Primitives_stringFromCharCode(byte);
            else
              t2 = spaceToPlus && byte === 32 ? t2 + "+" : t2 + "%" + "0123456789ABCDEF"[byte >>> 4 & 15] + "0123456789ABCDEF"[byte & 15];
          }
          return t2.charCodeAt(0) == 0 ? t2 : t2;
        },
        _Uri__Uri$notSimple: function(uri, start, end, schemeEnd, hostStart, portStart, pathStart, queryStart, fragmentStart, scheme) {
          var t1, userInfoStart, userInfo, host, port, path, query;
          if (scheme == null) {
            t1 = J.getInterceptor$n(schemeEnd);
            if (t1.$gt(schemeEnd, start))
              scheme = P._Uri__makeScheme(uri, start, schemeEnd);
            else {
              if (t1.$eq(schemeEnd, start) === true)
                P._Uri__fail(uri, start, "Invalid empty scheme");
              scheme = "";
            }
          }
          t1 = J.getInterceptor$n(hostStart);
          if (t1.$gt(hostStart, start)) {
            userInfoStart = J.$add$ansx(schemeEnd, 3);
            userInfo = J.$lt$n(userInfoStart, hostStart) ? P._Uri__makeUserInfo(uri, userInfoStart, t1.$sub(hostStart, 1)) : "";
            host = P._Uri__makeHost(uri, hostStart, portStart, false);
            t1 = J.getInterceptor$ansx(portStart);
            port = J.$lt$n(t1.$add(portStart, 1), pathStart) ? P._Uri__makePort(P.int_parse(J.substring$2$s(uri, t1.$add(portStart, 1), pathStart), new P._Uri__Uri$notSimple_closure(uri, portStart), null), scheme) : null;
          } else {
            userInfo = "";
            host = null;
            port = null;
          }
          path = P._Uri__makePath(uri, pathStart, queryStart, null, scheme, host != null);
          t1 = J.getInterceptor$n(queryStart);
          query = t1.$lt(queryStart, fragmentStart) ? P._Uri__makeQuery(uri, t1.$add(queryStart, 1), fragmentStart, null) : null;
          t1 = J.getInterceptor$n(fragmentStart);
          return new P._Uri(scheme, userInfo, host, port, path, query, t1.$lt(fragmentStart, end) ? P._Uri__makeFragment(uri, t1.$add(fragmentStart, 1), end) : null, null, null, null, null, null);
        },
        _Uri__Uri: function(fragment, host, path, pathSegments, port, query, queryParameters, scheme, userInfo) {
          var isFile, t1, hasAuthority, t2;
          scheme = P._Uri__makeScheme(scheme, 0, scheme == null ? 0 : scheme.length);
          userInfo = P._Uri__makeUserInfo(userInfo, 0, 0);
          host = P._Uri__makeHost(host, 0, host == null ? 0 : J.get$length$asx(host), false);
          query = P._Uri__makeQuery(query, 0, 0, queryParameters);
          fragment = P._Uri__makeFragment(fragment, 0, 0);
          port = P._Uri__makePort(port, scheme);
          isFile = scheme === "file";
          if (host == null)
            t1 = userInfo.length !== 0 || port != null || isFile;
          else
            t1 = false;
          if (t1)
            host = "";
          t1 = host == null;
          hasAuthority = !t1;
          path = P._Uri__makePath(path, 0, path == null ? 0 : path.length, pathSegments, scheme, hasAuthority);
          t2 = scheme.length === 0;
          if (t2 && t1 && !J.startsWith$1$s(path, "/"))
            path = P._Uri__normalizeRelativePath(path, !t2 || hasAuthority);
          else
            path = P._Uri__removeDotSegments(path);
          return new P._Uri(scheme, userInfo, t1 && J.startsWith$1$s(path, "//") ? "" : host, port, path, query, fragment, null, null, null, null, null);
        },
        _Uri__defaultPort: function(scheme) {
          if (scheme === "http")
            return 80;
          if (scheme === "https")
            return 443;
          return 0;
        },
        _Uri__fail: function(uri, index, message) {
          throw H.wrapException(P.FormatException$(message, uri, index));
        },
        _Uri__Uri$file: function(path, windows) {
          return windows ? P._Uri__makeWindowsFileUrl(path, false) : P._Uri__makeFileUri(path, false);
        },
        _Uri__checkNonWindowsPathReservedCharacters: function(segments, argumentError) {
          C.JSArray_methods.forEach$1(segments, new P._Uri__checkNonWindowsPathReservedCharacters_closure(false));
        },
        _Uri__checkWindowsPathReservedCharacters: function(segments, argumentError, firstSegment) {
          var t1, segment;
          for (t1 = H.SubListIterable$(segments, firstSegment, null, H.getTypeArgumentByIndex(segments, 0)), t1 = new H.ListIterator(t1, t1.get$length(t1), 0, null, [H.getTypeArgumentByIndex(t1, 0)]); t1.moveNext$0();) {
            segment = t1.__internal$_current;
            if (J.contains$1$asx(segment, P.RegExp_RegExp('["*/:<>?\\\\|]', true, false)) === true)
              if (argumentError)
                throw H.wrapException(P.ArgumentError$("Illegal character in path"));
              else
                throw H.wrapException(P.UnsupportedError$("Illegal character in path: " + H.S(segment)));
          }
        },
        _Uri__checkWindowsDriveLetter: function(charCode, argumentError) {
          var t1;
          if (!(65 <= charCode && charCode <= 90))
            t1 = 97 <= charCode && charCode <= 122;
          else
            t1 = true;
          if (t1)
            return;
          if (argumentError)
            throw H.wrapException(P.ArgumentError$("Illegal drive letter " + P.String_String$fromCharCode(charCode)));
          else
            throw H.wrapException(P.UnsupportedError$("Illegal drive letter " + P.String_String$fromCharCode(charCode)));
        },
        _Uri__makeFileUri: function(path, slashTerminated) {
          var segments = H.setRuntimeTypeInfo(path.split("/"), [P.String]);
          if (C.JSString_methods.startsWith$1(path, "/"))
            return P._Uri__Uri(null, null, null, segments, null, null, null, "file", null);
          else
            return P._Uri__Uri(null, null, null, segments, null, null, null, null, null);
        },
        _Uri__makeWindowsFileUrl: function(path, slashTerminated) {
          var t1, pathSegments, pathStart, hostPart;
          if (J.startsWith$1$s(path, "\\\\?\\"))
            if (C.JSString_methods.startsWith$2(path, "UNC\\", 4))
              path = C.JSString_methods.replaceRange$3(path, 0, 7, "\\");
            else {
              path = C.JSString_methods.substring$1(path, 4);
              if (path.length < 3 || C.JSString_methods._codeUnitAt$1(path, 1) !== 58 || C.JSString_methods._codeUnitAt$1(path, 2) !== 92)
                throw H.wrapException(P.ArgumentError$("Windows paths with \\\\?\\ prefix must be absolute"));
            }
          else
            path = H.stringReplaceAllUnchecked(path, "/", "\\");
          t1 = path.length;
          if (t1 > 1 && C.JSString_methods._codeUnitAt$1(path, 1) === 58) {
            P._Uri__checkWindowsDriveLetter(C.JSString_methods._codeUnitAt$1(path, 0), true);
            if (t1 === 2 || C.JSString_methods._codeUnitAt$1(path, 2) !== 92)
              throw H.wrapException(P.ArgumentError$("Windows paths with drive letter must be absolute"));
            pathSegments = H.setRuntimeTypeInfo(path.split("\\"), [P.String]);
            P._Uri__checkWindowsPathReservedCharacters(pathSegments, true, 1);
            return P._Uri__Uri(null, null, null, pathSegments, null, null, null, "file", null);
          }
          if (C.JSString_methods.startsWith$1(path, "\\"))
            if (C.JSString_methods.startsWith$2(path, "\\", 1)) {
              pathStart = C.JSString_methods.indexOf$2(path, "\\", 2);
              t1 = pathStart < 0;
              hostPart = t1 ? C.JSString_methods.substring$1(path, 2) : C.JSString_methods.substring$2(path, 2, pathStart);
              pathSegments = H.setRuntimeTypeInfo((t1 ? "" : C.JSString_methods.substring$1(path, pathStart + 1)).split("\\"), [P.String]);
              P._Uri__checkWindowsPathReservedCharacters(pathSegments, true, 0);
              return P._Uri__Uri(null, hostPart, null, pathSegments, null, null, null, "file", null);
            } else {
              pathSegments = H.setRuntimeTypeInfo(path.split("\\"), [P.String]);
              P._Uri__checkWindowsPathReservedCharacters(pathSegments, true, 0);
              return P._Uri__Uri(null, null, null, pathSegments, null, null, null, "file", null);
            }
          else {
            pathSegments = H.setRuntimeTypeInfo(path.split("\\"), [P.String]);
            P._Uri__checkWindowsPathReservedCharacters(pathSegments, true, 0);
            return P._Uri__Uri(null, null, null, pathSegments, null, null, null, null, null);
          }
        },
        _Uri__makePort: function(port, scheme) {
          if (port != null && J.$eq$(port, P._Uri__defaultPort(scheme)) === true)
            return;
          return port;
        },
        _Uri__makeHost: function(host, start, end, strictIPv6) {
          var t1, t2, t3, i;
          if (host == null)
            return;
          t1 = J.getInterceptor(start);
          if (t1.$eq(start, end))
            return "";
          t2 = J.getInterceptor$s(host);
          if (t2.codeUnitAt$1(host, start) === 91) {
            t3 = J.getInterceptor$n(end);
            if (t2.codeUnitAt$1(host, t3.$sub(end, 1)) !== 93)
              P._Uri__fail(host, start, "Missing end `]` to match `[` in host");
            P.Uri_parseIPv6Address(host, t1.$add(start, 1), t3.$sub(end, 1));
            return t2.substring$2(host, start, end).toLowerCase();
          }
          for (i = start; t1 = J.getInterceptor$n(i), t1.$lt(i, end); i = t1.$add(i, 1))
            if (t2.codeUnitAt$1(host, i) === 58) {
              P.Uri_parseIPv6Address(host, start, end);
              return "[" + H.S(host) + "]";
            }
          return P._Uri__normalizeRegName(host, start, end);
        },
        _Uri__normalizeRegName: function(host, start, end) {
          var t1, index, sectionStart, buffer, isNormalized, t2, char, replacement, t3, slice, sourceLength, tail;
          for (t1 = J.getInterceptor$s(host), index = start, sectionStart = index, buffer = null, isNormalized = true; t2 = J.getInterceptor$n(index), t2.$lt(index, end);) {
            char = t1.codeUnitAt$1(host, index);
            if (char === 37) {
              replacement = P._Uri__normalizeEscape(host, index, true);
              t3 = replacement == null;
              if (t3 && isNormalized) {
                index = t2.$add(index, 3);
                continue;
              }
              if (buffer == null)
                buffer = new P.StringBuffer("");
              slice = t1.substring$2(host, sectionStart, index);
              buffer._contents += !isNormalized ? slice.toLowerCase() : slice;
              if (t3) {
                replacement = t1.substring$2(host, index, t2.$add(index, 3));
                sourceLength = 3;
              } else if (replacement === "%") {
                replacement = "%25";
                sourceLength = 1;
              } else
                sourceLength = 3;
              buffer._contents += replacement;
              index = t2.$add(index, sourceLength);
              sectionStart = index;
              isNormalized = true;
            } else {
              if (char < 127) {
                t3 = char >>> 4;
                if (t3 >= 8)
                  return H.ioore(C.List_qNA, t3);
                t3 = (C.List_qNA[t3] & 1 << (char & 15)) !== 0;
              } else
                t3 = false;
              if (t3) {
                if (isNormalized && 65 <= char && 90 >= char) {
                  if (buffer == null)
                    buffer = new P.StringBuffer("");
                  if (J.$lt$n(sectionStart, index)) {
                    buffer._contents += t1.substring$2(host, sectionStart, index);
                    sectionStart = index;
                  }
                  isNormalized = false;
                }
                index = t2.$add(index, 1);
              } else {
                if (char <= 93) {
                  t3 = char >>> 4;
                  if (t3 >= 8)
                    return H.ioore(C.List_2Vk, t3);
                  t3 = (C.List_2Vk[t3] & 1 << (char & 15)) !== 0;
                } else
                  t3 = false;
                if (t3)
                  P._Uri__fail(host, index, "Invalid character");
                else {
                  if ((char & 64512) === 55296 && J.$lt$n(t2.$add(index, 1), end)) {
                    tail = t1.codeUnitAt$1(host, t2.$add(index, 1));
                    if ((tail & 64512) === 56320) {
                      char = 65536 | (char & 1023) << 10 | tail & 1023;
                      sourceLength = 2;
                    } else
                      sourceLength = 1;
                  } else
                    sourceLength = 1;
                  if (buffer == null)
                    buffer = new P.StringBuffer("");
                  slice = t1.substring$2(host, sectionStart, index);
                  buffer._contents += !isNormalized ? slice.toLowerCase() : slice;
                  buffer._contents += P._Uri__escapeChar(char);
                  index = t2.$add(index, sourceLength);
                  sectionStart = index;
                }
              }
            }
          }
          if (buffer == null)
            return t1.substring$2(host, start, end);
          if (J.$lt$n(sectionStart, end)) {
            slice = t1.substring$2(host, sectionStart, end);
            buffer._contents += !isNormalized ? slice.toLowerCase() : slice;
          }
          t1 = buffer._contents;
          return t1.charCodeAt(0) == 0 ? t1 : t1;
        },
        _Uri__makeScheme: function(scheme, start, end) {
          var t1, i, containsUpperCase, codeUnit, t2;
          if (start === end)
            return "";
          t1 = J.getInterceptor$s(scheme);
          if (!P._Uri__isAlphabeticCharacter(t1.codeUnitAt$1(scheme, start)))
            P._Uri__fail(scheme, start, "Scheme not starting with alphabetic character");
          if (typeof end !== "number")
            return H.iae(end);
          i = start;
          containsUpperCase = false;
          for (; i < end; ++i) {
            codeUnit = t1.codeUnitAt$1(scheme, i);
            if (codeUnit < 128) {
              t2 = codeUnit >>> 4;
              if (t2 >= 8)
                return H.ioore(C.List_JYB, t2);
              t2 = (C.List_JYB[t2] & 1 << (codeUnit & 15)) !== 0;
            } else
              t2 = false;
            if (!t2)
              P._Uri__fail(scheme, i, "Illegal scheme character");
            if (65 <= codeUnit && codeUnit <= 90)
              containsUpperCase = true;
          }
          scheme = t1.substring$2(scheme, start, end);
          return P._Uri__canonicalizeScheme(containsUpperCase ? scheme.toLowerCase() : scheme);
        },
        _Uri__canonicalizeScheme: function(scheme) {
          if (scheme === "http")
            return "http";
          if (scheme === "file")
            return "file";
          if (scheme === "https")
            return "https";
          if (scheme === "package")
            return "package";
          return scheme;
        },
        _Uri__makeUserInfo: function(userInfo, start, end) {
          if (userInfo == null)
            return "";
          return P._Uri__normalizeOrSubstring(userInfo, start, end, C.List_gRj);
        },
        _Uri__makePath: function(path, start, end, pathSegments, scheme, hasAuthority) {
          var isFile, ensureLeadingSlash, t1, result;
          isFile = scheme === "file";
          ensureLeadingSlash = isFile || hasAuthority;
          t1 = path == null;
          if (t1 && pathSegments == null)
            return isFile ? "/" : "";
          t1 = !t1;
          if (t1 && pathSegments != null)
            throw H.wrapException(P.ArgumentError$("Both path and pathSegments specified"));
          if (t1)
            result = P._Uri__normalizeOrSubstring(path, start, end, C.List_qg4);
          else {
            pathSegments.toString;
            result = new H.MappedListIterable(pathSegments, new P._Uri__makePath_closure(), [H.getTypeArgumentByIndex(pathSegments, 0), null]).join$1(0, "/");
          }
          if (result.length === 0) {
            if (isFile)
              return "/";
          } else if (ensureLeadingSlash && !C.JSString_methods.startsWith$1(result, "/"))
            result = "/" + result;
          return P._Uri__normalizePath(result, scheme, hasAuthority);
        },
        _Uri__normalizePath: function(path, scheme, hasAuthority) {
          var t1 = scheme.length === 0;
          if (t1 && !hasAuthority && !C.JSString_methods.startsWith$1(path, "/"))
            return P._Uri__normalizeRelativePath(path, !t1 || hasAuthority);
          return P._Uri__removeDotSegments(path);
        },
        _Uri__makeQuery: function(query, start, end, queryParameters) {
          if (query != null)
            return P._Uri__normalizeOrSubstring(query, start, end, C.List_CVk);
          return;
        },
        _Uri__makeFragment: function(fragment, start, end) {
          if (fragment == null)
            return;
          return P._Uri__normalizeOrSubstring(fragment, start, end, C.List_CVk);
        },
        _Uri__normalizeEscape: function(source, index, lowerCase) {
          var t1, t2, firstDigit, secondDigit, firstDigitValue, secondDigitValue, value, t3;
          t1 = J.getInterceptor$ansx(index);
          t2 = J.getInterceptor$asx(source);
          if (J.$ge$n(t1.$add(index, 2), t2.get$length(source)))
            return "%";
          firstDigit = t2.codeUnitAt$1(source, t1.$add(index, 1));
          secondDigit = t2.codeUnitAt$1(source, t1.$add(index, 2));
          firstDigitValue = H.hexDigitValue(firstDigit);
          secondDigitValue = H.hexDigitValue(secondDigit);
          if (firstDigitValue < 0 || secondDigitValue < 0)
            return "%";
          value = firstDigitValue * 16 + secondDigitValue;
          if (value < 127) {
            t3 = C.JSInt_methods._shrOtherPositive$1(value, 4);
            if (t3 >= 8)
              return H.ioore(C.List_nxB, t3);
            t3 = (C.List_nxB[t3] & 1 << (value & 15)) !== 0;
          } else
            t3 = false;
          if (t3)
            return H.Primitives_stringFromCharCode(lowerCase && 65 <= value && 90 >= value ? (value | 32) >>> 0 : value);
          if (firstDigit >= 97 || secondDigit >= 97)
            return t2.substring$2(source, index, t1.$add(index, 3)).toUpperCase();
          return;
        },
        _Uri__escapeChar: function(char) {
          var codeUnits, flag, encodedBytes, t1, index, byte, t2, t3;
          if (char < 128) {
            codeUnits = new Array(3);
            codeUnits.fixed$length = Array;
            codeUnits[0] = 37;
            codeUnits[1] = C.JSString_methods._codeUnitAt$1("0123456789ABCDEF", char >>> 4);
            codeUnits[2] = C.JSString_methods._codeUnitAt$1("0123456789ABCDEF", char & 15);
          } else {
            if (char > 2047)
              if (char > 65535) {
                flag = 240;
                encodedBytes = 4;
              } else {
                flag = 224;
                encodedBytes = 3;
              }
            else {
              flag = 192;
              encodedBytes = 2;
            }
            t1 = 3 * encodedBytes;
            codeUnits = new Array(t1);
            codeUnits.fixed$length = Array;
            for (index = 0; --encodedBytes, encodedBytes >= 0; flag = 128) {
              byte = C.JSInt_methods._shrReceiverPositive$1(char, 6 * encodedBytes) & 63 | flag;
              if (index >= t1)
                return H.ioore(codeUnits, index);
              codeUnits[index] = 37;
              t2 = index + 1;
              t3 = C.JSString_methods._codeUnitAt$1("0123456789ABCDEF", byte >>> 4);
              if (t2 >= t1)
                return H.ioore(codeUnits, t2);
              codeUnits[t2] = t3;
              t3 = index + 2;
              t2 = C.JSString_methods._codeUnitAt$1("0123456789ABCDEF", byte & 15);
              if (t3 >= t1)
                return H.ioore(codeUnits, t3);
              codeUnits[t3] = t2;
              index += 3;
            }
          }
          return P.String_String$fromCharCodes(codeUnits, 0, null);
        },
        _Uri__normalizeOrSubstring: function(component, start, end, charTable) {
          var t1 = P._Uri__normalize(component, start, end, charTable, false);
          return t1 == null ? J.substring$2$s(component, start, end) : t1;
        },
        _Uri__normalize: function(component, start, end, charTable, escapeDelimiters) {
          var t1, t2, index, sectionStart, buffer, t3, char, t4, replacement, sourceLength, tail;
          for (t1 = J.getInterceptor$s(component), t2 = !escapeDelimiters, index = start, sectionStart = index, buffer = null; t3 = J.getInterceptor$n(index), t3.$lt(index, end);) {
            char = t1.codeUnitAt$1(component, index);
            if (char < 127) {
              t4 = char >>> 4;
              if (t4 >= 8)
                return H.ioore(charTable, t4);
              t4 = (charTable[t4] & 1 << (char & 15)) !== 0;
            } else
              t4 = false;
            if (t4)
              index = t3.$add(index, 1);
            else {
              if (char === 37) {
                replacement = P._Uri__normalizeEscape(component, index, false);
                if (replacement == null) {
                  index = t3.$add(index, 3);
                  continue;
                }
                if ("%" === replacement) {
                  replacement = "%25";
                  sourceLength = 1;
                } else
                  sourceLength = 3;
              } else {
                if (t2)
                  if (char <= 93) {
                    t4 = char >>> 4;
                    if (t4 >= 8)
                      return H.ioore(C.List_2Vk, t4);
                    t4 = (C.List_2Vk[t4] & 1 << (char & 15)) !== 0;
                  } else
                    t4 = false;
                else
                  t4 = false;
                if (t4) {
                  P._Uri__fail(component, index, "Invalid character");
                  replacement = null;
                  sourceLength = null;
                } else {
                  if ((char & 64512) === 55296)
                    if (J.$lt$n(t3.$add(index, 1), end)) {
                      tail = t1.codeUnitAt$1(component, t3.$add(index, 1));
                      if ((tail & 64512) === 56320) {
                        char = 65536 | (char & 1023) << 10 | tail & 1023;
                        sourceLength = 2;
                      } else
                        sourceLength = 1;
                    } else
                      sourceLength = 1;
                  else
                    sourceLength = 1;
                  replacement = P._Uri__escapeChar(char);
                }
              }
              if (buffer == null)
                buffer = new P.StringBuffer("");
              buffer._contents += t1.substring$2(component, sectionStart, index);
              buffer._contents += H.S(replacement);
              index = t3.$add(index, sourceLength);
              sectionStart = index;
            }
          }
          if (buffer == null)
            return;
          if (J.$lt$n(sectionStart, end))
            buffer._contents += t1.substring$2(component, sectionStart, end);
          t1 = buffer._contents;
          return t1.charCodeAt(0) == 0 ? t1 : t1;
        },
        _Uri__mayContainDotSegments: function(path) {
          var t1 = J.getInterceptor$s(path);
          if (t1.startsWith$1(path, "."))
            return true;
          return t1.indexOf$1(path, "/.") !== -1;
        },
        _Uri__removeDotSegments: function(path) {
          var output, t1, t2, appendSlash, _i, segment, t3;
          if (!P._Uri__mayContainDotSegments(path))
            return path;
          output = [];
          for (t1 = J.split$1$s(path, "/"), t2 = t1.length, appendSlash = false, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
            segment = t1[_i];
            if (J.$eq$(segment, "..") === true) {
              t3 = output.length;
              if (t3 !== 0) {
                if (0 >= t3)
                  return H.ioore(output, -1);
                output.pop();
                if (output.length === 0)
                  output.push("");
              }
              appendSlash = true;
            } else if ("." === segment)
              appendSlash = true;
            else {
              output.push(segment);
              appendSlash = false;
            }
          }
          if (appendSlash)
            output.push("");
          return C.JSArray_methods.join$1(output, "/");
        },
        _Uri__normalizeRelativePath: function(path, allowScheme) {
          var output, t1, t2, appendSlash, _i, segment;
          if (!P._Uri__mayContainDotSegments(path))
            return !allowScheme ? P._Uri__escapeScheme(path) : path;
          output = [];
          for (t1 = J.split$1$s(path, "/"), t2 = t1.length, appendSlash = false, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
            segment = t1[_i];
            if (".." === segment)
              if (output.length !== 0 && J.$eq$(C.JSArray_methods.get$last(output), "..") !== true) {
                if (0 >= output.length)
                  return H.ioore(output, -1);
                output.pop();
                appendSlash = true;
              } else {
                output.push("..");
                appendSlash = false;
              }
            else if ("." === segment)
              appendSlash = true;
            else {
              output.push(segment);
              appendSlash = false;
            }
          }
          t1 = output.length;
          if (t1 !== 0)
            if (t1 === 1) {
              if (0 >= t1)
                return H.ioore(output, 0);
              t1 = J.get$isEmpty$asx(output[0]) === true;
            } else
              t1 = false;
          else
            t1 = true;
          if (t1)
            return "./";
          if (appendSlash || J.$eq$(C.JSArray_methods.get$last(output), "..") === true)
            output.push("");
          if (!allowScheme) {
            if (0 >= output.length)
              return H.ioore(output, 0);
            t1 = P._Uri__escapeScheme(output[0]);
            if (0 >= output.length)
              return H.ioore(output, 0);
            output[0] = t1;
          }
          return C.JSArray_methods.join$1(output, "/");
        },
        _Uri__escapeScheme: function(path) {
          var t1, i, t2, char;
          t1 = J.getInterceptor$asx(path);
          if (J.$ge$n(t1.get$length(path), 2) && P._Uri__isAlphabeticCharacter(t1.codeUnitAt$1(path, 0))) {
            i = 1;
            while (true) {
              t2 = t1.get$length(path);
              if (typeof t2 !== "number")
                return H.iae(t2);
              if (!(i < t2))
                break;
              char = t1.codeUnitAt$1(path, i);
              if (char === 58)
                return t1.substring$2(path, 0, i) + "%3A" + t1.substring$1(path, i + 1);
              if (char <= 127) {
                t2 = char >>> 4;
                if (t2 >= 8)
                  return H.ioore(C.List_JYB, t2);
                t2 = (C.List_JYB[t2] & 1 << (char & 15)) === 0;
              } else
                t2 = true;
              if (t2)
                break;
              ++i;
            }
          }
          return path;
        },
        _Uri__toWindowsFilePath: function(uri) {
          var segments, t1, hasDriveLetter, t2, host;
          segments = uri.get$pathSegments();
          t1 = segments.length;
          if (t1 > 0 && J.$eq$(J.get$length$asx(segments[0]), 2) === true && J.codeUnitAt$1$s(segments[0], 1) === 58) {
            if (0 >= t1)
              return H.ioore(segments, 0);
            P._Uri__checkWindowsDriveLetter(J.codeUnitAt$1$s(segments[0], 0), false);
            P._Uri__checkWindowsPathReservedCharacters(segments, false, 1);
            hasDriveLetter = true;
          } else {
            P._Uri__checkWindowsPathReservedCharacters(segments, false, 0);
            hasDriveLetter = false;
          }
          t2 = uri.get$hasAbsolutePath() && !hasDriveLetter ? "\\" : "";
          if (uri.get$hasAuthority()) {
            host = uri.get$host();
            if (host.length !== 0)
              t2 = t2 + "\\" + H.S(host) + "\\";
          }
          t2 = P.StringBuffer__writeAll(t2, segments, "\\");
          t1 = hasDriveLetter && t1 === 1 ? t2 + "\\" : t2;
          return t1.charCodeAt(0) == 0 ? t1 : t1;
        },
        _Uri__hexCharPairToByte: function(s, pos) {
          var t1, byte, i, charCode;
          for (t1 = J.getInterceptor$s(s), byte = 0, i = 0; i < 2; ++i) {
            charCode = t1.codeUnitAt$1(s, pos + i);
            if (48 <= charCode && charCode <= 57)
              byte = byte * 16 + charCode - 48;
            else {
              charCode |= 32;
              if (97 <= charCode && charCode <= 102)
                byte = byte * 16 + charCode - 87;
              else
                throw H.wrapException(P.ArgumentError$("Invalid URL encoding"));
            }
          }
          return byte;
        },
        _Uri__uriDecode: function(text, start, end, encoding, plusToSpace) {
          var t1, i, simple, codeUnit, t2, bytes;
          if (typeof end !== "number")
            return H.iae(end);
          t1 = J.getInterceptor$asx(text);
          i = start;
          while (true) {
            if (!(i < end)) {
              simple = true;
              break;
            }
            codeUnit = t1.codeUnitAt$1(text, i);
            if (codeUnit <= 127)
              if (codeUnit !== 37)
                t2 = false;
              else
                t2 = true;
            else
              t2 = true;
            if (t2) {
              simple = false;
              break;
            }
            ++i;
          }
          if (simple) {
            if (C.Utf8Codec_false !== encoding)
              t2 = false;
            else
              t2 = true;
            if (t2)
              return t1.substring$2(text, start, end);
            else
              bytes = new H.CodeUnits(t1.substring$2(text, start, end));
          } else {
            bytes = [];
            for (i = start; i < end; ++i) {
              codeUnit = t1.codeUnitAt$1(text, i);
              if (codeUnit > 127)
                throw H.wrapException(P.ArgumentError$("Illegal percent encoding in URI"));
              if (codeUnit === 37) {
                t2 = t1.get$length(text);
                if (typeof t2 !== "number")
                  return H.iae(t2);
                if (i + 3 > t2)
                  throw H.wrapException(P.ArgumentError$("Truncated URI"));
                bytes.push(P._Uri__hexCharPairToByte(text, i + 1));
                i += 2;
              } else
                bytes.push(codeUnit);
            }
          }
          return new P.Utf8Decoder(false).convert$1(bytes);
        },
        _Uri__isAlphabeticCharacter: function(codeUnit) {
          var lowerCase = codeUnit | 32;
          return 97 <= lowerCase && lowerCase <= 122;
        }
      }
    },
    _Uri__Uri$notSimple_closure: {
      "^": "Closure:0;uri,portStart",
      call$1: function(_) {
        throw H.wrapException(P.FormatException$("Invalid port", this.uri, J.$add$ansx(this.portStart, 1)));
      }
    },
    _Uri__checkNonWindowsPathReservedCharacters_closure: {
      "^": "Closure:0;argumentError",
      call$1: function(segment) {
        if (J.contains$1$asx(segment, "/") === true)
          if (this.argumentError)
            throw H.wrapException(P.ArgumentError$("Illegal path character " + H.S(segment)));
          else
            throw H.wrapException(P.UnsupportedError$("Illegal path character " + H.S(segment)));
      }
    },
    _Uri__makePath_closure: {
      "^": "Closure:0;",
      call$1: [function(s) {
        return P._Uri__uriEncode(C.List_qg40, s, C.Utf8Codec_false, false);
      }, null, null, 4, 0, null, 27, "call"]
    },
    UriData: {
      "^": "Object;_text,_separatorIndices,_uriCache",
      get$uri: function() {
        var t1, t2, t3, queryIndex, end, query;
        t1 = this._uriCache;
        if (t1 != null)
          return t1;
        t1 = this._separatorIndices;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t2 = this._text;
        t1 = t1[0] + 1;
        t3 = J.getInterceptor$asx(t2);
        queryIndex = t3.indexOf$2(t2, "?", t1);
        end = t3.get$length(t2);
        if (queryIndex >= 0) {
          query = P._Uri__normalizeOrSubstring(t2, queryIndex + 1, end, C.List_CVk);
          end = queryIndex;
        } else
          query = null;
        t1 = new P._DataUri(this, "data", null, null, null, P._Uri__normalizeOrSubstring(t2, t1, end, C.List_qg4), query, null, null, null, null, null, null);
        this._uriCache = t1;
        return t1;
      },
      toString$0: function(_) {
        var t1, t2;
        t1 = this._separatorIndices;
        if (0 >= t1.length)
          return H.ioore(t1, 0);
        t2 = this._text;
        return t1[0] === -1 ? "data:" + H.S(t2) : t2;
      },
      static: {
        UriData_UriData$fromUri: function(uri) {
          if (uri.scheme !== "data")
            throw H.wrapException(P.ArgumentError$value(uri, "uri", "Scheme must be 'data'"));
          if (uri._host != null)
            throw H.wrapException(P.ArgumentError$value(uri, "uri", "Data uri must not have authority"));
          if (uri._fragment != null)
            throw H.wrapException(P.ArgumentError$value(uri, "uri", "Data uri must not have a fragment part"));
          if (uri._query == null)
            return P.UriData__parse(uri.path, 0, uri);
          return P.UriData__parse(uri.toString$0(0), 5, uri);
        },
        UriData__writeUri: function(mimeType, charsetName, parameters, buffer, indices) {
          var t1, slashIndex;
          if (mimeType == null || mimeType === "text/plain")
            mimeType = "";
          if (mimeType.length === 0 || mimeType === "application/octet-stream")
            t1 = buffer._contents += mimeType;
          else {
            slashIndex = P.UriData__validateMimeType(mimeType);
            if (slashIndex < 0)
              throw H.wrapException(P.ArgumentError$value(mimeType, "mimeType", "Invalid MIME type"));
            t1 = buffer._contents += H.S(P._Uri__uriEncode(C.List_qFt, C.JSString_methods.substring$2(mimeType, 0, slashIndex), C.Utf8Codec_false, false));
            buffer._contents = t1 + "/";
            t1 = buffer._contents += H.S(P._Uri__uriEncode(C.List_qFt, C.JSString_methods.substring$1(mimeType, slashIndex + 1), C.Utf8Codec_false, false));
          }
          if (charsetName != null) {
            indices.push(t1.length);
            indices.push(buffer._contents.length + 8);
            buffer._contents += ";charset=";
            buffer._contents += H.S(P._Uri__uriEncode(C.List_qFt, charsetName, C.Utf8Codec_false, false));
          }
        },
        UriData__validateMimeType: function(mimeType) {
          var t1, slashIndex, i;
          for (t1 = mimeType.length, slashIndex = -1, i = 0; i < t1; ++i) {
            if (C.JSString_methods._codeUnitAt$1(mimeType, i) !== 47)
              continue;
            if (slashIndex < 0) {
              slashIndex = i;
              continue;
            }
            return -1;
          }
          return slashIndex;
        },
        UriData__parse: function(text, start, sourceUri) {
          var indices, t1, i, slashIndex, char, t2, equalsIndex, lastSeparator, data;
          indices = [start - 1];
          t1 = J.getInterceptor$asx(text);
          i = start;
          slashIndex = -1;
          char = null;
          while (true) {
            t2 = t1.get$length(text);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            c$0: {
              char = t1.codeUnitAt$1(text, i);
              if (char === 44 || char === 59)
                break;
              if (char === 47) {
                if (slashIndex < 0) {
                  slashIndex = i;
                  break c$0;
                }
                throw H.wrapException(P.FormatException$("Invalid MIME type", text, i));
              }
            }
            ++i;
          }
          if (slashIndex < 0 && i > start)
            throw H.wrapException(P.FormatException$("Invalid MIME type", text, i));
          for (; char !== 44;) {
            indices.push(i);
            ++i;
            equalsIndex = -1;
            while (true) {
              t2 = t1.get$length(text);
              if (typeof t2 !== "number")
                return H.iae(t2);
              if (!(i < t2))
                break;
              char = t1.codeUnitAt$1(text, i);
              if (char === 61) {
                if (equalsIndex < 0)
                  equalsIndex = i;
              } else if (char === 59 || char === 44)
                break;
              ++i;
            }
            if (equalsIndex >= 0)
              indices.push(equalsIndex);
            else {
              lastSeparator = C.JSArray_methods.get$last(indices);
              if (char !== 44 || i !== lastSeparator + 7 || !t1.startsWith$2(text, "base64", lastSeparator + 1))
                throw H.wrapException(P.FormatException$("Expecting '='", text, i));
              break;
            }
          }
          indices.push(i);
          t2 = i + 1;
          if ((indices.length & 1) === 1)
            text = C.Base64Codec_Base64Encoder_false.normalize$3(text, t2, t1.get$length(text));
          else {
            data = P._Uri__normalize(text, t2, t1.get$length(text), C.List_CVk, true);
            if (data != null)
              text = t1.replaceRange$3(text, t2, t1.get$length(text), data);
          }
          return new P.UriData(text, indices, sourceUri);
        },
        UriData__uriEncodeBytes: function(canonicalTable, bytes, buffer) {
          var t1, byteOr, i, t2, byte;
          t1 = J.getInterceptor$asx(bytes);
          byteOr = 0;
          i = 0;
          while (true) {
            t2 = t1.get$length(bytes);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            byte = t1.$index(bytes, i);
            if (typeof byte !== "number")
              return H.iae(byte);
            byteOr |= byte;
            if (byte < 128) {
              t2 = C.JSNumber_methods._shrOtherPositive$1(byte, 4);
              if (t2 >= 8)
                return H.ioore(canonicalTable, t2);
              t2 = (canonicalTable[t2] & 1 << (byte & 15)) !== 0;
            } else
              t2 = false;
            if (t2)
              buffer._contents += H.Primitives_stringFromCharCode(byte);
            else {
              buffer._contents += H.Primitives_stringFromCharCode(37);
              buffer._contents += H.Primitives_stringFromCharCode(C.JSString_methods._codeUnitAt$1("0123456789ABCDEF", C.JSNumber_methods._shrOtherPositive$1(byte, 4)));
              buffer._contents += H.Primitives_stringFromCharCode(C.JSString_methods._codeUnitAt$1("0123456789ABCDEF", byte & 15));
            }
            ++i;
          }
          if ((byteOr & 4294967040) >>> 0 !== 0) {
            i = 0;
            while (true) {
              t2 = t1.get$length(bytes);
              if (typeof t2 !== "number")
                return H.iae(t2);
              if (!(i < t2))
                break;
              byte = t1.$index(bytes, i);
              t2 = J.getInterceptor$n(byte);
              if (t2.$lt(byte, 0) || t2.$gt(byte, 255))
                throw H.wrapException(P.ArgumentError$value(byte, "non-byte value", null));
              ++i;
            }
          }
        }
      }
    },
    _createTables_closure: {
      "^": "Closure:0;",
      call$1: function(_) {
        return new Uint8Array(96);
      }
    },
    _createTables_build: {
      "^": "Closure:68;tables",
      call$2: function(state, defaultTransition) {
        var t1 = this.tables;
        if (state >= t1.length)
          return H.ioore(t1, state);
        t1 = t1[state];
        J.fillRange$3$ax(t1, 0, 96, defaultTransition);
        return t1;
      }
    },
    _createTables_setChars: {
      "^": "Closure:31;",
      call$3: function(target, chars, transition) {
        var t1, t2, i;
        for (t1 = chars.length, t2 = J.getInterceptor$ax(target), i = 0; i < t1; ++i)
          t2.$indexSet(target, C.JSString_methods._codeUnitAt$1(chars, i) ^ 96, transition);
      }
    },
    _createTables_setRange: {
      "^": "Closure:31;",
      call$3: function(target, range, transition) {
        var i, n, t1;
        for (i = C.JSString_methods._codeUnitAt$1(range, 0), n = C.JSString_methods._codeUnitAt$1(range, 1), t1 = J.getInterceptor$ax(target); i <= n; ++i)
          t1.$indexSet(target, (i ^ 96) >>> 0, transition);
      }
    },
    _SimpleUri: {
      "^": "Object;_uri,_schemeEnd,_hostStart,_portStart,_pathStart,_queryStart,_fragmentStart,_schemeCache,_hashCodeCache",
      get$hasAuthority: function() {
        return J.$gt$n(this._hostStart, 0);
      },
      get$hasPort: function() {
        return J.$gt$n(this._hostStart, 0) && J.$lt$n(J.$add$ansx(this._portStart, 1), this._pathStart);
      },
      get$hasQuery: function() {
        return J.$lt$n(this._queryStart, this._fragmentStart);
      },
      get$hasFragment: function() {
        return J.$lt$n(this._fragmentStart, J.get$length$asx(this._uri));
      },
      get$_isFile: function() {
        return J.$eq$(this._schemeEnd, 4) === true && J.startsWith$1$s(this._uri, "file");
      },
      get$_isHttp: function() {
        return J.$eq$(this._schemeEnd, 4) === true && J.startsWith$1$s(this._uri, "http");
      },
      get$_isHttps: function() {
        return J.$eq$(this._schemeEnd, 5) === true && J.startsWith$1$s(this._uri, "https");
      },
      get$hasAbsolutePath: function() {
        return J.startsWith$2$s(this._uri, "/", this._pathStart);
      },
      get$scheme: function() {
        var t1, t2, t3;
        t1 = this._schemeEnd;
        t2 = J.getInterceptor$n(t1);
        if (t2.$le(t1, 0))
          return "";
        t3 = this._schemeCache;
        if (t3 != null)
          return t3;
        if (this.get$_isHttp()) {
          this._schemeCache = "http";
          t1 = "http";
        } else if (this.get$_isHttps()) {
          this._schemeCache = "https";
          t1 = "https";
        } else if (this.get$_isFile()) {
          this._schemeCache = "file";
          t1 = "file";
        } else if (t2.$eq(t1, 7) === true && J.startsWith$1$s(this._uri, "package")) {
          this._schemeCache = "package";
          t1 = "package";
        } else {
          t1 = J.substring$2$s(this._uri, 0, t1);
          this._schemeCache = t1;
        }
        return t1;
      },
      get$userInfo: function() {
        var t1, t2, t3, t4;
        t1 = this._hostStart;
        t2 = this._schemeEnd;
        t3 = J.getInterceptor$ansx(t2);
        t4 = J.getInterceptor$n(t1);
        return t4.$gt(t1, t3.$add(t2, 3)) ? J.substring$2$s(this._uri, t3.$add(t2, 3), t4.$sub(t1, 1)) : "";
      },
      get$host: function() {
        var t1 = this._hostStart;
        return J.$gt$n(t1, 0) ? J.substring$2$s(this._uri, t1, this._portStart) : "";
      },
      get$port: function() {
        if (this.get$hasPort())
          return P.int_parse(J.substring$2$s(this._uri, J.$add$ansx(this._portStart, 1), this._pathStart), null, null);
        if (this.get$_isHttp())
          return 80;
        if (this.get$_isHttps())
          return 443;
        return 0;
      },
      get$path: function(_) {
        return J.substring$2$s(this._uri, this._pathStart, this._queryStart);
      },
      get$query: function() {
        var t1, t2, t3;
        t1 = this._queryStart;
        t2 = this._fragmentStart;
        t3 = J.getInterceptor$n(t1);
        return t3.$lt(t1, t2) ? J.substring$2$s(this._uri, t3.$add(t1, 1), t2) : "";
      },
      get$fragment: function() {
        var t1, t2, t3, t4;
        t1 = this._fragmentStart;
        t2 = this._uri;
        t3 = J.getInterceptor$asx(t2);
        t4 = J.getInterceptor$n(t1);
        return t4.$lt(t1, t3.get$length(t2)) ? t3.substring$1(t2, t4.$add(t1, 1)) : "";
      },
      get$pathSegments: function() {
        var start, end, t1, t2, parts, i, t3;
        start = this._pathStart;
        end = this._queryStart;
        t1 = this._uri;
        t2 = J.getInterceptor$s(t1);
        if (t2.startsWith$2(t1, "/", start))
          start = J.$add$ansx(start, 1);
        if (J.$eq$(start, end) === true)
          return C.List_empty0;
        parts = [];
        for (i = start; t3 = J.getInterceptor$n(i), t3.$lt(i, end); i = t3.$add(i, 1))
          if (t2.codeUnitAt$1(t1, i) === 47) {
            parts.push(t2.substring$2(t1, start, i));
            start = t3.$add(i, 1);
          }
        parts.push(t2.substring$2(t1, start, end));
        return P.List_List$unmodifiable(parts, P.String);
      },
      _isPort$1: function(port) {
        var portDigitStart = J.$add$ansx(this._portStart, 1);
        return J.$eq$(J.$add$ansx(portDigitStart, port.length), this._pathStart) && J.startsWith$2$s(this._uri, port, portDigitStart);
      },
      removeFragment$0: function() {
        var t1, t2, t3;
        t1 = this._fragmentStart;
        t2 = this._uri;
        t3 = J.getInterceptor$asx(t2);
        if (!J.$lt$n(t1, t3.get$length(t2)))
          return this;
        return new P._SimpleUri(t3.substring$2(t2, 0, t1), this._schemeEnd, this._hostStart, this._portStart, this._pathStart, this._queryStart, t1, this._schemeCache, null);
      },
      resolve$1: function(reference) {
        return this.resolveUri$1(P.Uri_parse(reference, 0, null));
      },
      resolveUri$1: function(reference) {
        if (reference instanceof P._SimpleUri)
          return this._simpleMerge$2(this, reference);
        return this._toNonSimple$0().resolveUri$1(reference);
      },
      _simpleMerge$2: function(base, ref) {
        var t1, t2, t3, t4, t5, t6, isSimple, delta, refStart, baseStart, baseEnd, baseUri, baseStart0, backCount, insert;
        t1 = ref._schemeEnd;
        t2 = J.getInterceptor$n(t1);
        if (t2.$gt(t1, 0))
          return ref;
        t3 = ref._hostStart;
        t4 = J.getInterceptor$n(t3);
        if (t4.$gt(t3, 0)) {
          t5 = base._schemeEnd;
          t6 = J.getInterceptor$n(t5);
          if (!t6.$gt(t5, 0))
            return ref;
          if (base.get$_isFile())
            isSimple = J.$eq$(ref._pathStart, ref._queryStart) !== true;
          else if (base.get$_isHttp())
            isSimple = !ref._isPort$1("80");
          else
            isSimple = !base.get$_isHttps() || !ref._isPort$1("443");
          if (isSimple) {
            delta = t6.$add(t5, 1);
            return new P._SimpleUri(J.substring$2$s(base._uri, 0, t6.$add(t5, 1)) + J.substring$1$s(ref._uri, t2.$add(t1, 1)), t5, t4.$add(t3, delta), J.$add$ansx(ref._portStart, delta), J.$add$ansx(ref._pathStart, delta), J.$add$ansx(ref._queryStart, delta), J.$add$ansx(ref._fragmentStart, delta), base._schemeCache, null);
          } else
            return this._toNonSimple$0().resolveUri$1(ref);
        }
        refStart = ref._pathStart;
        t1 = ref._queryStart;
        if (J.$eq$(refStart, t1) === true) {
          t2 = ref._fragmentStart;
          t3 = J.getInterceptor$n(t1);
          if (t3.$lt(t1, t2)) {
            t4 = base._queryStart;
            delta = J.$sub$n(t4, t1);
            return new P._SimpleUri(J.substring$2$s(base._uri, 0, t4) + J.substring$1$s(ref._uri, t1), base._schemeEnd, base._hostStart, base._portStart, base._pathStart, t3.$add(t1, delta), J.$add$ansx(t2, delta), base._schemeCache, null);
          }
          t1 = ref._uri;
          t3 = J.getInterceptor$asx(t1);
          t4 = J.getInterceptor$n(t2);
          if (t4.$lt(t2, t3.get$length(t1))) {
            t5 = base._fragmentStart;
            delta = J.$sub$n(t5, t2);
            return new P._SimpleUri(J.substring$2$s(base._uri, 0, t5) + t3.substring$1(t1, t2), base._schemeEnd, base._hostStart, base._portStart, base._pathStart, base._queryStart, t4.$add(t2, delta), base._schemeCache, null);
          }
          return base.removeFragment$0();
        }
        t2 = ref._uri;
        t3 = J.getInterceptor$s(t2);
        if (t3.startsWith$2(t2, "/", refStart)) {
          t4 = base._pathStart;
          delta = J.$sub$n(t4, refStart);
          return new P._SimpleUri(J.substring$2$s(base._uri, 0, t4) + t3.substring$1(t2, refStart), base._schemeEnd, base._hostStart, base._portStart, t4, J.$add$ansx(t1, delta), J.$add$ansx(ref._fragmentStart, delta), base._schemeCache, null);
        }
        baseStart = base._pathStart;
        baseEnd = base._queryStart;
        t4 = J.getInterceptor(baseStart);
        if (t4.$eq(baseStart, baseEnd) === true && J.$gt$n(base._hostStart, 0)) {
          for (; t3.startsWith$2(t2, "../", refStart);)
            refStart = J.$add$ansx(refStart, 3);
          delta = J.$add$ansx(t4.$sub(baseStart, refStart), 1);
          return new P._SimpleUri(J.substring$2$s(base._uri, 0, baseStart) + "/" + t3.substring$1(t2, refStart), base._schemeEnd, base._hostStart, base._portStart, baseStart, J.$add$ansx(t1, delta), J.$add$ansx(ref._fragmentStart, delta), base._schemeCache, null);
        }
        baseUri = base._uri;
        for (t4 = J.getInterceptor$s(baseUri), baseStart0 = baseStart; t4.startsWith$2(baseUri, "../", baseStart0);)
          baseStart0 = J.$add$ansx(baseStart0, 3);
        backCount = 0;
        while (true) {
          t5 = J.getInterceptor$ansx(refStart);
          if (!(J.$le$n(t5.$add(refStart, 3), t1) && t3.startsWith$2(t2, "../", refStart)))
            break;
          refStart = t5.$add(refStart, 3);
          ++backCount;
        }
        for (insert = ""; t6 = J.getInterceptor$n(baseEnd), t6.$gt(baseEnd, baseStart0);) {
          baseEnd = t6.$sub(baseEnd, 1);
          if (t4.codeUnitAt$1(baseUri, baseEnd) === 47) {
            if (backCount === 0) {
              insert = "/";
              break;
            }
            --backCount;
            insert = "/";
          }
        }
        t6 = J.getInterceptor(baseEnd);
        if (t6.$eq(baseEnd, baseStart0) === true && !J.$gt$n(base._schemeEnd, 0) && !t4.startsWith$2(baseUri, "/", baseStart)) {
          refStart = t5.$sub(refStart, backCount * 3);
          insert = "";
        }
        delta = J.$add$ansx(t6.$sub(baseEnd, refStart), insert.length);
        return new P._SimpleUri(t4.substring$2(baseUri, 0, baseEnd) + insert + t3.substring$1(t2, refStart), base._schemeEnd, base._hostStart, base._portStart, baseStart, J.$add$ansx(t1, delta), J.$add$ansx(ref._fragmentStart, delta), base._schemeCache, null);
      },
      toFilePath$1$windows: function(windows) {
        var t1, t2, t3, t4;
        if (J.$ge$n(this._schemeEnd, 0) && !this.get$_isFile())
          throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a " + H.S(this.get$scheme()) + " URI"));
        t1 = this._queryStart;
        t2 = this._uri;
        t3 = J.getInterceptor$asx(t2);
        t4 = J.getInterceptor$n(t1);
        if (t4.$lt(t1, t3.get$length(t2))) {
          if (t4.$lt(t1, this._fragmentStart))
            throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a URI with a query component"));
          throw H.wrapException(P.UnsupportedError$("Cannot extract a file path from a URI with a fragment component"));
        }
        windows = $.$get$_Uri__isWindowsCached();
        if (windows === true)
          t1 = P._Uri__toWindowsFilePath(this);
        else {
          if (J.$lt$n(this._hostStart, this._portStart))
            H.throwExpression(P.UnsupportedError$("Cannot extract a non-Windows file path from a file URI with an authority"));
          t1 = t3.substring$2(t2, this._pathStart, t1);
        }
        return t1;
      },
      toFilePath$0: function() {
        return this.toFilePath$1$windows(null);
      },
      get$data: function(_) {
        return;
      },
      get$hashCode: function(_) {
        var t1 = this._hashCodeCache;
        if (t1 == null) {
          t1 = J.get$hashCode$(this._uri);
          this._hashCodeCache = t1;
        }
        return t1;
      },
      $eq: function(_, other) {
        var t1;
        if (other == null)
          return false;
        if (this === other)
          return true;
        t1 = J.getInterceptor(other);
        if (!!t1.$isUri)
          return J.$eq$(this._uri, t1.toString$0(other));
        return false;
      },
      _toNonSimple$0: function() {
        var t1, t2, t3, t4, t5, t6, t7, t8, t9;
        t1 = this.get$scheme();
        t2 = this.get$userInfo();
        t3 = J.$gt$n(this._hostStart, 0) ? this.get$host() : null;
        t4 = this.get$hasPort() ? this.get$port() : null;
        t5 = this._uri;
        t6 = this._queryStart;
        t7 = J.getInterceptor$s(t5);
        t8 = t7.substring$2(t5, this._pathStart, t6);
        t9 = this._fragmentStart;
        t6 = J.$lt$n(t6, t9) ? this.get$query() : null;
        return new P._Uri(t1, t2, t3, t4, t8, t6, J.$lt$n(t9, t7.get$length(t5)) ? this.get$fragment() : null, null, null, null, null, null);
      },
      toString$0: function(_) {
        return this._uri;
      },
      $isUri: 1
    },
    _DataUri: {
      "^": "_Uri;_data,scheme,_userInfo,_host,_port,path,_query,_fragment,_pathSegments,_text,_hashCodeCache,_queryParameters,_queryParameterLists",
      get$data: function(_) {
        return this._data;
      }
    }
  }], ["dart.js", "dart:js",, P, {
    "^": "",
    _convertDartFunctionFast: function(f) {
      var existing, ret;
      existing = f.$dart_jsFunction;
      if (existing != null)
        return existing;
      ret = function(_call, f) {
        return function() {
          return _call(f, Array.prototype.slice.apply(arguments));
        };
      }(P._callDartFunctionFast, f);
      ret[$.$get$DART_CLOSURE_PROPERTY_NAME()] = f;
      f.$dart_jsFunction = ret;
      return ret;
    },
    _convertDartFunctionFastCaptureThis: function(f) {
      var existing, ret;
      existing = f._$dart_jsFunctionCaptureThis;
      if (existing != null)
        return existing;
      ret = function(_call, f) {
        return function() {
          return _call(f, this, Array.prototype.slice.apply(arguments));
        };
      }(P._callDartFunctionFastCaptureThis, f);
      ret[$.$get$DART_CLOSURE_PROPERTY_NAME()] = f;
      f._$dart_jsFunctionCaptureThis = ret;
      return ret;
    },
    _callDartFunctionFast: [function(callback, $arguments) {
      return P.Function_apply(callback, $arguments, null);
    }, null, null, 8, 0, null, 24, 0],
    _callDartFunctionFastCaptureThis: [function(callback, $self, $arguments) {
      var t1 = [$self];
      C.JSArray_methods.addAll$1(t1, $arguments);
      return P.Function_apply(callback, t1, null);
    }, null, null, 12, 0, null, 24, 84, 0],
    allowInterop: function(f) {
      if (typeof f == "function")
        return f;
      else
        return P._convertDartFunctionFast(f);
    },
    allowInteropCaptureThis: function(f) {
      if (typeof f == "function")
        throw H.wrapException(P.ArgumentError$("Function is already a JS function so cannot capture this."));
      else
        return P._convertDartFunctionFastCaptureThis(f);
    }
  }], ["dart.js_util", "dart:js_util",, P, {
    "^": "",
    callConstructor: function(constr, $arguments) {
      var args, factoryFunction;
      if ($arguments instanceof Array)
        switch ($arguments.length) {
          case 0:
            return new constr();
          case 1:
            return new constr($arguments[0]);
          case 2:
            return new constr($arguments[0], $arguments[1]);
          case 3:
            return new constr($arguments[0], $arguments[1], $arguments[2]);
          case 4:
            return new constr($arguments[0], $arguments[1], $arguments[2], $arguments[3]);
        }
      args = [null];
      C.JSArray_methods.addAll$1(args, $arguments);
      factoryFunction = constr.bind.apply(constr, args);
      String(factoryFunction);
      return new factoryFunction();
    }
  }], ["dart.math", "dart:math",, P, {
    "^": "",
    max: [function(a, b) {
      return Math.max(H.checkNum(a), H.checkNum(b));
    }, "call$2", "math__max$closure", 8, 0, function() {
      return {func: 1, args: [,,]};
    }, 21, 29],
    pow: function(x, exponent) {
      return Math.pow(x, exponent);
    },
    _JSRandom: {
      "^": "Object;",
      nextInt$1: function(max) {
        if (max <= 0 || max > 4294967296)
          throw H.wrapException(P.RangeError$("max must be in range 0 < max \u2264 2^32, was " + max));
        return Math.random() * max >>> 0;
      },
      nextDouble$0: function() {
        return Math.random();
      }
    }
  }], ["dart.typed_data", "dart:typed_data",, P, {
    "^": "",
    Uint8List: {
      "^": "Object;",
      $isEfficientLengthIterable: 1,
      $asEfficientLengthIterable: function() {
        return [P.int];
      },
      $isIterable: 1,
      $asIterable: function() {
        return [P.int];
      },
      $isList: 1,
      $asList: function() {
        return [P.int];
      }
    }
  }], ["", "package:args/src/arg_parser.dart",, N, {
    "^": "",
    ArgParser: {
      "^": "Object;_arg_parser$_options,_commands,options>,commands<,_optionsAndSeparators,allowTrailingOptions<",
      get$allowsAnything: function() {
        return false;
      },
      addFlag$7$abbr$callback$defaultsTo$help$hide$negatable: function($name, abbr, callback, defaultsTo, help, hide, negatable) {
        this._addOption$11$hide$negatable($name, abbr, help, null, null, null, defaultsTo, null, C.OptionType_nMZ, hide, negatable);
      },
      addFlag$2$hide: function($name, hide) {
        return this.addFlag$7$abbr$callback$defaultsTo$help$hide$negatable($name, null, null, false, null, hide, true);
      },
      addFlag$2$help: function($name, help) {
        return this.addFlag$7$abbr$callback$defaultsTo$help$hide$negatable($name, null, null, false, help, false, true);
      },
      addFlag$3$help$negatable: function($name, help, negatable) {
        return this.addFlag$7$abbr$callback$defaultsTo$help$hide$negatable($name, null, null, false, help, false, negatable);
      },
      addFlag$3$defaultsTo$help: function($name, defaultsTo, help) {
        return this.addFlag$7$abbr$callback$defaultsTo$help$hide$negatable($name, null, null, defaultsTo, help, false, true);
      },
      addFlag$4$abbr$help$negatable: function($name, abbr, help, negatable) {
        return this.addFlag$7$abbr$callback$defaultsTo$help$hide$negatable($name, abbr, null, false, help, false, negatable);
      },
      addFlag$3$abbr$help: function($name, abbr, help) {
        return this.addFlag$7$abbr$callback$defaultsTo$help$hide$negatable($name, abbr, null, false, help, false, true);
      },
      addOption$11$abbr$allowMultiple$allowed$allowedHelp$callback$defaultsTo$help$hide$splitCommas$valueHelp: function($name, abbr, allowMultiple, allowed, allowedHelp, callback, defaultsTo, help, hide, splitCommas, valueHelp) {
        this._addOption$11$hide$splitCommas($name, abbr, help, valueHelp, allowed, allowedHelp, defaultsTo, callback, C.OptionType_YwU, hide, splitCommas);
      },
      addOption$2$hide: function($name, hide) {
        return this.addOption$11$abbr$allowMultiple$allowed$allowedHelp$callback$defaultsTo$help$hide$splitCommas$valueHelp($name, null, false, null, null, null, null, null, hide, null, null);
      },
      addOption$6$abbr$allowed$defaultsTo$help$valueHelp: function($name, abbr, allowed, defaultsTo, help, valueHelp) {
        return this.addOption$11$abbr$allowMultiple$allowed$allowedHelp$callback$defaultsTo$help$hide$splitCommas$valueHelp($name, abbr, false, allowed, null, null, defaultsTo, help, false, null, valueHelp);
      },
      addOption$4$allowed$defaultsTo$help: function($name, allowed, defaultsTo, help) {
        return this.addOption$11$abbr$allowMultiple$allowed$allowedHelp$callback$defaultsTo$help$hide$splitCommas$valueHelp($name, null, false, allowed, null, null, defaultsTo, help, false, null, null);
      },
      addMultiOption$10$abbr$allowed$allowedHelp$callback$defaultsTo$help$hide$splitCommas$valueHelp: function($name, abbr, allowed, allowedHelp, callback, defaultsTo, help, hide, splitCommas, valueHelp) {
        var t1 = H.setRuntimeTypeInfo([], [P.String]);
        this._addOption$11$hide$splitCommas($name, abbr, help, valueHelp, allowed, allowedHelp, t1, null, C.OptionType_qyr, false, false);
      },
      addMultiOption$5$abbr$help$splitCommas$valueHelp: function($name, abbr, help, splitCommas, valueHelp) {
        return this.addMultiOption$10$abbr$allowed$allowedHelp$callback$defaultsTo$help$hide$splitCommas$valueHelp($name, abbr, null, null, null, null, help, false, splitCommas, valueHelp);
      },
      _addOption$12$hide$negatable$splitCommas: function($name, abbr, help, valueHelp, allowed, allowedHelp, defaultsTo, callback, type, hide, negatable, splitCommas) {
        var t1, t2, existing, t3, option;
        t1 = this._arg_parser$_options;
        if (t1.containsKey$1($name))
          throw H.wrapException(P.ArgumentError$('Duplicate option "' + $name + '".'));
        t2 = abbr != null;
        if (t2) {
          existing = this.findByAbbreviation$1(abbr);
          if (existing != null)
            throw H.wrapException(P.ArgumentError$('Abbreviation "' + abbr + '" is already used by "' + H.S(existing.get$name()) + '".'));
        }
        t3 = allowed == null ? null : P.List_List$unmodifiable(allowed, null);
        option = new G.Option($name, abbr, help, valueHelp, t3, null, defaultsTo, negatable, callback, type, splitCommas == null ? type === C.OptionType_qyr : splitCommas, hide);
        if ($name.length === 0)
          H.throwExpression(P.ArgumentError$("Name cannot be empty."));
        else if (C.JSString_methods.startsWith$1($name, "-"))
          H.throwExpression(P.ArgumentError$("Name " + $name + ' cannot start with "-".'));
        t3 = $.$get$Option__invalidChars()._nativeRegExp;
        if (t3.test($name))
          H.throwExpression(P.ArgumentError$('Name "' + $name + '" contains invalid characters.'));
        if (t2) {
          if (abbr.length !== 1)
            H.throwExpression(P.ArgumentError$("Abbreviation must be null or have length 1."));
          else if (abbr === "-")
            H.throwExpression(P.ArgumentError$('Abbreviation cannot be "-".'));
          if (t3.test(abbr))
            H.throwExpression(P.ArgumentError$("Abbreviation is an invalid character."));
        }
        t1.$indexSet(0, $name, option);
        this._optionsAndSeparators.push(option);
      },
      _addOption$11$hide$splitCommas: function($name, abbr, help, valueHelp, allowed, allowedHelp, defaultsTo, callback, type, hide, splitCommas) {
        return this._addOption$12$hide$negatable$splitCommas($name, abbr, help, valueHelp, allowed, allowedHelp, defaultsTo, callback, type, hide, false, splitCommas);
      },
      _addOption$11$hide$negatable: function($name, abbr, help, valueHelp, allowed, allowedHelp, defaultsTo, callback, type, hide, negatable) {
        return this._addOption$12$hide$negatable$splitCommas($name, abbr, help, valueHelp, allowed, allowedHelp, defaultsTo, callback, type, hide, negatable, null);
      },
      parse$1: function(args) {
        return G.Parser$(null, this, J.toList$0$ax(args), null, null).parse$0();
      },
      get$usage: function() {
        return new G.Usage(this._optionsAndSeparators, null, 0, null, 0, 0).generate$0();
      },
      findByAbbreviation$1: function(abbr) {
        return this.options._collection$_map.get$values().firstWhere$2$orElse(0, new N.ArgParser_findByAbbreviation_closure(abbr), new N.ArgParser_findByAbbreviation_closure0());
      }
    },
    ArgParser_findByAbbreviation_closure: {
      "^": "Closure:0;abbr",
      call$1: function(option) {
        var t1, t2;
        t1 = option.get$abbr();
        t2 = this.abbr;
        return t1 == null ? t2 == null : t1 === t2;
      }
    },
    ArgParser_findByAbbreviation_closure0: {
      "^": "Closure:1;",
      call$0: function() {
        return;
      }
    }
  }], ["", "package:args/src/arg_parser_exception.dart",, Z, {
    "^": "",
    ArgParserException: {
      "^": "FormatException;commands<,message,source,offset",
      static: {
        ArgParserException$: function(message, commands) {
          return new Z.ArgParserException(commands == null ? C.List_empty : P.List_List$unmodifiable(commands, null), message, null, null);
        }
      }
    }
  }], ["", "package:args/src/arg_results.dart",, V, {
    "^": "",
    ArgResults: {
      "^": "Object;_parser,_parsed,name<,command,rest,$arguments<",
      $index: function(_, $name) {
        var t1, t2;
        t1 = this._parser;
        t2 = J.getInterceptor$x(t1);
        if (t2.get$options(t1).containsKey$1($name) !== true)
          throw H.wrapException(P.ArgumentError$('Could not find an option named "' + H.S($name) + '".'));
        return J.$index$asx(t2.get$options(t1), $name).getOrDefault$1(this._parsed.$index(0, $name));
      },
      get$options: function(_) {
        var result = P.LinkedHashSet_LinkedHashSet$from(this._parsed.get$keys(), P.String);
        J.forEach$1$ax(J.get$options$x(this._parser), new V.ArgResults_options_closure(result));
        return result;
      },
      wasParsed$1: function($name) {
        if (J.$index$asx(J.get$options$x(this._parser), $name) == null)
          throw H.wrapException(P.ArgumentError$('Could not find an option named "' + H.S($name) + '".'));
        return this._parsed.containsKey$1($name);
      },
      static: {
        ArgResults$_: function(_parser, _parsed, $name, command, rest, $arguments) {
          var t1 = [null];
          return new V.ArgResults(_parser, _parsed, $name, command, new P.UnmodifiableListView(rest, t1), new P.UnmodifiableListView($arguments, t1));
        }
      }
    },
    ArgResults_options_closure: {
      "^": "Closure:2;result",
      call$2: function($name, option) {
        if (option.get$defaultsTo() != null)
          this.result.add$1(0, $name);
      }
    }
  }], ["", "package:args/src/option.dart",, G, {
    "^": "",
    Option: {
      "^": "Object;name<,abbr<,help,valueHelp,allowed<,allowedHelp,defaultsTo<,negatable<,callback<,type<,splitCommas<,hide",
      get$defaultValue: function() {
        return this.defaultsTo;
      },
      get$isFlag: function() {
        return this.type === C.OptionType_nMZ;
      },
      get$isMultiple: function() {
        return this.type === C.OptionType_qyr;
      },
      getOrDefault$1: function(value) {
        var t1;
        if (value != null)
          return value;
        if (this.type === C.OptionType_qyr) {
          t1 = this.defaultsTo;
          return t1 == null ? H.setRuntimeTypeInfo([], [P.String]) : t1;
        }
        return this.defaultsTo;
      },
      callback$1: function(arg0) {
        return this.callback.call$1(arg0);
      }
    },
    OptionType: {
      "^": "Object;name<",
      static: {
        "^": "OptionType_single<"
      }
    }
  }], ["", "package:args/src/parser.dart",, G, {
    "^": "",
    Parser: {
      "^": "Object;commandName,parent,grammar,args,rest,results",
      Parser$5: function(commandName, grammar, args, $parent, rest) {
        if (rest != null)
          C.JSArray_methods.addAll$1(this.rest, rest);
      },
      get$current: function(_) {
        return J.$index$asx(this.args, 0);
      },
      parse$0: function() {
        var commandResults, commandName, commandParser, error, t1, t2, $arguments, t3, t4, command, t5, t6, exception;
        t1 = this.args;
        t2 = J.getInterceptor$ax(t1);
        $arguments = t2.toList$0(t1);
        t3 = this.grammar;
        t3.get$allowsAnything();
        commandResults = null;
        for (t4 = this.rest; t2.get$length(t1) > 0;) {
          if (J.$eq$(t2.$index(t1, 0), "--") === true) {
            t2.removeAt$1(t1, 0);
            break;
          }
          command = J.$index$asx(t3.get$commands(), t2.$index(t1, 0));
          if (command != null) {
            if (t4.length !== 0)
              H.throwExpression(Z.ArgParserException$("Cannot specify arguments before a command.", null));
            commandName = t2.removeAt$1(t1, 0);
            t5 = P.String;
            t6 = H.setRuntimeTypeInfo([], [t5]);
            C.JSArray_methods.addAll$1(t6, t4);
            commandParser = new G.Parser(commandName, this, command, t1, t6, P.LinkedHashMap_LinkedHashMap$_empty(t5, null));
            try {
              commandResults = commandParser.parse$0();
            } catch (exception) {
              t1 = H.unwrapException(exception);
              if (t1 instanceof Z.ArgParserException) {
                error = t1;
                if (commandName == null)
                  throw exception;
                t1 = J.get$message$x(error);
                t2 = [commandName];
                C.JSArray_methods.addAll$1(t2, error.get$commands());
                throw H.wrapException(Z.ArgParserException$(t1, t2));
              } else
                throw exception;
            }
            C.JSArray_methods.set$length(t4, 0);
            break;
          }
          if (this.parseSoloOption$0())
            continue;
          if (this.parseAbbreviation$1(this))
            continue;
          if (this.parseLongOption$0())
            continue;
          if (!t3.get$allowTrailingOptions())
            break;
          t4.push(t2.removeAt$1(t1, 0));
        }
        J.forEach$1$ax(J.get$options$x(t3), new G.Parser_parse_closure(this));
        C.JSArray_methods.addAll$1(t4, t1);
        t2.clear$0(t1);
        return V.ArgResults$_(t3, this.results, this.commandName, commandResults, t4, $arguments);
      },
      readNextArgAsValue$1: function(option) {
        var t1, t2, t3, t4;
        t1 = this.args;
        t2 = J.getInterceptor$asx(t1);
        t3 = t2.get$length(t1);
        t4 = 'Missing argument for "' + H.S(option.get$name()) + '".';
        if (t3 <= 0)
          H.throwExpression(Z.ArgParserException$(t4, null));
        this.setOption$3(this.results, option, t2.$index(t1, 0));
        t2.removeAt$1(t1, 0);
      },
      parseSoloOption$0: function() {
        var t1, t2, soloOpt, t3, option;
        t1 = this.args;
        t2 = J.getInterceptor$asx(t1);
        soloOpt = $.$get$_soloOpt().firstMatch$1(t2.$index(t1, 0));
        if (soloOpt == null)
          return false;
        t3 = soloOpt._match;
        if (1 >= t3.length)
          return H.ioore(t3, 1);
        option = this.grammar.findByAbbreviation$1(t3[1]);
        if (option == null) {
          t1 = this.parent;
          if (1 >= t3.length)
            return H.ioore(t3, 1);
          t3 = 'Could not find an option or flag "-' + H.S(t3[1]) + '".';
          if (t1 == null)
            H.throwExpression(Z.ArgParserException$(t3, null));
          return t1.parseSoloOption$0();
        }
        t2.removeAt$1(t1, 0);
        if (option.get$isFlag())
          this.results.$indexSet(0, option.get$name(), true);
        else
          this.readNextArgAsValue$1(option);
        return true;
      },
      parseAbbreviation$1: function(innermostCommand) {
        var t1, t2, abbrOpt, t3, c, first, t4, t5, i, i0;
        t1 = this.args;
        t2 = J.getInterceptor$asx(t1);
        abbrOpt = $.$get$_abbrOpt().firstMatch$1(t2.$index(t1, 0));
        if (abbrOpt == null)
          return false;
        t3 = abbrOpt._match;
        if (1 >= t3.length)
          return H.ioore(t3, 1);
        c = J.substring$2$s(t3[1], 0, 1);
        first = this.grammar.findByAbbreviation$1(c);
        if (first == null) {
          t1 = this.parent;
          t2 = 'Could not find an option with short name "-' + c + '".';
          if (t1 == null)
            H.throwExpression(Z.ArgParserException$(t2, null));
          return t1.parseAbbreviation$1(innermostCommand);
        } else {
          t4 = first.get$isFlag();
          t5 = t3.length;
          if (!t4) {
            if (1 >= t5)
              return H.ioore(t3, 1);
            t4 = J.substring$1$s(t3[1], 1);
            if (2 >= t5)
              return H.ioore(t3, 2);
            this.setOption$3(this.results, first, t4 + H.S(t3[2]));
          } else {
            if (2 >= t5)
              return H.ioore(t3, 2);
            t4 = t3[2];
            t5 = 'Option "-' + c + '" is a flag and cannot handle value "' + J.substring$1$s(t3[1], 1) + H.S(t4) + '".';
            if (t4 !== "")
              H.throwExpression(Z.ArgParserException$(t5, null));
            i = 0;
            while (true) {
              if (1 >= t3.length)
                return H.ioore(t3, 1);
              t4 = t3[1];
              if (!(i < t4.length))
                break;
              i0 = i + 1;
              innermostCommand.parseShortFlag$1(J.substring$2$s(t4, i, i0));
              i = i0;
            }
          }
        }
        t2.removeAt$1(t1, 0);
        return true;
      },
      parseShortFlag$1: function(c) {
        var option, t1, t2;
        option = this.grammar.findByAbbreviation$1(c);
        if (option == null) {
          t1 = this.parent;
          t2 = 'Could not find an option with short name "-' + c + '".';
          if (t1 == null)
            H.throwExpression(Z.ArgParserException$(t2, null));
          t1.parseShortFlag$1(c);
          return;
        }
        t1 = option.get$isFlag();
        t2 = 'Option "-' + c + '" must be a flag to be in a collapsed "-".';
        if (!t1)
          H.throwExpression(Z.ArgParserException$(t2, null));
        this.results.$indexSet(0, option.get$name(), true);
      },
      parseLongOption$0: function() {
        var t1, t2, longOpt, t3, $name, t4, t5, option;
        t1 = this.args;
        t2 = J.getInterceptor$asx(t1);
        longOpt = $.$get$_longOpt().firstMatch$1(t2.$index(t1, 0));
        if (longOpt == null)
          return false;
        t3 = longOpt._match;
        if (1 >= t3.length)
          return H.ioore(t3, 1);
        $name = t3[1];
        t4 = this.grammar;
        t5 = J.getInterceptor$x(t4);
        option = J.$index$asx(t5.get$options(t4), $name);
        if (option != null) {
          t2.removeAt$1(t1, 0);
          if (option.get$isFlag()) {
            if (3 >= t3.length)
              return H.ioore(t3, 3);
            t1 = t3[3];
            t2 = 'Flag option "' + H.S($name) + '" should not be given a value.';
            if (t1 != null)
              H.throwExpression(Z.ArgParserException$(t2, null));
            this.results.$indexSet(0, option.get$name(), true);
          } else {
            if (3 >= t3.length)
              return H.ioore(t3, 3);
            t1 = t3[3];
            if (t1 != null)
              this.setOption$3(this.results, option, t1);
            else
              this.readNextArgAsValue$1(option);
          }
        } else if (J.getInterceptor$s($name).startsWith$1($name, "no-")) {
          $name = C.JSString_methods.substring$1($name, 3);
          option = J.$index$asx(t5.get$options(t4), $name);
          if (option == null) {
            t1 = this.parent;
            t2 = 'Could not find an option named "' + $name + '".';
            if (t1 == null)
              H.throwExpression(Z.ArgParserException$(t2, null));
            return t1.parseLongOption$0();
          }
          t2.removeAt$1(t1, 0);
          t1 = option.get$isFlag();
          t2 = 'Cannot negate non-flag option "' + $name + '".';
          if (!t1)
            H.throwExpression(Z.ArgParserException$(t2, null));
          t1 = option.get$negatable();
          t2 = 'Cannot negate option "' + $name + '".';
          if (!t1)
            H.throwExpression(Z.ArgParserException$(t2, null));
          this.results.$indexSet(0, option.get$name(), false);
        } else {
          t1 = this.parent;
          t2 = 'Could not find an option named "' + $name + '".';
          if (t1 == null)
            H.throwExpression(Z.ArgParserException$(t2, null));
          return t1.parseLongOption$0();
        }
        return true;
      },
      setOption$3: function(results, option, value) {
        var list, t1, t2, t3, _i, element;
        if (!option.get$isMultiple()) {
          this._validateAllowed$2(option, value);
          results.$indexSet(0, option.get$name(), value);
          return;
        }
        list = results.putIfAbsent$2(option.get$name(), new G.Parser_setOption_closure());
        if (option.get$splitCommas())
          for (t1 = J.split$1$s(value, ","), t2 = t1.length, t3 = J.getInterceptor$ax(list), _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
            element = t1[_i];
            this._validateAllowed$2(option, element);
            t3.add$1(list, element);
          }
        else {
          this._validateAllowed$2(option, value);
          J.add$1$ax(list, value);
        }
      },
      _validateAllowed$2: function(option, value) {
        var t1, t2;
        if (option.get$allowed() == null)
          return;
        t1 = option.get$allowed();
        t1 = (t1 && C.JSArray_methods).contains$1(t1, value);
        t2 = '"' + H.S(value) + '" is not an allowed value for option "' + H.S(option.get$name()) + '".';
        if (!t1)
          H.throwExpression(Z.ArgParserException$(t2, null));
      },
      static: {
        Parser$: function(commandName, grammar, args, $parent, rest) {
          var t1 = P.String;
          t1 = new G.Parser(commandName, $parent, grammar, args, H.setRuntimeTypeInfo([], [t1]), P.LinkedHashMap_LinkedHashMap$_empty(t1, null));
          t1.Parser$5(commandName, grammar, args, $parent, rest);
          return t1;
        }
      }
    },
    Parser_parse_closure: {
      "^": "Closure:2;$this",
      call$2: function($name, option) {
        if (option.get$callback() == null)
          return;
        option.callback$1(option.getOrDefault$1(this.$this.results.$index(0, $name)));
      }
    },
    Parser_setOption_closure: {
      "^": "Closure:1;",
      call$0: function() {
        return H.setRuntimeTypeInfo([], [P.String]);
      }
    }
  }], ["", "package:args/src/usage.dart",, G, {
    "^": "",
    padRight: function(source, $length) {
      var t1 = H.S(source);
      for (; t1.length < $length;)
        t1 += " ";
      return t1.charCodeAt(0) == 0 ? t1 : t1;
    },
    Usage: {
      "^": "Object;optionsAndSeparators,buffer,currentColumn,columnWidths,numHelpLines,newlinesNeeded",
      generate$0: function() {
        var t1, t2, _i, optionOrSeparator, t3, t4, allowedNames, t5, t6, _i0, $name, isDefault, t7;
        this.buffer = new P.StringBuffer("");
        this.calculateColumnWidths$0();
        for (t1 = this.optionsAndSeparators, t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          optionOrSeparator = t1[_i];
          if (typeof optionOrSeparator === "string") {
            t3 = this.buffer;
            t4 = t3._contents;
            if (t4.length !== 0) {
              t4 += "\n\n";
              t3._contents = t4;
            }
            t3._contents = t4 + optionOrSeparator;
            this.newlinesNeeded = 1;
            continue;
          }
          H.interceptedTypeCast(optionOrSeparator, "$isOption");
          if (optionOrSeparator.hide)
            continue;
          t3 = optionOrSeparator.abbr;
          this.write$2(0, 0, t3 == null ? "" : "-" + t3 + ", ");
          this.write$2(0, 1, this.getLongOption$1(optionOrSeparator));
          t3 = optionOrSeparator.help;
          if (t3 != null)
            this.write$2(0, 2, t3);
          t3 = optionOrSeparator.allowedHelp;
          if (t3 != null) {
            t4 = t3.get$keys();
            allowedNames = P.List_List$from(t4, false, H.getRuntimeTypeArgument(t4, "Iterable", 0));
            t4 = allowedNames.length - 1;
            if (t4 - 0 <= 32)
              H.Sort__insertionSort(allowedNames, 0, t4, J._interceptors_JSArray__compareAny$closure());
            else
              H.Sort__dualPivotQuicksort(allowedNames, 0, t4, J._interceptors_JSArray__compareAny$closure());
            ++this.newlinesNeeded;
            this.currentColumn = 0;
            this.numHelpLines = 0;
            for (t4 = allowedNames.length, t5 = optionOrSeparator.defaultsTo, t6 = !!J.getInterceptor(t5).$isList, _i0 = 0; _i0 < allowedNames.length; allowedNames.length === t4 || (0, H.throwConcurrentModificationError)(allowedNames), ++_i0) {
              $name = allowedNames[_i0];
              isDefault = t6 ? C.JSArray_methods.contains$1(t5, $name) : t5 == null ? $name == null : t5 === $name;
              t7 = "      [" + H.S($name) + "]";
              this.write$2(0, 1, t7 + (isDefault ? " (default)" : ""));
              this.write$2(0, 2, t3.$index(0, $name));
            }
            ++this.newlinesNeeded;
            this.currentColumn = 0;
            this.numHelpLines = 0;
          } else if (optionOrSeparator.allowed != null)
            this.write$2(0, 2, this.buildAllowedList$1(optionOrSeparator));
          else {
            t3 = optionOrSeparator.type;
            if (t3 === C.OptionType_nMZ) {
              if (optionOrSeparator.defaultsTo === true)
                this.write$2(0, 2, "(defaults to on)");
            } else if (t3 === C.OptionType_qyr) {
              t3 = optionOrSeparator.defaultsTo;
              if (t3 != null && J.get$isNotEmpty$asx(t3))
                this.write$2(0, 2, "(defaults to " + J.map$1$ax(t3, new G.Usage_generate_closure()).join$1(0, ", ") + ")");
            } else {
              t3 = optionOrSeparator.defaultsTo;
              if (t3 != null)
                this.write$2(0, 2, '(defaults to "' + H.S(t3) + '")');
            }
          }
          if (this.numHelpLines > 1) {
            ++this.newlinesNeeded;
            this.currentColumn = 0;
            this.numHelpLines = 0;
          }
        }
        return J.toString$0$(this.buffer);
      },
      getLongOption$1: function(option) {
        var result, t1;
        result = option.negatable ? "--[no-]" + option.name : "--" + option.name;
        t1 = option.valueHelp;
        return t1 != null ? result + ("=<" + t1 + ">") : result;
      },
      calculateColumnWidths$0: function() {
        var t1, t2, abbr, title, _i, option, t3, t4, t5, allowed, isDefault, t6;
        for (t1 = this.optionsAndSeparators, t2 = t1.length, abbr = 0, title = 0, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          option = t1[_i];
          if (!(option instanceof G.Option))
            continue;
          if (option.hide)
            continue;
          t3 = option.abbr;
          abbr = Math.max(abbr, (t3 == null ? "" : "-" + t3 + ", ").length);
          title = Math.max(title, this.getLongOption$1(option).length);
          t3 = option.allowedHelp;
          if (t3 != null)
            for (t3 = t3.get$keys(), t3 = t3.get$iterator(t3), t4 = option.defaultsTo, t5 = !!J.getInterceptor(t4).$isList; t3.moveNext$0();) {
              allowed = t3.get$current(t3);
              isDefault = t5 ? C.JSArray_methods.contains$1(t4, allowed) : t4 == null ? allowed == null : t4 === allowed;
              t6 = "      [" + H.S(allowed) + "]";
              title = Math.max(title, (t6 + (isDefault ? " (default)" : "")).length);
            }
        }
        this.columnWidths = [abbr, title + 4];
      },
      write$2: function(_, column, text) {
        var lines, t1, _i;
        lines = J.split$1$s(text, "\n");
        t1 = !!lines.fixed$length;
        while (true) {
          if (!(lines.length > 0 && J.trim$0$s(lines[0]) === ""))
            break;
          if (t1)
            H.throwExpression(P.UnsupportedError$("removeRange"));
          P.RangeError_checkValidRange(0, 1, lines.length, null, null, null);
          lines.splice(0, 1);
        }
        while (true) {
          t1 = lines.length;
          if (!(t1 > 0 && J.trim$0$s(lines[t1 - 1]) === ""))
            break;
          C.JSArray_methods.removeLast$0(lines);
        }
        for (t1 = lines.length, _i = 0; _i < lines.length; lines.length === t1 || (0, H.throwConcurrentModificationError)(lines), ++_i)
          this.writeLine$2(column, lines[_i]);
      },
      writeLine$2: function(column, text) {
        var t1, t2;
        for (; t1 = this.newlinesNeeded, t1 > 0;) {
          this.buffer._contents += "\n";
          this.newlinesNeeded = t1 - 1;
        }
        for (; t1 = this.currentColumn, t1 !== column;) {
          t2 = this.buffer;
          if (t1 < 2)
            t2._contents += G.padRight("", this.columnWidths[t1]);
          else
            t2._contents += "\n";
          this.currentColumn = (this.currentColumn + 1) % 3;
        }
        t1 = this.columnWidths;
        t1.length;
        t2 = this.buffer;
        if (column < 2)
          t2._contents += G.padRight(text, t1[column]);
        else {
          t2.toString;
          t2._contents += H.S(text);
        }
        this.currentColumn = (this.currentColumn + 1) % 3;
        t1 = column === 2;
        if (t1)
          ++this.newlinesNeeded;
        if (t1)
          ++this.numHelpLines;
        else
          this.numHelpLines = 0;
      },
      buildAllowedList$1: function(option) {
        var t1, isDefault, t2, first, _i, t3, allowed;
        t1 = option.defaultsTo;
        isDefault = !!J.getInterceptor(t1).$isList ? C.JSArray_methods.get$contains(t1) : new G.Usage_buildAllowedList_closure(option);
        for (t1 = option.allowed, t2 = t1.length, first = true, _i = 0, t3 = "["; _i < t2; ++_i, first = false) {
          allowed = t1[_i];
          if (!first)
            t3 += ", ";
          t3 += H.S(allowed);
          if (isDefault.call$1(allowed) === true)
            t3 += " (default)";
        }
        t1 = t3 + "]";
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }
    },
    Usage_generate_closure: {
      "^": "Closure:0;",
      call$1: [function(value) {
        return '"' + H.S(value) + '"';
      }, null, null, 4, 0, null, 3, "call"]
    },
    Usage_buildAllowedList_closure: {
      "^": "Closure:0;option",
      call$1: function(value) {
        return J.$eq$(value, this.option.defaultsTo);
      }
    }
  }], ["", "package:async/src/delegate/stream_subscription.dart",, Y, {
    "^": "",
    DelegatingStreamSubscription: {
      "^": "Object;$ti",
      onData$1: function(handleData) {
        this._stream_subscription$_source.onData$1(handleData);
      },
      onError$1: ["super$DelegatingStreamSubscription$onError", function(handleError) {
        this._stream_subscription$_source.onError$1(handleError);
      }],
      onDone$1: function(handleDone) {
        this._stream_subscription$_source.onDone$1(handleDone);
      },
      pause$1: [function(_, resumeFuture) {
        this._stream_subscription$_source.pause$1(0, resumeFuture);
      }, function($receiver) {
        return this.pause$1($receiver, null);
      }, "pause$0", "call$1", "call$0", "get$pause", 1, 2, 18],
      resume$0: [function() {
        this._stream_subscription$_source.resume$0();
      }, "call$0", "get$resume", 0, 0, 3],
      cancel$0: ["super$DelegatingStreamSubscription$cancel", function() {
        return this._stream_subscription$_source.cancel$0();
      }],
      get$isPaused: function() {
        return this._stream_subscription$_source.get$isPaused();
      },
      $isStreamSubscription: 1
    }
  }], ["", "package:async/src/result/error.dart",, V, {
    "^": "",
    ErrorResult: {
      "^": "Object;error<,stackTrace<",
      get$isError: function() {
        return true;
      },
      get$asValue: function() {
        return;
      },
      get$asError: function() {
        return this;
      },
      complete$1: function(completer) {
        completer.completeError$2(this.error, this.stackTrace);
      },
      get$hashCode: function(_) {
        return (J.get$hashCode$(this.error) ^ J.get$hashCode$(this.stackTrace) ^ 492929599) >>> 0;
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        return other instanceof V.ErrorResult && J.$eq$(this.error, other.error) === true && J.$eq$(this.stackTrace, other.stackTrace) === true;
      }
    }
  }], ["", "package:async/src/result/result.dart",, E, {
    "^": "",
    Result: {
      "^": "Object;$ti"
    }
  }], ["", "package:async/src/result/value.dart",, F, {
    "^": "",
    ValueResult: {
      "^": "Object;value<,$ti",
      get$isError: function() {
        return false;
      },
      get$asValue: function() {
        return this;
      },
      get$asError: function() {
        return;
      },
      complete$1: function(completer) {
        completer.complete$1(this.value);
      },
      get$hashCode: function(_) {
        return (J.get$hashCode$(this.value) ^ 842997089) >>> 0;
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        return other instanceof F.ValueResult && J.$eq$(this.value, other.value) === true;
      }
    }
  }], ["", "package:async/src/stream_completer.dart",, Y, {
    "^": "",
    StreamCompleter: {
      "^": "Object;_stream_completer$_stream,$ti",
      get$stream: function() {
        return this._stream_completer$_stream;
      },
      setSourceStream$1: [function(sourceStream) {
        var t1 = this._stream_completer$_stream;
        if (t1._sourceStream != null)
          throw H.wrapException(P.StateError$("Source stream already set"));
        t1._sourceStream = sourceStream;
        if (t1._stream_completer$_controller != null)
          t1._linkStreamToController$0();
      }, "call$1", "get$setSourceStream", 4, 0, function() {
        return H.computeSignature(function(T) {
          return {func: 1, v: true, args: [[P.Stream, T]]};
        }, this.$receiver, "StreamCompleter");
      }, 78],
      setError$2: [function(error, stackTrace) {
        this.setSourceStream$1(P.Stream_Stream$fromFuture(P.Future_Future$error(error, stackTrace, null), null));
      }, function(error) {
        return this.setError$2(error, null);
      }, "setError$1", "call$2", "call$1", "get$setError", 4, 2, 65, 2, 4, 5]
    },
    _CompleterStream: {
      "^": "Stream;_stream_completer$_controller,_sourceStream,$ti",
      listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
        var t1;
        if (this._stream_completer$_controller == null) {
          t1 = this._sourceStream;
          if (t1 != null && !t1.get$isBroadcast())
            return this._sourceStream.listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
          this._stream_completer$_controller = P.StreamController_StreamController(null, null, null, null, true, H.getTypeArgumentByIndex(this, 0));
          if (this._sourceStream != null)
            this._linkStreamToController$0();
        }
        t1 = this._stream_completer$_controller;
        t1.toString;
        return new P._ControllerStream(t1, [H.getTypeArgumentByIndex(t1, 0)]).listen$4$cancelOnError$onDone$onError(onData, cancelOnError, onDone, onError);
      },
      listen$3$onDone$onError: function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      },
      listen$1: function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      },
      _linkStreamToController$0: function() {
        var t1, t2;
        t1 = this._stream_completer$_controller.addStream$2$cancelOnError(this._sourceStream, false);
        t2 = this._stream_completer$_controller;
        t1.whenComplete$1(t2.get$close(t2));
      }
    }
  }], ["", "package:async/src/stream_group.dart",, L, {
    "^": "",
    StreamGroup: {
      "^": "Object;_controller,_closed,_stream_group$_state,_subscriptions,$ti",
      get$stream: function() {
        var t1 = this._controller;
        t1.toString;
        return new P._ControllerStream(t1, [H.getTypeArgumentByIndex(t1, 0)]);
      },
      add$1: function(_, stream) {
        var t1;
        if (this._closed)
          throw H.wrapException(P.StateError$("Can't add a Stream to a closed StreamGroup."));
        t1 = this._stream_group$_state;
        if (t1 === C._StreamGroupState_dormant)
          this._subscriptions.putIfAbsent$2(stream, new L.StreamGroup_add_closure());
        else if (t1 === C._StreamGroupState_canceled)
          return stream.listen$1(null).cancel$0();
        else
          this._subscriptions.putIfAbsent$2(stream, new L.StreamGroup_add_closure0(this, stream));
        return;
      },
      remove$1: function(_, stream) {
        var t1, subscription, future;
        t1 = this._subscriptions;
        subscription = t1.remove$1(0, stream);
        future = subscription == null ? null : subscription.cancel$0();
        if (this._closed && t1.get$isEmpty(t1))
          this._controller.close$0(0);
        return future;
      },
      _onListen$0: [function() {
        this._stream_group$_state = C._StreamGroupState_listening;
        this._subscriptions.forEach$1(0, new L.StreamGroup__onListen_closure(this));
      }, "call$0", "get$_onListen", 0, 0, 3],
      _onPause$0: [function() {
        this._stream_group$_state = C._StreamGroupState_paused;
        for (var t1 = this._subscriptions.get$values(), t1 = t1.get$iterator(t1); t1.moveNext$0();)
          J.pause$0$x(t1.get$current(t1));
      }, "call$0", "get$_onPause", 0, 0, 3],
      _onResume$0: [function() {
        this._stream_group$_state = C._StreamGroupState_listening;
        for (var t1 = this._subscriptions.get$values(), t1 = t1.get$iterator(t1); t1.moveNext$0();)
          t1.get$current(t1).resume$0();
      }, "call$0", "get$_onResume", 0, 0, 3],
      _onCancel$0: [function() {
        var t1, t2, t3, futures;
        this._stream_group$_state = C._StreamGroupState_canceled;
        t1 = this._subscriptions;
        t2 = t1.get$values();
        t2 = H.MappedIterable_MappedIterable(t2, new L.StreamGroup__onCancel_closure(), H.getRuntimeTypeArgument(t2, "Iterable", 0), null);
        t3 = H.getRuntimeTypeArgument(t2, "Iterable", 0);
        futures = P.List_List$from(new H.WhereIterable(t2, new L.StreamGroup__onCancel_closure0(), [t3]), true, t3);
        t1.clear$0(0);
        return futures.length === 0 ? null : P.Future_wait(futures, null, false);
      }, "call$0", "get$_onCancel", 0, 0, 4],
      _listenToStream$1: function(stream) {
        var t1, subscription;
        t1 = this._controller;
        subscription = stream.listen$3$onDone$onError(t1.get$add(t1), new L.StreamGroup__listenToStream_closure(this, stream), t1.get$addError());
        if (this._stream_group$_state === C._StreamGroupState_paused)
          subscription.pause$0(0);
        return subscription;
      },
      close$0: function(_) {
        var t1;
        if (this._closed)
          return this._controller._ensureDoneFuture$0();
        this._closed = true;
        t1 = this._subscriptions;
        if (t1.get$isEmpty(t1))
          this._controller.close$0(0);
        return this._controller._ensureDoneFuture$0();
      }
    },
    StreamGroup_add_closure: {
      "^": "Closure:1;",
      call$0: function() {
        return;
      }
    },
    StreamGroup_add_closure0: {
      "^": "Closure:1;$this,stream",
      call$0: function() {
        return this.$this._listenToStream$1(this.stream);
      }
    },
    StreamGroup__onListen_closure: {
      "^": "Closure:2;$this",
      call$2: function(stream, subscription) {
        var t1;
        if (subscription != null)
          return;
        t1 = this.$this;
        t1._subscriptions.$indexSet(0, stream, t1._listenToStream$1(stream));
      }
    },
    StreamGroup__onCancel_closure: {
      "^": "Closure:0;",
      call$1: [function(subscription) {
        return subscription.cancel$0();
      }, null, null, 4, 0, null, 50, "call"]
    },
    StreamGroup__onCancel_closure0: {
      "^": "Closure:0;",
      call$1: function(future) {
        return future != null;
      }
    },
    StreamGroup__listenToStream_closure: {
      "^": "Closure:1;$this,stream",
      call$0: [function() {
        return this.$this.remove$1(0, this.stream);
      }, null, null, 0, 0, null, "call"]
    },
    _StreamGroupState: {
      "^": "Object;name<",
      toString$0: function(_) {
        return this.name;
      }
    }
  }], ["", "package:async/src/stream_queue.dart",, G, {
    "^": "",
    StreamQueue: {
      "^": "Object;$ti",
      get$next: function() {
        var t1, t2;
        if (!this._isClosed) {
          t1 = this.$ti;
          t2 = new P._Future(0, $.Zone__current, null, t1);
          this._addRequest$1(new G._NextRequest(new P._AsyncCompleter(t2, t1), t1));
          return t2;
        }
        throw H.wrapException(this._failClosed$0());
      },
      skip$1: function(_, count) {
        var t1, t2;
        if (J.$lt$n(count, 0))
          throw H.wrapException(P.RangeError$range(count, 0, null, "count", null));
        if (!this._isClosed) {
          t1 = P.int;
          t2 = new P._Future(0, $.Zone__current, null, [t1]);
          this._addRequest$1(new G._SkipRequest(new P._AsyncCompleter(t2, [t1]), count, this.$ti));
          return t2;
        }
        throw H.wrapException(this._failClosed$0());
      },
      take$1: function(_, count) {
        var t1, t2, t3;
        if (J.$lt$n(count, 0))
          throw H.wrapException(P.RangeError$range(count, 0, null, "count", null));
        if (!this._isClosed) {
          t1 = [P.List, H.getTypeArgumentByIndex(this, 0)];
          t2 = new P._Future(0, $.Zone__current, null, [t1]);
          t3 = this.$ti;
          this._addRequest$1(new G._TakeRequest(new P._AsyncCompleter(t2, [t1]), H.setRuntimeTypeInfo([], t3), count, t3));
          return t2;
        }
        throw H.wrapException(this._failClosed$0());
      },
      cancel$1$immediate: function(immediate) {
        var t1;
        if (this._isClosed)
          throw H.wrapException(this._failClosed$0());
        this._isClosed = true;
        t1 = new P._Future(0, $.Zone__current, null, [null]);
        this._addRequest$1(new G._CancelRequest(new P._AsyncCompleter(t1, [null]), this, this.$ti));
        return t1;
      },
      cancel$0: function() {
        return this.cancel$1$immediate(false);
      },
      _updateRequests$0: function() {
        var t1, t2, t3, t4;
        for (t1 = this._requestQueue, t2 = this._eventQueue; !t1.get$isEmpty(t1);) {
          t3 = t1._collection$_head;
          if (t3 === t1._collection$_tail)
            H.throwExpression(H.IterableElementError_noElement());
          t4 = t1._collection$_table;
          if (t3 >= t4.length)
            return H.ioore(t4, t3);
          if (t4[t3].update$2(t2, this._isDone) === true)
            t1.removeFirst$0();
          else
            return;
        }
        if (!this._isDone)
          this._stream_queue$_subscription.pause$0(0);
      },
      _addResult$1: function(result) {
        ++this._eventsReceived;
        this._eventQueue._queue_list$_add$1(result);
        this._updateRequests$0();
      },
      _failClosed$0: function() {
        return new P.StateError("Already cancelled");
      },
      _addRequest$1: function(request) {
        var t1 = this._requestQueue;
        if (t1._collection$_head === t1._collection$_tail) {
          if (request.update$2(this._eventQueue, this._isDone))
            return;
          this._ensureListening$0();
        }
        t1._add$1(request);
      }
    },
    _StreamQueue: {
      "^": "StreamQueue;_stream_queue$_sourceStream,_stream_queue$_subscription,_isDone,_isClosed,_eventsReceived,_eventQueue,_requestQueue,$ti",
      _ensureListening$0: function() {
        if (this._isDone)
          return;
        var t1 = this._stream_queue$_subscription;
        if (t1 == null)
          this._stream_queue$_subscription = this._stream_queue$_sourceStream.listen$3$onDone$onError(new G._StreamQueue__ensureListening_closure(this), new G._StreamQueue__ensureListening_closure0(this), new G._StreamQueue__ensureListening_closure1(this));
        else
          t1.resume$0();
      },
      _extractStream$0: function() {
        var t1, wasPaused;
        if (this._isDone)
          return new P._EmptyStream(this.$ti);
        this._isDone = true;
        t1 = this._stream_queue$_subscription;
        if (t1 == null)
          return this._stream_queue$_sourceStream;
        this._stream_queue$_subscription = null;
        wasPaused = t1.get$isPaused();
        t1.pause$0(0);
        t1.onData$1(null);
        t1.onError$1(null);
        t1.onDone$1(null);
        if (wasPaused)
          t1.resume$0();
        return new T.SubscriptionStream(t1, this.$ti);
      }
    },
    _StreamQueue__ensureListening_closure: {
      "^": "Closure:0;$this",
      call$1: [function(data) {
        this.$this._addResult$1(new F.ValueResult(data, [null]));
      }, null, null, 4, 0, null, 16, "call"]
    },
    _StreamQueue__ensureListening_closure1: {
      "^": "Closure:7;$this",
      call$2: [function(error, stackTrace) {
        this.$this._addResult$1(new V.ErrorResult(error, stackTrace));
      }, null, null, 8, 0, null, 4, 5, "call"]
    },
    _StreamQueue__ensureListening_closure0: {
      "^": "Closure:1;$this",
      call$0: [function() {
        var t1 = this.$this;
        t1._stream_queue$_subscription = null;
        t1._isDone = true;
        t1._updateRequests$0();
      }, null, null, 0, 0, null, "call"]
    },
    _NextRequest: {
      "^": "Object;_stream_queue$_completer,$ti",
      get$future: function() {
        return this._stream_queue$_completer.future;
      },
      update$2: function(events, isDone) {
        if (events.get$isEmpty(events) !== true) {
          events.removeFirst$0().complete$1(this._stream_queue$_completer);
          return true;
        }
        if (isDone) {
          this._stream_queue$_completer.completeError$2(new P.StateError("No elements"), P.StackTrace_current());
          return true;
        }
        return false;
      }
    },
    _SkipRequest: {
      "^": "Object;_stream_queue$_completer,_eventsToSkip,$ti",
      get$future: function() {
        return this._stream_queue$_completer.future;
      },
      update$2: function(events, isDone) {
        var $event;
        for (; J.$gt$n(this._eventsToSkip, 0);) {
          if (events.get$length(events) === 0) {
            if (isDone)
              break;
            return false;
          }
          this._eventsToSkip = J.$sub$n(this._eventsToSkip, 1);
          $event = events.removeFirst$0();
          if ($event.get$isError()) {
            this._stream_queue$_completer.completeError$2($event.get$asError().error, $event.get$asError().stackTrace);
            return true;
          }
        }
        this._stream_queue$_completer.complete$1(this._eventsToSkip);
        return true;
      }
    },
    _ListRequest: {
      "^": "Object;$ti",
      get$future: function() {
        return this._stream_queue$_completer.future;
      }
    },
    _TakeRequest: {
      "^": "_ListRequest;_stream_queue$_completer,_list,_eventsToTake,$ti",
      update$2: function(events, isDone) {
        var t1, t2, $event;
        t1 = this._list;
        t2 = this._eventsToTake;
        if (typeof t2 !== "number")
          return H.iae(t2);
        for (; t1.length < t2;) {
          if (events.get$length(events) === 0) {
            if (isDone)
              break;
            return false;
          }
          $event = events.removeFirst$0();
          if ($event.get$isError()) {
            t1 = $event.get$asError();
            this._stream_queue$_completer.completeError$2(t1.error, t1.stackTrace);
            return true;
          }
          t1.push($event.get$asValue().value);
        }
        this._stream_queue$_completer.complete$1(t1);
        return true;
      }
    },
    _CancelRequest: {
      "^": "Object;_stream_queue$_completer,_streamQueue,$ti",
      get$future: function() {
        return this._stream_queue$_completer.future;
      },
      update$2: function(events, isDone) {
        var t1, t2;
        t1 = this._streamQueue;
        t2 = this._stream_queue$_completer;
        if (t1._isDone)
          t2.complete$0();
        else {
          t1._ensureListening$0();
          t2.complete$1(t1._extractStream$0().listen$1(null).cancel$0());
        }
        return true;
      }
    }
  }], ["", "package:async/src/subscription_stream.dart",, T, {
    "^": "",
    SubscriptionStream: {
      "^": "Stream;_subscription_stream$_source,$ti",
      listen$4$cancelOnError$onDone$onError: function(onData, cancelOnError, onDone, onError) {
        var result, result0;
        result = this._subscription_stream$_source;
        if (result == null)
          throw H.wrapException(P.StateError$("Stream has already been listened to."));
        this._subscription_stream$_source = null;
        result0 = true === cancelOnError ? new T._CancelOnErrorSubscriptionWrapper(result, this.$ti) : result;
        result0.onData$1(onData);
        result0.onError$1(onError);
        result0.onDone$1(onDone);
        result.resume$0();
        return result0;
      },
      listen$3$onDone$onError: function(onData, onDone, onError) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, onDone, onError);
      },
      listen$1: function(onData) {
        return this.listen$4$cancelOnError$onDone$onError(onData, null, null, null);
      }
    },
    _CancelOnErrorSubscriptionWrapper: {
      "^": "DelegatingStreamSubscription;_stream_subscription$_source,$ti",
      onError$1: function(handleError) {
        this.super$DelegatingStreamSubscription$onError(new T._CancelOnErrorSubscriptionWrapper_onError_closure(this, handleError));
      }
    },
    _CancelOnErrorSubscriptionWrapper_onError_closure: {
      "^": "Closure:7;$this,handleError",
      call$2: [function(error, stackTrace) {
        var cancelFuture, t1;
        cancelFuture = this.$this.super$DelegatingStreamSubscription$cancel();
        if (cancelFuture != null)
          cancelFuture.whenComplete$1(new T._CancelOnErrorSubscriptionWrapper_onError__closure(this.handleError, error, stackTrace));
        else {
          t1 = this.handleError;
          if (H.functionTypeTest(t1, {func: 1, args: [,,]}))
            t1.call$2(error, stackTrace);
          else
            t1.call$1(error);
        }
      }, null, null, 8, 0, null, 4, 5, "call"]
    },
    _CancelOnErrorSubscriptionWrapper_onError__closure: {
      "^": "Closure:1;handleError,error,stackTrace",
      call$0: function() {
        var t1, t2;
        t1 = this.handleError;
        t2 = this.error;
        if (H.functionTypeTest(t1, {func: 1, args: [,,]}))
          t1.call$2(t2, this.stackTrace);
        else
          t1.call$1(t2);
      }
    }
  }], ["cli_repl", "package:cli_repl/cli_repl.dart",, Q, {
    "^": "",
    Repl: {
      "^": "Object;prompt,continuation,validator,useSharedStdIn,_adapter<,history,maxHistory",
      run$0: function(_) {
        return this._adapter.run$0(0);
      }
    },
    closure121: {
      "^": "Closure:0;",
      call$1: function(text) {
        return true;
      }
    }
  }], ["", "package:cli_repl/src/repl_adapter/node.dart",, B, {
    "^": "",
    ReplAdapter: {
      "^": "Object;repl,rl",
      run$0: function($async$_) {
        return P._makeSyncStarIterable(function() {
          var _ = $async$_;
          var $async$goto = 0, $async$handler = 1, $async$currentError;
          return function $async$run$0($async$errorCode, $async$result) {
            if ($async$errorCode === 1) {
              $async$currentError = $async$result;
              $async$goto = $async$handler;
            }
            while (true)
              switch ($async$goto) {
                case 0:
                  // Function start
                  throw H.wrapException(P.UnsupportedError$("Synchronous REPLs not supported in Node"));
                  // implicit return
                  return P._IterationMarker_endOfIteration();
                case 1:
                  // rethrow
                  return P._IterationMarker_uncaughtError($async$currentError);
              }
          };
        }, P.String);
      },
      runAsync$0: function() {
        var $async$runAsync$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          switch ($async$errorCode) {
            case 2:
              $async$next = $async$nextWhenCanceled;
              $async$goto = $async$next.pop();
              break;
            case 1:
              $async$currentError = $async$result;
              $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = J.get$isTTY$x(self.process.stdin);
                output = (t1 == null ? false : t1) === true ? self.process.stdout : null;
                t1 = $async$self.repl;
                $prompt = t1.prompt;
                $async$self.rl = J.createInterface$1$x($.$get$readline(), {input: self.process.stdin, output: output, prompt: $prompt});
                t2 = P.String;
                controller = P.StreamController_StreamController(null, null, null, null, false, t2);
                queue = new G._StreamQueue(new P._ControllerStream(controller, [H.getTypeArgumentByIndex(controller, 0)]), null, false, false, 0, Q.QueueList$(null, null), P.ListQueue$(null, null), [t2]);
                J.on$2$x($async$self.rl, "line", P.allowInterop(new B.ReplAdapter_runAsync_closure(controller)));
                prompt0 = t1.continuation, prompt1 = $prompt, statement = "";
              case 3:
                // for condition
                // trivial condition
                t2 = J.get$isTTY$x(self.process.stdin);
                if ((t2 == null ? false : t2) === true)
                  J.write$1$x(self.process.stdout, prompt1);
                $async$goto = 5;
                return P._asyncStarHelper(queue.get$next(), $async$runAsync$0, $async$controller);
              case 5:
                // returning from await.
                line = $async$result;
                t2 = J.get$isTTY$x(self.process.stdin);
                if ((t2 == null ? false : t2) !== true)
                  H.printString(prompt1 + H.S(line));
                statement = C.JSString_methods.$add(statement, line);
                $async$goto = t1.validator.call$1(statement) === true ? 6 : 8;
                break;
              case 6:
                // then
                $async$goto = 9;
                $async$nextWhenCanceled = [1];
                return P._asyncStarHelper(P._IterationMarker_yieldSingle(statement), $async$runAsync$0, $async$controller);
              case 9:
                // after yield
                J.setPrompt$1$x($async$self.rl, $prompt);
                prompt1 = $prompt;
                statement = "";
                // goto join
                $async$goto = 7;
                break;
              case 8:
                // else
                statement += "\n";
                J.setPrompt$1$x($async$self.rl, prompt0);
                prompt1 = prompt0;
              case 7:
                // join
                // goto for condition
                $async$goto = 3;
                break;
              case 4:
                // after for
              case 1:
                // return
                return P._asyncStarHelper(null, 0, $async$controller);
              case 2:
                // rethrow
                return P._asyncStarHelper($async$currentError, 1, $async$controller);
            }
        });
        var $async$goto = 0, $async$controller = P._makeAsyncStarStreamController($async$runAsync$0, P.String), $async$nextWhenCanceled, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, t1, output, $prompt, t2, controller, queue, prompt0, prompt1, statement, line;
        return P._streamOfController($async$controller);
      }
    },
    ReplAdapter_runAsync_closure: {
      "^": "Closure:5;controller",
      call$1: [function(value) {
        this.controller.add$1(0, value);
      }, function() {
        return this.call$1(null);
      }, "call$0", null, null, null, 0, 2, null, 2, 3, "call"]
    },
    Stdin: {
      "^": "JavaScriptObject;",
      "%": ""
    },
    Stdout: {
      "^": "JavaScriptObject;",
      "%": ""
    },
    ReadlineModule: {
      "^": "JavaScriptObject;",
      "%": ""
    },
    ReadlineOptions: {
      "^": "JavaScriptObject;",
      "%": ""
    },
    ReadlineInterface: {
      "^": "JavaScriptObject;",
      "%": ""
    }
  }], ["", "package:collection/src/empty_unmodifiable_set.dart",, O, {
    "^": "",
    EmptyUnmodifiableSet: {
      "^": "IterableBase;$ti",
      get$iterator: function(_) {
        return C.C_EmptyIterator;
      },
      get$length: function(_) {
        return 0;
      },
      contains$1: function(_, element) {
        return false;
      },
      add$1: function(_, value) {
        return O.EmptyUnmodifiableSet__throw();
      },
      remove$1: function(_, element) {
        return O.EmptyUnmodifiableSet__throw();
      },
      $isEfficientLengthIterable: 1,
      $isSet: 1,
      static: {
        EmptyUnmodifiableSet__throw: function() {
          throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable Set"));
        }
      }
    }
  }], ["", "package:collection/src/equality.dart",, U, {
    "^": "",
    DefaultEquality: {
      "^": "Object;$ti"
    },
    ListEquality: {
      "^": "Object;_elementEquality,$ti",
      equals$2: function(list1, list2) {
        var t1, $length, t2, i;
        if (list1 == null ? list2 == null : list1 === list2)
          return true;
        if (list1 == null || list2 == null)
          return false;
        t1 = J.getInterceptor$asx(list1);
        $length = t1.get$length(list1);
        t2 = J.getInterceptor$asx(list2);
        if (J.$eq$($length, t2.get$length(list2)) !== true)
          return false;
        if (typeof $length !== "number")
          return H.iae($length);
        i = 0;
        for (; i < $length; ++i)
          if (J.$eq$(t1.$index(list1, i), t2.$index(list2, i)) !== true)
            return false;
        return true;
      },
      hash$1: function(list) {
        var t1, hash, i;
        for (t1 = list.length, hash = 0, i = 0; i < t1; ++i) {
          hash = hash + J.get$hashCode$(list[i]) & 2147483647;
          hash = hash + (hash << 10 >>> 0) & 2147483647;
          hash ^= hash >>> 6;
        }
        hash = hash + (hash << 3 >>> 0) & 2147483647;
        hash ^= hash >>> 11;
        return hash + (hash << 15 >>> 0) & 2147483647;
      }
    },
    _MapEntry: {
      "^": "Object;equality,key<,value<",
      get$hashCode: function(_) {
        return 3 * J.get$hashCode$(this.key) + 7 * J.get$hashCode$(this.value) & 2147483647;
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        return other instanceof U._MapEntry && J.$eq$(this.key, other.key) === true && J.$eq$(this.value, other.value) === true;
      }
    },
    MapEquality: {
      "^": "Object;_keyEquality,_valueEquality,$ti",
      equals$2: function(map1, map2) {
        var equalElementCounts, t1, key, entry, count;
        if (map1 === map2)
          return true;
        if (J.$eq$(map1.get$length(map1), map2.get$length(map2)) !== true)
          return false;
        equalElementCounts = P.HashMap_HashMap(null, null, null, null, null);
        for (t1 = map1.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
          key = t1.get$current(t1);
          entry = new U._MapEntry(this, key, map1.$index(0, key));
          count = equalElementCounts.$index(0, entry);
          equalElementCounts.$indexSet(0, entry, J.$add$ansx(count == null ? 0 : count, 1));
        }
        for (t1 = map2.get$keys(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
          key = t1.get$current(t1);
          entry = new U._MapEntry(this, key, map2.$index(0, key));
          count = equalElementCounts.$index(0, entry);
          if (count == null || J.$eq$(count, 0) === true)
            return false;
          equalElementCounts.$indexSet(0, entry, J.$sub$n(count, 1));
        }
        return true;
      },
      hash$1: function(map) {
        var t1, hash, key;
        for (t1 = map.get$keys(), t1 = t1.get$iterator(t1), hash = 0; t1.moveNext$0();) {
          key = t1.get$current(t1);
          hash = hash + 3 * J.get$hashCode$(key) + 7 * J.get$hashCode$(map.$index(0, key)) & 2147483647;
        }
        hash = hash + (hash << 3 >>> 0) & 2147483647;
        hash ^= hash >>> 11;
        return hash + (hash << 15 >>> 0) & 2147483647;
      }
    }
  }], ["", "package:collection/src/functions.dart",, Y, {
    "^": "",
    mapMap: function(map, key, value) {
      var t1, result;
      t1 = {};
      t1.key = key;
      t1.value = value;
      if (key == null)
        t1.key = new Y.mapMap_closure();
      if (value == null)
        t1.value = new Y.mapMap_closure0();
      result = P.LinkedHashMap__makeEmpty();
      map.forEach$1(0, new Y.mapMap_closure1(t1, result));
      return result;
    },
    mapMap_closure: {
      "^": "Closure:2;",
      call$2: function(mapKey, _) {
        return mapKey;
      }
    },
    mapMap_closure0: {
      "^": "Closure:2;",
      call$2: function(_, mapValue) {
        return mapValue;
      }
    },
    mapMap_closure1: {
      "^": "Closure:2;_box_0,result",
      call$2: function(mapKey, mapValue) {
        var t1 = this._box_0;
        this.result.$indexSet(0, t1.key.call$2(mapKey, mapValue), t1.value.call$2(mapKey, mapValue));
      }
    }
  }], ["", "package:collection/src/queue_list.dart",, Q, {
    "^": "",
    QueueList: {
      "^": "_QueueList_Object_ListMixin;_table,_head@,_tail@,$ti",
      QueueList$1: function(initialCapacity, $E) {
        var t1;
        if (initialCapacity == null || J.$lt$n(initialCapacity, 8))
          initialCapacity = 8;
        else {
          t1 = J.getInterceptor$n(initialCapacity);
          if (t1.$and(initialCapacity, t1.$sub(initialCapacity, 1)) !== 0)
            initialCapacity = Q.QueueList__nextPowerOf2(initialCapacity);
        }
        if (typeof initialCapacity !== "number")
          return H.iae(initialCapacity);
        t1 = new Array(initialCapacity);
        t1.fixed$length = Array;
        this._table = H.setRuntimeTypeInfo(t1, [$E]);
      },
      add$1: function(_, element) {
        this._queue_list$_add$1(element);
      },
      addAll$1: function(_, iterable) {
        var t1, addCount, $length, t2, endSpace, preSpace;
        t1 = J.getInterceptor(iterable);
        if (!!t1.$isList) {
          addCount = t1.get$length(iterable);
          $length = this.get$length(this);
          if (typeof addCount !== "number")
            return H.iae(addCount);
          t1 = $length + addCount;
          t2 = J.get$length$asx(this._table);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (t1 >= t2) {
            this._preGrow$1(t1);
            J.setRange$4$ax(this._table, $length, t1, iterable, 0);
            this.set$_tail(J.$add$ansx(this.get$_tail(), addCount));
          } else {
            endSpace = J.$sub$n(J.get$length$asx(this._table), this.get$_tail());
            if (typeof endSpace !== "number")
              return H.iae(endSpace);
            t1 = this._table;
            if (addCount < endSpace) {
              J.setRange$4$ax(t1, this.get$_tail(), J.$add$ansx(this.get$_tail(), addCount), iterable, 0);
              this.set$_tail(J.$add$ansx(this.get$_tail(), addCount));
            } else {
              preSpace = addCount - endSpace;
              J.setRange$4$ax(t1, this.get$_tail(), J.$add$ansx(this.get$_tail(), endSpace), iterable, 0);
              J.setRange$4$ax(this._table, 0, preSpace, iterable, endSpace);
              this.set$_tail(preSpace);
            }
          }
        } else
          for (t1 = t1.get$iterator(iterable); t1.moveNext$0();)
            this._queue_list$_add$1(t1.get$current(t1));
      },
      cast$0: function(_) {
        var t1 = new Q._CastQueueList(this, null, null, null, [null, null]);
        t1._table = J.cast$0$ax(this._table);
        return t1;
      },
      toString$0: function(_) {
        return P.IterableBase_iterableToFullString(this, "{", "}");
      },
      addFirst$1: function(element) {
        var t1, t2;
        t1 = this.get$_head();
        if (typeof t1 !== "number")
          return t1.$sub();
        t2 = J.$sub$n(J.get$length$asx(this._table), 1);
        if (typeof t2 !== "number")
          return H.iae(t2);
        this.set$_head((t1 - 1 & t2) >>> 0);
        J.$indexSet$ax(this._table, this.get$_head(), element);
        t1 = this.get$_head();
        t2 = this.get$_tail();
        if (t1 == null ? t2 == null : t1 === t2)
          this._queue_list$_grow$0();
      },
      removeFirst$0: function() {
        var t1, t2, result;
        t1 = this.get$_head();
        t2 = this.get$_tail();
        if (t1 == null ? t2 == null : t1 === t2)
          throw H.wrapException(P.StateError$("No element"));
        result = J.$index$asx(this._table, this.get$_head());
        J.$indexSet$ax(this._table, this.get$_head(), null);
        t1 = this.get$_head();
        if (typeof t1 !== "number")
          return t1.$add();
        t2 = J.$sub$n(J.get$length$asx(this._table), 1);
        if (typeof t2 !== "number")
          return H.iae(t2);
        this.set$_head((t1 + 1 & t2) >>> 0);
        return result;
      },
      get$length: function(_) {
        return J.$and$n(J.$sub$n(this.get$_tail(), this.get$_head()), J.$sub$n(J.get$length$asx(this._table), 1));
      },
      set$length: function(_, value) {
        var t1, delta, newTail, t2, t3;
        t1 = J.getInterceptor$n(value);
        if (t1.$lt(value, 0))
          throw H.wrapException(P.RangeError$("Length " + H.S(value) + " may not be negative."));
        delta = t1.$sub(value, this.get$length(this));
        if (J.$ge$n(delta, 0)) {
          if (J.$le$n(J.get$length$asx(this._table), value))
            this._preGrow$1(value);
          this.set$_tail(J.$and$n(J.$add$ansx(this.get$_tail(), delta), J.$sub$n(J.get$length$asx(this._table), 1)));
          return;
        }
        newTail = J.$add$ansx(this.get$_tail(), delta);
        t1 = J.getInterceptor$n(newTail);
        t2 = t1.$ge(newTail, 0);
        t3 = this._table;
        if (t2)
          J.fillRange$3$ax(t3, newTail, this.get$_tail(), null);
        else {
          newTail = t1.$add(newTail, J.get$length$asx(t3));
          J.fillRange$3$ax(this._table, 0, this.get$_tail(), null);
          t1 = this._table;
          t2 = J.getInterceptor$asx(t1);
          t2.fillRange$3(t1, newTail, t2.get$length(t1), null);
        }
        this.set$_tail(newTail);
      },
      $index: function(_, index) {
        var t1, t2, t3;
        t1 = J.getInterceptor$n(index);
        if (t1.$lt(index, 0) || t1.$ge(index, this.get$length(this)))
          throw H.wrapException(P.RangeError$("Index " + H.S(index) + " must be in the range [0.." + this.get$length(this) + ")."));
        t1 = this._table;
        t2 = this.get$_head();
        if (typeof t2 !== "number")
          return t2.$add();
        if (typeof index !== "number")
          return H.iae(index);
        t3 = J.$sub$n(J.get$length$asx(this._table), 1);
        if (typeof t3 !== "number")
          return H.iae(t3);
        return J.$index$asx(t1, (t2 + index & t3) >>> 0);
      },
      $indexSet: function(_, index, value) {
        var t1, t2, t3;
        t1 = J.getInterceptor$n(index);
        if (t1.$lt(index, 0) || t1.$ge(index, this.get$length(this)))
          throw H.wrapException(P.RangeError$("Index " + H.S(index) + " must be in the range [0.." + this.get$length(this) + ")."));
        t1 = this._table;
        t2 = this.get$_head();
        if (typeof t2 !== "number")
          return t2.$add();
        if (typeof index !== "number")
          return H.iae(index);
        t3 = J.$sub$n(J.get$length$asx(this._table), 1);
        if (typeof t3 !== "number")
          return H.iae(t3);
        J.$indexSet$ax(t1, (t2 + index & t3) >>> 0, value);
      },
      _queue_list$_add$1: function(element) {
        var t1, t2;
        J.$indexSet$ax(this._table, this.get$_tail(), element);
        this.set$_tail(J.$and$n(J.$add$ansx(this.get$_tail(), 1), J.$sub$n(J.get$length$asx(this._table), 1)));
        t1 = this.get$_head();
        t2 = this.get$_tail();
        if (t1 == null ? t2 == null : t1 === t2)
          this._queue_list$_grow$0();
      },
      _queue_list$_grow$0: function() {
        var t1, newTable, split;
        t1 = J.$mul$ns(J.get$length$asx(this._table), 2);
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = new Array(t1);
        t1.fixed$length = Array;
        newTable = H.setRuntimeTypeInfo(t1, [H.getRuntimeTypeArgument(this, "QueueList", 0)]);
        split = J.$sub$n(J.get$length$asx(this._table), this.get$_head());
        C.JSArray_methods.setRange$4(newTable, 0, split, this._table, this.get$_head());
        C.JSArray_methods.setRange$4(newTable, split, J.$add$ansx(split, this.get$_head()), this._table, 0);
        this.set$_head(0);
        this.set$_tail(J.get$length$asx(this._table));
        this._table = newTable;
      },
      _queue_list$_writeToList$1: function(target) {
        var t1, t2, $length, firstPartSize;
        t1 = this.get$_head();
        t2 = this.get$_tail();
        if (typeof t1 !== "number")
          return t1.$le();
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (t1 <= t2) {
          $length = J.$sub$n(this.get$_tail(), this.get$_head());
          C.JSArray_methods.setRange$4(target, 0, $length, this._table, this.get$_head());
          return $length;
        } else {
          firstPartSize = J.$sub$n(J.get$length$asx(this._table), this.get$_head());
          C.JSArray_methods.setRange$4(target, 0, firstPartSize, this._table, this.get$_head());
          C.JSArray_methods.setRange$4(target, firstPartSize, J.$add$ansx(firstPartSize, this.get$_tail()), this._table, 0);
          return J.$add$ansx(this.get$_tail(), firstPartSize);
        }
      },
      _preGrow$1: function(newElementCount) {
        var t1, newCapacity, newTable;
        t1 = J.getInterceptor$n(newElementCount);
        newCapacity = Q.QueueList__nextPowerOf2(t1.$add(newElementCount, t1.$shr(newElementCount, 1)));
        if (typeof newCapacity !== "number")
          return H.iae(newCapacity);
        t1 = new Array(newCapacity);
        t1.fixed$length = Array;
        newTable = H.setRuntimeTypeInfo(t1, [H.getRuntimeTypeArgument(this, "QueueList", 0)]);
        this.set$_tail(this._queue_list$_writeToList$1(newTable));
        this._table = newTable;
        this.set$_head(0);
      },
      $isEfficientLengthIterable: 1,
      $isIterable: 1,
      $isList: 1,
      static: {
        QueueList$: function(initialCapacity, $E) {
          var t1 = new Q.QueueList(null, 0, 0, [$E]);
          t1.QueueList$1(initialCapacity, $E);
          return t1;
        },
        QueueList_QueueList$from: function(source, $E) {
          var t1, $length, queue;
          t1 = J.getInterceptor(source);
          if (!!t1.$isList) {
            $length = t1.get$length(source);
            queue = Q.QueueList$(J.$add$ansx($length, 1), null);
            J.setRange$4$ax(queue._table, 0, $length, source, 0);
            queue._tail = $length;
            return queue;
          } else {
            t1 = Q.QueueList$(null, $E);
            t1.addAll$1(0, source);
            return t1;
          }
        },
        QueueList__nextPowerOf2: function(number) {
          var nextNumber;
          number = J.$shl$n(number, 1) - 1;
          for (; true; number = nextNumber) {
            nextNumber = (number & number - 1) >>> 0;
            if (nextNumber === 0)
              return number;
          }
        }
      }
    },
    _CastQueueList: {
      "^": "QueueList;_delegate,_table,_head,_tail,$ti",
      get$_head: function() {
        return this._delegate.get$_head();
      },
      set$_head: function(value) {
        this._delegate.set$_head(value);
        return value;
      },
      get$_tail: function() {
        return this._delegate.get$_tail();
      },
      set$_tail: function(value) {
        this._delegate.set$_tail(value);
        return value;
      },
      $asEfficientLengthIterable: function($S, $T) {
        return [$T];
      },
      $asListMixin: function($S, $T) {
        return [$T];
      },
      $asIterable: function($S, $T) {
        return [$T];
      },
      $asList: function($S, $T) {
        return [$T];
      },
      $asQueueList: function($S, $T) {
        return [$T];
      },
      $as_QueueList_Object_ListMixin: function($S, $T) {
        return [$T];
      }
    },
    _QueueList_Object_ListMixin: {
      "^": "Object+ListMixin;$ti"
    }
  }], ["", "package:collection/src/unmodifiable_wrappers.dart",, L, {
    "^": "",
    UnmodifiableSetMixin__throw: function() {
      throw H.wrapException(P.UnsupportedError$("Cannot modify an unmodifiable Set"));
    },
    UnmodifiableSetView: {
      "^": "_UnmodifiableSetView_DelegatingSet_UnmodifiableSetMixin;_base,$ti"
    },
    UnmodifiableSetMixin: {
      "^": "Object;$ti",
      add$1: function(_, value) {
        return L.UnmodifiableSetMixin__throw();
      },
      remove$1: function(_, value) {
        return L.UnmodifiableSetMixin__throw();
      }
    },
    _UnmodifiableSetView_DelegatingSet_UnmodifiableSetMixin: {
      "^": "DelegatingSet+UnmodifiableSetMixin;$ti"
    }
  }], ["", "package:collection/src/wrappers.dart",, M, {
    "^": "",
    _DelegatingIterableBase: {
      "^": "Object;$ti",
      any$1: function(_, test) {
        return J.any$1$ax(this.get$_base(), test);
      },
      contains$1: function(_, element) {
        return J.contains$1$asx(this.get$_base(), element);
      },
      elementAt$1: function(_, index) {
        return J.elementAt$1$ax(this.get$_base(), index);
      },
      every$1: function(_, test) {
        return J.every$1$ax(this.get$_base(), test);
      },
      expand$1: function(_, f) {
        return J.expand$1$ax(this.get$_base(), f);
      },
      get$first: function(_) {
        return J.get$first$ax(this.get$_base());
      },
      forEach$1: function(_, f) {
        return J.forEach$1$ax(this.get$_base(), f);
      },
      get$isEmpty: function(_) {
        return J.get$isEmpty$asx(this.get$_base());
      },
      get$isNotEmpty: function(_) {
        return J.get$isNotEmpty$asx(this.get$_base());
      },
      get$iterator: function(_) {
        return J.get$iterator$ax(this.get$_base());
      },
      join$1: function(_, separator) {
        return J.join$1$ax(this.get$_base(), separator);
      },
      join$0: function($receiver) {
        return this.join$1($receiver, "");
      },
      get$last: function(_) {
        return J.get$last$ax(this.get$_base());
      },
      get$length: function(_) {
        return J.get$length$asx(this.get$_base());
      },
      map$1: function(_, f) {
        return J.map$1$ax(this.get$_base(), f);
      },
      get$single: function(_) {
        return J.get$single$ax(this.get$_base());
      },
      skip$1: function(_, n) {
        return J.skip$1$ax(this.get$_base(), n);
      },
      take$1: function(_, n) {
        return J.take$1$ax(this.get$_base(), n);
      },
      toList$1$growable: function(_, growable) {
        return J.toList$1$growable$ax(this.get$_base(), growable);
      },
      toList$0: function($receiver) {
        return this.toList$1$growable($receiver, true);
      },
      where$1: function(_, test) {
        return J.where$1$ax(this.get$_base(), test);
      },
      toString$0: function(_) {
        return J.toString$0$(this.get$_base());
      },
      $isIterable: 1
    },
    DelegatingIterable: {
      "^": "_DelegatingIterableBase;_base<,$ti"
    },
    DelegatingSet: {
      "^": "DelegatingIterable;$ti",
      add$1: function(_, value) {
        return this._base.add$1(0, value);
      },
      remove$1: function(_, value) {
        return this._base.remove$1(0, value);
      },
      $isEfficientLengthIterable: 1,
      $isSet: 1
    },
    MapKeySet: {
      "^": "_MapKeySet__DelegatingIterableBase_UnmodifiableSetMixin;_baseMap,$ti",
      get$_base: function() {
        return this._baseMap.get$keys();
      },
      contains$1: function(_, element) {
        return this._baseMap.containsKey$1(element);
      },
      get$isEmpty: function(_) {
        return J.get$isEmpty$asx(this._baseMap);
      },
      get$isNotEmpty: function(_) {
        return J.get$isNotEmpty$asx(this._baseMap);
      },
      get$length: function(_) {
        return J.get$length$asx(this._baseMap);
      },
      toString$0: function(_) {
        var t1 = this._baseMap.get$keys();
        return "{" + t1.join$1(t1, ", ") + "}";
      },
      $isEfficientLengthIterable: 1,
      $isSet: 1
    },
    _MapKeySet__DelegatingIterableBase_UnmodifiableSetMixin: {
      "^": "_DelegatingIterableBase+UnmodifiableSetMixin;$ti"
    }
  }], ["", "package:path/path.dart",, D, {
    "^": "",
    current: function() {
      var uri, t1, t2, path, lastIndex;
      uri = P.Uri_base();
      if (J.$eq$(uri, $._currentUriBase) === true)
        return $._current;
      $._currentUriBase = uri;
      t1 = $.$get$Style_platform();
      t2 = $.$get$Style_url();
      if (t1 == null ? t2 == null : t1 === t2) {
        t1 = uri.resolve$1(".").toString$0(0);
        $._current = t1;
        return t1;
      } else {
        path = uri.toFilePath$0();
        lastIndex = path.length - 1;
        t1 = lastIndex === 0 ? path : C.JSString_methods.substring$2(path, 0, lastIndex);
        $._current = t1;
        return t1;
      }
    }
  }], ["", "package:path/src/context.dart",, M, {
    "^": "",
    _parseUri: function(uri) {
      if (typeof uri === "string")
        return P.Uri_parse(uri, 0, null);
      if (!!J.getInterceptor(uri).$isUri)
        return uri;
      throw H.wrapException(P.ArgumentError$value(uri, "uri", "Value must be a String or a Uri"));
    },
    _validateArgList: function(method, args) {
      var numArgs, i, numArgs0, message, t1, t2;
      for (numArgs = args.length, i = 1; i < numArgs; ++i) {
        if (args[i] == null || args[i - 1] != null)
          continue;
        for (; numArgs >= 1; numArgs = numArgs0) {
          numArgs0 = numArgs - 1;
          if (args[numArgs0] != null)
            break;
        }
        message = new P.StringBuffer("");
        t1 = method + "(";
        message._contents = t1;
        t2 = H.SubListIterable$(args, 0, numArgs, H.getTypeArgumentByIndex(args, 0));
        t2 = t1 + new H.MappedListIterable(t2, new M._validateArgList_closure(), [H.getTypeArgumentByIndex(t2, 0), null]).join$1(0, ", ");
        message._contents = t2;
        message._contents = t2 + ("): part " + (i - 1) + " was null, but part " + i + " was not.");
        throw H.wrapException(P.ArgumentError$(message.toString$0(0)));
      }
    },
    Context: {
      "^": "Object;style,_context$_current",
      get$current: function(_) {
        var t1 = this._context$_current;
        return t1 != null ? t1 : D.current();
      },
      get$separator: function() {
        return this.style.get$separator();
      },
      absolute$7: function(part1, part2, part3, part4, part5, part6, part7) {
        var t1;
        M._validateArgList("absolute", [part1, part2, part3, part4, part5, part6, part7]);
        t1 = this.style;
        t1 = J.$gt$n(t1.rootLength$1(part1), 0) && t1.isRootRelative$1(part1) !== true;
        if (t1)
          return part1;
        t1 = this._context$_current;
        return this.join$8(0, t1 != null ? t1 : D.current(), part1, part2, part3, part4, part5, part6, part7);
      },
      absolute$1: function(part1) {
        return this.absolute$7(part1, null, null, null, null, null, null);
      },
      dirname$1: [function(path) {
        var parsed, t1, t2;
        parsed = X.ParsedPath_ParsedPath$parse(path, this.style);
        parsed.removeTrailingSeparators$0();
        t1 = parsed.parts;
        t2 = t1.length;
        if (t2 === 0) {
          t1 = parsed.root;
          return t1 == null ? "." : t1;
        }
        if (t2 === 1) {
          t1 = parsed.root;
          return t1 == null ? "." : t1;
        }
        C.JSArray_methods.removeLast$0(t1);
        C.JSArray_methods.removeLast$0(parsed.separators);
        parsed.removeTrailingSeparators$0();
        return parsed.toString$0(0);
      }, "call$1", "get$dirname", 4, 0, 33, 6],
      join$8: function(_, part1, part2, part3, part4, part5, part6, part7, part8) {
        var parts = H.setRuntimeTypeInfo([part1, part2, part3, part4, part5, part6, part7, part8], [P.String]);
        M._validateArgList("join", parts);
        return this.joinAll$1(new H.WhereIterable(parts, new M.Context_join_closure(), [H.getTypeArgumentByIndex(parts, 0)]));
      },
      join$1: function($receiver, part1) {
        return this.join$8($receiver, part1, null, null, null, null, null, null, null);
      },
      join$2: function($receiver, part1, part2) {
        return this.join$8($receiver, part1, part2, null, null, null, null, null, null);
      },
      joinAll$1: function(parts) {
        var t1, t2, t3, needsSeparator, isAbsoluteAndNotRootRelative, t4, part, parsed, path, t5;
        for (t1 = parts.get$iterator(parts), t2 = new H.WhereIterator(t1, new M.Context_joinAll_closure(), [H.getTypeArgumentByIndex(parts, 0)]), t3 = this.style, needsSeparator = false, isAbsoluteAndNotRootRelative = false, t4 = ""; t2.moveNext$0();) {
          part = t1.get$current(t1);
          if (t3.isRootRelative$1(part) === true && isAbsoluteAndNotRootRelative) {
            parsed = X.ParsedPath_ParsedPath$parse(part, t3);
            path = t4.charCodeAt(0) == 0 ? t4 : t4;
            t4 = C.JSString_methods.substring$2(path, 0, t3.rootLength$2$withDrive(path, true));
            parsed.root = t4;
            if (t3.needsSeparator$1(t4)) {
              t4 = parsed.separators;
              t5 = t3.get$separator();
              if (0 >= t4.length)
                return H.ioore(t4, 0);
              t4[0] = t5;
            }
            t4 = parsed.toString$0(0);
          } else if (J.$gt$n(t3.rootLength$1(part), 0)) {
            isAbsoluteAndNotRootRelative = t3.isRootRelative$1(part) !== true;
            t4 = H.S(part);
          } else {
            t5 = J.getInterceptor$asx(part);
            if (!(J.$gt$n(t5.get$length(part), 0) && t3.containsSeparator$1(t5.$index(part, 0)) === true))
              if (needsSeparator)
                t4 += t3.get$separator();
            t4 += H.S(part);
          }
          needsSeparator = t3.needsSeparator$1(part);
        }
        return t4.charCodeAt(0) == 0 ? t4 : t4;
      },
      split$1: function(_, path) {
        var parsed, t1, t2;
        parsed = X.ParsedPath_ParsedPath$parse(path, this.style);
        t1 = parsed.parts;
        t2 = H.getTypeArgumentByIndex(t1, 0);
        t2 = P.List_List$from(new H.WhereIterable(t1, new M.Context_split_closure(), [t2]), true, t2);
        parsed.parts = t2;
        t1 = parsed.root;
        if (t1 != null)
          C.JSArray_methods.insert$2(t2, 0, t1);
        return parsed.parts;
      },
      canonicalize$1: function(path) {
        var t1, t2, parsed;
        path = this.absolute$1(path);
        t1 = this.style;
        t2 = $.$get$Style_windows();
        if ((t1 == null ? t2 != null : t1 !== t2) && !this._needsNormalization$1(path))
          return path;
        parsed = X.ParsedPath_ParsedPath$parse(path, t1);
        parsed.normalize$1$canonicalize(true);
        return parsed.toString$0(0);
      },
      normalize$1: function(path) {
        var parsed;
        if (!this._needsNormalization$1(path))
          return path;
        parsed = X.ParsedPath_ParsedPath$parse(path, this.style);
        parsed.normalize$0();
        return parsed.toString$0(0);
      },
      _needsNormalization$1: function(path) {
        var codeUnits, t1, root, t2, i, start, previous, t3, previousPrevious, t4, codeUnit, t5;
        codeUnits = J.get$codeUnits$s(path);
        t1 = this.style;
        root = t1.rootLength$1(path);
        if (J.$eq$(root, 0) !== true) {
          if (t1 === $.$get$Style_windows()) {
            if (typeof root !== "number")
              return H.iae(root);
            t2 = codeUnits.__internal$_string;
            i = 0;
            for (; i < root; ++i)
              if (C.JSString_methods._codeUnitAt$1(t2, i) === 47)
                return true;
          }
          start = root;
          previous = 47;
        } else {
          start = 0;
          previous = null;
        }
        for (t2 = codeUnits.__internal$_string, t3 = t2.length, i = start, previousPrevious = null; t4 = J.getInterceptor$n(i), t4.$lt(i, t3); i = t4.$add(i, 1), previousPrevious = previous, previous = codeUnit) {
          codeUnit = C.JSString_methods.codeUnitAt$1(t2, i);
          if (t1.isSeparator$1(codeUnit)) {
            if (t1 === $.$get$Style_windows() && codeUnit === 47)
              return true;
            if (previous != null && t1.isSeparator$1(previous))
              return true;
            if (previous === 46)
              t5 = previousPrevious == null || previousPrevious === 46 || t1.isSeparator$1(previousPrevious);
            else
              t5 = false;
            if (t5)
              return true;
          }
        }
        if (previous == null)
          return true;
        if (t1.isSeparator$1(previous))
          return true;
        if (previous === 46)
          t1 = previousPrevious == null || t1.isSeparator$1(previousPrevious) || previousPrevious === 46;
        else
          t1 = false;
        if (t1)
          return true;
        return false;
      },
      relative$2$from: function(path, from) {
        var t1, fromParsed, pathParsed, t2, t3;
        t1 = from == null;
        if (t1 && !J.$gt$n(this.style.rootLength$1(path), 0))
          return this.normalize$1(path);
        if (t1) {
          t1 = this._context$_current;
          from = t1 != null ? t1 : D.current();
        } else
          from = this.absolute$1(from);
        t1 = this.style;
        if (!J.$gt$n(t1.rootLength$1(from), 0) && J.$gt$n(t1.rootLength$1(path), 0))
          return this.normalize$1(path);
        if (!J.$gt$n(t1.rootLength$1(path), 0) || t1.isRootRelative$1(path) === true)
          path = this.absolute$1(path);
        if (!J.$gt$n(t1.rootLength$1(path), 0) && J.$gt$n(t1.rootLength$1(from), 0))
          throw H.wrapException(X.PathException$('Unable to find a path to "' + H.S(path) + '" from "' + H.S(from) + '".'));
        fromParsed = X.ParsedPath_ParsedPath$parse(from, t1);
        fromParsed.normalize$0();
        pathParsed = X.ParsedPath_ParsedPath$parse(path, t1);
        pathParsed.normalize$0();
        t2 = fromParsed.parts;
        if (t2.length > 0 && J.$eq$(t2[0], ".") === true)
          return pathParsed.toString$0(0);
        if (J.$eq$(fromParsed.root, pathParsed.root) !== true) {
          t2 = fromParsed.root;
          if (t2 != null) {
            t3 = pathParsed.root;
            t2 = t3 == null || t1.pathsEqual$2(t2, t3) !== true;
          } else
            t2 = true;
        } else
          t2 = false;
        if (t2)
          return pathParsed.toString$0(0);
        while (true) {
          t2 = fromParsed.parts;
          if (t2.length > 0) {
            t3 = pathParsed.parts;
            t2 = t3.length > 0 && t1.pathsEqual$2(t2[0], t3[0]) === true;
          } else
            t2 = false;
          if (!t2)
            break;
          C.JSArray_methods.removeAt$1(fromParsed.parts, 0);
          C.JSArray_methods.removeAt$1(fromParsed.separators, 1);
          C.JSArray_methods.removeAt$1(pathParsed.parts, 0);
          C.JSArray_methods.removeAt$1(pathParsed.separators, 1);
        }
        t2 = fromParsed.parts;
        if (t2.length > 0 && J.$eq$(t2[0], "..") === true)
          throw H.wrapException(X.PathException$('Unable to find a path to "' + H.S(path) + '" from "' + H.S(from) + '".'));
        C.JSArray_methods.insertAll$2(pathParsed.parts, 0, P.List_List$filled(fromParsed.parts.length, "..", false, null));
        t2 = pathParsed.separators;
        if (0 >= t2.length)
          return H.ioore(t2, 0);
        t2[0] = "";
        C.JSArray_methods.insertAll$2(t2, 1, P.List_List$filled(fromParsed.parts.length, t1.get$separator(), false, null));
        t1 = pathParsed.parts;
        t2 = t1.length;
        if (t2 === 0)
          return ".";
        if (t2 > 1 && J.$eq$(C.JSArray_methods.get$last(t1), ".") === true) {
          C.JSArray_methods.removeLast$0(pathParsed.parts);
          t1 = pathParsed.separators;
          C.JSArray_methods.removeLast$0(t1);
          C.JSArray_methods.removeLast$0(t1);
          C.JSArray_methods.add$1(t1, "");
        }
        pathParsed.root = "";
        pathParsed.removeTrailingSeparators$0();
        return pathParsed.toString$0(0);
      },
      relative$1: function(path) {
        return this.relative$2$from(path, null);
      },
      _isWithinOrEquals$2: function($parent, child) {
        var relative, t1, parentIsAbsolute, childIsAbsolute, childIsRootRelative, parentIsRootRelative, t2, result, exception;
        t1 = this.style;
        parentIsAbsolute = J.$gt$n(t1.rootLength$1($parent), 0);
        childIsAbsolute = J.$gt$n(t1.rootLength$1(child), 0);
        if (parentIsAbsolute && !childIsAbsolute) {
          child = this.absolute$1(child);
          if (t1.isRootRelative$1($parent) === true)
            $parent = this.absolute$1($parent);
        } else if (childIsAbsolute && !parentIsAbsolute) {
          $parent = this.absolute$1($parent);
          if (t1.isRootRelative$1(child) === true)
            child = this.absolute$1(child);
        } else if (childIsAbsolute && parentIsAbsolute) {
          childIsRootRelative = t1.isRootRelative$1(child);
          parentIsRootRelative = t1.isRootRelative$1($parent);
          t2 = childIsRootRelative === true;
          if (t2 && parentIsRootRelative !== true)
            child = this.absolute$1(child);
          else if (parentIsRootRelative === true && !t2)
            $parent = this.absolute$1($parent);
        }
        result = this._isWithinOrEqualsFast$2($parent, child);
        if (result !== C._PathRelation_inconclusive)
          return result;
        relative = null;
        try {
          relative = this.relative$2$from(child, $parent);
        } catch (exception) {
          if (H.unwrapException(exception) instanceof X.PathException)
            return C._PathRelation_different;
          else
            throw exception;
        }
        if (J.$gt$n(t1.rootLength$1(relative), 0))
          return C._PathRelation_different;
        if (J.$eq$(relative, ".") === true)
          return C._PathRelation_equal;
        if (J.$eq$(relative, "..") === true)
          return C._PathRelation_different;
        return J.$ge$n(J.get$length$asx(relative), 3) && J.startsWith$1$s(relative, "..") && t1.isSeparator$1(J.codeUnitAt$1$s(relative, 2)) ? C._PathRelation_different : C._PathRelation_within;
      },
      _isWithinOrEqualsFast$2: function($parent, child) {
        var t1, parentRootLength, childRootLength, t2, t3, i, childIndex, parentIndex, lastCodeUnit, lastParentSeparator, t4, parentCodeUnit, childCodeUnit, parentIndex0, direction;
        if (J.$eq$($parent, ".") === true)
          $parent = "";
        t1 = this.style;
        parentRootLength = t1.rootLength$1($parent);
        childRootLength = t1.rootLength$1(child);
        if (J.$eq$(parentRootLength, childRootLength) !== true)
          return C._PathRelation_different;
        if (typeof parentRootLength !== "number")
          return H.iae(parentRootLength);
        t2 = J.getInterceptor$asx($parent);
        t3 = J.getInterceptor$asx(child);
        i = 0;
        for (; i < parentRootLength; ++i)
          if (!t1.codeUnitsEqual$2(t2.codeUnitAt$1($parent, i), t3.codeUnitAt$1(child, i)))
            return C._PathRelation_different;
        childIndex = childRootLength;
        parentIndex = parentRootLength;
        lastCodeUnit = 47;
        lastParentSeparator = null;
        while (true) {
          t4 = t2.get$length($parent);
          if (typeof t4 !== "number")
            return H.iae(t4);
          if (!(parentIndex < t4 && J.$lt$n(childIndex, t3.get$length(child))))
            break;
          c$0: {
            parentCodeUnit = t2.codeUnitAt$1($parent, parentIndex);
            childCodeUnit = t3.codeUnitAt$1(child, childIndex);
            if (t1.codeUnitsEqual$2(parentCodeUnit, childCodeUnit)) {
              if (t1.isSeparator$1(parentCodeUnit))
                lastParentSeparator = parentIndex;
              ++parentIndex;
              childIndex = J.$add$ansx(childIndex, 1);
              lastCodeUnit = parentCodeUnit;
              break c$0;
            }
            if (t1.isSeparator$1(parentCodeUnit) && t1.isSeparator$1(lastCodeUnit)) {
              parentIndex0 = parentIndex + 1;
              lastParentSeparator = parentIndex;
              parentIndex = parentIndex0;
              break c$0;
            } else if (t1.isSeparator$1(childCodeUnit) && t1.isSeparator$1(lastCodeUnit)) {
              childIndex = J.$add$ansx(childIndex, 1);
              break c$0;
            }
            if (parentCodeUnit === 46 && t1.isSeparator$1(lastCodeUnit)) {
              ++parentIndex;
              if (parentIndex === t2.get$length($parent))
                break;
              parentCodeUnit = t2.codeUnitAt$1($parent, parentIndex);
              if (t1.isSeparator$1(parentCodeUnit)) {
                parentIndex0 = parentIndex + 1;
                lastParentSeparator = parentIndex;
                parentIndex = parentIndex0;
                break c$0;
              }
              if (parentCodeUnit === 46) {
                ++parentIndex;
                if (parentIndex === t2.get$length($parent) || t1.isSeparator$1(t2.codeUnitAt$1($parent, parentIndex)))
                  return C._PathRelation_inconclusive;
              }
            }
            if (childCodeUnit === 46 && t1.isSeparator$1(lastCodeUnit)) {
              childIndex = J.$add$ansx(childIndex, 1);
              t4 = J.getInterceptor(childIndex);
              if (t4.$eq(childIndex, t3.get$length(child)))
                break;
              childCodeUnit = t3.codeUnitAt$1(child, childIndex);
              if (t1.isSeparator$1(childCodeUnit)) {
                childIndex = t4.$add(childIndex, 1);
                break c$0;
              }
              if (childCodeUnit === 46) {
                childIndex = t4.$add(childIndex, 1);
                if (J.$eq$(childIndex, t3.get$length(child)) || t1.isSeparator$1(t3.codeUnitAt$1(child, childIndex)))
                  return C._PathRelation_inconclusive;
              }
            }
            if (this._pathDirection$2(child, childIndex) !== C._PathDirection_988)
              return C._PathRelation_inconclusive;
            if (this._pathDirection$2($parent, parentIndex) !== C._PathDirection_988)
              return C._PathRelation_inconclusive;
            return C._PathRelation_different;
          }
        }
        if (J.$eq$(childIndex, t3.get$length(child)) === true) {
          if (parentIndex === t2.get$length($parent) || t1.isSeparator$1(t2.codeUnitAt$1($parent, parentIndex)))
            lastParentSeparator = parentIndex;
          else if (lastParentSeparator == null)
            lastParentSeparator = Math.max(0, parentRootLength - 1);
          direction = this._pathDirection$2($parent, lastParentSeparator);
          if (direction === C._PathDirection_8Gl)
            return C._PathRelation_equal;
          return direction === C._PathDirection_ZGD ? C._PathRelation_inconclusive : C._PathRelation_different;
        }
        direction = this._pathDirection$2(child, childIndex);
        if (direction === C._PathDirection_8Gl)
          return C._PathRelation_equal;
        if (direction === C._PathDirection_ZGD)
          return C._PathRelation_inconclusive;
        return t1.isSeparator$1(t3.codeUnitAt$1(child, childIndex)) || t1.isSeparator$1(lastCodeUnit) ? C._PathRelation_within : C._PathRelation_different;
      },
      _pathDirection$2: function(path, index) {
        var t1, t2, i, depth, reachedRoot, t3, i0, t4;
        for (t1 = J.getInterceptor$asx(path), t2 = this.style, i = index, depth = 0, reachedRoot = false; J.$lt$n(i, t1.get$length(path));) {
          while (true) {
            t3 = J.getInterceptor$n(i);
            if (!(t3.$lt(i, t1.get$length(path)) && t2.isSeparator$1(t1.codeUnitAt$1(path, i))))
              break;
            i = t3.$add(i, 1);
          }
          if (t3.$eq(i, t1.get$length(path)) === true)
            break;
          i0 = i;
          while (true) {
            t4 = J.getInterceptor$n(i0);
            if (!(t4.$lt(i0, t1.get$length(path)) && !t2.isSeparator$1(t1.codeUnitAt$1(path, i0))))
              break;
            i0 = t4.$add(i0, 1);
          }
          if (!(J.$eq$(t4.$sub(i0, i), 1) && t1.codeUnitAt$1(path, i) === 46))
            if (J.$eq$(t4.$sub(i0, i), 2) && t1.codeUnitAt$1(path, i) === 46 && t1.codeUnitAt$1(path, t3.$add(i, 1)) === 46) {
              --depth;
              if (depth < 0)
                break;
              if (depth === 0)
                reachedRoot = true;
            } else
              ++depth;
          if (t4.$eq(i0, t1.get$length(path)) === true)
            break;
          i = t4.$add(i0, 1);
        }
        if (depth < 0)
          return C._PathDirection_ZGD;
        if (depth === 0)
          return C._PathDirection_8Gl;
        if (reachedRoot)
          return C._PathDirection_FIw;
        return C._PathDirection_988;
      },
      hash$1: function(path) {
        var result, parsed;
        path = this.absolute$1(path);
        result = this._hashFast$1(path);
        if (result != null)
          return result;
        parsed = X.ParsedPath_ParsedPath$parse(path, this.style);
        parsed.normalize$0();
        return this._hashFast$1(parsed.toString$0(0));
      },
      _hashFast$1: function(path) {
        var t1, t2, hash, beginning, wasSeparator, i, t3, codeUnit, next;
        t1 = J.getInterceptor$asx(path);
        t2 = this.style;
        hash = 4603;
        beginning = true;
        wasSeparator = true;
        i = 0;
        while (true) {
          t3 = t1.get$length(path);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          c$0: {
            codeUnit = t2.canonicalizeCodeUnit$1(t1.codeUnitAt$1(path, i));
            if (t2.isSeparator$1(codeUnit)) {
              wasSeparator = true;
              break c$0;
            }
            if (codeUnit === 46 && wasSeparator) {
              t3 = i + 1;
              if (t3 === t1.get$length(path))
                break;
              next = t1.codeUnitAt$1(path, t3);
              if (t2.isSeparator$1(next))
                break c$0;
              if (!beginning)
                if (next === 46) {
                  t3 = i + 2;
                  t3 = t3 === t1.get$length(path) || t2.isSeparator$1(t1.codeUnitAt$1(path, t3));
                } else
                  t3 = false;
              else
                t3 = false;
              if (t3)
                return;
            }
            hash = ((hash & 67108863) * 33 ^ codeUnit) >>> 0;
            beginning = false;
            wasSeparator = false;
          }
          ++i;
        }
        return hash;
      },
      withoutExtension$1: function(path) {
        var parsed, i, t1, t2;
        parsed = X.ParsedPath_ParsedPath$parse(path, this.style);
        for (i = parsed.parts.length - 1; i >= 0; --i) {
          t1 = parsed.parts;
          if (i >= t1.length)
            return H.ioore(t1, i);
          if (J.get$isEmpty$asx(t1[i]) !== true) {
            t1 = parsed.parts;
            t2 = parsed._splitExtension$0()[0];
            if (i >= t1.length)
              return H.ioore(t1, i);
            t1[i] = t2;
            break;
          }
        }
        return parsed.toString$0(0);
      },
      toUri$1: function(path) {
        var t1, t2;
        t1 = this.style;
        if (!J.$gt$n(t1.rootLength$1(path), 0))
          return t1.relativePathToUri$1(path);
        else {
          t2 = this._context$_current;
          return t1.absolutePathToUri$1(this.join$2(0, t2 != null ? t2 : D.current(), path));
        }
      },
      prettyUri$1: function(uri) {
        var typedUri, t1, t2, path, rel;
        typedUri = M._parseUri(uri);
        if (typedUri.get$scheme() === "file") {
          t1 = this.style;
          t2 = $.$get$Style_url();
          t2 = t1 == null ? t2 == null : t1 === t2;
          t1 = t2;
        } else
          t1 = false;
        if (t1)
          return typedUri.toString$0(0);
        else {
          if (typedUri.get$scheme() !== "file")
            if (typedUri.get$scheme() !== "") {
              t1 = this.style;
              t2 = $.$get$Style_url();
              t2 = t1 == null ? t2 != null : t1 !== t2;
              t1 = t2;
            } else
              t1 = false;
          else
            t1 = false;
          if (t1)
            return typedUri.toString$0(0);
        }
        path = this.normalize$1(this.style.pathFromUri$1(M._parseUri(typedUri)));
        rel = this.relative$1(path);
        return this.split$1(0, rel).length > this.split$1(0, path).length ? path : rel;
      },
      static: {
        Context_Context: function(current, style) {
          if (current == null)
            current = style == null ? D.current() : ".";
          if (style == null)
            style = $.$get$Style_platform();
          return new M.Context(style, current);
        }
      }
    },
    Context_join_closure: {
      "^": "Closure:0;",
      call$1: function(part) {
        return part != null;
      }
    },
    Context_joinAll_closure: {
      "^": "Closure:0;",
      call$1: function(part) {
        return J.$eq$(part, "") !== true;
      }
    },
    Context_split_closure: {
      "^": "Closure:0;",
      call$1: function(part) {
        return J.get$isEmpty$asx(part) !== true;
      }
    },
    _validateArgList_closure: {
      "^": "Closure:0;",
      call$1: [function(arg) {
        return arg == null ? "null" : '"' + H.S(arg) + '"';
      }, null, null, 4, 0, null, 35, "call"]
    },
    _PathDirection: {
      "^": "Object;name<",
      toString$0: function(_) {
        return this.name;
      }
    },
    _PathRelation: {
      "^": "Object;name<",
      toString$0: function(_) {
        return this.name;
      }
    }
  }], ["", "package:path/src/internal_style.dart",, B, {
    "^": "",
    InternalStyle: {
      "^": "Style;",
      getRoot$1: function(path) {
        var $length = this.rootLength$1(path);
        if (J.$gt$n($length, 0))
          return J.substring$2$s(path, 0, $length);
        return this.isRootRelative$1(path) === true ? J.$index$asx(path, 0) : null;
      },
      relativePathToUri$1: function(path) {
        var segments, t1;
        segments = M.Context_Context(null, this).split$1(0, path);
        t1 = J.getInterceptor$asx(path);
        if (this.isSeparator$1(t1.codeUnitAt$1(path, J.$sub$n(t1.get$length(path), 1))))
          C.JSArray_methods.add$1(segments, "");
        return P._Uri__Uri(null, null, null, segments, null, null, null, null, null);
      },
      codeUnitsEqual$2: function(codeUnit1, codeUnit2) {
        return codeUnit1 === codeUnit2;
      },
      pathsEqual$2: function(path1, path2) {
        return J.$eq$(path1, path2);
      },
      canonicalizeCodeUnit$1: function(codeUnit) {
        return codeUnit;
      },
      canonicalizePart$1: function(part) {
        return part;
      }
    }
  }], ["", "package:path/src/parsed_path.dart",, X, {
    "^": "",
    ParsedPath: {
      "^": "Object;style,root,isRootRelative,parts,separators",
      get$basename: function() {
        var copy, t1;
        copy = new X.ParsedPath(this.style, this.root, this.isRootRelative, P.List_List$from(this.parts, true, null), P.List_List$from(this.separators, true, null));
        copy.removeTrailingSeparators$0();
        t1 = copy.parts;
        if (t1.length === 0) {
          t1 = this.root;
          return t1 == null ? "" : t1;
        }
        return C.JSArray_methods.get$last(t1);
      },
      get$hasTrailingSeparator: function() {
        var t1 = this.parts;
        if (t1.length !== 0)
          t1 = J.$eq$(C.JSArray_methods.get$last(t1), "") === true || J.$eq$(C.JSArray_methods.get$last(this.separators), "") !== true;
        else
          t1 = false;
        return t1;
      },
      removeTrailingSeparators$0: function() {
        var t1, t2;
        while (true) {
          t1 = this.parts;
          if (!(t1.length !== 0 && J.$eq$(C.JSArray_methods.get$last(t1), "") === true))
            break;
          C.JSArray_methods.removeLast$0(this.parts);
          C.JSArray_methods.removeLast$0(this.separators);
        }
        t1 = this.separators;
        t2 = t1.length;
        if (t2 > 0)
          t1[t2 - 1] = "";
      },
      normalize$1$canonicalize: function(canonicalize) {
        var t1, newParts, t2, t3, t4, leadingDoubles, _i, part, t5, newSeparators;
        t1 = P.String;
        newParts = H.setRuntimeTypeInfo([], [t1]);
        for (t2 = this.parts, t3 = t2.length, t4 = this.style, leadingDoubles = 0, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i) {
          part = t2[_i];
          t5 = J.getInterceptor(part);
          if (!(t5.$eq(part, ".") === true || t5.$eq(part, "") === true))
            if (t5.$eq(part, "..") === true)
              if (newParts.length > 0)
                newParts.pop();
              else
                ++leadingDoubles;
            else
              newParts.push(canonicalize ? t4.canonicalizePart$1(part) : part);
        }
        if (this.root == null)
          C.JSArray_methods.insertAll$2(newParts, 0, P.List_List$filled(leadingDoubles, "..", false, null));
        if (newParts.length === 0 && this.root == null)
          newParts.push(".");
        newSeparators = P.List_List$generate(newParts.length, new X.ParsedPath_normalize_closure(this), true, t1);
        t1 = this.root;
        C.JSArray_methods.insert$2(newSeparators, 0, t1 != null && newParts.length > 0 && t4.needsSeparator$1(t1) ? t4.get$separator() : "");
        this.parts = newParts;
        this.separators = newSeparators;
        t1 = this.root;
        if (t1 != null) {
          t2 = $.$get$Style_windows();
          t2 = t4 == null ? t2 == null : t4 === t2;
        } else
          t2 = false;
        if (t2) {
          if (canonicalize) {
            t1 = J.toLowerCase$0$s(t1);
            this.root = t1;
          }
          this.root = J.replaceAll$2$s(t1, "/", "\\");
        }
        this.removeTrailingSeparators$0();
      },
      normalize$0: function() {
        return this.normalize$1$canonicalize(false);
      },
      toString$0: function(_) {
        var t1, i, t2;
        t1 = this.root;
        t1 = t1 != null ? H.S(t1) : "";
        for (i = 0; i < this.parts.length; ++i) {
          t2 = this.separators;
          if (i >= t2.length)
            return H.ioore(t2, i);
          t2 = t1 + H.S(t2[i]);
          t1 = this.parts;
          if (i >= t1.length)
            return H.ioore(t1, i);
          t1 = t2 + H.S(t1[i]);
        }
        t1 += H.S(C.JSArray_methods.get$last(this.separators));
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      },
      _splitExtension$0: function() {
        var file, t1, lastDot;
        file = C.JSArray_methods.lastWhere$2$orElse(this.parts, new X.ParsedPath__splitExtension_closure(), new X.ParsedPath__splitExtension_closure0());
        if (file == null)
          return ["", ""];
        t1 = J.getInterceptor(file);
        if (t1.$eq(file, "..") === true)
          return ["..", ""];
        lastDot = t1.lastIndexOf$1(file, ".");
        if (J.$le$n(lastDot, 0))
          return [file, ""];
        return [t1.substring$2(file, 0, lastDot), t1.substring$1(file, lastDot)];
      },
      static: {
        ParsedPath_ParsedPath$parse: function(path, style) {
          var root, isRootRelative, t1, parts, separators, start, i, t2;
          root = style.getRoot$1(path);
          isRootRelative = style.isRootRelative$1(path);
          if (root != null)
            path = J.substring$1$s(path, J.get$length$asx(root));
          t1 = [P.String];
          parts = H.setRuntimeTypeInfo([], t1);
          separators = H.setRuntimeTypeInfo([], t1);
          t1 = J.getInterceptor$asx(path);
          if (t1.get$isNotEmpty(path) && style.isSeparator$1(t1.codeUnitAt$1(path, 0))) {
            separators.push(t1.$index(path, 0));
            start = 1;
          } else {
            separators.push("");
            start = 0;
          }
          i = start;
          while (true) {
            t2 = t1.get$length(path);
            if (typeof t2 !== "number")
              return H.iae(t2);
            if (!(i < t2))
              break;
            if (style.isSeparator$1(t1.codeUnitAt$1(path, i))) {
              parts.push(t1.substring$2(path, start, i));
              separators.push(t1.$index(path, i));
              start = i + 1;
            }
            ++i;
          }
          t2 = t1.get$length(path);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (start < t2) {
            parts.push(t1.substring$1(path, start));
            separators.push("");
          }
          return new X.ParsedPath(style, root, isRootRelative, parts, separators);
        }
      }
    },
    ParsedPath_normalize_closure: {
      "^": "Closure:0;$this",
      call$1: function(_) {
        return this.$this.style.get$separator();
      }
    },
    ParsedPath__splitExtension_closure: {
      "^": "Closure:0;",
      call$1: function(p) {
        return J.$eq$(p, "") !== true;
      }
    },
    ParsedPath__splitExtension_closure0: {
      "^": "Closure:1;",
      call$0: function() {
        return;
      }
    }
  }], ["", "package:path/src/path_exception.dart",, X, {
    "^": "",
    PathException: {
      "^": "Object;message>",
      toString$0: function(_) {
        return "PathException: " + this.message;
      },
      static: {
        PathException$: function(message) {
          return new X.PathException(message);
        }
      }
    }
  }], ["", "package:path/src/style.dart",, O, {
    "^": "",
    Style__getPlatformStyle: function() {
      if (P.Uri_base().get$scheme() !== "file")
        return $.$get$Style_url();
      var t1 = P.Uri_base();
      if (!J.endsWith$1$s(t1.get$path(t1), "/"))
        return $.$get$Style_url();
      if (P._Uri__Uri(null, null, "a/b", null, null, null, null, null, null).toFilePath$0() === "a\\b")
        return $.$get$Style_windows();
      return $.$get$Style_posix();
    },
    Style: {
      "^": "Object;",
      toString$0: function(_) {
        return this.get$name();
      },
      static: {
        "^": "Style_url<,Style_platform<"
      }
    }
  }], ["", "package:path/src/style/posix.dart",, E, {
    "^": "",
    PosixStyle: {
      "^": "InternalStyle;name<,separator<,separators,separatorPattern,needsSeparatorPattern,rootPattern,relativeRootPattern",
      containsSeparator$1: function(path) {
        return J.contains$1$asx(path, "/");
      },
      isSeparator$1: function(codeUnit) {
        return codeUnit === 47;
      },
      needsSeparator$1: function(path) {
        var t1 = J.getInterceptor$asx(path);
        return t1.get$isNotEmpty(path) && t1.codeUnitAt$1(path, J.$sub$n(t1.get$length(path), 1)) !== 47;
      },
      rootLength$2$withDrive: function(path, withDrive) {
        var t1 = J.getInterceptor$asx(path);
        if (t1.get$isNotEmpty(path) && t1.codeUnitAt$1(path, 0) === 47)
          return 1;
        return 0;
      },
      rootLength$1: function(path) {
        return this.rootLength$2$withDrive(path, false);
      },
      isRootRelative$1: function(path) {
        return false;
      },
      pathFromUri$1: function(uri) {
        var t1;
        if (uri.get$scheme() === "" || uri.get$scheme() === "file") {
          t1 = uri.get$path(uri);
          return P._Uri__uriDecode(t1, 0, J.get$length$asx(t1), C.Utf8Codec_false, false);
        }
        throw H.wrapException(P.ArgumentError$("Uri " + H.S(uri) + " must have scheme 'file:'."));
      },
      absolutePathToUri$1: function(path) {
        var parsed, t1;
        parsed = X.ParsedPath_ParsedPath$parse(path, this);
        t1 = parsed.parts;
        if (t1.length === 0)
          C.JSArray_methods.addAll$1(t1, ["", ""]);
        else if (parsed.get$hasTrailingSeparator())
          C.JSArray_methods.add$1(parsed.parts, "");
        return P._Uri__Uri(null, null, null, parsed.parts, null, null, null, "file", null);
      }
    }
  }], ["", "package:path/src/style/url.dart",, F, {
    "^": "",
    UrlStyle: {
      "^": "InternalStyle;name<,separator<,separators,separatorPattern,needsSeparatorPattern,rootPattern,relativeRootPattern",
      containsSeparator$1: function(path) {
        return J.contains$1$asx(path, "/");
      },
      isSeparator$1: function(codeUnit) {
        return codeUnit === 47;
      },
      needsSeparator$1: function(path) {
        var t1 = J.getInterceptor$asx(path);
        if (t1.get$isEmpty(path) === true)
          return false;
        if (t1.codeUnitAt$1(path, J.$sub$n(t1.get$length(path), 1)) !== 47)
          return true;
        return t1.endsWith$1(path, "://") && J.$eq$(this.rootLength$1(path), t1.get$length(path)) === true;
      },
      rootLength$2$withDrive: function(path, withDrive) {
        var t1, i, t2, codeUnit, index;
        t1 = J.getInterceptor$asx(path);
        if (t1.get$isEmpty(path) === true)
          return 0;
        if (t1.codeUnitAt$1(path, 0) === 47)
          return 1;
        i = 0;
        while (true) {
          t2 = t1.get$length(path);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          codeUnit = t1.codeUnitAt$1(path, i);
          if (codeUnit === 47)
            return 0;
          if (codeUnit === 58) {
            if (i === 0)
              return 0;
            index = t1.indexOf$2(path, "/", t1.startsWith$2(path, "//", i + 1) ? i + 3 : i);
            if (index <= 0)
              return t1.get$length(path);
            if (!withDrive || J.$lt$n(t1.get$length(path), index + 3))
              return index;
            if (!t1.startsWith$1(path, "file://"))
              return index;
            if (!B.isDriveLetter(path, index + 1))
              return index;
            t2 = index + 3;
            return J.$eq$(t1.get$length(path), t2) === true ? t2 : index + 4;
          }
          ++i;
        }
        return 0;
      },
      rootLength$1: function(path) {
        return this.rootLength$2$withDrive(path, false);
      },
      isRootRelative$1: function(path) {
        var t1 = J.getInterceptor$asx(path);
        return t1.get$isNotEmpty(path) && t1.codeUnitAt$1(path, 0) === 47;
      },
      pathFromUri$1: function(uri) {
        return J.toString$0$(uri);
      },
      relativePathToUri$1: function(path) {
        return P.Uri_parse(path, 0, null);
      },
      absolutePathToUri$1: function(path) {
        return P.Uri_parse(path, 0, null);
      }
    }
  }], ["", "package:path/src/style/windows.dart",, L, {
    "^": "",
    WindowsStyle: {
      "^": "InternalStyle;name<,separator<,separators,separatorPattern,needsSeparatorPattern,rootPattern,relativeRootPattern",
      containsSeparator$1: function(path) {
        return J.contains$1$asx(path, "/");
      },
      isSeparator$1: function(codeUnit) {
        return codeUnit === 47 || codeUnit === 92;
      },
      needsSeparator$1: function(path) {
        var t1 = J.getInterceptor$asx(path);
        if (t1.get$isEmpty(path) === true)
          return false;
        t1 = t1.codeUnitAt$1(path, J.$sub$n(t1.get$length(path), 1));
        return !(t1 === 47 || t1 === 92);
      },
      rootLength$2$withDrive: function(path, withDrive) {
        var t1, index;
        t1 = J.getInterceptor$asx(path);
        if (t1.get$isEmpty(path) === true)
          return 0;
        if (t1.codeUnitAt$1(path, 0) === 47)
          return 1;
        if (t1.codeUnitAt$1(path, 0) === 92) {
          if (J.$lt$n(t1.get$length(path), 2) || t1.codeUnitAt$1(path, 1) !== 92)
            return 1;
          index = t1.indexOf$2(path, "\\", 2);
          if (index > 0) {
            index = t1.indexOf$2(path, "\\", index + 1);
            if (index > 0)
              return index;
          }
          return t1.get$length(path);
        }
        if (J.$lt$n(t1.get$length(path), 3))
          return 0;
        if (!B.isAlphabetic(t1.codeUnitAt$1(path, 0)))
          return 0;
        if (t1.codeUnitAt$1(path, 1) !== 58)
          return 0;
        t1 = t1.codeUnitAt$1(path, 2);
        if (!(t1 === 47 || t1 === 92))
          return 0;
        return 3;
      },
      rootLength$1: function(path) {
        return this.rootLength$2$withDrive(path, false);
      },
      isRootRelative$1: function(path) {
        return J.$eq$(this.rootLength$1(path), 1);
      },
      pathFromUri$1: function(uri) {
        var path, t1;
        if (uri.get$scheme() !== "" && uri.get$scheme() !== "file")
          throw H.wrapException(P.ArgumentError$("Uri " + H.S(uri) + " must have scheme 'file:'."));
        path = uri.get$path(uri);
        if (uri.get$host() === "") {
          t1 = J.getInterceptor$asx(path);
          if (J.$ge$n(t1.get$length(path), 3) && t1.startsWith$1(path, "/") && B.isDriveLetter(path, 1))
            path = t1.replaceFirst$2(path, "/", "");
        } else
          path = "\\\\" + H.S(uri.get$host()) + H.S(path);
        t1 = J.replaceAll$2$s(path, "/", "\\");
        return P._Uri__uriDecode(t1, 0, t1.length, C.Utf8Codec_false, false);
      },
      absolutePathToUri$1: function(path) {
        var parsed, t1, rootParts, t2;
        parsed = X.ParsedPath_ParsedPath$parse(path, this);
        if (J.startsWith$1$s(parsed.root, "\\\\")) {
          t1 = J.split$1$s(parsed.root, "\\");
          rootParts = new H.WhereIterable(t1, new L.WindowsStyle_absolutePathToUri_closure(), [H.getTypeArgumentByIndex(t1, 0)]);
          C.JSArray_methods.insert$2(parsed.parts, 0, rootParts.get$last(rootParts));
          if (parsed.get$hasTrailingSeparator())
            C.JSArray_methods.add$1(parsed.parts, "");
          return P._Uri__Uri(null, rootParts.get$first(rootParts), null, parsed.parts, null, null, null, "file", null);
        } else {
          if (parsed.parts.length === 0 || parsed.get$hasTrailingSeparator())
            C.JSArray_methods.add$1(parsed.parts, "");
          t1 = parsed.parts;
          t2 = J.replaceAll$2$s(parsed.root, "/", "");
          C.JSArray_methods.insert$2(t1, 0, H.stringReplaceAllUnchecked(t2, "\\", ""));
          return P._Uri__Uri(null, null, null, parsed.parts, null, null, null, "file", null);
        }
      },
      codeUnitsEqual$2: function(codeUnit1, codeUnit2) {
        var upperCase1;
        if (codeUnit1 === codeUnit2)
          return true;
        if (codeUnit1 === 47)
          return codeUnit2 === 92;
        if (codeUnit1 === 92)
          return codeUnit2 === 47;
        if ((codeUnit1 ^ codeUnit2) !== 32)
          return false;
        upperCase1 = codeUnit1 | 32;
        return upperCase1 >= 97 && upperCase1 <= 122;
      },
      pathsEqual$2: function(path1, path2) {
        var t1, t2, i, t3;
        if (path1 == null ? path2 == null : path1 === path2)
          return true;
        t1 = J.getInterceptor$asx(path1);
        t2 = J.getInterceptor$asx(path2);
        if (J.$eq$(t1.get$length(path1), t2.get$length(path2)) !== true)
          return false;
        i = 0;
        while (true) {
          t3 = t1.get$length(path1);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          if (!this.codeUnitsEqual$2(t1.codeUnitAt$1(path1, i), t2.codeUnitAt$1(path2, i)))
            return false;
          ++i;
        }
        return true;
      },
      canonicalizeCodeUnit$1: function(codeUnit) {
        if (codeUnit === 47)
          return 92;
        if (codeUnit < 65)
          return codeUnit;
        if (codeUnit > 90)
          return codeUnit;
        return codeUnit | 32;
      },
      canonicalizePart$1: function(part) {
        return J.toLowerCase$0$s(part);
      }
    },
    WindowsStyle_absolutePathToUri_closure: {
      "^": "Closure:0;",
      call$1: function(part) {
        return J.$eq$(part, "") !== true;
      }
    }
  }], ["", "package:path/src/utils.dart",, B, {
    "^": "",
    isAlphabetic: function(char) {
      var t1;
      if (!(char >= 65 && char <= 90))
        t1 = char >= 97 && char <= 122;
      else
        t1 = true;
      return t1;
    },
    isDriveLetter: function(path, index) {
      var t1, t2;
      t1 = J.getInterceptor$asx(path);
      t2 = index + 2;
      if (J.$lt$n(t1.get$length(path), t2))
        return false;
      if (!B.isAlphabetic(t1.codeUnitAt$1(path, index)))
        return false;
      if (t1.codeUnitAt$1(path, index + 1) !== 58)
        return false;
      if (J.$eq$(t1.get$length(path), t2) === true)
        return true;
      return t1.codeUnitAt$1(path, t2) === 47;
    }
  }], ["quiver.hashcode", "package:quiver_hashcode/hashcode.dart",, L, {
    "^": "",
    _combine: function(hash, value) {
      hash = 536870911 & hash + value;
      hash = 536870911 & hash + ((524287 & hash) << 10);
      return hash ^ hash >>> 6;
    }
  }], ["", "package:sass/src/ast/css/at_rule.dart",, U, {
    "^": "",
    CssAtRule: {
      "^": "CssParentNode;name<,value<,isChildless<,span<,children,_children,_node0$_parent,_indexInParent,isGroupEnd",
      accept$1: function(visitor) {
        return visitor.visitAtRule$1(this);
      },
      copyWithoutChildren$0: function() {
        var t1 = [];
        return new U.CssAtRule(this.name, this.value, this.isChildless, this.span, new P.UnmodifiableListView(t1, [B.CssNode]), t1, null, null, false);
      },
      addChild$1: function(child) {
        this.super$CssParentNode$addChild(child);
      }
    }
  }], ["", "package:sass/src/ast/css/comment.dart",, R, {
    "^": "",
    CssComment: {
      "^": "CssNode;text<,span<,_node0$_parent,_indexInParent,isGroupEnd",
      accept$1: function(visitor) {
        return visitor.visitComment$1(this);
      }
    }
  }], ["", "package:sass/src/ast/css/declaration.dart",, L, {
    "^": "",
    CssDeclaration: {
      "^": "CssNode;name<,value<,valueSpanForMap<,span<,_node0$_parent,_indexInParent,isGroupEnd",
      accept$1: function(visitor) {
        return visitor.visitDeclaration$1(this);
      },
      static: {
        CssDeclaration$: function($name, value, span, valueSpanForMap) {
          return new L.CssDeclaration($name, value, valueSpanForMap == null ? span : valueSpanForMap, span, null, null, false);
        }
      }
    }
  }], ["", "package:sass/src/ast/css/import.dart",, F, {
    "^": "",
    CssImport: {
      "^": "CssNode;url<,supports,media,span<,_node0$_parent,_indexInParent,isGroupEnd",
      accept$1: function(visitor) {
        return visitor.visitImport$1(this);
      },
      static: {
        CssImport$: function(url, span, media, supports) {
          return new F.CssImport(url, supports, media == null ? null : P.List_List$unmodifiable(media, null), span, null, null, false);
        }
      }
    }
  }], ["", "package:sass/src/ast/css/keyframe_block.dart",, U, {
    "^": "",
    CssKeyframeBlock: {
      "^": "CssParentNode;selector<,span<,children,_children,_node0$_parent,_indexInParent,isGroupEnd",
      accept$1: function(visitor) {
        return visitor.visitKeyframeBlock$1(this);
      },
      copyWithoutChildren$0: function() {
        var t1 = [];
        return new U.CssKeyframeBlock(this.selector, this.span, new P.UnmodifiableListView(t1, [B.CssNode]), t1, null, null, false);
      }
    }
  }], ["", "package:sass/src/ast/css/media_query.dart",, F, {
    "^": "",
    CssMediaQuery: {
      "^": "Object;modifier<,type<,features<",
      get$isCondition: function() {
        return this.modifier == null && this.type == null;
      },
      merge$1: function(other) {
        var t1, ourModifier, t2, ourType, t3, theirModifier, theirType, t4, type, modifier;
        t1 = this.modifier;
        ourModifier = t1 == null ? null : t1.toLowerCase();
        t2 = this.type;
        ourType = t2 == null ? null : J.toLowerCase$0$s(t2);
        t3 = other.get$modifier();
        theirModifier = t3 == null ? null : t3.toLowerCase();
        t3 = other.get$type();
        theirType = t3 == null ? null : J.toLowerCase$0$s(t3);
        t3 = ourType == null;
        if (t3 && theirType == null) {
          t1 = this.features;
          t1 = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
          C.JSArray_methods.addAll$1(t1, other.get$features());
          return new F.CssMediaQuery(null, null, P.List_List$unmodifiable(t1, null));
        }
        t4 = ourModifier === "not";
        if (t4 !== (theirModifier === "not")) {
          if (ourType == null ? theirType == null : ourType === theirType)
            return;
          if (t4) {
            if (other.get$features().length !== 0)
              return;
            type = theirType;
            modifier = theirModifier;
          } else {
            if (this.features.length !== 0)
              return;
            type = ourType;
            modifier = ourModifier;
          }
        } else if (t4) {
          if (ourType == null ? theirType == null : ourType === theirType)
            return;
          type = ourType;
          modifier = ourModifier;
        } else if (t3) {
          type = theirType;
          modifier = theirModifier;
        } else {
          if (theirType == null)
            modifier = ourModifier;
          else if (ourType !== theirType)
            return;
          else
            modifier = ourModifier == null ? theirModifier : ourModifier;
          type = ourType;
        }
        t2 = (type == null ? ourType == null : type === ourType) ? t2 : other.get$type();
        t1 = (modifier == null ? ourModifier == null : modifier === ourModifier) ? t1 : other.get$modifier();
        t3 = this.features;
        t3 = H.setRuntimeTypeInfo(t3.slice(0), [H.getTypeArgumentByIndex(t3, 0)]);
        C.JSArray_methods.addAll$1(t3, other.get$features());
        return F.CssMediaQuery$(t2, t3, t1);
      },
      $eq: function(_, other) {
        var t1, t2;
        if (other == null)
          return false;
        if (other instanceof F.CssMediaQuery) {
          t1 = other.modifier;
          t2 = this.modifier;
          t1 = (t1 == null ? t2 == null : t1 === t2) && J.$eq$(other.type, this.type) === true && C.ListEquality_DefaultEquality.equals$2(other.features, this.features);
        } else
          t1 = false;
        return t1;
      },
      get$hashCode: function(_) {
        return (J.get$hashCode$(this.modifier) ^ J.get$hashCode$(this.type) ^ C.ListEquality_DefaultEquality.hash$1(this.features)) >>> 0;
      },
      toString$0: function(_) {
        var t1, t2;
        t1 = this.modifier;
        t1 = t1 != null ? t1 + " " : "";
        t2 = this.type;
        if (t2 != null) {
          t1 += H.S(t2);
          if (this.features.length !== 0)
            t1 += " and ";
        }
        t1 += C.JSArray_methods.join$1(this.features, " and ");
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      },
      static: {
        CssMediaQuery$: function(type, features, modifier) {
          return new F.CssMediaQuery(modifier, type, features == null ? C.List_empty : P.List_List$unmodifiable(features, null));
        }
      }
    }
  }], ["", "package:sass/src/ast/css/media_rule.dart",, G, {
    "^": "",
    CssMediaRule: {
      "^": "CssParentNode;queries<,span<,children,_children,_node0$_parent,_indexInParent,isGroupEnd",
      CssMediaRule$2: function(queries, span) {
        if (J.get$isEmpty$asx(queries) === true)
          throw H.wrapException(P.ArgumentError$value(queries, "queries", "may not be empty."));
      },
      accept$1: function(visitor) {
        return visitor.visitMediaRule$1(this);
      },
      copyWithoutChildren$0: function() {
        return G.CssMediaRule$(this.queries, this.span);
      },
      static: {
        CssMediaRule$: function(queries, span) {
          var t1 = [];
          t1 = new G.CssMediaRule(P.List_List$unmodifiable(queries, null), span, new P.UnmodifiableListView(t1, [B.CssNode]), t1, null, null, false);
          t1.CssMediaRule$2(queries, span);
          return t1;
        }
      }
    }
  }], ["", "package:sass/src/ast/css/node.dart",, B, {
    "^": "",
    CssNode: {
      "^": "AstNode;isGroupEnd@",
      get$hasFollowingSibling: function() {
        var t1, siblings, i, t2, t3;
        t1 = this._node0$_parent;
        if (t1 == null)
          return false;
        siblings = t1.children;
        t1 = this._indexInParent;
        if (typeof t1 !== "number")
          return t1.$add();
        i = t1 + 1;
        t1 = siblings._collection$_source;
        t2 = J.getInterceptor$asx(t1);
        while (true) {
          t3 = t2.get$length(t1);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          if (!this._node0$_isInvisible$1(t2.elementAt$1(t1, i)))
            return true;
          ++i;
        }
        return false;
      },
      _node0$_isInvisible$1: [function(node) {
        var t1 = J.getInterceptor(node);
        if (!!t1.$isCssParentNode) {
          if (!!t1.$isCssAtRule)
            return false;
          if (!!t1.$isCssStyleRule && node.selector.value.get$isInvisible() === true)
            return true;
          t1 = node.children;
          return t1.every$1(t1, this.get$_node0$_isInvisible());
        } else
          return false;
      }, "call$1", "get$_node0$_isInvisible", 4, 0, 34],
      toString$0: function(_) {
        return N.serialize(this, null, true, null, false, null, true).css;
      }
    },
    CssParentNode: {
      "^": "CssNode;children<",
      get$isChildless: function() {
        return false;
      },
      addChild$1: ["super$CssParentNode$addChild", function(child) {
        var t1;
        child._node0$_parent = this;
        t1 = this._children;
        child._indexInParent = t1.length;
        t1.push(child);
      }]
    }
  }], ["", "package:sass/src/ast/css/style_rule.dart",, X, {
    "^": "",
    CssStyleRule: {
      "^": "CssParentNode;selector<,originalSelector,span<,children,_children,_node0$_parent,_indexInParent,isGroupEnd",
      accept$1: function(visitor) {
        return visitor.visitStyleRule$1(this);
      },
      copyWithoutChildren$0: function() {
        return X.CssStyleRule$(this.selector, this.span, this.originalSelector);
      },
      static: {
        CssStyleRule$: function(selector, span, originalSelector) {
          var t1, t2;
          t1 = originalSelector == null ? selector.value : originalSelector;
          t2 = [];
          return new X.CssStyleRule(selector, t1, span, new P.UnmodifiableListView(t2, [B.CssNode]), t2, null, null, false);
        }
      }
    }
  }], ["", "package:sass/src/ast/css/stylesheet.dart",, V, {
    "^": "",
    CssStylesheet: {
      "^": "CssParentNode;span<,children,_children,_node0$_parent,_indexInParent,isGroupEnd",
      accept$1: function(visitor) {
        return visitor.visitStylesheet$1(this);
      },
      copyWithoutChildren$0: function() {
        var t1 = [];
        return new V.CssStylesheet(this.span, new P.UnmodifiableListView(t1, [B.CssNode]), t1, null, null, false);
      }
    }
  }], ["", "package:sass/src/ast/css/supports_rule.dart",, B, {
    "^": "",
    CssSupportsRule: {
      "^": "CssParentNode;condition<,span<,children,_children,_node0$_parent,_indexInParent,isGroupEnd",
      accept$1: function(visitor) {
        return visitor.visitSupportsRule$1(this);
      },
      copyWithoutChildren$0: function() {
        var t1 = [];
        return new B.CssSupportsRule(this.condition, this.span, new P.UnmodifiableListView(t1, [B.CssNode]), t1, null, null, false);
      }
    }
  }], ["", "package:sass/src/ast/css/value.dart",, F, {
    "^": "",
    CssValue: {
      "^": "Object;value@,span<,$ti",
      toString$0: function(_) {
        return J.toString$0$(this.value);
      }
    }
  }], ["", "package:sass/src/ast/node.dart",, B, {
    "^": "",
    AstNode: {
      "^": "Object;"
    }
  }], ["", "package:sass/src/ast/sass/argument.dart",, Z, {
    "^": "",
    Argument: {
      "^": "Object;name<,defaultValue<,span<",
      toString$0: function(_) {
        var t1, t2;
        t1 = this.defaultValue;
        t2 = this.name;
        return t1 == null ? t2 : t2 + ": " + H.S(t1);
      }
    }
  }], ["", "package:sass/src/ast/sass/argument_declaration.dart",, B, {
    "^": "",
    ArgumentDeclaration: {
      "^": "Object;$arguments<,restArgument<,span<",
      verify$2: function(positional, names) {
        var t1, t2, t3, namedUsed, i, argument, unknownNames;
        for (t1 = this.$arguments, t2 = t1.length, t3 = names._baseMap, namedUsed = 0, i = 0; i < t2; ++i) {
          argument = t1[i];
          if (typeof positional !== "number")
            return H.iae(positional);
          if (i < positional) {
            if (t3.containsKey$1(argument.get$name()) === true)
              throw H.wrapException(E.SassScriptException$("Argument $" + H.S(argument.get$name()) + " was passed both by position and by name."));
          } else if (t3.containsKey$1(argument.get$name()) === true)
            ++namedUsed;
          else if (argument.get$defaultValue() == null)
            throw H.wrapException(E.SassScriptException$("Missing argument $" + H.S(argument.get$name()) + "."));
        }
        if (this.restArgument != null)
          return;
        if (J.$gt$n(positional, t2))
          throw H.wrapException(E.SassScriptException$("Only " + t2 + " " + B.pluralize("argument", t2, null) + " allowed, but " + H.S(positional) + " " + B.pluralize("was", positional, "were") + " passed."));
        t2 = J.get$length$asx(t3);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (namedUsed < t2) {
          unknownNames = B.normalizedSet(names);
          unknownNames.removeAll$1(new H.MappedListIterable(t1, new B.ArgumentDeclaration_verify_closure(), [H.getTypeArgumentByIndex(t1, 0), null]));
          throw H.wrapException(E.SassScriptException$("No " + B.pluralize("argument", unknownNames.get$length(unknownNames), null) + " named " + H.S(B.toSentence(unknownNames.map$1(0, new B.ArgumentDeclaration_verify_closure0()), "or")) + "."));
        }
      },
      matches$2: function(positional, names) {
        var t1, t2, t3, namedUsed, i, argument;
        for (t1 = this.$arguments, t2 = t1.length, t3 = names._baseMap, namedUsed = 0, i = 0; i < t2; ++i) {
          argument = t1[i];
          if (i < positional) {
            if (t3.containsKey$1(argument.get$name()) === true)
              return false;
          } else if (t3.containsKey$1(argument.get$name()) === true)
            ++namedUsed;
          else if (argument.get$defaultValue() == null)
            return false;
        }
        if (this.restArgument != null)
          return true;
        if (positional > t2)
          return false;
        t1 = J.get$length$asx(t3);
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (namedUsed < t1)
          return false;
        return true;
      },
      toString$0: function(_) {
        var t1, components;
        t1 = this.$arguments;
        components = P.List_List$from(new H.MappedListIterable(t1, new B.ArgumentDeclaration_toString_closure(), [H.getTypeArgumentByIndex(t1, 0), null]), true, null);
        t1 = this.restArgument;
        if (t1 != null)
          C.JSArray_methods.add$1(components, t1 + "...");
        return C.JSArray_methods.join$1(components, ", ");
      },
      static: {
        ArgumentDeclaration_ArgumentDeclaration$parse: function(contents, logger, url) {
          var t1, t2, t3;
          t1 = "(" + H.S(contents) + ")";
          t2 = C.JSString_methods.get$codeUnits(t1);
          t3 = H.setRuntimeTypeInfo([0], [P.int]);
          t3 = new Y.SourceFile(url, t3, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
          t3.SourceFile$decoded$2$url(t2, url);
          return new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t3, null, url, t1, 0, null, null), C.StderrLogger_false).parseArgumentDeclaration$0();
        }
      }
    },
    ArgumentDeclaration_verify_closure: {
      "^": "Closure:0;",
      call$1: [function(argument) {
        return argument.get$name();
      }, null, null, 4, 0, null, 30, "call"]
    },
    ArgumentDeclaration_verify_closure0: {
      "^": "Closure:0;",
      call$1: [function($name) {
        return "$" + H.S($name);
      }, null, null, 4, 0, null, 8, "call"]
    },
    ArgumentDeclaration_toString_closure: {
      "^": "Closure:0;",
      call$1: [function(arg) {
        return J.toString$0$(arg);
      }, null, null, 4, 0, null, 35, "call"]
    }
  }], ["", "package:sass/src/ast/sass/argument_invocation.dart",, X, {
    "^": "",
    ArgumentInvocation: {
      "^": "Object;positional<,named<,rest,keywordRest,span<",
      ArgumentInvocation$5$keywordRest$rest: function(positional, named, span, keywordRest, rest) {
      },
      toString$0: function(_) {
        var components, t1;
        components = P.List_List$from(this.positional, true, P.Object);
        t1 = this.named.get$keys();
        C.JSArray_methods.addAll$1(components, H.MappedIterable_MappedIterable(t1, new X.ArgumentInvocation_toString_closure(this), H.getRuntimeTypeArgument(t1, "Iterable", 0), null));
        t1 = this.rest;
        if (t1 != null)
          C.JSArray_methods.add$1(components, H.S(t1) + "...");
        t1 = this.keywordRest;
        if (t1 != null)
          C.JSArray_methods.add$1(components, H.S(t1) + "...");
        return "(" + C.JSArray_methods.join$1(components, ", ") + ")";
      },
      static: {
        ArgumentInvocation$: function(positional, named, span, keywordRest, rest) {
          var t1 = new X.ArgumentInvocation(P.List_List$unmodifiable(positional, null), H.ConstantMap_ConstantMap$from(named, null, null), rest, keywordRest, span);
          t1.ArgumentInvocation$5$keywordRest$rest(positional, named, span, keywordRest, rest);
          return t1;
        }
      }
    },
    ArgumentInvocation_toString_closure: {
      "^": "Closure:0;$this",
      call$1: [function($name) {
        return H.S($name) + ": " + H.S(this.$this.named.$index(0, $name));
      }, null, null, 4, 0, null, 8, "call"]
    }
  }], ["", "package:sass/src/ast/sass/at_root_query.dart",, V, {
    "^": "",
    AtRootQuery: {
      "^": "Object;include,names,_all,_rule",
      get$excludesMedia: function() {
        var t1 = this.include;
        return this._all ? !t1 : this.names.contains$1(0, "media") !== t1;
      },
      get$excludesStyleRules: function() {
        var t1 = this._all || this._rule;
        return t1 !== this.include;
      },
      excludes$1: function(node) {
        if (this._all)
          return !this.include;
        if (this._rule && node instanceof X.CssStyleRule)
          return !this.include;
        return this.names.contains$1(0, this._nameFor$1(node)) !== this.include;
      },
      excludesName$1: function($name) {
        return this.names.contains$1(0, $name) !== this.include;
      },
      _nameFor$1: function(node) {
        var t1 = J.getInterceptor(node);
        if (!!t1.$isCssMediaRule)
          return "media";
        if (!!t1.$isCssSupportsRule)
          return "supports";
        if (!!t1.$isCssAtRule)
          return node.name.toLowerCase();
        return;
      }
    }
  }], ["", "package:sass/src/ast/sass/expression.dart",, T, {
    "^": "",
    Expression: {
      "^": "Object;"
    }
  }], ["", "package:sass/src/ast/sass/expression/binary_operation.dart",, V, {
    "^": "",
    BinaryOperationExpression: {
      "^": "Object;operator,left,right,allowsSlash",
      get$span: function() {
        return B.spanForList([this.left, this.right]);
      },
      accept$1: function(visitor) {
        return visitor.visitBinaryOperationExpression$1(this);
      },
      toString$0: function(_) {
        var left, leftNeedsParens, t1, t2, right, rightNeedsParens;
        left = this.left;
        leftNeedsParens = left instanceof V.BinaryOperationExpression && left.operator.precedence < this.operator.precedence;
        t1 = leftNeedsParens ? H.Primitives_stringFromCharCode(40) : "";
        t1 += H.S(left);
        if (leftNeedsParens)
          t1 += H.Primitives_stringFromCharCode(41);
        t2 = this.operator;
        t1 = t1 + H.Primitives_stringFromCharCode(32) + t2.operator + H.Primitives_stringFromCharCode(32);
        right = this.right;
        rightNeedsParens = right instanceof V.BinaryOperationExpression && right.operator.precedence <= t2.precedence;
        if (rightNeedsParens)
          t1 += H.Primitives_stringFromCharCode(40);
        t1 += H.S(right);
        if (rightNeedsParens)
          t1 += H.Primitives_stringFromCharCode(41);
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      },
      $isExpression: 1
    },
    BinaryOperator: {
      "^": "Object;name<,operator,precedence",
      toString$0: function(_) {
        return this.name;
      },
      singleEquals$1: function(arg0) {
        return this.singleEquals.call$1(arg0);
      },
      greaterThan$1: function(arg0) {
        return this.greaterThan.call$1(arg0);
      },
      greaterThanOrEquals$1: function(arg0) {
        return this.greaterThanOrEquals.call$1(arg0);
      },
      lessThan$1: function(arg0) {
        return this.lessThan.call$1(arg0);
      },
      lessThanOrEquals$1: function(arg0) {
        return this.lessThanOrEquals.call$1(arg0);
      },
      plus$1: function(arg0) {
        return this.plus.call$1(arg0);
      },
      minus$1: function(arg0) {
        return this.minus.call$1(arg0);
      },
      times$1: function(arg0) {
        return this.times.call$1(arg0);
      },
      dividedBy$1: function(arg0) {
        return this.dividedBy.call$1(arg0);
      },
      modulo$1: function(arg0) {
        return this.modulo.call$1(arg0);
      }
    }
  }], ["", "package:sass/src/ast/sass/expression/boolean.dart",, Z, {
    "^": "",
    BooleanExpression: {
      "^": "Object;value<,span<",
      accept$1: function(visitor) {
        return visitor.visitBooleanExpression$1(this);
      },
      toString$0: function(_) {
        return String(this.value);
      },
      $isExpression: 1
    }
  }], ["", "package:sass/src/ast/sass/expression/color.dart",, K, {
    "^": "",
    ColorExpression: {
      "^": "Object;value<",
      get$span: function() {
        return this.value.originalSpan;
      },
      accept$1: function(visitor) {
        return visitor.visitColorExpression$1(this);
      },
      toString$0: function(_) {
        return N.serializeValue(this.value, true, true);
      },
      $isExpression: 1
    }
  }], ["", "package:sass/src/ast/sass/expression/function.dart",, F, {
    "^": "",
    FunctionExpression: {
      "^": "Object;name<,$arguments<",
      get$span: function() {
        return B.spanForList([this.name, this.$arguments]);
      },
      accept$1: function(visitor) {
        return visitor.visitFunctionExpression$1(this);
      },
      toString$0: function(_) {
        return this.name.toString$0(0) + this.$arguments.toString$0(0);
      },
      $isExpression: 1
    }
  }], ["", "package:sass/src/ast/sass/expression/if.dart",, L, {
    "^": "",
    IfExpression: {
      "^": "Object;$arguments<,span<",
      accept$1: function(visitor) {
        return visitor.visitIfExpression$1(this);
      },
      toString$0: function(_) {
        return "if" + this.$arguments.toString$0(0);
      },
      $isExpression: 1
    }
  }], ["", "package:sass/src/ast/sass/expression/list.dart",, D, {
    "^": "",
    ListExpression: {
      "^": "Object;contents>,separator<,hasBrackets<,span<",
      accept$1: function(visitor) {
        return visitor.visitListExpression$1(this);
      },
      toString$0: function(_) {
        var t1, t2, t3, t4;
        t1 = this.hasBrackets;
        t2 = t1 ? H.Primitives_stringFromCharCode(91) : "";
        t3 = this.contents;
        t4 = this.separator === C.ListSeparator_kWM ? ", " : " ";
        t4 = t2 + new H.MappedListIterable(t3, new D.ListExpression_toString_closure(this), [H.getTypeArgumentByIndex(t3, 0), null]).join$1(0, t4);
        t1 = t1 ? t4 + H.Primitives_stringFromCharCode(93) : t4;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      },
      _list0$_elementNeedsParens$1: function(expression) {
        var t1, t2;
        t1 = J.getInterceptor(expression);
        if (!!t1.$isListExpression) {
          if (expression.contents.length < 2)
            return false;
          if (expression.hasBrackets)
            return false;
          t1 = this.separator;
          t2 = t1 === C.ListSeparator_kWM;
          return t2 ? t2 : t1 !== C.ListSeparator_undecided_null;
        }
        if (this.separator !== C.ListSeparator_woc)
          return false;
        if (!!t1.$isUnaryOperationExpression) {
          t1 = expression.operator;
          return t1 === C.UnaryOperator_j2w || t1 === C.UnaryOperator_U4G;
        }
        return false;
      },
      $isExpression: 1
    },
    ListExpression_toString_closure: {
      "^": "Closure:0;$this",
      call$1: [function(element) {
        return this.$this._list0$_elementNeedsParens$1(element) ? "(" + H.S(element) + ")" : J.toString$0$(element);
      }, null, null, 4, 0, null, 11, "call"]
    }
  }], ["", "package:sass/src/ast/sass/expression/map.dart",, A, {
    "^": "",
    MapExpression: {
      "^": "Object;pairs,span<",
      accept$1: function(visitor) {
        return visitor.visitMapExpression$1(this);
      },
      toString$0: function(_) {
        var t1 = this.pairs;
        return "(" + new H.MappedListIterable(t1, new A.MapExpression_toString_closure(), [H.getTypeArgumentByIndex(t1, 0), null]).join$1(0, ", ") + ")";
      },
      $isExpression: 1
    },
    MapExpression_toString_closure: {
      "^": "Closure:0;",
      call$1: [function(pair) {
        return H.S(pair.get$item1()) + ": " + H.S(pair.get$item2());
      }, null, null, 4, 0, null, 45, "call"]
    }
  }], ["", "package:sass/src/ast/sass/expression/null.dart",, O, {
    "^": "",
    NullExpression: {
      "^": "Object;span<",
      accept$1: function(visitor) {
        return visitor.visitNullExpression$1(this);
      },
      toString$0: function(_) {
        return "null";
      },
      $isExpression: 1
    }
  }], ["", "package:sass/src/ast/sass/expression/number.dart",, T, {
    "^": "",
    NumberExpression: {
      "^": "Object;value<,unit,span<",
      accept$1: function(visitor) {
        return visitor.visitNumberExpression$1(this);
      },
      toString$0: function(_) {
        var t1, t2;
        t1 = H.S(this.value);
        t2 = this.unit;
        return t1 + (t2 == null ? "" : t2);
      },
      $isExpression: 1
    }
  }], ["", "package:sass/src/ast/sass/expression/selector.dart",, T, {
    "^": "",
    SelectorExpression: {
      "^": "Object;span<",
      accept$1: function(visitor) {
        return visitor.visitSelectorExpression$1(this);
      },
      toString$0: function(_) {
        return "&";
      },
      $isExpression: 1
    }
  }], ["", "package:sass/src/ast/sass/expression/string.dart",, D, {
    "^": "",
    StringExpression: {
      "^": "Object;text<,hasQuotes<",
      get$span: function() {
        return this.text.span;
      },
      accept$1: function(visitor) {
        return visitor.visitStringExpression$1(this);
      },
      asInterpolation$2$quote$static: function(quote, $static) {
        var t1, t2, buffer, t3, t4, t5, _i, value, t6, t7, i, codeUnit, next, t8;
        if (!this.hasQuotes)
          return this.text;
        quote = this._bestQuote$0();
        t1 = new P.StringBuffer("");
        t2 = [];
        buffer = new Z.InterpolationBuffer(t1, t2);
        t1._contents += H.Primitives_stringFromCharCode(quote);
        for (t3 = this.text, t4 = t3.contents, t5 = t4.length, _i = 0; _i < t5; ++_i) {
          value = t4[_i];
          if (!!J.getInterceptor(value).$isExpression) {
            buffer._flushText$0();
            t2.push(value);
          } else if (typeof value === "string")
            for (t6 = value.length, t7 = t6 - 1, i = 0; i < t6; ++i) {
              codeUnit = C.JSString_methods._codeUnitAt$1(value, i);
              if (codeUnit === 10 || codeUnit === 13 || codeUnit === 12) {
                t1._contents += H.Primitives_stringFromCharCode(92);
                t1._contents += H.Primitives_stringFromCharCode(97);
                if (i !== t7) {
                  next = C.JSString_methods._codeUnitAt$1(value, i + 1);
                  if (!(next === 32 || next === 9 || next === 10 || next === 13 || next === 12)) {
                    t8 = next >= 48 && next <= 57;
                    if (!t8)
                      if (!(next >= 97 && next <= 102))
                        t8 = next >= 65 && next <= 70;
                      else
                        t8 = true;
                    else
                      t8 = true;
                  } else
                    t8 = true;
                  if (t8)
                    t1._contents += H.Primitives_stringFromCharCode(32);
                }
              } else {
                if (codeUnit !== quote)
                  if (codeUnit !== 92)
                    t8 = $static && codeUnit === 35 && i < t7 && C.JSString_methods._codeUnitAt$1(value, i + 1) === 123;
                  else
                    t8 = true;
                else
                  t8 = true;
                if (t8)
                  t1._contents += H.Primitives_stringFromCharCode(92);
                t1._contents += H.Primitives_stringFromCharCode(codeUnit);
              }
            }
        }
        t1._contents += H.Primitives_stringFromCharCode(quote);
        return buffer.interpolation$1(t3.span);
      },
      asInterpolation$0: function() {
        return this.asInterpolation$2$quote$static(null, false);
      },
      asInterpolation$1$static: function($static) {
        return this.asInterpolation$2$quote$static(null, $static);
      },
      _bestQuote$0: function() {
        var t1, t2, containsDoubleQuote, _i, value, t3, i, codeUnit;
        for (t1 = this.text.contents, t2 = t1.length, containsDoubleQuote = false, _i = 0; _i < t2; ++_i) {
          value = t1[_i];
          if (typeof value === "string")
            for (t3 = value.length, i = 0; i < t3; ++i) {
              codeUnit = C.JSString_methods._codeUnitAt$1(value, i);
              if (codeUnit === 39)
                return 34;
              if (codeUnit === 34)
                containsDoubleQuote = true;
            }
        }
        return containsDoubleQuote ? 39 : 34;
      },
      toString$0: function(_) {
        return this.asInterpolation$0().toString$0(0);
      },
      $isExpression: 1
    }
  }], ["", "package:sass/src/ast/sass/expression/unary_operation.dart",, X, {
    "^": "",
    UnaryOperationExpression: {
      "^": "Object;operator,operand,span<",
      accept$1: function(visitor) {
        return visitor.visitUnaryOperationExpression$1(this);
      },
      toString$0: function(_) {
        var t1, t2;
        t1 = this.operator;
        t2 = t1.operator;
        t1 = t1 === C.UnaryOperator_not_not ? t2 + H.Primitives_stringFromCharCode(32) : t2;
        t1 += H.S(this.operand);
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      },
      $isExpression: 1
    },
    UnaryOperator: {
      "^": "Object;name<,operator",
      toString$0: function(_) {
        return this.name;
      },
      plus$1: function(arg0) {
        return this.plus.call$1(arg0);
      },
      minus$1: function(arg0) {
        return this.minus.call$1(arg0);
      }
    }
  }], ["", "package:sass/src/ast/sass/expression/value.dart",, F, {
    "^": "",
    ValueExpression: {
      "^": "Object;value<,span<",
      accept$1: function(visitor) {
        return visitor.visitValueExpression$1(this);
      },
      toString$0: function(_) {
        return J.toString$0$(this.value);
      },
      $isExpression: 1
    }
  }], ["", "package:sass/src/ast/sass/expression/variable.dart",, S, {
    "^": "",
    VariableExpression: {
      "^": "Object;name<,span<",
      accept$1: function(visitor) {
        return visitor.visitVariableExpression$1(this);
      },
      toString$0: function(_) {
        return "$" + this.name;
      },
      $isExpression: 1
    }
  }], ["", "package:sass/src/ast/sass/import.dart",, F, {
    "^": "",
    Import: {
      "^": "Object;"
    }
  }], ["", "package:sass/src/ast/sass/import/dynamic.dart",, B, {
    "^": "",
    DynamicImport: {
      "^": "Object;url<,span<",
      toString$0: function(_) {
        return new D.StringExpression(X.Interpolation$([this.url], null), true).asInterpolation$1$static(true).get$asPlain();
      }
    }
  }], ["", "package:sass/src/ast/sass/import/static.dart",, Q, {
    "^": "",
    StaticImport: {
      "^": "Object;url<,supports,media,span<",
      toString$0: function(_) {
        var t1, t2;
        t1 = this.url.toString$0(0);
        t2 = this.supports;
        if (t2 != null)
          t1 += " supports(" + H.S(t2) + ")";
        t2 = this.media;
        if (t2 != null)
          t1 += " " + H.S(t2);
        t1 += H.Primitives_stringFromCharCode(59);
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }
    }
  }], ["", "package:sass/src/ast/sass/interpolation.dart",, X, {
    "^": "",
    Interpolation: {
      "^": "Object;contents>,span<",
      get$asPlain: function() {
        var t1, t2, first;
        t1 = this.contents;
        t2 = t1.length;
        if (t2 === 0)
          return "";
        if (t2 > 1)
          return;
        first = C.JSArray_methods.get$first(t1);
        return typeof first === "string" ? first : null;
      },
      Interpolation$2: function(contents, span) {
        var t1, t2, i, t3, t4;
        for (t1 = this.contents, t2 = t1.length, i = 0; i < t2; ++i) {
          t3 = t1[i];
          t4 = typeof t3 === "string";
          if (!t4 && !J.getInterceptor(t3).$isExpression)
            throw H.wrapException(P.ArgumentError$value(t1, "contents", "May only contains Strings or Expressions."));
          if (i !== 0) {
            t3 = i - 1;
            if (t3 < 0)
              return H.ioore(t1, t3);
            t3 = t1[t3];
            t3 = typeof t3 === "string" && t4;
          } else
            t3 = false;
          if (t3)
            throw H.wrapException(P.ArgumentError$value(t1, "contents", "May not contain adjacent Strings."));
        }
      },
      toString$0: function(_) {
        var t1 = this.contents;
        return new H.MappedListIterable(t1, new X.Interpolation_toString_closure(), [H.getTypeArgumentByIndex(t1, 0), null]).join$0(0);
      },
      static: {
        Interpolation$: function(contents, span) {
          var t1 = new X.Interpolation(P.List_List$unmodifiable(contents, null), span);
          t1.Interpolation$2(contents, span);
          return t1;
        }
      }
    },
    Interpolation_toString_closure: {
      "^": "Closure:0;",
      call$1: [function(value) {
        return typeof value === "string" ? value : "#{" + H.S(value) + "}";
      }, null, null, 4, 0, null, 3, "call"]
    }
  }], ["", "package:sass/src/ast/sass/statement.dart",, O, {
    "^": "",
    Statement: {
      "^": "Object;"
    }
  }], ["", "package:sass/src/ast/sass/statement/at_root_rule.dart",, V, {
    "^": "",
    AtRootRule: {
      "^": "ParentStatement;query<,span<,children,hasDeclarations",
      accept$1: function(visitor) {
        return visitor.visitAtRootRule$1(this);
      },
      toString$0: function(_) {
        var buffer, t1;
        buffer = new P.StringBuffer("@at-root ");
        t1 = this.query;
        if (t1 != null)
          buffer._contents = "@at-root " + (t1.toString$0(0) + " ");
        t1 = this.children;
        return buffer.toString$0(0) + " {" + (t1 && C.JSArray_methods).join$1(t1, " ") + "}";
      }
    }
  }], ["", "package:sass/src/ast/sass/statement/at_rule.dart",, U, {
    "^": "",
    AtRule: {
      "^": "ParentStatement;name<,normalizedName<,value<,span<,children,hasDeclarations",
      accept$1: function(visitor) {
        return visitor.visitAtRule$1(this);
      },
      toString$0: function(_) {
        var t1, buffer, t2;
        t1 = "@" + this.name;
        buffer = new P.StringBuffer(t1);
        t2 = this.value;
        if (t2 != null)
          buffer._contents = t1 + (" " + t2.toString$0(0));
        t1 = this.children;
        return t1 == null ? buffer.toString$0(0) + ";" : buffer.toString$0(0) + " {" + C.JSArray_methods.join$1(t1, " ") + "}";
      },
      static: {
        AtRule$: function($name, span, children, value) {
          var t1, t2, t3;
          t1 = B.unvendor($name);
          t2 = children == null ? null : P.List_List$unmodifiable(children, null);
          t3 = t2 == null ? null : C.JSArray_methods.any$1(t2, new M.ParentStatement_closure());
          return new U.AtRule($name, t1, value, span, t2, t3 == null ? false : t3);
        }
      }
    }
  }], ["", "package:sass/src/ast/sass/statement/callable_declaration.dart",, M, {
    "^": "",
    CallableDeclaration: {
      "^": "ParentStatement;name<,$arguments<,span<"
    }
  }], ["", "package:sass/src/ast/sass/statement/content_rule.dart",, Q, {
    "^": "",
    ContentRule: {
      "^": "Object;span<",
      accept$1: function(visitor) {
        return visitor.visitContentRule$1(this);
      },
      toString$0: function(_) {
        return "@content;";
      },
      $isStatement: 1
    }
  }], ["", "package:sass/src/ast/sass/statement/debug_rule.dart",, Q, {
    "^": "",
    DebugRule: {
      "^": "Object;expression<,span<",
      accept$1: function(visitor) {
        return visitor.visitDebugRule$1(this);
      },
      toString$0: function(_) {
        return "@debug " + H.S(this.expression) + ";";
      },
      $isStatement: 1
    }
  }], ["", "package:sass/src/ast/sass/statement/declaration.dart",, L, {
    "^": "",
    Declaration: {
      "^": "ParentStatement;name<,value<,span<,children,hasDeclarations",
      accept$1: function(visitor) {
        return visitor.visitDeclaration$1(this);
      },
      toString$0: function(_) {
        return this.name.toString$0(0) + ": " + H.S(this.value) + ";";
      },
      static: {
        Declaration$: function($name, span, children, value) {
          var t1;
          children = children == null ? null : P.List_List$unmodifiable(children, null);
          t1 = children == null ? null : C.JSArray_methods.any$1(children, new M.ParentStatement_closure());
          return new L.Declaration($name, value, span, children, t1 == null ? false : t1);
        }
      }
    }
  }], ["", "package:sass/src/ast/sass/statement/each_rule.dart",, V, {
    "^": "",
    EachRule: {
      "^": "ParentStatement;variables,list,span<,children,hasDeclarations",
      accept$1: function(visitor) {
        return visitor.visitEachRule$1(this);
      },
      toString$0: function(_) {
        var t1, t2;
        t1 = this.variables;
        t2 = this.children;
        return "@each " + new H.MappedListIterable(t1, new V.EachRule_toString_closure(), [H.getTypeArgumentByIndex(t1, 0), null]).join$1(0, ", ") + " in " + H.S(this.list) + " {" + (t2 && C.JSArray_methods).join$1(t2, " ") + "}";
      }
    },
    EachRule_toString_closure: {
      "^": "Closure:0;",
      call$1: [function(variable) {
        return C.JSString_methods.$add("$", variable);
      }, null, null, 4, 0, null, 47, "call"]
    }
  }], ["", "package:sass/src/ast/sass/statement/error_rule.dart",, D, {
    "^": "",
    ErrorRule: {
      "^": "Object;expression<,span<",
      accept$1: function(visitor) {
        return visitor.visitErrorRule$1(this);
      },
      toString$0: function(_) {
        return "@error " + H.S(this.expression) + ";";
      },
      $isStatement: 1
    }
  }], ["", "package:sass/src/ast/sass/statement/extend_rule.dart",, X, {
    "^": "",
    ExtendRule: {
      "^": "Object;selector<,isOptional<,span<",
      accept$1: function(visitor) {
        return visitor.visitExtendRule$1(this);
      },
      toString$0: function(_) {
        return "@extend " + this.selector.toString$0(0);
      },
      $isStatement: 1
    }
  }], ["", "package:sass/src/ast/sass/statement/for_rule.dart",, B, {
    "^": "",
    ForRule: {
      "^": "ParentStatement;variable,from,to,isExclusive,span<,children,hasDeclarations",
      accept$1: function(visitor) {
        return visitor.visitForRule$1(this);
      },
      toString$0: function(_) {
        var t1, t2;
        t1 = "@for $" + this.variable + " from " + H.S(this.from) + " ";
        t2 = this.children;
        return t1 + (this.isExclusive === true ? "to" : "through") + " " + H.S(this.to) + " {" + (t2 && C.JSArray_methods).join$1(t2, " ") + "}";
      }
    }
  }], ["", "package:sass/src/ast/sass/statement/function_rule.dart",, M, {
    "^": "",
    FunctionRule: {
      "^": "CallableDeclaration;name,$arguments,span,children,hasDeclarations",
      accept$1: function(visitor) {
        return visitor.visitFunctionRule$1(this);
      },
      toString$0: function(_) {
        var t1 = this.children;
        return "@function " + this.name + "(" + this.$arguments.toString$0(0) + ") {" + (t1 && C.JSArray_methods).join$1(t1, " ") + "}";
      }
    }
  }], ["", "package:sass/src/ast/sass/statement/if_rule.dart",, V, {
    "^": "",
    IfRule: {
      "^": "Object;clauses,lastClause,span<",
      accept$1: function(visitor) {
        return visitor.visitIfRule$1(this);
      },
      toString$0: function(_) {
        var t1, t2;
        t1 = {};
        t1.first = true;
        t2 = this.clauses;
        return new H.MappedListIterable(t2, new V.IfRule_toString_closure(t1), [H.getTypeArgumentByIndex(t2, 0), null]).join$1(0, " ");
      },
      $isStatement: 1
    },
    IfRule_toString_closure: {
      "^": "Closure:0;_box_0",
      call$1: [function(clause) {
        var t1, $name;
        t1 = this._box_0;
        $name = t1.first ? "if" : "else";
        t1.first = false;
        return "@" + $name + " " + H.S(clause.get$expression()) + " {" + J.join$1$ax(clause.get$children(), " ") + "}";
      }, null, null, 4, 0, null, 48, "call"]
    },
    IfClause: {
      "^": "Object;expression<,children<,hasDeclarations<",
      toString$0: function(_) {
        var t1 = this.expression;
        t1 = t1 == null ? "@else" : "@if " + H.S(t1);
        return t1 + (" {" + C.JSArray_methods.join$1(this.children, " ") + "}");
      }
    },
    IfClause$__closure: {
      "^": "Closure:0;",
      call$1: function(child) {
        var t1 = J.getInterceptor(child);
        return !!t1.$isVariableDeclaration || !!t1.$isFunctionRule || !!t1.$isMixinRule;
      }
    }
  }], ["", "package:sass/src/ast/sass/statement/import_rule.dart",, B, {
    "^": "",
    ImportRule: {
      "^": "Object;imports,span<",
      accept$1: function(visitor) {
        return visitor.visitImportRule$1(this);
      },
      toString$0: function(_) {
        return "@import " + C.JSArray_methods.join$1(this.imports, ", ") + ";";
      },
      $isStatement: 1
    }
  }], ["", "package:sass/src/ast/sass/statement/include_rule.dart",, A, {
    "^": "",
    IncludeRule: {
      "^": "ParentStatement;name<,$arguments<,span<,children,hasDeclarations",
      accept$1: function(visitor) {
        return visitor.visitIncludeRule$1(this);
      },
      toString$0: function(_) {
        var t1, t2;
        t1 = "@include " + this.name + "(" + this.$arguments.toString$0(0) + ")";
        t2 = this.children;
        return t1 + (t2 == null ? ";" : " {" + C.JSArray_methods.join$1(t2, " ") + "}");
      }
    }
  }], ["", "package:sass/src/ast/sass/statement/loud_comment.dart",, L, {
    "^": "",
    LoudComment: {
      "^": "Object;text<",
      get$span: function() {
        return this.text.span;
      },
      accept$1: function(visitor) {
        return visitor.visitLoudComment$1(this);
      },
      toString$0: function(_) {
        return this.text.toString$0(0);
      },
      $isStatement: 1
    }
  }], ["", "package:sass/src/ast/sass/statement/media_rule.dart",, G, {
    "^": "",
    MediaRule: {
      "^": "ParentStatement;query<,span<,children,hasDeclarations",
      accept$1: function(visitor) {
        return visitor.visitMediaRule$1(this);
      },
      toString$0: function(_) {
        var t1 = this.children;
        return "@media " + this.query.toString$0(0) + " {" + (t1 && C.JSArray_methods).join$1(t1, " ") + "}";
      }
    }
  }], ["", "package:sass/src/ast/sass/statement/mixin_rule.dart",, T, {
    "^": "",
    MixinRule: {
      "^": "CallableDeclaration;hasContent,name,$arguments,span,children,hasDeclarations",
      accept$1: function(visitor) {
        return visitor.visitMixinRule$1(this);
      },
      toString$0: function(_) {
        var t1 = this.children;
        return "@mixin " + this.name + "(" + this.$arguments.toString$0(0) + ") {" + (t1 && C.JSArray_methods).join$1(t1, " ") + "}";
      }
    }
  }], ["", "package:sass/src/ast/sass/statement/parent.dart",, M, {
    "^": "",
    ParentStatement: {
      "^": "Object;children<,hasDeclarations<",
      $isStatement: 1
    },
    ParentStatement_closure: {
      "^": "Closure:0;",
      call$1: function(child) {
        var t1 = J.getInterceptor(child);
        return !!t1.$isVariableDeclaration || !!t1.$isFunctionRule || !!t1.$isMixinRule;
      }
    }
  }], ["", "package:sass/src/ast/sass/statement/return_rule.dart",, B, {
    "^": "",
    ReturnRule: {
      "^": "Object;expression<,span<",
      accept$1: function(visitor) {
        return visitor.visitReturnRule$1(this);
      },
      toString$0: function(_) {
        return "@return " + H.S(this.expression) + ";";
      },
      $isStatement: 1
    }
  }], ["", "package:sass/src/ast/sass/statement/silent_comment.dart",, B, {
    "^": "",
    SilentComment: {
      "^": "Object;text<,span<",
      accept$1: function(visitor) {
        return visitor.visitSilentComment$1(this);
      },
      toString$0: function(_) {
        return this.text;
      },
      $isStatement: 1
    }
  }], ["", "package:sass/src/ast/sass/statement/style_rule.dart",, X, {
    "^": "",
    StyleRule: {
      "^": "ParentStatement;selector<,span<,children,hasDeclarations",
      accept$1: function(visitor) {
        return visitor.visitStyleRule$1(this);
      },
      toString$0: function(_) {
        var t1 = this.children;
        return this.selector.toString$0(0) + " {" + (t1 && C.JSArray_methods).join$1(t1, " ") + "}";
      }
    }
  }], ["", "package:sass/src/ast/sass/statement/stylesheet.dart",, V, {
    "^": "",
    Stylesheet: {
      "^": "ParentStatement;span<,children,hasDeclarations",
      accept$1: function(visitor) {
        return visitor.visitStylesheet$1(this);
      },
      toString$0: function(_) {
        var t1 = this.children;
        return (t1 && C.JSArray_methods).join$1(t1, " ");
      }
    }
  }], ["", "package:sass/src/ast/sass/statement/supports_rule.dart",, B, {
    "^": "",
    SupportsRule: {
      "^": "ParentStatement;condition<,span<,children,hasDeclarations",
      accept$1: function(visitor) {
        return visitor.visitSupportsRule$1(this);
      },
      toString$0: function(_) {
        var t1 = this.children;
        return "@supports " + this.condition.toString$0(0) + " {" + (t1 && C.JSArray_methods).join$1(t1, " ") + "}";
      }
    }
  }], ["", "package:sass/src/ast/sass/statement/variable_declaration.dart",, Z, {
    "^": "",
    VariableDeclaration: {
      "^": "Object;name<,expression<,isGuarded,isGlobal,span<",
      accept$1: function(visitor) {
        return visitor.visitVariableDeclaration$1(this);
      },
      toString$0: function(_) {
        return "$" + this.name + ": " + H.S(this.expression) + ";";
      },
      $isStatement: 1
    }
  }], ["", "package:sass/src/ast/sass/statement/warn_rule.dart",, Y, {
    "^": "",
    WarnRule: {
      "^": "Object;expression<,span<",
      accept$1: function(visitor) {
        return visitor.visitWarnRule$1(this);
      },
      toString$0: function(_) {
        return "@warn " + H.S(this.expression) + ";";
      },
      $isStatement: 1
    }
  }], ["", "package:sass/src/ast/sass/statement/while_rule.dart",, G, {
    "^": "",
    WhileRule: {
      "^": "ParentStatement;condition,span<,children,hasDeclarations",
      accept$1: function(visitor) {
        return visitor.visitWhileRule$1(this);
      },
      toString$0: function(_) {
        var t1 = this.children;
        return "@while " + H.S(this.condition) + " {" + (t1 && C.JSArray_methods).join$1(t1, " ") + "}";
      }
    }
  }], ["", "package:sass/src/ast/sass/supports_condition/declaration.dart",, L, {
    "^": "",
    SupportsDeclaration: {
      "^": "Object;name<,value<,span<",
      toString$0: function(_) {
        return "(" + H.S(this.name) + ": " + H.S(this.value) + ")";
      }
    }
  }], ["", "package:sass/src/ast/sass/supports_condition/interpolation.dart",, X, {
    "^": "",
    SupportsInterpolation: {
      "^": "Object;expression<,span<",
      toString$0: function(_) {
        return "#{" + H.S(this.expression) + "}";
      }
    }
  }], ["", "package:sass/src/ast/sass/supports_condition/negation.dart",, M, {
    "^": "",
    SupportsNegation: {
      "^": "Object;condition,span<",
      toString$0: function(_) {
        var t1 = this.condition;
        if (!!t1.$isSupportsNegation || !!t1.$isSupportsOperation)
          return "not (" + t1.toString$0(0) + ")";
        else
          return "not " + t1.toString$0(0);
      }
    }
  }], ["", "package:sass/src/ast/sass/supports_condition/operation.dart",, U, {
    "^": "",
    SupportsOperation: {
      "^": "Object;left,right,operator,span<",
      toString$0: function(_) {
        return this._operation$_parenthesize$1(this.left) + " " + this.operator + " " + this._operation$_parenthesize$1(this.right);
      },
      _operation$_parenthesize$1: function(condition) {
        var t1;
        if (!condition.$isSupportsNegation)
          t1 = !!condition.$isSupportsOperation && condition.operator === this.operator;
        else
          t1 = true;
        return t1 ? "(" + condition.toString$0(0) + ")" : condition.toString$0(0);
      }
    }
  }], ["", "package:sass/src/ast/selector.dart",, T, {
    "^": "",
    Selector: {
      "^": "Object;",
      get$isInvisible: function() {
        return false;
      },
      toString$0: function(_) {
        var visitor = N._SerializeVisitor$(null, true, null, true, false, null, true);
        this.accept$1(visitor);
        return visitor._buffer.toString$0(0);
      }
    }
  }], ["", "package:sass/src/ast/selector/attribute.dart",, N, {
    "^": "",
    AttributeSelector: {
      "^": "SimpleSelector;name<,op,value<",
      accept$1: function(visitor) {
        return visitor.visitAttributeSelector$1(this);
      },
      $eq: function(_, other) {
        var t1, t2;
        if (other == null)
          return false;
        if (other instanceof N.AttributeSelector)
          if (other.name.$eq(0, this.name)) {
            t1 = other.op;
            t2 = this.op;
            if (t1 == null ? t2 == null : t1 === t2) {
              t1 = other.value;
              t2 = this.value;
              t2 = t1 == null ? t2 == null : t1 === t2;
              t1 = t2;
            } else
              t1 = false;
          } else
            t1 = false;
        else
          t1 = false;
        return t1;
      },
      get$hashCode: function(_) {
        var t1 = this.name;
        return (C.JSString_methods.get$hashCode(t1.name) ^ J.get$hashCode$(t1.namespace) ^ J.get$hashCode$(this.op) ^ J.get$hashCode$(this.value)) >>> 0;
      }
    },
    AttributeOperator: {
      "^": "Object;_attribute$_text",
      toString$0: function(_) {
        return this._attribute$_text;
      },
      substring$1: function(arg0) {
        return this.substring.call$1(arg0);
      },
      substring$2: function(arg0, arg1) {
        return this.substring.call$2(arg0, arg1);
      }
    }
  }], ["", "package:sass/src/ast/selector/class.dart",, X, {
    "^": "",
    ClassSelector: {
      "^": "SimpleSelector;name<",
      $eq: function(_, other) {
        if (other == null)
          return false;
        return other instanceof X.ClassSelector && other.name === this.name;
      },
      accept$1: function(visitor) {
        return visitor.visitClassSelector$1(this);
      },
      addSuffix$1: function(suffix) {
        return new X.ClassSelector(this.name + suffix);
      },
      get$hashCode: function(_) {
        return C.JSString_methods.get$hashCode(this.name);
      }
    }
  }], ["", "package:sass/src/ast/selector/complex.dart",, S, {
    "^": "",
    ComplexSelector: {
      "^": "Selector;components<,lineBreak<,_minSpecificity,_maxSpecificity,_complex$_isInvisible",
      get$minSpecificity: function() {
        if (this._minSpecificity == null)
          this._computeSpecificity$0();
        return this._minSpecificity;
      },
      get$maxSpecificity: function() {
        if (this._maxSpecificity == null)
          this._computeSpecificity$0();
        return this._maxSpecificity;
      },
      get$isInvisible: function() {
        var t1 = this._complex$_isInvisible;
        if (t1 != null)
          return t1;
        t1 = C.JSArray_methods.any$1(this.components, new S.ComplexSelector_isInvisible_closure());
        this._complex$_isInvisible = t1;
        return t1;
      },
      ComplexSelector$2$lineBreak: function(components, lineBreak) {
        if (this.components.length === 0)
          throw H.wrapException(P.ArgumentError$("components may not be empty."));
      },
      accept$1: function(visitor) {
        return visitor.visitComplexSelector$1(this);
      },
      isSuperselector$1: function(other) {
        return Y.complexIsSuperselector(this.components, other.get$components());
      },
      _computeSpecificity$0: function() {
        var t1, t2, _i, component, t3, t4;
        this._minSpecificity = 0;
        this._maxSpecificity = 0;
        for (t1 = this.components, t2 = t1.length, _i = 0; _i < t2; ++_i) {
          component = t1[_i];
          if (component instanceof X.CompoundSelector) {
            t3 = this._minSpecificity;
            if (component._compound$_minSpecificity == null)
              component._compound$_computeSpecificity$0();
            t4 = component._compound$_minSpecificity;
            if (typeof t3 !== "number")
              return t3.$add();
            if (typeof t4 !== "number")
              return H.iae(t4);
            this._minSpecificity = t3 + t4;
            t4 = this._maxSpecificity;
            if (component._compound$_maxSpecificity == null)
              component._compound$_computeSpecificity$0();
            t3 = component._compound$_maxSpecificity;
            if (typeof t4 !== "number")
              return t4.$add();
            if (typeof t3 !== "number")
              return H.iae(t3);
            this._maxSpecificity = t4 + t3;
          }
        }
      },
      get$hashCode: function(_) {
        return C.ListEquality_DefaultEquality.hash$1(this.components);
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        return other instanceof S.ComplexSelector && C.ListEquality_DefaultEquality.equals$2(this.components, other.components);
      },
      static: {
        ComplexSelector$: function(components, lineBreak) {
          var t1 = new S.ComplexSelector(P.List_List$unmodifiable(components, null), lineBreak, null, null, null);
          t1.ComplexSelector$2$lineBreak(components, lineBreak);
          return t1;
        }
      }
    },
    ComplexSelector_isInvisible_closure: {
      "^": "Closure:0;",
      call$1: function(component) {
        return component instanceof X.CompoundSelector && component.get$isInvisible();
      }
    },
    ComplexSelectorComponent: {
      "^": "Object;"
    },
    Combinator: {
      "^": "Object;_complex$_text",
      toString$0: function(_) {
        return this._complex$_text;
      },
      $isComplexSelectorComponent: 1
    }
  }], ["", "package:sass/src/ast/selector/compound.dart",, X, {
    "^": "",
    CompoundSelector: {
      "^": "Selector;components<,_compound$_minSpecificity,_compound$_maxSpecificity",
      get$minSpecificity: function() {
        if (this._compound$_minSpecificity == null)
          this._compound$_computeSpecificity$0();
        return this._compound$_minSpecificity;
      },
      get$maxSpecificity: function() {
        if (this._compound$_maxSpecificity == null)
          this._compound$_computeSpecificity$0();
        return this._compound$_maxSpecificity;
      },
      get$isInvisible: function() {
        return C.JSArray_methods.any$1(this.components, new X.CompoundSelector_isInvisible_closure());
      },
      CompoundSelector$1: function(components) {
        if (this.components.length === 0)
          throw H.wrapException(P.ArgumentError$("components may not be empty."));
      },
      accept$1: function(visitor) {
        return visitor.visitCompoundSelector$1(this);
      },
      isSuperselector$1: function(other) {
        return Y.compoundIsSuperselector(this, other, null);
      },
      _compound$_computeSpecificity$0: function() {
        var t1, t2, _i, simple, t3, t4;
        this._compound$_minSpecificity = 0;
        this._compound$_maxSpecificity = 0;
        for (t1 = this.components, t2 = t1.length, _i = 0; _i < t2; ++_i) {
          simple = t1[_i];
          t3 = this._compound$_minSpecificity;
          t4 = simple.get$minSpecificity();
          if (typeof t3 !== "number")
            return t3.$add();
          if (typeof t4 !== "number")
            return H.iae(t4);
          this._compound$_minSpecificity = t3 + t4;
          t4 = this._compound$_maxSpecificity;
          t3 = simple.get$maxSpecificity();
          if (typeof t4 !== "number")
            return t4.$add();
          if (typeof t3 !== "number")
            return H.iae(t3);
          this._compound$_maxSpecificity = t4 + t3;
        }
      },
      get$hashCode: function(_) {
        return C.ListEquality_DefaultEquality.hash$1(this.components);
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        return other instanceof X.CompoundSelector && C.ListEquality_DefaultEquality.equals$2(this.components, other.components);
      },
      $isComplexSelectorComponent: 1,
      static: {
        CompoundSelector$: function(components) {
          var t1 = new X.CompoundSelector(P.List_List$unmodifiable(components, null), null, null);
          t1.CompoundSelector$1(components);
          return t1;
        }
      }
    },
    CompoundSelector_isInvisible_closure: {
      "^": "Closure:0;",
      call$1: function(component) {
        return component.get$isInvisible();
      }
    }
  }], ["", "package:sass/src/ast/selector/id.dart",, N, {
    "^": "",
    IDSelector: {
      "^": "SimpleSelector;name<",
      get$minSpecificity: function() {
        return H.intTypeCast(Math.pow(M.SimpleSelector.prototype.get$minSpecificity.call(this), 2));
      },
      accept$1: function(visitor) {
        return visitor.visitIDSelector$1(this);
      },
      addSuffix$1: function(suffix) {
        return new N.IDSelector(this.name + suffix);
      },
      unify$1: function(compound) {
        if (J.any$1$ax(compound, new N.IDSelector_unify_closure(this)) === true)
          return;
        return this.super$SimpleSelector$unify(compound);
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        return other instanceof N.IDSelector && other.name === this.name;
      },
      get$hashCode: function(_) {
        return C.JSString_methods.get$hashCode(this.name);
      }
    },
    IDSelector_unify_closure: {
      "^": "Closure:0;$this",
      call$1: function(simple) {
        var t1;
        if (simple instanceof N.IDSelector) {
          t1 = simple.name;
          t1 = this.$this.name !== t1;
        } else
          t1 = false;
        return t1;
      }
    }
  }], ["", "package:sass/src/ast/selector/list.dart",, D, {
    "^": "",
    SelectorList: {
      "^": "Selector;components<",
      get$isInvisible: function() {
        return C.JSArray_methods.every$1(this.components, new D.SelectorList_isInvisible_closure());
      },
      get$asSassList: function() {
        var t1 = this.components;
        return D.SassList$(new H.MappedListIterable(t1, new D.SelectorList_asSassList_closure(), [H.getTypeArgumentByIndex(t1, 0), null]), C.ListSeparator_kWM, false);
      },
      SelectorList$1: function(components) {
        if (this.components.length === 0)
          throw H.wrapException(P.ArgumentError$("components may not be empty."));
      },
      accept$1: function(visitor) {
        return visitor.visitSelectorList$1(this);
      },
      unify$1: function(other) {
        var t1, contents;
        t1 = this.components;
        contents = P.List_List$from(new H.ExpandIterable(t1, new D.SelectorList_unify_closure(other), [H.getTypeArgumentByIndex(t1, 0), null]), true, null);
        return contents.length === 0 ? null : D.SelectorList$(contents);
      },
      resolveParentSelectors$2$implicitParent: function($parent, implicitParent) {
        var t1;
        if ($parent == null) {
          if (!C.JSArray_methods.any$1(this.components, this.get$_complexContainsParentSelector()))
            return this;
          throw H.wrapException(E.SassScriptException$('Top-level selectors may not contain the parent selector "&".'));
        }
        t1 = this.components;
        return D.SelectorList$(B.flattenVertically(new H.MappedListIterable(t1, new D.SelectorList_resolveParentSelectors_closure(this, implicitParent, $parent), [H.getTypeArgumentByIndex(t1, 0), null])));
      },
      resolveParentSelectors$1: function($parent) {
        return this.resolveParentSelectors$2$implicitParent($parent, true);
      },
      _complexContainsParentSelector$1: [function(complex) {
        return C.JSArray_methods.any$1(complex.get$components(), new D.SelectorList__complexContainsParentSelector_closure());
      }, "call$1", "get$_complexContainsParentSelector", 4, 0, 101],
      _resolveParentSelectorsCompound$2: function(compound, $parent) {
        var resolvedMembers, containsSelectorPseudo, resolvedMembers0, parentSelector, t1;
        resolvedMembers = compound.components;
        containsSelectorPseudo = C.JSArray_methods.any$1(resolvedMembers, new D.SelectorList__resolveParentSelectorsCompound_closure());
        if (!containsSelectorPseudo && !(C.JSArray_methods.get$first(resolvedMembers) instanceof M.ParentSelector))
          return;
        resolvedMembers0 = containsSelectorPseudo ? new H.MappedListIterable(resolvedMembers, new D.SelectorList__resolveParentSelectorsCompound_closure0($parent), [H.getTypeArgumentByIndex(resolvedMembers, 0), null]) : resolvedMembers;
        parentSelector = C.JSArray_methods.get$first(resolvedMembers);
        if (parentSelector instanceof M.ParentSelector) {
          if (resolvedMembers.length === 1 && parentSelector.suffix == null)
            return $parent.get$components();
        } else
          return [S.ComplexSelector$([X.CompoundSelector$(resolvedMembers0)], false)];
        t1 = $parent.get$components();
        return new H.MappedListIterable(t1, new D.SelectorList__resolveParentSelectorsCompound_closure1(compound, resolvedMembers0), [H.getTypeArgumentByIndex(t1, 0), null]);
      },
      isSuperselector$1: function(other) {
        return Y.listIsSuperslector(this.components, other.get$components());
      },
      get$hashCode: function(_) {
        return C.ListEquality_DefaultEquality.hash$1(this.components);
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        return other instanceof D.SelectorList && C.ListEquality_DefaultEquality.equals$2(this.components, other.components);
      },
      static: {
        SelectorList$: function(components) {
          var t1 = new D.SelectorList(P.List_List$unmodifiable(components, null));
          t1.SelectorList$1(components);
          return t1;
        }
      }
    },
    SelectorList_isInvisible_closure: {
      "^": "Closure:0;",
      call$1: function(complex) {
        return complex.get$isInvisible();
      }
    },
    SelectorList_asSassList_closure: {
      "^": "Closure:0;",
      call$1: [function(complex) {
        var t1 = complex.get$components();
        return D.SassList$(new H.MappedListIterable(t1, new D.SelectorList_asSassList__closure(), [H.getTypeArgumentByIndex(t1, 0), null]), C.ListSeparator_woc, false);
      }, null, null, 4, 0, null, 9, "call"]
    },
    SelectorList_asSassList__closure: {
      "^": "Closure:0;",
      call$1: [function(component) {
        return new D.SassString(J.toString$0$(component), false, null);
      }, null, null, 4, 0, null, 31, "call"]
    },
    SelectorList_unify_closure: {
      "^": "Closure:0;other",
      call$1: function(complex1) {
        var t1 = this.other.get$components();
        return new H.ExpandIterable(t1, new D.SelectorList_unify__closure(complex1), [H.getTypeArgumentByIndex(t1, 0), null]);
      }
    },
    SelectorList_unify__closure: {
      "^": "Closure:0;complex1",
      call$1: function(complex2) {
        var unified = Y.unifyComplex([this.complex1.get$components(), complex2.get$components()]);
        if (unified == null)
          return C.List_empty3;
        return J.map$1$ax(unified, new D.SelectorList_unify___closure());
      }
    },
    SelectorList_unify___closure: {
      "^": "Closure:0;",
      call$1: [function(complex) {
        return S.ComplexSelector$(complex, false);
      }, null, null, 4, 0, null, 9, "call"]
    },
    SelectorList_resolveParentSelectors_closure: {
      "^": "Closure:0;$this,implicitParent,parent",
      call$1: [function(complex) {
        var _box_0, t1, newComplexes, t2, t3, t4, t5, t6, _i, component, resolved, t7, _i0, previousLineBreaks, newComplexes0, t8, i, newComplex, i0, lineBreak, t9, t10, t11, resolvedComplex, t12;
        _box_0 = {};
        t1 = this.$this;
        if (!t1._complexContainsParentSelector$1(complex)) {
          if (!this.implicitParent)
            return [complex];
          t1 = this.parent.get$components();
          return new H.MappedListIterable(t1, new D.SelectorList_resolveParentSelectors__closure(complex), [H.getTypeArgumentByIndex(t1, 0), null]);
        }
        newComplexes = [H.setRuntimeTypeInfo([], [S.ComplexSelectorComponent])];
        t2 = [P.bool];
        _box_0.lineBreaks = H.setRuntimeTypeInfo([false], t2);
        for (t3 = complex.get$components(), t4 = t3.length, t5 = [[P.List, S.ComplexSelectorComponent]], t6 = this.parent, _i = 0; _i < t4; ++_i) {
          component = t3[_i];
          if (component instanceof X.CompoundSelector) {
            resolved = t1._resolveParentSelectorsCompound$2(component, t6);
            if (resolved == null) {
              for (t7 = newComplexes.length, _i0 = 0; _i0 < newComplexes.length; newComplexes.length === t7 || (0, H.throwConcurrentModificationError)(newComplexes), ++_i0)
                J.add$1$ax(newComplexes[_i0], component);
              continue;
            }
            previousLineBreaks = _box_0.lineBreaks;
            newComplexes0 = H.setRuntimeTypeInfo([], t5);
            _box_0.lineBreaks = H.setRuntimeTypeInfo([], t2);
            for (t7 = newComplexes.length, t8 = J.getInterceptor$ax(resolved), i = 0, _i0 = 0; _i0 < newComplexes.length; newComplexes.length === t7 || (0, H.throwConcurrentModificationError)(newComplexes), ++_i0, i = i0) {
              newComplex = newComplexes[_i0];
              i0 = i + 1;
              if (i >= previousLineBreaks.length)
                return H.ioore(previousLineBreaks, i);
              lineBreak = previousLineBreaks[i];
              for (t9 = t8.get$iterator(resolved), t10 = !lineBreak, t11 = J.getInterceptor$ax(newComplex); t9.moveNext$0();) {
                resolvedComplex = t9.get$current(t9);
                t12 = t11.toList$0(newComplex);
                C.JSArray_methods.addAll$1(t12, resolvedComplex.get$components());
                newComplexes0.push(t12);
                t12 = _box_0.lineBreaks;
                t12.push(!t10 || resolvedComplex.get$lineBreak());
              }
            }
            newComplexes = newComplexes0;
          } else
            for (t7 = newComplexes.length, _i0 = 0; _i0 < newComplexes.length; newComplexes.length === t7 || (0, H.throwConcurrentModificationError)(newComplexes), ++_i0)
              J.add$1$ax(newComplexes[_i0], component);
        }
        _box_0.i = 0;
        return new H.MappedListIterable(newComplexes, new D.SelectorList_resolveParentSelectors__closure0(_box_0), [H.getTypeArgumentByIndex(newComplexes, 0), null]);
      }, null, null, 4, 0, null, 9, "call"]
    },
    SelectorList_resolveParentSelectors__closure: {
      "^": "Closure:0;complex",
      call$1: [function(parentComplex) {
        var t1, t2;
        t1 = parentComplex.get$components();
        t1 = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
        t2 = this.complex;
        C.JSArray_methods.addAll$1(t1, t2.get$components());
        return S.ComplexSelector$(t1, t2.get$lineBreak() || parentComplex.get$lineBreak());
      }, null, null, 4, 0, null, 60, "call"]
    },
    SelectorList_resolveParentSelectors__closure0: {
      "^": "Closure:0;_box_0",
      call$1: [function(newComplex) {
        var t1, t2;
        t1 = this._box_0;
        t2 = t1.lineBreaks;
        t1 = t1.i++;
        if (t1 >= t2.length)
          return H.ioore(t2, t1);
        return S.ComplexSelector$(newComplex, t2[t1]);
      }, null, null, 4, 0, null, 61, "call"]
    },
    SelectorList__complexContainsParentSelector_closure: {
      "^": "Closure:0;",
      call$1: function(component) {
        return component instanceof X.CompoundSelector && C.JSArray_methods.any$1(component.components, new D.SelectorList__complexContainsParentSelector__closure());
      }
    },
    SelectorList__complexContainsParentSelector__closure: {
      "^": "Closure:0;",
      call$1: function(simple) {
        var t1 = J.getInterceptor(simple);
        if (!t1.$isParentSelector)
          if (!!t1.$isPseudoSelector) {
            t1 = simple.selector;
            t1 = t1 != null && C.JSArray_methods.any$1(t1.components, t1.get$_complexContainsParentSelector());
          } else
            t1 = false;
        else
          t1 = true;
        return t1;
      }
    },
    SelectorList__resolveParentSelectorsCompound_closure: {
      "^": "Closure:0;",
      call$1: function(simple) {
        var t1;
        if (simple instanceof D.PseudoSelector) {
          t1 = simple.selector;
          t1 = t1 != null && C.JSArray_methods.any$1(t1.components, t1.get$_complexContainsParentSelector());
        } else
          t1 = false;
        return t1;
      }
    },
    SelectorList__resolveParentSelectorsCompound_closure0: {
      "^": "Closure:0;parent",
      call$1: [function(simple) {
        var t1, t2, t3, t4;
        if (simple instanceof D.PseudoSelector) {
          t1 = simple.selector;
          if (t1 == null)
            return simple;
          if (!C.JSArray_methods.any$1(t1.components, t1.get$_complexContainsParentSelector()))
            return simple;
          t1 = t1.resolveParentSelectors$2$implicitParent(this.parent, false);
          t2 = simple.name;
          t3 = simple.isClass;
          t4 = simple.argument;
          return new D.PseudoSelector(t2, B.unvendor(t2), t3, t4, t1, null, null);
        } else
          return simple;
      }, null, null, 4, 0, null, 32, "call"]
    },
    SelectorList__resolveParentSelectorsCompound_closure1: {
      "^": "Closure:0;compound,resolvedMembers",
      call$1: [function(complex) {
        var lastComponent, suffix, t1, t2, last;
        lastComponent = C.JSArray_methods.get$last(complex.get$components());
        if (!(lastComponent instanceof X.CompoundSelector))
          throw H.wrapException(E.SassScriptException$('Parent "' + H.S(complex) + '" is incompatible with this selector.'));
        suffix = H.interceptedTypeCast(C.JSArray_methods.get$first(this.compound.components), "$isParentSelector").suffix;
        t1 = lastComponent.components;
        if (suffix != null) {
          t2 = H.SubListIterable$(t1, 0, t1.length - 1, H.getTypeArgumentByIndex(t1, 0)).toList$0(0);
          C.JSArray_methods.add$1(t2, C.JSArray_methods.get$last(t1).addSuffix$1(suffix));
          C.JSArray_methods.addAll$1(t2, J.skip$1$ax(this.resolvedMembers, 1));
          last = X.CompoundSelector$(t2);
        } else {
          t1 = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
          C.JSArray_methods.addAll$1(t1, J.skip$1$ax(this.resolvedMembers, 1));
          last = X.CompoundSelector$(t1);
        }
        t1 = complex.get$components();
        t1 = H.SubListIterable$(t1, 0, complex.get$components().length - 1, H.getTypeArgumentByIndex(t1, 0)).toList$0(0);
        C.JSArray_methods.add$1(t1, last);
        return S.ComplexSelector$(t1, complex.get$lineBreak());
      }, null, null, 4, 0, null, 9, "call"]
    }
  }], ["", "package:sass/src/ast/selector/parent.dart",, M, {
    "^": "",
    ParentSelector: {
      "^": "SimpleSelector;suffix",
      accept$1: function(visitor) {
        return visitor.visitParentSelector$1(this);
      },
      unify$1: function(compound) {
        return H.throwExpression(P.UnsupportedError$("& doesn't support unification."));
      }
    }
  }], ["", "package:sass/src/ast/selector/placeholder.dart",, N, {
    "^": "",
    PlaceholderSelector: {
      "^": "SimpleSelector;name<",
      get$isInvisible: function() {
        return true;
      },
      accept$1: function(visitor) {
        return visitor.visitPlaceholderSelector$1(this);
      },
      addSuffix$1: function(suffix) {
        return new N.PlaceholderSelector(this.name + suffix);
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        return other instanceof N.PlaceholderSelector && other.name === this.name;
      },
      get$hashCode: function(_) {
        return C.JSString_methods.get$hashCode(this.name);
      }
    }
  }], ["", "package:sass/src/ast/selector/pseudo.dart",, D, {
    "^": "",
    PseudoSelector: {
      "^": "SimpleSelector;name<,normalizedName,isClass,argument,selector<,_pseudo$_minSpecificity,_pseudo$_maxSpecificity",
      get$minSpecificity: function() {
        if (this._pseudo$_minSpecificity == null)
          this._pseudo$_computeSpecificity$0();
        return this._pseudo$_minSpecificity;
      },
      get$maxSpecificity: function() {
        if (this._pseudo$_maxSpecificity == null)
          this._pseudo$_computeSpecificity$0();
        return this._pseudo$_maxSpecificity;
      },
      get$isInvisible: function() {
        var t1 = this.selector;
        if (t1 == null)
          return false;
        return this.name !== "not" && t1.get$isInvisible();
      },
      addSuffix$1: function(suffix) {
        var t1;
        if (this.argument != null || this.selector != null)
          this.super$SimpleSelector$addSuffix(suffix);
        t1 = this.name + suffix;
        return new D.PseudoSelector(t1, B.unvendor(t1), this.isClass, null, null, null, null);
      },
      unify$1: function(compound) {
        var t1, result, t2, addedThis, simple;
        t1 = J.getInterceptor$asx(compound);
        if (J.$eq$(t1.get$length(compound), 1) === true && t1.get$first(compound) instanceof N.UniversalSelector)
          return t1.get$first(compound).unify$1([this]);
        if (t1.contains$1(compound, this) === true)
          return compound;
        result = H.setRuntimeTypeInfo([], [M.SimpleSelector]);
        for (t1 = t1.get$iterator(compound), t2 = !this.isClass, addedThis = false; t1.moveNext$0();) {
          simple = t1.get$current(t1);
          if (simple instanceof D.PseudoSelector && !simple.isClass) {
            if (t2)
              return;
            result.push(this);
            addedThis = true;
          }
          result.push(simple);
        }
        if (!addedThis)
          result.push(this);
        return result;
      },
      _pseudo$_computeSpecificity$0: function() {
        var t1, t2, _i, complex, t3, t4;
        if (!this.isClass) {
          this._pseudo$_minSpecificity = 1;
          this._pseudo$_maxSpecificity = 1;
          return;
        }
        t1 = this.selector;
        if (t1 == null) {
          this._pseudo$_minSpecificity = M.SimpleSelector.prototype.get$minSpecificity.call(this);
          this._pseudo$_maxSpecificity = M.SimpleSelector.prototype.get$maxSpecificity.call(this);
          return;
        }
        if (this.name === "not") {
          this._pseudo$_minSpecificity = 0;
          this._pseudo$_maxSpecificity = 0;
          for (t1 = t1.components, t2 = t1.length, _i = 0; _i < t2; ++_i) {
            complex = t1[_i];
            t3 = this._pseudo$_minSpecificity;
            t4 = complex.get$minSpecificity();
            this._pseudo$_minSpecificity = Math.max(H.checkNum(t3), H.checkNum(t4));
            t4 = this._pseudo$_maxSpecificity;
            t3 = complex.get$maxSpecificity();
            this._pseudo$_maxSpecificity = Math.max(H.checkNum(t4), H.checkNum(t3));
          }
        } else {
          this._pseudo$_minSpecificity = H.intTypeCast(Math.pow(M.SimpleSelector.prototype.get$minSpecificity.call(this), 3));
          this._pseudo$_maxSpecificity = 0;
          for (t1 = t1.components, t2 = t1.length, _i = 0; _i < t2; ++_i) {
            complex = t1[_i];
            t3 = this._pseudo$_minSpecificity;
            t4 = complex.get$minSpecificity();
            this._pseudo$_minSpecificity = Math.min(H.checkNum(t3), H.checkNum(t4));
            t4 = this._pseudo$_maxSpecificity;
            t3 = complex.get$maxSpecificity();
            this._pseudo$_maxSpecificity = Math.max(H.checkNum(t4), H.checkNum(t3));
          }
        }
      },
      accept$1: function(visitor) {
        return visitor.visitPseudoSelector$1(this);
      },
      $eq: function(_, other) {
        var t1, t2;
        if (other == null)
          return false;
        if (other instanceof D.PseudoSelector)
          if (other.name === this.name)
            if (other.isClass === this.isClass) {
              t1 = other.argument;
              t2 = this.argument;
              t1 = (t1 == null ? t2 == null : t1 === t2) && J.$eq$(other.selector, this.selector);
            } else
              t1 = false;
          else
            t1 = false;
        else
          t1 = false;
        return t1;
      },
      get$hashCode: function(_) {
        return (C.JSString_methods.get$hashCode(this.name) ^ C.JSBool_methods.get$hashCode(!this.isClass) ^ J.get$hashCode$(this.argument) ^ J.get$hashCode$(this.selector)) >>> 0;
      }
    }
  }], ["", "package:sass/src/ast/selector/qualified_name.dart",, D, {
    "^": "",
    QualifiedName: {
      "^": "Object;name<,namespace",
      $eq: function(_, other) {
        var t1, t2;
        if (other == null)
          return false;
        if (other instanceof D.QualifiedName)
          if (other.name === this.name) {
            t1 = other.namespace;
            t2 = this.namespace;
            t2 = t1 == null ? t2 == null : t1 === t2;
            t1 = t2;
          } else
            t1 = false;
        else
          t1 = false;
        return t1;
      },
      get$hashCode: function(_) {
        return C.JSString_methods.get$hashCode(this.name) ^ J.get$hashCode$(this.namespace);
      },
      toString$0: function(_) {
        var t1, t2;
        t1 = this.namespace;
        t2 = this.name;
        return t1 == null ? t2 : t1 + "|" + t2;
      }
    }
  }], ["", "package:sass/src/ast/selector/simple.dart",, M, {
    "^": "",
    SimpleSelector: {
      "^": "Selector;",
      get$minSpecificity: function() {
        return 1000;
      },
      get$maxSpecificity: function() {
        return this.get$minSpecificity();
      },
      addSuffix$1: ["super$SimpleSelector$addSuffix", function(suffix) {
        return H.throwExpression(E.SassScriptException$('Invalid parent selector "' + this.toString$0(0) + '"'));
      }],
      unify$1: ["super$SimpleSelector$unify", function(compound) {
        var t1, result, addedThis, simple;
        t1 = J.getInterceptor$asx(compound);
        if (J.$eq$(t1.get$length(compound), 1) === true && t1.get$first(compound) instanceof N.UniversalSelector)
          return t1.get$first(compound).unify$1([this]);
        if (t1.contains$1(compound, this) === true)
          return compound;
        result = H.setRuntimeTypeInfo([], [M.SimpleSelector]);
        for (t1 = t1.get$iterator(compound), addedThis = false; t1.moveNext$0();) {
          simple = t1.get$current(t1);
          if (!addedThis && simple instanceof D.PseudoSelector) {
            result.push(this);
            addedThis = true;
          }
          result.push(simple);
        }
        if (!addedThis)
          result.push(this);
        return result;
      }]
    }
  }], ["", "package:sass/src/ast/selector/type.dart",, F, {
    "^": "",
    TypeSelector: {
      "^": "SimpleSelector;name<",
      get$minSpecificity: function() {
        return 1;
      },
      accept$1: function(visitor) {
        return visitor.visitTypeSelector$1(this);
      },
      addSuffix$1: function(suffix) {
        var t1 = this.name;
        return new F.TypeSelector(new D.QualifiedName(t1.name + suffix, t1.namespace));
      },
      unify$1: function(compound) {
        var t1, unified, t2;
        t1 = J.getInterceptor$ax(compound);
        if (t1.get$first(compound) instanceof N.UniversalSelector || t1.get$first(compound) instanceof F.TypeSelector) {
          unified = Y.unifyUniversalAndElement(this, t1.get$first(compound));
          if (unified == null)
            return;
          t2 = [unified];
          C.JSArray_methods.addAll$1(t2, t1.skip$1(compound, 1));
          return t2;
        } else {
          t1 = H.setRuntimeTypeInfo([this], [M.SimpleSelector]);
          C.JSArray_methods.addAll$1(t1, compound);
          return t1;
        }
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        return other instanceof F.TypeSelector && other.name.$eq(0, this.name);
      },
      get$hashCode: function(_) {
        var t1 = this.name;
        return C.JSString_methods.get$hashCode(t1.name) ^ J.get$hashCode$(t1.namespace);
      }
    }
  }], ["", "package:sass/src/ast/selector/universal.dart",, N, {
    "^": "",
    UniversalSelector: {
      "^": "SimpleSelector;namespace",
      get$minSpecificity: function() {
        return 0;
      },
      accept$1: function(visitor) {
        return visitor.visitUniversalSelector$1(this);
      },
      unify$1: function(compound) {
        var t1, unified, t2;
        t1 = J.getInterceptor$ax(compound);
        if (t1.get$first(compound) instanceof N.UniversalSelector || t1.get$first(compound) instanceof F.TypeSelector) {
          unified = Y.unifyUniversalAndElement(this, t1.get$first(compound));
          if (unified == null)
            return;
          t2 = [unified];
          C.JSArray_methods.addAll$1(t2, t1.skip$1(compound, 1));
          return t2;
        }
        t2 = this.namespace;
        if (t2 != null && t2 !== "*") {
          t1 = H.setRuntimeTypeInfo([this], [M.SimpleSelector]);
          C.JSArray_methods.addAll$1(t1, compound);
          return t1;
        }
        if (t1.get$isNotEmpty(compound))
          return compound;
        return [this];
      },
      $eq: function(_, other) {
        var t1, t2;
        if (other == null)
          return false;
        if (other instanceof N.UniversalSelector) {
          t1 = other.namespace;
          t2 = this.namespace;
          t2 = t1 == null ? t2 == null : t1 === t2;
          t1 = t2;
        } else
          t1 = false;
        return t1;
      },
      get$hashCode: function(_) {
        return J.get$hashCode$(this.namespace);
      }
    }
  }], ["", "package:sass/src/async_environment.dart",, Q, {
    "^": "",
    AsyncEnvironment: {
      "^": "Object;_async_environment$_variables,_async_environment$_variableSpans,_async_environment$_variableIndices,_async_environment$_functions,_async_environment$_functionIndices,_async_environment$_mixins,_async_environment$_mixinIndices,_async_environment$_contentBlock,_async_environment$_contentEnvironment,_async_environment$_inMixin,_async_environment$_inSemiGlobalScope,_async_environment$_lastVariableName,_async_environment$_lastVariableIndex",
      get$contentBlock: function() {
        return this._async_environment$_contentBlock;
      },
      get$contentEnvironment: function() {
        return this._async_environment$_contentEnvironment;
      },
      get$inMixin: function() {
        return this._async_environment$_inMixin;
      },
      closure$0: function() {
        var t1, t2, t3, t4;
        t1 = this._async_environment$_variables;
        t1 = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
        t2 = this._async_environment$_variableSpans;
        if (t2 == null)
          t2 = null;
        else
          t2 = H.setRuntimeTypeInfo(t2.slice(0), [H.getTypeArgumentByIndex(t2, 0)]);
        t3 = this._async_environment$_functions;
        t3 = H.setRuntimeTypeInfo(t3.slice(0), [H.getTypeArgumentByIndex(t3, 0)]);
        t4 = this._async_environment$_mixins;
        t4 = H.setRuntimeTypeInfo(t4.slice(0), [H.getTypeArgumentByIndex(t4, 0)]);
        return Q.AsyncEnvironment$_(t1, t2, t3, t4, this._async_environment$_contentBlock, this._async_environment$_contentEnvironment);
      },
      global$0: function() {
        var t1, t2;
        t1 = C.JSArray_methods.get$first(this._async_environment$_variables);
        t2 = this._async_environment$_variableSpans;
        t2 = t2 == null ? null : [C.JSArray_methods.get$first(t2)];
        return Q.AsyncEnvironment$_([t1], t2, [C.JSArray_methods.get$first(this._async_environment$_functions)], [C.JSArray_methods.get$first(this._async_environment$_mixins)], null, null);
      },
      getVariable$1: function($name) {
        var t1, t2, index;
        if (J.$eq$(this._async_environment$_lastVariableName, $name) === true) {
          t1 = this._async_environment$_variables;
          t2 = this._async_environment$_lastVariableIndex;
          if (t2 >>> 0 !== t2 || t2 >= t1.length)
            return H.ioore(t1, t2);
          return J.$index$asx(t1[t2], $name);
        }
        t1 = this._async_environment$_variableIndices;
        index = t1.$index(0, $name);
        if (index != null) {
          this._async_environment$_lastVariableName = $name;
          this._async_environment$_lastVariableIndex = index;
          t1 = this._async_environment$_variables;
          if (index >>> 0 !== index || index >= t1.length)
            return H.ioore(t1, index);
          return J.$index$asx(t1[index], $name);
        }
        index = this._async_environment$_variableIndex$1($name);
        if (index == null)
          return;
        this._async_environment$_lastVariableName = $name;
        this._async_environment$_lastVariableIndex = index;
        t1.$indexSet(0, $name, index);
        t1 = this._async_environment$_variables;
        if (index >>> 0 !== index || index >= t1.length)
          return H.ioore(t1, index);
        return J.$index$asx(t1[index], $name);
      },
      getVariableSpan$1: function($name) {
        var t1, t2, index;
        if (J.$eq$(this._async_environment$_lastVariableName, $name) === true) {
          t1 = this._async_environment$_variableSpans;
          t2 = this._async_environment$_lastVariableIndex;
          if (t2 >>> 0 !== t2 || t2 >= t1.length)
            return H.ioore(t1, t2);
          return J.$index$asx(t1[t2], $name);
        }
        t1 = this._async_environment$_variableIndices;
        index = t1.$index(0, $name);
        if (index != null) {
          this._async_environment$_lastVariableName = $name;
          this._async_environment$_lastVariableIndex = index;
          t1 = this._async_environment$_variableSpans;
          if (index >>> 0 !== index || index >= t1.length)
            return H.ioore(t1, index);
          return J.$index$asx(t1[index], $name);
        }
        index = this._async_environment$_variableIndex$1($name);
        if (index == null)
          return;
        this._async_environment$_lastVariableName = $name;
        this._async_environment$_lastVariableIndex = index;
        t1.$indexSet(0, $name, index);
        t1 = this._async_environment$_variableSpans;
        if (index >>> 0 !== index || index >= t1.length)
          return H.ioore(t1, index);
        return J.$index$asx(t1[index], $name);
      },
      variableExists$1: function($name) {
        return this.getVariable$1($name) != null;
      },
      globalVariableExists$1: function($name) {
        return C.JSArray_methods.get$first(this._async_environment$_variables).containsKey$1($name);
      },
      _async_environment$_variableIndex$1: function($name) {
        var t1, i;
        for (t1 = this._async_environment$_variables, i = t1.length - 1; i >= 0; --i) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          if (t1[i].containsKey$1($name) === true)
            return i;
        }
        return;
      },
      setVariable$4$global: function($name, value, span, global) {
        var t1, index;
        if (global || this._async_environment$_variables.length === 1) {
          this._async_environment$_variableIndices.putIfAbsent$2($name, new Q.AsyncEnvironment_setVariable_closure(this, $name));
          J.$indexSet$ax(C.JSArray_methods.get$first(this._async_environment$_variables), $name, value);
          t1 = this._async_environment$_variableSpans;
          if (t1 != null)
            J.$indexSet$ax(C.JSArray_methods.get$first(t1), $name, span);
          return;
        }
        index = J.$eq$(this._async_environment$_lastVariableName, $name) === true ? this._async_environment$_lastVariableIndex : this._async_environment$_variableIndices.putIfAbsent$2($name, new Q.AsyncEnvironment_setVariable_closure0(this, $name));
        if (!this._async_environment$_inSemiGlobalScope && J.$eq$(index, 0) === true) {
          index = this._async_environment$_variables.length - 1;
          this._async_environment$_variableIndices.$indexSet(0, $name, index);
        }
        this._async_environment$_lastVariableName = $name;
        this._async_environment$_lastVariableIndex = index;
        t1 = this._async_environment$_variables;
        if (index >>> 0 !== index || index >= t1.length)
          return H.ioore(t1, index);
        J.$indexSet$ax(t1[index], $name, value);
        t1 = this._async_environment$_variableSpans;
        if (t1 != null) {
          if (index >= t1.length)
            return H.ioore(t1, index);
          J.$indexSet$ax(t1[index], $name, span);
        }
      },
      setLocalVariable$3: function($name, value, span) {
        var t1, index;
        t1 = this._async_environment$_variables;
        index = t1.length - 1;
        this._async_environment$_lastVariableName = $name;
        this._async_environment$_lastVariableIndex = index;
        this._async_environment$_variableIndices.$indexSet(0, $name, index);
        if (index < 0 || index >= t1.length)
          return H.ioore(t1, index);
        J.$indexSet$ax(t1[index], $name, value);
        t1 = this._async_environment$_variableSpans;
        if (t1 != null) {
          if (index >= t1.length)
            return H.ioore(t1, index);
          J.$indexSet$ax(t1[index], $name, span);
        }
      },
      getFunction$1: function($name) {
        var t1, index;
        t1 = this._async_environment$_functionIndices;
        index = t1.$index(0, $name);
        if (index != null) {
          t1 = this._async_environment$_functions;
          if (index >>> 0 !== index || index >= t1.length)
            return H.ioore(t1, index);
          return J.$index$asx(t1[index], $name);
        }
        index = this._async_environment$_functionIndex$1($name);
        if (index == null)
          return;
        t1.$indexSet(0, $name, index);
        t1 = this._async_environment$_functions;
        if (index >>> 0 !== index || index >= t1.length)
          return H.ioore(t1, index);
        return J.$index$asx(t1[index], $name);
      },
      _async_environment$_functionIndex$1: function($name) {
        var t1, i;
        for (t1 = this._async_environment$_functions, i = t1.length - 1; i >= 0; --i) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          if (t1[i].containsKey$1($name) === true)
            return i;
        }
        return;
      },
      functionExists$1: function($name) {
        return this.getFunction$1($name) != null;
      },
      setFunction$1: [function(callable) {
        var t1, index;
        t1 = this._async_environment$_functions;
        index = t1.length - 1;
        this._async_environment$_functionIndices.$indexSet(0, callable.get$name(), index);
        if (index < 0 || index >= t1.length)
          return H.ioore(t1, index);
        J.$indexSet$ax(t1[index], callable.get$name(), callable);
      }, "call$1", "get$setFunction", 4, 0, 61],
      getMixin$1: function($name) {
        var t1, index;
        t1 = this._async_environment$_mixinIndices;
        index = t1.$index(0, $name);
        if (index != null) {
          t1 = this._async_environment$_mixins;
          if (index >>> 0 !== index || index >= t1.length)
            return H.ioore(t1, index);
          return J.$index$asx(t1[index], $name);
        }
        index = this._async_environment$_mixinIndex$1($name);
        if (index == null)
          return;
        t1.$indexSet(0, $name, index);
        t1 = this._async_environment$_mixins;
        if (index >>> 0 !== index || index >= t1.length)
          return H.ioore(t1, index);
        return J.$index$asx(t1[index], $name);
      },
      _async_environment$_mixinIndex$1: function($name) {
        var t1, i;
        for (t1 = this._async_environment$_mixins, i = t1.length - 1; i >= 0; --i) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          if (t1[i].containsKey$1($name) === true)
            return i;
        }
        return;
      },
      mixinExists$1: function($name) {
        return this.getMixin$1($name) != null;
      },
      setMixin$1: function(callable) {
        var t1, index, t2;
        t1 = this._async_environment$_mixins;
        index = t1.length - 1;
        t2 = callable.declaration.name;
        this._async_environment$_mixinIndices.$indexSet(0, t2, index);
        if (index < 0 || index >= t1.length)
          return H.ioore(t1, index);
        J.$indexSet$ax(t1[index], t2, callable);
      },
      withContent$3: function(block, environment, callback) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, oldBlock, oldEnvironment;
        var $async$withContent$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                oldBlock = $async$self._async_environment$_contentBlock;
                oldEnvironment = $async$self._async_environment$_contentEnvironment;
                $async$self._async_environment$_contentBlock = block;
                $async$self._async_environment$_contentEnvironment = environment;
                $async$goto = 2;
                return P._asyncAwait(callback.call$0(), $async$withContent$3);
              case 2:
                // returning from await.
                $async$self._async_environment$_contentBlock = oldBlock;
                $async$self._async_environment$_contentEnvironment = oldEnvironment;
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$withContent$3, $async$completer);
      },
      asMixin$1: function(callback) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, oldInMixin;
        var $async$asMixin$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                oldInMixin = $async$self._async_environment$_inMixin;
                $async$self._async_environment$_inMixin = true;
                $async$goto = 2;
                return P._asyncAwait(callback.call$0(), $async$asMixin$1);
              case 2:
                // returning from await.
                $async$self._async_environment$_inMixin = oldInMixin;
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$asMixin$1, $async$completer);
      },
      scope$3$semiGlobal$when: function(callback, semiGlobal, when) {
        return this.scope$body$AsyncEnvironment(callback, semiGlobal, when);
      },
      scope$1: function(callback) {
        return this.scope$3$semiGlobal$when(callback, false, true);
      },
      scope$2$when: function(callback, when) {
        return this.scope$3$semiGlobal$when(callback, false, when);
      },
      scope$2$semiGlobal: function(callback, semiGlobal) {
        return this.scope$3$semiGlobal$when(callback, semiGlobal, true);
      },
      scope$body$AsyncEnvironment: function(callback, semiGlobal, when) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, wasInSemiGlobalScope, wasInSemiGlobalScope0, $name, name0, name1, t1, t2, t3, t4;
        var $async$scope$3$semiGlobal$when = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = !when ? 3 : 4;
                break;
              case 3:
                // then
                wasInSemiGlobalScope = $async$self._async_environment$_inSemiGlobalScope;
                $async$self._async_environment$_inSemiGlobalScope = semiGlobal;
                $async$handler = 5;
                $async$goto = 8;
                return P._asyncAwait(callback.call$0(), $async$scope$3$semiGlobal$when);
              case 8:
                // returning from await.
                t1 = $async$result;
                $async$returnValue = t1;
                $async$next = [1];
                // goto finally
                $async$goto = 6;
                break;
                $async$next.push(7);
                // goto finally
                $async$goto = 6;
                break;
              case 5:
                // uncaught
                $async$next = [2];
              case 6:
                // finally
                $async$handler = 2;
                $async$self._async_environment$_inSemiGlobalScope = wasInSemiGlobalScope;
                // goto the next finally handler
                $async$goto = $async$next.pop();
                break;
              case 7:
                // after finally
              case 4:
                // join
                semiGlobal = semiGlobal && $async$self._async_environment$_inSemiGlobalScope;
                wasInSemiGlobalScope0 = $async$self._async_environment$_inSemiGlobalScope;
                $async$self._async_environment$_inSemiGlobalScope = semiGlobal;
                t1 = $async$self._async_environment$_variables;
                C.JSArray_methods.add$1(t1, B.normalizedMap(null));
                t2 = $async$self._async_environment$_variableSpans;
                if (!(t2 == null))
                  C.JSArray_methods.add$1(t2, B.normalizedMap(null));
                t2 = $async$self._async_environment$_functions;
                C.JSArray_methods.add$1(t2, B.normalizedMap(null));
                t3 = $async$self._async_environment$_mixins;
                C.JSArray_methods.add$1(t3, B.normalizedMap(null));
                $async$handler = 9;
                $async$goto = 12;
                return P._asyncAwait(callback.call$0(), $async$scope$3$semiGlobal$when);
              case 12:
                // returning from await.
                t4 = $async$result;
                $async$returnValue = t4;
                $async$next = [1];
                // goto finally
                $async$goto = 10;
                break;
                $async$next.push(11);
                // goto finally
                $async$goto = 10;
                break;
              case 9:
                // uncaught
                $async$next = [2];
              case 10:
                // finally
                $async$handler = 2;
                $async$self._async_environment$_inSemiGlobalScope = wasInSemiGlobalScope0;
                $async$self._async_environment$_lastVariableName = null;
                $async$self._async_environment$_lastVariableIndex = null;
                for (t1 = C.JSArray_methods.removeLast$0(t1).get$keys(), t1 = t1.get$iterator(t1), t4 = $async$self._async_environment$_variableIndices; t1.moveNext$0();) {
                  $name = t1.get$current(t1);
                  t4.remove$1(0, $name);
                }
                for (t1 = C.JSArray_methods.removeLast$0(t2).get$keys(), t1 = t1.get$iterator(t1), t2 = $async$self._async_environment$_functionIndices; t1.moveNext$0();) {
                  name0 = t1.get$current(t1);
                  t2.remove$1(0, name0);
                }
                for (t1 = C.JSArray_methods.removeLast$0(t3).get$keys(), t1 = t1.get$iterator(t1), t2 = $async$self._async_environment$_mixinIndices; t1.moveNext$0();) {
                  name1 = t1.get$current(t1);
                  t2.remove$1(0, name1);
                }
                // goto the next finally handler
                $async$goto = $async$next.pop();
                break;
              case 11:
                // after finally
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
              case 2:
                // rethrow
                return P._asyncRethrow($async$currentError, $async$completer);
            }
        });
        return P._asyncStartSync($async$scope$3$semiGlobal$when, $async$completer);
      },
      static: {
        AsyncEnvironment$_: function(_variables, _variableSpans, _functions, _mixins, _contentBlock, _contentEnvironment) {
          return new Q.AsyncEnvironment(_variables, _variableSpans, B.normalizedMap(null), _functions, B.normalizedMap(null), _mixins, B.normalizedMap(null), _contentBlock, _contentEnvironment, false, true, null, null);
        }
      }
    },
    AsyncEnvironment_setVariable_closure: {
      "^": "Closure:1;$this,name",
      call$0: function() {
        var t1 = this.$this;
        t1._async_environment$_lastVariableName = this.name;
        t1._async_environment$_lastVariableIndex = 0;
        return 0;
      }
    },
    AsyncEnvironment_setVariable_closure0: {
      "^": "Closure:1;$this,name",
      call$0: function() {
        var t1, t2;
        t1 = this.$this;
        t2 = t1._async_environment$_variableIndex$1(this.name);
        return t2 == null ? t1._async_environment$_variables.length - 1 : t2;
      }
    }
  }], ["", "package:sass/src/async_import_cache.dart",, O, {
    "^": "",
    AsyncImportCache: {
      "^": "Object;_async_import_cache$_importers,_async_import_cache$_logger,_async_import_cache$_canonicalizeCache,_async_import_cache$_importCache",
      canonicalize$3: function(url, baseImporter, baseUrl) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter([S.Tuple2, B.AsyncImporter, P.Uri]), $async$returnValue, $async$self = this, canonicalUrl;
        var $async$canonicalize$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = baseImporter != null ? 3 : 4;
                break;
              case 3:
                // then
                $async$goto = 5;
                return P._asyncAwait(baseImporter.canonicalize$1(baseUrl != null ? baseUrl.resolveUri$1(url) : url), $async$canonicalize$3);
              case 5:
                // returning from await.
                canonicalUrl = $async$result;
                if (canonicalUrl != null) {
                  $async$returnValue = new S.Tuple2(baseImporter, canonicalUrl, [null, null]);
                  // goto return
                  $async$goto = 1;
                  break;
                }
              case 4:
                // join
                $async$goto = 6;
                return P._asyncAwait(B.putIfAbsentAsync($async$self._async_import_cache$_canonicalizeCache, url, new O.AsyncImportCache_canonicalize_closure($async$self, url)), $async$canonicalize$3);
              case 6:
                // returning from await.
                $async$returnValue = $async$result;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$canonicalize$3, $async$completer);
      },
      canonicalize$1: function(url) {
        return this.canonicalize$3(url, null, null);
      },
      import$3: function(url, baseImporter, baseUrl) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter([S.Tuple2, B.AsyncImporter, V.Stylesheet]), $async$returnValue, $async$self = this, tuple, t1, t2, stylesheet;
        var $async$import$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 3;
                return P._asyncAwait($async$self.canonicalize$3(url, baseImporter, baseUrl), $async$import$3);
              case 3:
                // returning from await.
                tuple = $async$result;
                if (tuple == null) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t1 = tuple.get$item1();
                t2 = tuple.get$item2();
                $async$goto = 4;
                return P._asyncAwait($async$self.importCanonical$3(t1, t2, baseUrl != null ? baseUrl.resolveUri$1(url) : url), $async$import$3);
              case 4:
                // returning from await.
                stylesheet = $async$result;
                $async$returnValue = new S.Tuple2(tuple.get$item1(), stylesheet, [null, null]);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$import$3, $async$completer);
      },
      importCanonical$3: function(importer, canonicalUrl, originalUrl) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(V.Stylesheet), $async$returnValue, $async$self = this;
        var $async$importCanonical$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 3;
                return P._asyncAwait(B.putIfAbsentAsync($async$self._async_import_cache$_importCache, canonicalUrl, new O.AsyncImportCache_importCanonical_closure($async$self, importer, canonicalUrl, originalUrl)), $async$importCanonical$3);
              case 3:
                // returning from await.
                $async$returnValue = $async$result;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$importCanonical$3, $async$completer);
      },
      static: {
        AsyncImportCache$: function(importers, loadPaths, logger, packageResolver) {
          var t1, t2;
          t1 = O.AsyncImportCache__toImporters(importers, loadPaths, packageResolver);
          t2 = logger == null ? C.StderrLogger_false : logger;
          return new O.AsyncImportCache(t1, t2, P.LinkedHashMap__makeEmpty(), P.LinkedHashMap__makeEmpty());
        },
        AsyncImportCache__toImporters: function(importers, loadPaths, packageResolver) {
          var list, t1;
          if (importers == null)
            list = null;
          else {
            t1 = H.setRuntimeTypeInfo(importers.slice(0), [H.getTypeArgumentByIndex(importers, 0)]);
            list = t1;
          }
          if (list == null)
            list = [];
          if (loadPaths != null)
            C.JSArray_methods.addAll$1(list, J.map$1$ax(loadPaths, new O.AsyncImportCache__toImporters_closure()));
          return list;
        }
      }
    },
    AsyncImportCache__toImporters_closure: {
      "^": "Closure:0;",
      call$1: [function(path) {
        return new F.FilesystemImporter(path);
      }, null, null, 4, 0, null, 6, "call"]
    },
    AsyncImportCache_canonicalize_closure: {
      "^": "Closure:4;$this,url",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$self = this, t1, t2, t3, _i, importer, canonicalUrl;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this._async_import_cache$_importers, t2 = t1.length, t3 = $async$self.url, _i = 0;
              case 3:
                // for condition
                if (!(_i < t1.length)) {
                  // goto after for
                  $async$goto = 5;
                  break;
                }
                importer = t1[_i];
                $async$goto = 6;
                return P._asyncAwait(importer.canonicalize$1(t3), $async$call$0);
              case 6:
                // returning from await.
                canonicalUrl = $async$result;
                if (canonicalUrl != null) {
                  $async$returnValue = new S.Tuple2(importer, canonicalUrl, [null, null]);
                  // goto return
                  $async$goto = 1;
                  break;
                }
              case 4:
                // for update
                t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i;
                // goto for condition
                $async$goto = 3;
                break;
              case 5:
                // after for
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    AsyncImportCache_importCanonical_closure: {
      "^": "Closure:4;$this,importer,canonicalUrl,originalUrl",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$self = this, displayUrl, result, t1, t2, t3, t4, t5, t6;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                displayUrl = $async$self.canonicalUrl;
                $async$goto = 3;
                return P._asyncAwait($async$self.importer.load$1(displayUrl), $async$call$0);
              case 3:
                // returning from await.
                result = $async$result;
                if (result == null) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t1 = $async$self.originalUrl;
                if (!(t1 == null)) {
                  t2 = $.$get$url();
                  displayUrl = t1.resolve$1(X.ParsedPath_ParsedPath$parse(J.get$path$x(displayUrl), t2.style).get$basename());
                }
                t1 = J.getInterceptor$x(result);
                t2 = $async$self.$this._async_import_cache$_logger;
                t3 = [P.int];
                if (result.get$isIndented() === true) {
                  t1 = t1.get$contents(result);
                  t4 = J.get$codeUnits$s(t1);
                  t3 = H.setRuntimeTypeInfo([0], t3);
                  t5 = typeof displayUrl === "string";
                  t6 = t5 ? P.Uri_parse(displayUrl, 0, null) : displayUrl;
                  t3 = new Y.SourceFile(t6, t3, new Uint32Array(H._ensureNativeList(t4.toList$0(t4))), null);
                  t3.SourceFile$decoded$2$url(t4, displayUrl);
                  t4 = t5 ? P.Uri_parse(displayUrl, 0, null) : displayUrl;
                  t1 = new U.SassParser(0, null, null, null, false, null, false, false, false, false, false, new S.SpanScanner(t3, null, t4, t1, 0, null, null), t2).parse$0();
                } else {
                  t1 = t1.get$contents(result);
                  t4 = J.get$codeUnits$s(t1);
                  t3 = H.setRuntimeTypeInfo([0], t3);
                  t5 = typeof displayUrl === "string";
                  t6 = t5 ? P.Uri_parse(displayUrl, 0, null) : displayUrl;
                  t3 = new Y.SourceFile(t6, t3, new Uint32Array(H._ensureNativeList(t4.toList$0(t4))), null);
                  t3.SourceFile$decoded$2$url(t4, displayUrl);
                  t4 = t5 ? P.Uri_parse(displayUrl, 0, null) : displayUrl;
                  t1 = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t3, null, t4, t1, 0, null, null), t2).parse$0();
                }
                $async$returnValue = t1;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    }
  }], ["", "package:sass/src/callable.dart",, D, {
    "^": "",
    Callable: {
      "^": "AsyncCallable;"
    }
  }], ["", "package:sass/src/callable/async.dart",, B, {
    "^": "",
    AsyncCallable: {
      "^": "Object;"
    }
  }], ["", "package:sass/src/callable/async_built_in.dart",, S, {
    "^": "",
    AsyncBuiltInCallable: {
      "^": "Object;name<,_async_built_in$_overloads",
      AsyncBuiltInCallable$parsed$3: function($name, $arguments, callback) {
        this._async_built_in$_overloads.push(new S.Tuple2($arguments, callback, [null, null]));
      },
      callbackFor$2: function(positional, names) {
        var t1 = this._async_built_in$_overloads;
        return H.SubListIterable$(t1, 0, t1.length - 1, H.getTypeArgumentByIndex(t1, 0)).firstWhere$2$orElse(0, new S.AsyncBuiltInCallable_callbackFor_closure(positional, names), new S.AsyncBuiltInCallable_callbackFor_closure0(this));
      },
      $isAsyncCallable: 1,
      static: {
        AsyncBuiltInCallable$parsed: function($name, $arguments, callback) {
          var t1 = new S.AsyncBuiltInCallable($name, H.setRuntimeTypeInfo([], [[S.Tuple2, B.ArgumentDeclaration, {func: 1, args: [[P.List, F.Value]]}]]));
          t1.AsyncBuiltInCallable$parsed$3($name, $arguments, callback);
          return t1;
        }
      }
    },
    AsyncBuiltInCallable_callbackFor_closure: {
      "^": "Closure:0;positional,names",
      call$1: function(overload) {
        return overload.get$item1().matches$2(this.positional, this.names);
      }
    },
    AsyncBuiltInCallable_callbackFor_closure0: {
      "^": "Closure:1;$this",
      call$0: function() {
        return C.JSArray_methods.get$last(this.$this._async_built_in$_overloads);
      }
    }
  }], ["", "package:sass/src/callable/built_in.dart",, Q, {
    "^": "",
    BuiltInCallable: {
      "^": "Object;name<,_overloads",
      BuiltInCallable$overloaded$2: function($name, overloads) {
        overloads.forEach$1(0, new Q.BuiltInCallable$overloaded_closure(this));
      },
      callbackFor$2: function(positional, names) {
        var t1 = this._overloads;
        return H.SubListIterable$(t1, 0, t1.length - 1, H.getTypeArgumentByIndex(t1, 0)).firstWhere$2$orElse(0, new Q.BuiltInCallable_callbackFor_closure(positional, names), new Q.BuiltInCallable_callbackFor_closure0(this));
      },
      $isCallable: 1,
      $isAsyncCallable: 1,
      $isAsyncBuiltInCallable: 1,
      static: {
        BuiltInCallable$: function($name, $arguments, callback) {
          var t1, t2, t3;
          t1 = "(" + $arguments + ")";
          t2 = C.JSString_methods.get$codeUnits(t1);
          t3 = H.setRuntimeTypeInfo([0], [P.int]);
          t3 = new Y.SourceFile(null, t3, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
          t3.SourceFile$decoded$2$url(t2, null);
          t1 = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t3, null, null, t1, 0, null, null), C.StderrLogger_false).parseArgumentDeclaration$0();
          t2 = H.setRuntimeTypeInfo([], [[S.Tuple2, B.ArgumentDeclaration, {func: 1, ret: F.Value, args: [[P.List, F.Value]]}]]);
          t2.push(new S.Tuple2(t1, callback, [null, null]));
          return new Q.BuiltInCallable($name, t2);
        },
        BuiltInCallable$parsed: function($name, $arguments, callback) {
          var t1 = H.setRuntimeTypeInfo([], [[S.Tuple2, B.ArgumentDeclaration, {func: 1, ret: F.Value, args: [[P.List, F.Value]]}]]);
          t1.push(new S.Tuple2($arguments, callback, [null, null]));
          return new Q.BuiltInCallable($name, t1);
        },
        BuiltInCallable$overloaded: function($name, overloads) {
          var t1 = new Q.BuiltInCallable($name, H.setRuntimeTypeInfo([], [[S.Tuple2, B.ArgumentDeclaration, {func: 1, ret: F.Value, args: [[P.List, F.Value]]}]]));
          t1.BuiltInCallable$overloaded$2($name, overloads);
          return t1;
        }
      }
    },
    BuiltInCallable$overloaded_closure: {
      "^": "Closure:2;$this",
      call$2: function($arguments, callback) {
        var t1, t2, t3;
        t1 = "(" + H.S($arguments) + ")";
        t2 = C.JSString_methods.get$codeUnits(t1);
        t3 = H.setRuntimeTypeInfo([0], [P.int]);
        t3 = new Y.SourceFile(null, t3, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
        t3.SourceFile$decoded$2$url(t2, null);
        this.$this._overloads.push(new S.Tuple2(new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t3, null, null, t1, 0, null, null), C.StderrLogger_false).parseArgumentDeclaration$0(), callback, [null, null]));
      }
    },
    BuiltInCallable_callbackFor_closure: {
      "^": "Closure:0;positional,names",
      call$1: function(overload) {
        return overload.get$item1().matches$2(this.positional, this.names);
      }
    },
    BuiltInCallable_callbackFor_closure0: {
      "^": "Closure:1;$this",
      call$0: function() {
        return C.JSArray_methods.get$last(this.$this._overloads);
      }
    }
  }], ["", "package:sass/src/callable/plain_css.dart",, L, {
    "^": "",
    PlainCssCallable: {
      "^": "Object;name<",
      $eq: function(_, other) {
        if (other == null)
          return false;
        return other instanceof L.PlainCssCallable && J.$eq$(this.name, other.name) === true;
      },
      get$hashCode: function(_) {
        return J.get$hashCode$(this.name);
      },
      $isCallable: 1,
      $isAsyncCallable: 1
    }
  }], ["", "package:sass/src/callable/user_defined.dart",, E, {
    "^": "",
    UserDefinedCallable: {
      "^": "Object;declaration,environment,$ti",
      get$name: function() {
        return this.declaration.name;
      },
      $isCallable: 1,
      $isAsyncCallable: 1
    }
  }], ["", "package:sass/src/color_names.dart",, X, {
    "^": "",
    closure34: {
      "^": "Closure:2;",
      call$2: function(_, color) {
        return color;
      }
    },
    closure35: {
      "^": "Closure:2;",
      call$2: function($name, _) {
        return $name;
      }
    }
  }], ["", "package:sass/src/compile.dart",, U, {
    "^": "",
    compileString: function(source, functions, importer, importers, indentWidth, indented, lineFeed, loadPaths, logger, nodeImporter, packageResolver, sourceMap, style, url, useSpaces) {
      var t1, t2, t3, t4, sassTree, evaluateResult;
      t1 = J.getInterceptor$s(source);
      t2 = [P.int];
      if (indented === true) {
        t1 = t1.get$codeUnits(source);
        t2 = H.setRuntimeTypeInfo([0], t2);
        t3 = typeof url === "string";
        t4 = t3 ? P.Uri_parse(url, 0, null) : url;
        t2 = new Y.SourceFile(t4, t2, new Uint32Array(H._ensureNativeList(t1.toList$0(t1))), null);
        t2.SourceFile$decoded$2$url(t1, url);
        t1 = t3 ? P.Uri_parse(url, 0, null) : url;
        sassTree = new U.SassParser(0, null, null, null, false, null, false, false, false, false, false, new S.SpanScanner(t2, null, t1, source, 0, null, null), C.StderrLogger_false).parse$0();
      } else {
        t1 = t1.get$codeUnits(source);
        t2 = H.setRuntimeTypeInfo([0], t2);
        t3 = typeof url === "string";
        t4 = t3 ? P.Uri_parse(url, 0, null) : url;
        t2 = new Y.SourceFile(t4, t2, new Uint32Array(H._ensureNativeList(t1.toList$0(t1))), null);
        t2.SourceFile$decoded$2$url(t1, url);
        t1 = t3 ? P.Uri_parse(url, 0, null) : url;
        sassTree = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t2, null, t1, source, 0, null, null), C.StderrLogger_false).parse$0();
      }
      evaluateResult = R.evaluate(sassTree, functions, R.ImportCache$(importers, loadPaths, logger, packageResolver), importer, logger, nodeImporter, sourceMap, null);
      return new U.CompileResult(evaluateResult, N.serialize(evaluateResult.stylesheet, indentWidth, false, lineFeed, sourceMap, style, useSpaces));
    },
    compileStringAsync: function(source, functions, importer, importers, indentWidth, indented, lineFeed, loadPaths, logger, nodeImporter, packageResolver, sourceMap, style, url, useSpaces) {
      var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(U.CompileResult), $async$returnValue, t1, t2, t3, t4, sassTree, evaluateResult;
      var $async$compileStringAsync = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = J.getInterceptor$s(source);
              t2 = [P.int];
              if (indented === true) {
                t1 = t1.get$codeUnits(source);
                t2 = H.setRuntimeTypeInfo([0], t2);
                t3 = typeof url === "string";
                t4 = t3 ? P.Uri_parse(url, 0, null) : url;
                t2 = new Y.SourceFile(t4, t2, new Uint32Array(H._ensureNativeList(t1.toList$0(t1))), null);
                t2.SourceFile$decoded$2$url(t1, url);
                t1 = t3 ? P.Uri_parse(url, 0, null) : url;
                sassTree = new U.SassParser(0, null, null, null, false, null, false, false, false, false, false, new S.SpanScanner(t2, null, t1, source, 0, null, null), C.StderrLogger_false).parse$0();
              } else {
                t1 = t1.get$codeUnits(source);
                t2 = H.setRuntimeTypeInfo([0], t2);
                t3 = typeof url === "string";
                t4 = t3 ? P.Uri_parse(url, 0, null) : url;
                t2 = new Y.SourceFile(t4, t2, new Uint32Array(H._ensureNativeList(t1.toList$0(t1))), null);
                t2.SourceFile$decoded$2$url(t1, url);
                t1 = t3 ? P.Uri_parse(url, 0, null) : url;
                sassTree = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t2, null, t1, source, 0, null, null), C.StderrLogger_false).parse$0();
              }
              $async$goto = 3;
              return P._asyncAwait(E.evaluateAsync(sassTree, functions, O.AsyncImportCache$(importers, loadPaths, logger, packageResolver), importer, logger, nodeImporter, sourceMap, null), $async$compileStringAsync);
            case 3:
              // returning from await.
              evaluateResult = $async$result;
              $async$returnValue = new U.CompileResult(evaluateResult, N.serialize(evaluateResult.get$stylesheet(), indentWidth, false, lineFeed, sourceMap, style, useSpaces));
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$compileStringAsync, $async$completer);
    },
    CompileResult: {
      "^": "Object;_evaluate,_serialize",
      get$css: function(_) {
        return this._serialize.css;
      },
      get$sourceMap: function(_) {
        return this._serialize.sourceMap;
      },
      get$includedFiles: function(_) {
        return J.get$includedFiles$x(this._evaluate);
      }
    }
  }], ["", "package:sass/src/environment.dart",, O, {
    "^": "",
    Environment: {
      "^": "Object;_variables,_variableSpans,_variableIndices,_functions,_functionIndices,_mixins,_mixinIndices,_contentBlock,_contentEnvironment,_inMixin,_inSemiGlobalScope,_lastVariableName,_lastVariableIndex",
      get$contentBlock: function() {
        return this._contentBlock;
      },
      get$contentEnvironment: function() {
        return this._contentEnvironment;
      },
      get$inMixin: function() {
        return this._inMixin;
      },
      closure$0: function() {
        var t1, t2, t3, t4;
        t1 = this._variables;
        t1 = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
        t2 = this._variableSpans;
        if (t2 == null)
          t2 = null;
        else
          t2 = H.setRuntimeTypeInfo(t2.slice(0), [H.getTypeArgumentByIndex(t2, 0)]);
        t3 = this._functions;
        t3 = H.setRuntimeTypeInfo(t3.slice(0), [H.getTypeArgumentByIndex(t3, 0)]);
        t4 = this._mixins;
        t4 = H.setRuntimeTypeInfo(t4.slice(0), [H.getTypeArgumentByIndex(t4, 0)]);
        return O.Environment$_(t1, t2, t3, t4, this._contentBlock, this._contentEnvironment);
      },
      global$0: function() {
        var t1, t2;
        t1 = C.JSArray_methods.get$first(this._variables);
        t2 = this._variableSpans;
        t2 = t2 == null ? null : [C.JSArray_methods.get$first(t2)];
        return O.Environment$_([t1], t2, [C.JSArray_methods.get$first(this._functions)], [C.JSArray_methods.get$first(this._mixins)], null, null);
      },
      getVariable$1: function($name) {
        var t1, t2, index;
        if (J.$eq$(this._lastVariableName, $name) === true) {
          t1 = this._variables;
          t2 = this._lastVariableIndex;
          if (t2 >>> 0 !== t2 || t2 >= t1.length)
            return H.ioore(t1, t2);
          return J.$index$asx(t1[t2], $name);
        }
        t1 = this._variableIndices;
        index = t1.$index(0, $name);
        if (index != null) {
          this._lastVariableName = $name;
          this._lastVariableIndex = index;
          t1 = this._variables;
          if (index >>> 0 !== index || index >= t1.length)
            return H.ioore(t1, index);
          return J.$index$asx(t1[index], $name);
        }
        index = this._variableIndex$1($name);
        if (index == null)
          return;
        this._lastVariableName = $name;
        this._lastVariableIndex = index;
        t1.$indexSet(0, $name, index);
        t1 = this._variables;
        if (index >>> 0 !== index || index >= t1.length)
          return H.ioore(t1, index);
        return J.$index$asx(t1[index], $name);
      },
      getVariableSpan$1: function($name) {
        var t1, t2, index;
        if (J.$eq$(this._lastVariableName, $name) === true) {
          t1 = this._variableSpans;
          t2 = this._lastVariableIndex;
          if (t2 >>> 0 !== t2 || t2 >= t1.length)
            return H.ioore(t1, t2);
          return J.$index$asx(t1[t2], $name);
        }
        t1 = this._variableIndices;
        index = t1.$index(0, $name);
        if (index != null) {
          this._lastVariableName = $name;
          this._lastVariableIndex = index;
          t1 = this._variableSpans;
          if (index >>> 0 !== index || index >= t1.length)
            return H.ioore(t1, index);
          return J.$index$asx(t1[index], $name);
        }
        index = this._variableIndex$1($name);
        if (index == null)
          return;
        this._lastVariableName = $name;
        this._lastVariableIndex = index;
        t1.$indexSet(0, $name, index);
        t1 = this._variableSpans;
        if (index >>> 0 !== index || index >= t1.length)
          return H.ioore(t1, index);
        return J.$index$asx(t1[index], $name);
      },
      variableExists$1: function($name) {
        return this.getVariable$1($name) != null;
      },
      globalVariableExists$1: function($name) {
        return C.JSArray_methods.get$first(this._variables).containsKey$1($name);
      },
      _variableIndex$1: function($name) {
        var t1, i;
        for (t1 = this._variables, i = t1.length - 1; i >= 0; --i) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          if (t1[i].containsKey$1($name) === true)
            return i;
        }
        return;
      },
      setVariable$4$global: function($name, value, span, global) {
        var t1, index;
        if (global || this._variables.length === 1) {
          this._variableIndices.putIfAbsent$2($name, new O.Environment_setVariable_closure(this, $name));
          J.$indexSet$ax(C.JSArray_methods.get$first(this._variables), $name, value);
          t1 = this._variableSpans;
          if (t1 != null)
            J.$indexSet$ax(C.JSArray_methods.get$first(t1), $name, span);
          return;
        }
        index = J.$eq$(this._lastVariableName, $name) === true ? this._lastVariableIndex : this._variableIndices.putIfAbsent$2($name, new O.Environment_setVariable_closure0(this, $name));
        if (!this._inSemiGlobalScope && J.$eq$(index, 0) === true) {
          index = this._variables.length - 1;
          this._variableIndices.$indexSet(0, $name, index);
        }
        this._lastVariableName = $name;
        this._lastVariableIndex = index;
        t1 = this._variables;
        if (index >>> 0 !== index || index >= t1.length)
          return H.ioore(t1, index);
        J.$indexSet$ax(t1[index], $name, value);
        t1 = this._variableSpans;
        if (t1 != null) {
          if (index >= t1.length)
            return H.ioore(t1, index);
          J.$indexSet$ax(t1[index], $name, span);
        }
      },
      setLocalVariable$3: function($name, value, span) {
        var t1, index;
        t1 = this._variables;
        index = t1.length - 1;
        this._lastVariableName = $name;
        this._lastVariableIndex = index;
        this._variableIndices.$indexSet(0, $name, index);
        if (index < 0 || index >= t1.length)
          return H.ioore(t1, index);
        J.$indexSet$ax(t1[index], $name, value);
        t1 = this._variableSpans;
        if (t1 != null) {
          if (index >= t1.length)
            return H.ioore(t1, index);
          J.$indexSet$ax(t1[index], $name, span);
        }
      },
      getFunction$1: function($name) {
        var t1, index;
        t1 = this._functionIndices;
        index = t1.$index(0, $name);
        if (index != null) {
          t1 = this._functions;
          if (index >>> 0 !== index || index >= t1.length)
            return H.ioore(t1, index);
          return J.$index$asx(t1[index], $name);
        }
        index = this._functionIndex$1($name);
        if (index == null)
          return;
        t1.$indexSet(0, $name, index);
        t1 = this._functions;
        if (index >>> 0 !== index || index >= t1.length)
          return H.ioore(t1, index);
        return J.$index$asx(t1[index], $name);
      },
      _functionIndex$1: function($name) {
        var t1, i;
        for (t1 = this._functions, i = t1.length - 1; i >= 0; --i) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          if (t1[i].containsKey$1($name) === true)
            return i;
        }
        return;
      },
      functionExists$1: function($name) {
        return this.getFunction$1($name) != null;
      },
      setFunction$1: [function(callable) {
        var t1, index;
        t1 = this._functions;
        index = t1.length - 1;
        this._functionIndices.$indexSet(0, callable.get$name(), index);
        if (index < 0 || index >= t1.length)
          return H.ioore(t1, index);
        J.$indexSet$ax(t1[index], callable.get$name(), callable);
      }, "call$1", "get$setFunction", 4, 0, 59],
      getMixin$1: function($name) {
        var t1, index;
        t1 = this._mixinIndices;
        index = t1.$index(0, $name);
        if (index != null) {
          t1 = this._mixins;
          if (index >>> 0 !== index || index >= t1.length)
            return H.ioore(t1, index);
          return J.$index$asx(t1[index], $name);
        }
        index = this._mixinIndex$1($name);
        if (index == null)
          return;
        t1.$indexSet(0, $name, index);
        t1 = this._mixins;
        if (index >>> 0 !== index || index >= t1.length)
          return H.ioore(t1, index);
        return J.$index$asx(t1[index], $name);
      },
      _mixinIndex$1: function($name) {
        var t1, i;
        for (t1 = this._mixins, i = t1.length - 1; i >= 0; --i) {
          if (i >= t1.length)
            return H.ioore(t1, i);
          if (t1[i].containsKey$1($name) === true)
            return i;
        }
        return;
      },
      mixinExists$1: function($name) {
        return this.getMixin$1($name) != null;
      },
      setMixin$1: function(callable) {
        var t1, index, t2;
        t1 = this._mixins;
        index = t1.length - 1;
        t2 = callable.declaration.name;
        this._mixinIndices.$indexSet(0, t2, index);
        if (index < 0 || index >= t1.length)
          return H.ioore(t1, index);
        J.$indexSet$ax(t1[index], t2, callable);
      },
      withContent$3: function(block, environment, callback) {
        var oldBlock, oldEnvironment;
        oldBlock = this._contentBlock;
        oldEnvironment = this._contentEnvironment;
        this._contentBlock = block;
        this._contentEnvironment = environment;
        callback.call$0();
        this._contentBlock = oldBlock;
        this._contentEnvironment = oldEnvironment;
      },
      asMixin$1: function(callback) {
        var oldInMixin = this._inMixin;
        this._inMixin = true;
        callback.call$0();
        this._inMixin = oldInMixin;
      },
      scope$3$semiGlobal$when: function(callback, semiGlobal, when) {
        var wasInSemiGlobalScope, wasInSemiGlobalScope0, $name, name0, name1, t1, t2, t3, t4;
        if (!when) {
          wasInSemiGlobalScope = this._inSemiGlobalScope;
          this._inSemiGlobalScope = semiGlobal;
          try {
            t1 = callback.call$0();
            return t1;
          } finally {
            this._inSemiGlobalScope = wasInSemiGlobalScope;
          }
        }
        semiGlobal = semiGlobal && this._inSemiGlobalScope;
        wasInSemiGlobalScope0 = this._inSemiGlobalScope;
        this._inSemiGlobalScope = semiGlobal;
        t1 = this._variables;
        C.JSArray_methods.add$1(t1, B.normalizedMap(null));
        t2 = this._variableSpans;
        if (!(t2 == null))
          C.JSArray_methods.add$1(t2, B.normalizedMap(null));
        t2 = this._functions;
        C.JSArray_methods.add$1(t2, B.normalizedMap(null));
        t3 = this._mixins;
        C.JSArray_methods.add$1(t3, B.normalizedMap(null));
        try {
          t4 = callback.call$0();
          return t4;
        } finally {
          this._inSemiGlobalScope = wasInSemiGlobalScope0;
          this._lastVariableName = null;
          this._lastVariableIndex = null;
          for (t1 = C.JSArray_methods.removeLast$0(t1).get$keys(), t1 = t1.get$iterator(t1), t4 = this._variableIndices; t1.moveNext$0();) {
            $name = t1.get$current(t1);
            t4.remove$1(0, $name);
          }
          for (t1 = C.JSArray_methods.removeLast$0(t2).get$keys(), t1 = t1.get$iterator(t1), t2 = this._functionIndices; t1.moveNext$0();) {
            name0 = t1.get$current(t1);
            t2.remove$1(0, name0);
          }
          for (t1 = C.JSArray_methods.removeLast$0(t3).get$keys(), t1 = t1.get$iterator(t1), t2 = this._mixinIndices; t1.moveNext$0();) {
            name1 = t1.get$current(t1);
            t2.remove$1(0, name1);
          }
        }
      },
      scope$1: function(callback) {
        return this.scope$3$semiGlobal$when(callback, false, true);
      },
      scope$2$when: function(callback, when) {
        return this.scope$3$semiGlobal$when(callback, false, when);
      },
      scope$2$semiGlobal: function(callback, semiGlobal) {
        return this.scope$3$semiGlobal$when(callback, semiGlobal, true);
      },
      static: {
        Environment$_: function(_variables, _variableSpans, _functions, _mixins, _contentBlock, _contentEnvironment) {
          return new O.Environment(_variables, _variableSpans, B.normalizedMap(null), _functions, B.normalizedMap(null), _mixins, B.normalizedMap(null), _contentBlock, _contentEnvironment, false, true, null, null);
        }
      }
    },
    Environment_setVariable_closure: {
      "^": "Closure:1;$this,name",
      call$0: function() {
        var t1 = this.$this;
        t1._lastVariableName = this.name;
        t1._lastVariableIndex = 0;
        return 0;
      }
    },
    Environment_setVariable_closure0: {
      "^": "Closure:1;$this,name",
      call$0: function() {
        var t1, t2;
        t1 = this.$this;
        t2 = t1._variableIndex$1(this.name);
        return t2 == null ? t1._variables.length - 1 : t2;
      }
    }
  }], ["", "package:sass/src/exception.dart",, E, {
    "^": "",
    SassException: {
      "^": "SourceSpanException;_span_exception$_message,_span",
      get$trace: function() {
        return new Y.Trace(P.List_List$unmodifiable([B.frameForSpan(H.interceptedTypeCast(G.SourceSpanException.prototype.get$span.call(this), "$isFileSpan"), "root stylesheet")], A.Frame), new P._StringStackTrace(null));
      },
      get$span: function() {
        return H.interceptedTypeCast(G.SourceSpanException.prototype.get$span.call(this), "$isFileSpan");
      },
      toString$1$color: function(_, color) {
        var buffer, t1, t2, _i, frame, t3;
        buffer = new P.StringBuffer("");
        t1 = "Error: " + H.S(this._span_exception$_message) + "\n";
        buffer._contents = t1;
        buffer._contents = t1 + H.interceptedTypeCast(G.SourceSpanException.prototype.get$span.call(this), "$isFileSpan").highlight$1$color(color);
        for (t1 = this.get$trace().toString$0(0).split("\n"), t2 = t1.length, _i = 0; _i < t2; ++_i) {
          frame = t1[_i];
          if (J.get$isEmpty$asx(frame) === true)
            continue;
          t3 = buffer._contents += "\n";
          buffer._contents = t3 + ("  " + H.S(frame));
        }
        t1 = buffer._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      },
      toString$0: function($receiver) {
        return this.toString$1$color($receiver, null);
      },
      static: {
        SassException$: function(message, span) {
          return new E.SassException(message, span);
        }
      }
    },
    SassRuntimeException: {
      "^": "SassException;trace<,_span_exception$_message,_span",
      static: {
        SassRuntimeException$: function(message, span, trace) {
          return new E.SassRuntimeException(trace, message, span);
        }
      }
    },
    SassFormatException: {
      "^": "SassException;_span_exception$_message,_span",
      get$source: function() {
        return P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(H.interceptedTypeCast(G.SourceSpanException.prototype.get$span.call(this), "$isFileSpan").file._decodedChars, 0, null), 0, null);
      },
      get$offset: function() {
        var t1 = H.interceptedTypeCast(G.SourceSpanException.prototype.get$span.call(this), "$isFileSpan");
        return Y.FileLocation$_(t1.file, t1._file$_start).offset;
      },
      static: {
        SassFormatException$: function(message, span) {
          return new E.SassFormatException(message, span);
        }
      }
    },
    SassScriptException: {
      "^": "Object;message>",
      toString$0: function(_) {
        return this.message + "\n\nBUG: This should include a source span!";
      },
      static: {
        SassScriptException$: function(message) {
          return new E.SassScriptException(message);
        }
      }
    }
  }], ["", "package:sass/src/executable.dart",, F, {
    "^": "",
    main: [function(args) {
      return F.main$body(args);
    }, "call$1", "executable__main$closure", 4, 0, 91, 65],
    main$body: function(args) {
      var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], _box_0, printError, options, graph, source, destination, error, stackTrace, error0, stackTrace0, error1, error2, stackTrace1, buffer, t1, t2, t3, exception, $async$exception, $async$exception1, $async$temp1;
      var $async$main = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              _box_0 = {};
              _box_0.printedError = false;
              printError = new F.main_printError(_box_0);
              options = null;
              $async$handler = 4;
              options = B.ExecutableOptions_ExecutableOptions$parse(args);
              $async$goto = H.boolTypeCast(options.get$_options().$index(0, "version")) === true ? 7 : 8;
              break;
            case 7:
              // then
              $async$temp1 = P;
              $async$goto = 9;
              return P._asyncAwait(F._loadVersion(), $async$main);
            case 9:
              // returning from await.
              $async$temp1.print($async$result);
              self.process.exitCode = 0;
              // goto return
              $async$goto = 1;
              break;
            case 8:
              // join
              $async$goto = options.get$interactive() === true ? 10 : 11;
              break;
            case 10:
              // then
              $async$goto = 12;
              return P._asyncAwait(Y.repl(options), $async$main);
            case 12:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 11:
              // join
              t1 = H.subtypeCast(options.get$_options().$index(0, "load-path"), "$isList", [P.String], "$asList");
              t2 = options;
              t2 = H.boolTypeCast(t2.get$_options().$index(0, "quiet")) === true ? $.$get$Logger_quiet() : new S.StderrLogger(t2.get$color());
              t3 = P.Uri;
              graph = new M.StylesheetGraph(P.LinkedHashMap_LinkedHashMap$_empty(t3, M.StylesheetNode), R.ImportCache$([], t1, t2, null), P.LinkedHashMap_LinkedHashMap$_empty(t3, P.DateTime));
              $async$goto = H.boolTypeCast(options.get$_options().$index(0, "watch")) === true ? 13 : 14;
              break;
            case 13:
              // then
              $async$goto = 15;
              return P._asyncAwait(A.watch(options, graph), $async$main);
            case 15:
              // returning from await.
              // goto return
              $async$goto = 1;
              break;
            case 14:
              // join
              t1 = options, t1._ensureSources$0(), t1 = t1.get$_sourcesToDestinations().get$keys(), t1 = t1.get$iterator(t1);
            case 16:
              // for condition
              if (!t1.moveNext$0()) {
                // goto after for
                $async$goto = 17;
                break;
              }
              source = t1.get$current(t1);
              t2 = options;
              t2._ensureSources$0();
              destination = t2.get$_sourcesToDestinations().$index(0, source);
              $async$handler = 19;
              $async$goto = 22;
              return P._asyncAwait(D.compileStylesheet(options, graph, source, destination, H.boolTypeCast(options.get$_options().$index(0, "update"))), $async$main);
            case 22:
              // returning from await.
              $async$handler = 4;
              // goto after finally
              $async$goto = 21;
              break;
            case 19:
              // catch
              $async$handler = 18;
              $async$exception = $async$currentError;
              t2 = H.unwrapException($async$exception);
              t3 = J.getInterceptor(t2);
              if (!!t3.$isSassException) {
                error = t2;
                stackTrace = H.getTraceFromException($async$exception);
                new F.main_closure(destination).call$0();
                t2 = options;
                t3 = t2.get$_options();
                if (J.$index$asx(J.get$options$x(t3._parser), "color") == null)
                  H.throwExpression(P.ArgumentError$('Could not find an option named "color".'));
                if (t3._parsed.containsKey$1("color") === true)
                  t2 = H.boolTypeCast(t2.get$_options().$index(0, "color"));
                else {
                  t2 = self.process.stdout.isTTY;
                  if (t2 == null)
                    t2 = false;
                }
                t2 = J.toString$1$color$(error, t2);
                t3 = H.boolTypeCast(options.get$_options().$index(0, "trace")) === true ? stackTrace : null;
                printError.call$2(t2, t3);
                if (J.$eq$(self.process.exitCode, 66) !== true)
                  self.process.exitCode = 65;
              } else if (!!t3.$isFileSystemException) {
                error0 = t2;
                stackTrace0 = H.getTraceFromException($async$exception);
                t2 = "Error reading " + H.S(D.p().relative$1(J.get$path$x(error0))) + ": " + J.get$message$x(error0) + ".";
                t3 = H.boolTypeCast(options.get$_options().$index(0, "trace")) === true ? stackTrace0 : null;
                printError.call$2(t2, t3);
                self.process.exitCode = 66;
              } else
                throw $async$exception;
              // goto after finally
              $async$goto = 21;
              break;
            case 18:
              // uncaught
              // goto catch
              $async$goto = 4;
              break;
            case 21:
              // after finally
              // goto for condition
              $async$goto = 16;
              break;
            case 17:
              // after for
              $async$handler = 2;
              // goto after finally
              $async$goto = 6;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception1 = $async$currentError;
              t1 = H.unwrapException($async$exception1);
              if (t1 instanceof B.UsageException) {
                error1 = t1;
                P.print(H.S(J.get$message$x(error1)) + "\n");
                P.print("Usage: sass <input.scss> [output.css]\n       sass <input.scss>:<output.css> <input/>:<output/>\n");
                P.print($.$get$ExecutableOptions__parser().get$usage());
                self.process.exitCode = 64;
              } else {
                error2 = t1;
                stackTrace1 = H.getTraceFromException($async$exception1);
                buffer = new P.StringBuffer("");
                if (options != null && options.get$color() === true) {
                  t1 = buffer;
                  t1.set$_contents(t1.get$_contents() + "\x1b[31m\x1b[1m");
                }
                t1 = buffer;
                t1.set$_contents(t1.get$_contents() + "Unexpected exception:");
                if (options != null && options.get$color() === true) {
                  t1 = buffer;
                  t1.set$_contents(t1.get$_contents() + "\x1b[0m");
                }
                t1 = buffer;
                t1.set$_contents(t1.get$_contents() + "\n");
                t1 = buffer;
                t2 = H.S(error2) + "\n";
                t1.set$_contents(t1.get$_contents() + t2);
                t2 = buffer.get$_contents();
                printError.call$2(t2.charCodeAt(0) == 0 ? t2 : t2, stackTrace1);
                self.process.exitCode = 255;
              }
              // goto after finally
              $async$goto = 6;
              break;
            case 3:
              // uncaught
              // goto rethrow
              $async$goto = 2;
              break;
            case 6:
              // after finally
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$main, $async$completer);
    },
    _loadVersion: function() {
      var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(P.String), $async$returnValue;
      var $async$_loadVersion = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$returnValue = "1.6.0 compiled with dart2js 2.0.0-dev.62.0";
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_loadVersion, $async$completer);
    },
    main_printError: {
      "^": "Closure:58;_box_0",
      call$2: function(error, stackTrace) {
        var t1 = this._box_0;
        if (t1.printedError)
          $.$get$stderr().writeln$0();
        t1.printedError = true;
        t1 = $.$get$stderr();
        t1.writeln$1(error);
        if (stackTrace != null) {
          t1.writeln$0();
          t1.writeln$1(J.trimRight$0$s(Y.Trace_Trace$from(stackTrace).get$terse().toString$0(0)));
        }
      }
    },
    main_closure: {
      "^": "Closure:1;destination",
      call$0: function() {
        var t1, exception;
        try {
          t1 = this.destination;
          if (t1 != null)
            B.deleteFile(t1);
        } catch (exception) {
          if (!(H.unwrapException(exception) instanceof B.FileSystemException))
            throw exception;
        }
      }
    }
  }], ["", "package:sass/src/executable/compile_stylesheet.dart",, D, {
    "^": "",
    compileStylesheet: function(options, graph, source, destination, ifModified) {
      return D.compileStylesheet$body(options, graph, source, destination, ifModified);
    },
    compileStylesheet$body: function(options, graph, source, destination, ifModified) {
      var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$next = [], importer, exception, t1, stylesheet, t2, t3, evaluateResult, serializeResult, css, buffer;
      var $async$compileStylesheet = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              importer = new F.FilesystemImporter(".");
              if (ifModified === true)
                try {
                  if (source != null && destination != null && !graph.modifiedSince$3(D.p().toUri$1(source), B.modificationTime(destination), importer)) {
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                } catch (exception) {
                  if (!(H.unwrapException(exception) instanceof B.FileSystemException))
                    throw exception;
                }
              t1 = graph.importCache;
              $async$goto = 3;
              return P._asyncAwait(D._parseStylesheet(options, t1, source), $async$compileStylesheet);
            case 3:
              // returning from await.
              stylesheet = $async$result;
              t2 = options._options;
              $async$goto = H.boolTypeCast(t2.$index(0, "async")) === true ? 4 : 6;
              break;
            case 4:
              // then
              t1 = H.subtypeCast(t2.$index(0, "load-path"), "$isList", [P.String], "$asList");
              t3 = H.boolTypeCast(t2.$index(0, "quiet")) === true ? $.$get$Logger_quiet() : new S.StderrLogger(options.get$color());
              t3 = O.AsyncImportCache$([], t1, t3, null);
              t1 = H.boolTypeCast(t2.$index(0, "quiet")) === true ? $.$get$Logger_quiet() : new S.StderrLogger(options.get$color());
              $async$goto = 7;
              return P._asyncAwait(E.evaluateAsync(stylesheet, null, t3, importer, t1, null, options.get$emitSourceMap(), null), $async$compileStylesheet);
            case 7:
              // returning from await.
              evaluateResult = $async$result;
              // goto join
              $async$goto = 5;
              break;
            case 6:
              // else
              t3 = H.boolTypeCast(t2.$index(0, "quiet")) === true ? $.$get$Logger_quiet() : new S.StderrLogger(options.get$color());
              evaluateResult = R.evaluate(stylesheet, null, t1, importer, t3, null, options.get$emitSourceMap(), null);
            case 5:
              // join
              t1 = evaluateResult.get$stylesheet();
              t3 = J.$eq$(t2.$index(0, "style"), "compressed") === true ? C.OutputStyle_compressed : C.OutputStyle_expanded;
              serializeResult = N.serialize(t1, null, false, null, options.get$emitSourceMap(), t3, true);
              css = serializeResult.css + D._writeSourceMap(options, serializeResult.sourceMap, destination);
              if (destination == null) {
                if (css.length !== 0)
                  P.print(css);
              } else {
                B.ensureDir(D.p().dirname$1(destination));
                B.writeFile(destination, css + "\n");
              }
              if (H.boolTypeCast(t2.$index(0, "quiet")) !== true)
                t1 = H.boolTypeCast(t2.$index(0, "update")) !== true && H.boolTypeCast(t2.$index(0, "watch")) !== true;
              else
                t1 = true;
              if (t1) {
                // goto return
                $async$goto = 1;
                break;
              }
              buffer = new P.StringBuffer("");
              if (options.get$color() === true) {
                buffer._contents = "\x1b[32m";
                t1 = "\x1b[32m";
              } else
                t1 = "";
              t1 += "Compiled " + H.S(source == null ? "stdin" : D.p().prettyUri$1(D.p().toUri$1(source))) + " to " + H.S(destination) + ".";
              buffer._contents = t1;
              if (options.get$color() === true)
                buffer._contents = t1 + "\x1b[0m";
              P.print(buffer);
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$compileStylesheet, $async$completer);
    },
    _parseStylesheet: function(options, importCache, source) {
      var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(V.Stylesheet), $async$returnValue, t1, t2, text, url, t3;
      var $async$_parseStylesheet = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = source == null;
              t2 = !t1;
              if (t2 && H.boolTypeCast(options._ifParsed$1("indented")) == null) {
                $async$returnValue = importCache.importCanonical$3(new F.FilesystemImporter("."), D.p().toUri$1(D.p().canonicalize$1(source)), D.p().toUri$1(source));
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = t1 ? 3 : 5;
              break;
            case 3:
              // then
              $async$goto = 6;
              return P._asyncAwait(B.readStdin(), $async$_parseStylesheet);
            case 6:
              // returning from await.
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              $async$result = B.readFile(source);
            case 4:
              // join
              text = $async$result;
              url = t1 ? null : D.p().toUri$1(source);
              t1 = H.boolTypeCast(options._ifParsed$1("indented"));
              if (t1 == null)
                t1 = t2 && J.$eq$(X.ParsedPath_ParsedPath$parse(source, D.p().style)._splitExtension$0()[1], ".sass") === true;
              if (t1) {
                t1 = H.boolTypeCast(options._options.$index(0, "quiet")) === true ? $.$get$Logger_quiet() : new S.StderrLogger(options.get$color());
                t2 = J.get$codeUnits$s(text);
                t3 = H.setRuntimeTypeInfo([0], [P.int]);
                t3 = new Y.SourceFile(url, t3, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
                t3.SourceFile$decoded$2$url(t2, url);
                if (t1 == null)
                  t1 = C.StderrLogger_false;
                t1 = new U.SassParser(0, null, null, null, false, null, false, false, false, false, false, new S.SpanScanner(t3, null, url, text, 0, null, null), t1).parse$0();
              } else {
                t1 = H.boolTypeCast(options._options.$index(0, "quiet")) === true ? $.$get$Logger_quiet() : new S.StderrLogger(options.get$color());
                t2 = J.get$codeUnits$s(text);
                t3 = H.setRuntimeTypeInfo([0], [P.int]);
                t3 = new Y.SourceFile(url, t3, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
                t3.SourceFile$decoded$2$url(t2, url);
                if (t1 == null)
                  t1 = C.StderrLogger_false;
                t1 = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t3, null, url, text, 0, null, null), t1).parse$0();
              }
              $async$returnValue = t1;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_parseStylesheet, $async$completer);
    },
    _writeSourceMap: function(options, sourceMap, destination) {
      var t1, i, url, t2, path, sourceMapText, sourceMapPath;
      if (sourceMap == null)
        return "";
      if (destination != null)
        sourceMap.targetUrl = J.toString$0$(D.p().toUri$1(X.ParsedPath_ParsedPath$parse(destination, D.p().style).get$basename()));
      for (t1 = sourceMap.urls, i = 0; i < t1.length; ++i) {
        url = t1[i];
        if (J.$eq$(url, "") === true)
          continue;
        t2 = P.Uri_parse(url, 0, null);
        options.toString;
        path = D.p().canonicalize$1(D.p().style.pathFromUri$1(M._parseUri(t2)));
        t2 = D.p();
        t2 = J.toString$0$(t2.toUri$1(J.$eq$(options._options.$index(0, "source-map-urls"), "relative") === true ? D.p().relative$2$from(path, D.p().dirname$1(destination)) : D.p().absolute$1(path)));
        if (i >= t1.length)
          return H.ioore(t1, i);
        t1[i] = t2;
      }
      t1 = options._options;
      sourceMapText = C.JsonCodec_null_null.encode$1(sourceMap.toJson$1$includeSourceContents(H.boolTypeCast(t1.$index(0, "embed-sources"))));
      if (H.boolTypeCast(t1.$index(0, "embed-source-map")) === true)
        url = P.Uri_Uri$dataFromString(sourceMapText, false, null, "application/json", null);
      else {
        sourceMapPath = J.$add$ansx(destination, ".map");
        B.ensureDir(D.p().dirname$1(sourceMapPath));
        B.writeFile(sourceMapPath, sourceMapText);
        url = D.p().toUri$1(sourceMapPath);
      }
      t1 = (J.$eq$(t1.$index(0, "style"), "compressed") === true ? C.OutputStyle_compressed : C.OutputStyle_expanded) === C.OutputStyle_compressed ? "" : "\n\n";
      return t1 + ("/*# sourceMappingURL=" + H.S(url) + " */");
    }
  }], ["", "package:sass/src/executable/options.dart",, B, {
    "^": "",
    ExecutableOptions: {
      "^": "Object;_options<,_interactive,_sourcesToDestinations<,_sourceDirectoriesToDestinations",
      get$interactive: function() {
        var t1, t2, invalidOptions, t3, _i, option;
        t1 = this._interactive;
        if (t1 != null)
          return t1;
        t1 = this._options;
        t2 = H.boolTypeCast(t1.$index(0, "interactive"));
        this._interactive = t2;
        if (t2 !== true)
          return false;
        invalidOptions = ["stdin", "indented", "load-path", "style", "source-map", "source-map-urls", "embed-sources", "embed-source-map", "update", "watch"];
        for (t2 = t1._parser, t3 = J.getInterceptor$x(t2), _i = 0; _i < 10; ++_i) {
          option = invalidOptions[_i];
          if (J.$index$asx(t3.get$options(t2), option) == null)
            H.throwExpression(P.ArgumentError$('Could not find an option named "' + option + '".'));
          if (t1._parsed.containsKey$1(option) === true)
            throw H.wrapException(B.UsageException$("--" + option + " isn't allowed with --interactive."));
        }
        return true;
      },
      get$color: function() {
        var t1 = this._options;
        if (t1.wasParsed$1("color") === true)
          t1 = H.boolTypeCast(t1.$index(0, "color"));
        else {
          t1 = self.process.stdout.isTTY;
          if (t1 == null)
            t1 = false;
        }
        return t1;
      },
      get$trace: function() {
        return H.boolTypeCast(this._options.$index(0, "trace"));
      },
      get$update: function() {
        return H.boolTypeCast(this._options.$index(0, "update"));
      },
      get$watch: function(_) {
        return H.boolTypeCast(this._options.$index(0, "watch"));
      },
      _ensureSources$0: function() {
        var t1, stdin, t2, t3, t4, colonArgs, positionalArgs, argument, t5, t6, source, destination, seen, i, t7;
        if (this._sourcesToDestinations != null)
          return;
        t1 = this._options;
        stdin = H.boolTypeCast(t1.$index(0, "stdin"));
        t2 = t1.rest;
        if (J.$eq$(t2.get$length(t2), 0) === true && stdin !== true)
          B.ExecutableOptions__fail("Compile Sass to CSS.");
        for (t3 = [H.getTypeArgumentByIndex(t2, 0)], t4 = new H.ListIterator(t2, t2.get$length(t2), 0, null, t3), colonArgs = false, positionalArgs = false; t4.moveNext$0();) {
          argument = t4.__internal$_current;
          t5 = J.getInterceptor$asx(argument);
          if (t5.get$isEmpty(argument) === true)
            B.ExecutableOptions__fail('Invalid argument "".');
          if (t5.contains$1(argument, ":") === true) {
            if (J.$gt$n(t5.get$length(argument), 2)) {
              t6 = t5.codeUnitAt$1(argument, 0);
              if (!(t6 >= 97 && t6 <= 122))
                t6 = t6 >= 65 && t6 <= 90;
              else
                t6 = true;
              t6 = t6 && t5.codeUnitAt$1(argument, 1) === 58;
            } else
              t6 = false;
            t5 = t6 && t5.indexOf$2(argument, ":", 2) === -1;
          } else
            t5 = true;
          if (t5)
            positionalArgs = true;
          else
            colonArgs = true;
        }
        if (positionalArgs || J.$eq$(t2.get$length(t2), 0) === true) {
          if (colonArgs)
            B.ExecutableOptions__fail('Positional and ":" arguments may not both be used.');
          else if (stdin === true) {
            if (J.$gt$n(J.get$length$asx(t2._collection$_source), 1))
              B.ExecutableOptions__fail("Only one argument is allowed with --stdin.");
            else if (H.boolTypeCast(t1.$index(0, "update")) === true)
              B.ExecutableOptions__fail("--update is not allowed with --stdin.");
            else if (H.boolTypeCast(t1.$index(0, "watch")) === true)
              B.ExecutableOptions__fail("--watch is not allowed with --stdin.");
            this._sourcesToDestinations = H.ConstantMap_ConstantMap$from(P.LinkedHashMap__makeLiteral([null, J.$eq$(t2.get$length(t2), 0) === true ? null : t2.get$first(t2)]), null, null);
          } else {
            t3 = t2._collection$_source;
            t4 = J.getInterceptor$asx(t3);
            if (J.$gt$n(t4.get$length(t3), 2))
              B.ExecutableOptions__fail("Only two positional args may be passed.");
            else {
              source = J.$eq$(t2.get$first(t2), "-") === true ? null : t2.get$first(t2);
              destination = J.$eq$(t4.get$length(t3), 1) === true ? null : t2.get$last(t2);
              if (destination == null)
                if (H.boolTypeCast(t1.$index(0, "update")) === true)
                  B.ExecutableOptions__fail("--update is not allowed when printing to stdout.");
                else if (H.boolTypeCast(t1.$index(0, "watch")) === true)
                  B.ExecutableOptions__fail("--watch is not allowed when printing to stdout.");
              t1 = P.LinkedHashMap__makeLiteral([source, destination]);
              t2 = K.PathMap__create(null);
              t2.addAll$1(0, t1);
              this._sourcesToDestinations = new P.UnmodifiableMapView(new K.PathMap(t2, [null]), [null, null]);
            }
          }
          this._sourceDirectoriesToDestinations = C.Map_empty0;
          return;
        }
        if (stdin === true)
          B.ExecutableOptions__fail('--stdin may not be used with ":" arguments.');
        t1 = P.String;
        seen = P.LinkedHashSet_LinkedHashSet(null, null, null, t1);
        t4 = K.PathMap__create(null);
        t1 = [t1];
        t5 = K.PathMap__create(null);
        for (t2 = new H.ListIterator(t2, t2.get$length(t2), 0, null, t3); t2.moveNext$0();) {
          argument = t2.__internal$_current;
          t3 = J.getInterceptor$asx(argument);
          source = null;
          destination = null;
          i = 0;
          while (true) {
            t6 = t3.get$length(argument);
            if (typeof t6 !== "number")
              return H.iae(t6);
            if (!(i < t6))
              break;
            c$0: {
              if (i === 1) {
                t6 = i - 1;
                if (J.$gt$n(t3.get$length(argument), t6 + 2)) {
                  t7 = t3.codeUnitAt$1(argument, t6);
                  if (!(t7 >= 97 && t7 <= 122))
                    t7 = t7 >= 65 && t7 <= 90;
                  else
                    t7 = true;
                  t6 = t7 && t3.codeUnitAt$1(argument, t6 + 1) === 58;
                } else
                  t6 = false;
              } else
                t6 = false;
              if (t6)
                break c$0;
              if (t3.codeUnitAt$1(argument, i) === 58)
                if (source == null) {
                  source = t3.substring$2(argument, 0, i);
                  destination = t3.substring$1(argument, i + 1);
                } else {
                  if (i === source.length + 2) {
                    t6 = i - 1;
                    if (J.$gt$n(t3.get$length(argument), t6 + 2)) {
                      t7 = t3.codeUnitAt$1(argument, t6);
                      if (!(t7 >= 97 && t7 <= 122))
                        t7 = t7 >= 65 && t7 <= 90;
                      else
                        t7 = true;
                      t6 = t7 && t3.codeUnitAt$1(argument, t6 + 1) === 58;
                    } else
                      t6 = false;
                    t6 = !t6;
                  } else
                    t6 = true;
                  if (t6)
                    B.ExecutableOptions__fail('"' + H.S(argument) + '" may only contain one ":".');
                }
            }
            ++i;
          }
          if (!seen.add$1(0, source))
            B.ExecutableOptions__fail('Duplicate source "' + H.S(source) + '".');
          if (source === "-")
            t4.$indexSet(0, null, destination);
          else if (B.dirExists(source) === true) {
            t5.$indexSet(0, source, destination);
            t4.addAll$1(0, this._listSourceDirectory$2(source, destination));
          } else
            t4.$indexSet(0, source, destination);
        }
        t2 = [null, null];
        this._sourcesToDestinations = new P.UnmodifiableMapView(new K.PathMap(t4, t1), t2);
        this._sourceDirectoriesToDestinations = new P.UnmodifiableMapView(new K.PathMap(t5, t1), t2);
      },
      _listSourceDirectory$2: function(source, destination) {
        var t1, map, path, extension, t2;
        t1 = P.String;
        map = P.LinkedHashMap_LinkedHashMap$_empty(t1, t1);
        for (t1 = J.get$iterator$ax(B.listDir(source)); t1.moveNext$0();) {
          path = t1.get$current(t1);
          if (J.startsWith$1$s(X.ParsedPath_ParsedPath$parse(path, D.p().style).get$basename(), "_"))
            continue;
          extension = X.ParsedPath_ParsedPath$parse(path, D.p().style)._splitExtension$0()[1];
          t2 = J.getInterceptor(extension);
          if (t2.$eq(extension, ".scss") !== true && t2.$eq(extension, ".sass") !== true)
            continue;
          map.$indexSet(0, path, D.p().join$2(0, destination, D.p().withoutExtension$1(D.p().relative$2$from(path, source)) + ".css"));
        }
        return map;
      },
      get$emitSourceMap: function() {
        var t1, t2, writeToStdout;
        t1 = this._options;
        if (H.boolTypeCast(t1.$index(0, "source-map")) !== true)
          if (t1.wasParsed$1("source-map-urls") === true)
            B.ExecutableOptions__fail("--source-map-urls isn't allowed with --no-source-map.");
          else if (t1.wasParsed$1("embed-sources") === true)
            B.ExecutableOptions__fail("--embed-sources isn't allowed with --no-source-map.");
          else if (t1.wasParsed$1("embed-source-map") === true)
            B.ExecutableOptions__fail("--embed-source-map isn't allowed with --no-source-map.");
        this._ensureSources$0();
        t2 = this._sourcesToDestinations;
        if (J.$eq$(t2.get$length(t2), 1) === true) {
          this._ensureSources$0();
          t2 = this._sourcesToDestinations.get$values();
          writeToStdout = t2.get$single(t2) == null;
        } else
          writeToStdout = false;
        if (!writeToStdout)
          return H.boolTypeCast(t1.$index(0, "source-map"));
        if (J.$eq$(this._ifParsed$1("source-map-urls"), "relative") === true)
          B.ExecutableOptions__fail("--source-map-urls=relative isn't allowed when printing to stdout.");
        if (H.boolTypeCast(t1.$index(0, "embed-source-map")) === true)
          return H.boolTypeCast(t1.$index(0, "source-map"));
        else if (J.$eq$(this._ifParsed$1("source-map"), true) === true)
          B.ExecutableOptions__fail("When printing to stdout, --source-map requires --embed-source-map.");
        else if (t1.wasParsed$1("source-map-urls") === true)
          B.ExecutableOptions__fail("When printing to stdout, --source-map-urls requires --embed-source-map.");
        else if (H.boolTypeCast(t1.$index(0, "embed-sources")) === true)
          B.ExecutableOptions__fail("When printing to stdout, --embed-sources requires --embed-source-map.");
        else
          return false;
      },
      _ifParsed$1: function($name) {
        var t1 = this._options;
        return t1.wasParsed$1($name) === true ? t1.$index(0, $name) : null;
      },
      update$2: function(arg0, arg1) {
        return this.get$update().call$2(arg0, arg1);
      },
      watch$2: function($receiver, arg0, arg1) {
        return this.get$watch(this).call$2(arg0, arg1);
      },
      static: {
        ExecutableOptions__separator: function(text) {
          var t1, t2, t3;
          t1 = $.$get$ExecutableOptions__separatorBar();
          t2 = C.JSString_methods.$mul(t1, 3) + " ";
          t3 = self.process.stdout.isTTY;
          t2 = t2 + ((t3 == null ? false : t3) === true ? "\x1b[1m" : "") + text;
          t3 = self.process.stdout.isTTY;
          return t2 + ((t3 == null ? false : t3) === true ? "\x1b[0m" : "") + " " + C.JSString_methods.$mul(t1, 35 - text.length);
        },
        ExecutableOptions__fail: function(message) {
          return H.throwExpression(B.UsageException$(message));
        },
        ExecutableOptions_ExecutableOptions$parse: function(args) {
          var options, error, exception, t1;
          try {
            options = new B.ExecutableOptions($.$get$ExecutableOptions__parser().parse$1(args), null, null, null);
            if (H.boolTypeCast(options.get$_options().$index(0, "help")) === true)
              B.ExecutableOptions__fail("Compile Sass to CSS.");
            return options;
          } catch (exception) {
            t1 = H.unwrapException(exception);
            if (!!J.getInterceptor(t1).$isFormatException) {
              error = t1;
              B.ExecutableOptions__fail(J.get$message$x(error));
            } else
              throw exception;
          }
        }
      }
    },
    ExecutableOptions_closure: {
      "^": "Closure:1;",
      call$0: function() {
        var t1, t2, t3, t4, parser;
        t1 = P.String;
        t2 = P.LinkedHashMap_LinkedHashMap$_empty(t1, G.Option);
        t1 = P.LinkedHashMap_LinkedHashMap$_empty(t1, N.ArgParser);
        t3 = [];
        t4 = [null, null];
        parser = new N.ArgParser(t2, t1, new P.UnmodifiableMapView(t2, t4), new P.UnmodifiableMapView(t1, t4), t3, true);
        parser.addOption$2$hide("precision", true);
        parser.addFlag$2$hide("async", true);
        t3.push(B.ExecutableOptions__separator("Input and Output"));
        parser.addFlag$2$help("stdin", "Read the stylesheet from stdin.");
        parser.addFlag$2$help("indented", "Use the indented syntax for input from stdin.");
        parser.addMultiOption$5$abbr$help$splitCommas$valueHelp("load-path", "I", "A path to use when resolving imports.\nMay be passed multiple times.", false, "PATH");
        parser.addOption$6$abbr$allowed$defaultsTo$help$valueHelp("style", "s", ["expanded", "compressed"], "expanded", "Output style.", "NAME");
        parser.addFlag$3$help$negatable("update", "Only compile out-of-date stylesheets.", false);
        t3.push(B.ExecutableOptions__separator("Source Maps"));
        parser.addFlag$3$defaultsTo$help("source-map", true, "Whether to generate source maps.");
        parser.addOption$4$allowed$defaultsTo$help("source-map-urls", ["relative", "absolute"], "relative", "How to link from source maps to source files.");
        parser.addFlag$3$defaultsTo$help("embed-sources", false, "Embed source file contents in source maps.");
        parser.addFlag$3$defaultsTo$help("embed-source-map", false, "Embed source map contents in CSS.");
        t3.push(B.ExecutableOptions__separator("Other"));
        parser.addFlag$3$help$negatable("watch", "Watch stylesheets and recompile when they change.", false);
        parser.addFlag$4$abbr$help$negatable("interactive", "i", "Run an interactive SassScript shell.", false);
        parser.addFlag$3$abbr$help("color", "c", "Whether to emit terminal colors.");
        parser.addFlag$3$abbr$help("quiet", "q", "Don't print warnings.");
        parser.addFlag$2$help("trace", "Print full Dart stack traces for exceptions.");
        parser.addFlag$4$abbr$help$negatable("help", "h", "Print this usage information.", false);
        parser.addFlag$3$help$negatable("version", "Print the version of Dart Sass.", false);
        return parser;
      }
    },
    UsageException: {
      "^": "Object;message>",
      static: {
        UsageException$: function(message) {
          return new B.UsageException(message);
        }
      }
    }
  }], ["", "package:sass/src/executable/repl.dart",, Y, {
    "^": "",
    repl: function(options) {
      return Y.repl$body(options);
    },
    repl$body: function(options) {
      var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$handler = 1, $async$currentError, $async$next = [], repl, variables, line, logger, expression, declaration, result, error, stackTrace, t1, t2, repl0, t3, t4, t5, t6, exception;
      var $async$repl = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$currentError = $async$result;
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = C.JSString_methods.$mul(" ", 3);
              t2 = $.$get$alwaysValid();
              repl0 = new Q.Repl(">> ", t1, t2, false, null, [], 50);
              repl0._adapter = new B.ReplAdapter(repl0, null);
              repl = repl0;
              t1 = P.String;
              variables = P.LinkedHashMap_LinkedHashMap$_empty(t1, F.Value);
              t1 = new P._StreamIterator(null, repl.get$_adapter().runAsync$0(), false, [t1]);
              $async$handler = 2;
              t2 = [P.int];
            case 5:
              // for condition
              $async$goto = 7;
              return P._asyncAwait(t1.moveNext$0(), $async$repl);
            case 7:
              // returning from await.
              if (!($async$result === true)) {
                // goto after for
                $async$goto = 6;
                break;
              }
              line = t1.get$current(t1);
              if (J.trim$0$s(line).length === 0) {
                // goto for condition
                $async$goto = 5;
                break;
              }
              t3 = options._options;
              if (H.boolTypeCast(t3.$index(0, "quiet")) === true)
                t3 = $.$get$Logger_quiet();
              else {
                if (J.$index$asx(J.get$options$x(t3._parser), "color") == null)
                  H.throwExpression(P.ArgumentError$('Could not find an option named "color".'));
                if (t3._parsed.containsKey$1("color") === true)
                  t3 = H.boolTypeCast(t3.$index(0, "color"));
                else {
                  t3 = self.process.stdout.isTTY;
                  if (t3 == null)
                    t3 = false;
                }
                t3 = new S.StderrLogger(t3);
              }
              logger = new T.TrackingLogger(t3, false, false);
              try {
                expression = null;
                declaration = null;
                try {
                  t3 = line;
                  t4 = logger;
                  t5 = J.get$codeUnits$s(t3);
                  t6 = H.setRuntimeTypeInfo([0], t2);
                  t6 = new Y.SourceFile(null, t6, new Uint32Array(H._ensureNativeList(t5.toList$0(t5))), null);
                  t6.SourceFile$decoded$2$url(t5, null);
                  if (t4 == null)
                    t4 = C.StderrLogger_false;
                  declaration = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t6, null, null, t3, 0, null, null), t4).parseVariableDeclaration$0();
                  expression = declaration.get$expression();
                } catch (exception) {
                  if (H.unwrapException(exception) instanceof E.SassFormatException) {
                    t3 = line;
                    t4 = logger;
                    t5 = J.get$codeUnits$s(t3);
                    t6 = H.setRuntimeTypeInfo([0], t2);
                    t6 = new Y.SourceFile(null, t6, new Uint32Array(H._ensureNativeList(t5.toList$0(t5))), null);
                    t6.SourceFile$decoded$2$url(t5, null);
                    if (t4 == null)
                      t4 = C.StderrLogger_false;
                    expression = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t6, null, null, t3, 0, null, null), t4).parseExpression$0();
                  } else
                    throw exception;
                }
                result = expression.accept$1(R._EvaluateVisitor$(null, null, null, logger, null, false, variables));
                if (declaration != null)
                  J.$indexSet$ax(variables, declaration.get$name(), result);
                H.printString(H.S(result));
              } catch (exception) {
                t3 = H.unwrapException(exception);
                if (t3 instanceof E.SassException) {
                  error = t3;
                  stackTrace = H.getTraceFromException(exception);
                  Y._logError(error, stackTrace, line, repl, options, logger);
                } else
                  throw exception;
              }
              // goto for condition
              $async$goto = 5;
              break;
            case 6:
              // after for
              $async$next.push(4);
              // goto finally
              $async$goto = 3;
              break;
            case 2:
              // uncaught
              $async$next = [1];
            case 3:
              // finally
              $async$handler = 1;
              $async$goto = 8;
              return P._asyncAwait(t1.cancel$0(), $async$repl);
            case 8:
              // returning from await.
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 4:
              // after finally
              // implicit return
              return P._asyncReturn(null, $async$completer);
            case 1:
              // rethrow
              return P._asyncRethrow($async$currentError, $async$completer);
          }
      });
      return P._asyncStartSync($async$repl, $async$completer);
    },
    _logError: function(error, stackTrace, line, repl, options, logger) {
      var t1, t2, arrows, t3, start;
      t1 = options._options;
      if (H.boolTypeCast(t1.$index(0, "quiet")) !== true)
        t2 = logger._emittedDebug || logger._emittedWarning;
      else
        t2 = false;
      if (t2) {
        P.print("Error: " + H.S(error._span_exception$_message));
        P.print(H.interceptedTypeCast(G.SourceSpanException.prototype.get$span.call(error), "$isFileSpan").highlight$1$color(options.get$color()));
        return;
      }
      arrows = J.trimRight$0$s(C.JSArray_methods.get$last(H.interceptedTypeCast(G.SourceSpanException.prototype.get$span.call(error), "$isFileSpan").highlight$0().split("\n")));
      t2 = options.get$color() === true ? "\x1b[31m" : "";
      if (options.get$color() === true) {
        t3 = J.get$length$asx(line);
        if (typeof t3 !== "number")
          return H.iae(t3);
        t3 = arrows.length <= t3;
      } else
        t3 = false;
      if (t3) {
        t3 = arrows.length;
        start = t3 - C.JSString_methods.trimLeft$0(arrows).length;
        t3 = t2 + ("\x1b[1F\x1b[" + (start + 3) + "C") + (J.substring$2$s(line, start, t3) + "\n");
        t2 = t3;
      }
      t2 = t2 + C.JSString_methods.$mul(" ", repl.prompt.length) + (arrows + "\n");
      if (options.get$color() === true)
        t2 += "\x1b[0m";
      t2 += "Error: " + H.S(error._span_exception$_message) + "\n";
      t1 = H.boolTypeCast(t1.$index(0, "trace")) === true ? t2 + H.S(Y.Trace_Trace$from(stackTrace).get$terse()) : t2;
      P.print(C.JSString_methods.trimRight$0(t1.charCodeAt(0) == 0 ? t1 : t1));
    }
  }], ["", "package:sass/src/executable/watch.dart",, A, {
    "^": "",
    watch: function(options, graph) {
      var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), t1, t2, directoriesToWatch, t3, t4, dirWatcher, watcher, source, destination;
      var $async$watch = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = P.String;
              t2 = [t1];
              directoriesToWatch = H.setRuntimeTypeInfo([], t2);
              options._ensureSources$0();
              C.JSArray_methods.addAll$1(directoriesToWatch, options._sourceDirectoriesToDestinations.get$keys());
              options._ensureSources$0();
              t3 = options._sourcesToDestinations.get$keys();
              C.JSArray_methods.addAll$1(directoriesToWatch, H.MappedIterable_MappedIterable(t3, D.p().get$dirname(), H.getRuntimeTypeArgument(t3, "Iterable", 0), null));
              C.JSArray_methods.addAll$1(directoriesToWatch, H.subtypeCast(options._options.$index(0, "load-path"), "$isList", t2, "$asList"));
              t2 = [P.Stream, E.WatchEvent];
              t3 = E.WatchEvent;
              t4 = new L.StreamGroup(null, false, C._StreamGroupState_dormant, new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [t2, [P.StreamSubscription, E.WatchEvent]]), [t3]);
              t4._controller = P.StreamController_StreamController(t4.get$_onCancel(), t4.get$_onListen(), t4.get$_onPause(), t4.get$_onResume(), true, t3);
              dirWatcher = new U.MultiDirWatcher(P.LinkedHashMap_LinkedHashMap$_empty(t1, t2), t4);
              $async$goto = 2;
              return P._asyncAwait(P.Future_wait(new H.MappedListIterable(directoriesToWatch, new A.watch_closure(dirWatcher), [H.getTypeArgumentByIndex(directoriesToWatch, 0), null]), null, false), $async$watch);
            case 2:
              // returning from await.
              watcher = new A._Watcher(options, graph);
              options._ensureSources$0(), t1 = options._sourcesToDestinations.get$keys(), t1 = t1.get$iterator(t1);
            case 3:
              // for condition
              if (!t1.moveNext$0()) {
                // goto after for
                $async$goto = 4;
                break;
              }
              source = t1.get$current(t1);
              options._ensureSources$0();
              destination = options._sourcesToDestinations.$index(0, source);
              graph.addCanonical$3(new F.FilesystemImporter("."), D.p().toUri$1(D.p().canonicalize$1(source)), D.p().toUri$1(source));
              $async$goto = 5;
              return P._asyncAwait(watcher.compile$3$ifModified(source, destination, true), $async$watch);
            case 5:
              // returning from await.
              // goto for condition
              $async$goto = 3;
              break;
            case 4:
              // after for
              P.print("Sass is watching for changes. Press Ctrl-C to stop.\n");
              $async$goto = 6;
              return P._asyncAwait(watcher.watch$1(0, dirWatcher), $async$watch);
            case 6:
              // returning from await.
              // implicit return
              return P._asyncReturn(null, $async$completer);
          }
      });
      return P._asyncStartSync($async$watch, $async$completer);
    },
    watch_closure: {
      "^": "Closure:0;dirWatcher",
      call$1: [function(dir) {
        for (; B.dirExists(dir) !== true;)
          dir = D.p().dirname$1(dir);
        return this.dirWatcher.watch$1(0, dir);
      }, null, null, 4, 0, null, 44, "call"]
    },
    _Watcher: {
      "^": "Object;_watch$_options,_graph",
      compile$3$ifModified: function(source, destination, ifModified) {
        return this.compile$body$_Watcher(source, destination, ifModified);
      },
      compile$2: function(source, destination) {
        return this.compile$3$ifModified(source, destination, false);
      },
      compile$body$_Watcher: function(source, destination, ifModified) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$handler = 1, $async$currentError, $async$next = [], $async$self = this, error, stackTrace, error0, stackTrace0, exception, t1, t2, $async$exception;
        var $async$compile$3$ifModified = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$handler = 3;
                $async$goto = 6;
                return P._asyncAwait(D.compileStylesheet($async$self._watch$_options, $async$self._graph, source, destination, ifModified), $async$compile$3$ifModified);
              case 6:
                // returning from await.
                $async$handler = 1;
                // goto after finally
                $async$goto = 5;
                break;
              case 3:
                // catch
                $async$handler = 2;
                $async$exception = $async$currentError;
                t1 = H.unwrapException($async$exception);
                t2 = J.getInterceptor(t1);
                if (!!t2.$isSassException) {
                  error = t1;
                  stackTrace = H.getTraceFromException($async$exception);
                  $async$self._delete$1(destination);
                  $async$self._printError$2(J.toString$1$color$(error, $async$self._watch$_options.get$color()), stackTrace);
                } else if (!!t2.$isFileSystemException) {
                  error0 = t1;
                  stackTrace0 = H.getTraceFromException($async$exception);
                  $async$self._printError$2("Error reading " + H.S(D.p().relative$1(J.get$path$x(error0))) + ": " + J.get$message$x(error0) + ".", stackTrace0);
                } else
                  throw $async$exception;
                // goto after finally
                $async$goto = 5;
                break;
              case 2:
                // uncaught
                // goto rethrow
                $async$goto = 1;
                break;
              case 5:
                // after finally
                // implicit return
                return P._asyncReturn(null, $async$completer);
              case 1:
                // rethrow
                return P._asyncRethrow($async$currentError, $async$completer);
            }
        });
        return P._asyncStartSync($async$compile$3$ifModified, $async$completer);
      },
      _delete$1: function(path) {
        var buffer, t1, t2, t3, exception;
        try {
          B.deleteFile(path);
          buffer = new P.StringBuffer("");
          t1 = this._watch$_options;
          if (t1.get$color() === true) {
            t2 = buffer;
            t2.set$_contents(t2.get$_contents() + "\x1b[33m");
          }
          t2 = buffer;
          t3 = "Deleted " + H.S(path) + ".";
          t2.set$_contents(t2.get$_contents() + t3);
          if (t1.get$color() === true) {
            t1 = buffer;
            t1.set$_contents(t1.get$_contents() + "\x1b[0m");
          }
          P.print(buffer);
        } catch (exception) {
          if (!(H.unwrapException(exception) instanceof B.FileSystemException))
            throw exception;
        }
      },
      _printError$2: function(message, stackTrace) {
        var t1 = $.$get$stderr();
        t1.writeln$1(message);
        if (H.boolTypeCast(this._watch$_options._options.$index(0, "trace")) === true) {
          t1.writeln$0();
          t1.writeln$1(J.trimRight$0$s(Y.Trace_Trace$from(stackTrace).get$terse().toString$0(0)));
        }
        t1.writeln$0();
      },
      watch$1: function(_, watcher) {
        return this.watch$body$_Watcher(_, watcher);
      },
      watch$body$_Watcher: function(_, watcher) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$handler = 1, $async$currentError, $async$next = [], $async$self = this, $event, extension, url, node, destination, destination0, downstream, t1, t2, t3, t4;
        var $async$watch$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = watcher._group._controller;
                t1.toString;
                t1 = new P._StreamIterator(null, $async$self._debounceEvents$1(new P._ControllerStream(t1, [H.getTypeArgumentByIndex(t1, 0)])), false, [null]);
                $async$handler = 2;
                t2 = $async$self._graph, t3 = t2._nodes;
              case 5:
                // for condition
                $async$goto = 7;
                return P._asyncAwait(t1.moveNext$0(), $async$watch$1);
              case 7:
                // returning from await.
                if (!($async$result === true)) {
                  // goto after for
                  $async$goto = 6;
                  break;
                }
                $event = t1.get$current(t1);
                t4 = D.p();
                extension = X.ParsedPath_ParsedPath$parse(J.get$path$x($event), t4.style)._splitExtension$0()[1];
                if (J.$eq$(extension, ".sass") !== true && J.$eq$(extension, ".scss") !== true) {
                  // goto for condition
                  $async$goto = 5;
                  break;
                }
                url = D.p().toUri$1(D.p().canonicalize$1(J.get$path$x($event)));
              case 8:
                // switch
                switch ($event.get$type()) {
                  case C.ChangeType_modify:
                    // goto case
                    $async$goto = 10;
                    break;
                  case C.ChangeType_add:
                    // goto case
                    $async$goto = 11;
                    break;
                  case C.ChangeType_remove:
                    // goto case
                    $async$goto = 12;
                    break;
                  default:
                    // goto after switch
                    $async$goto = 9;
                    break;
                }
                break;
              case 10:
                // case
                if (!t3.containsKey$1(url)) {
                  // goto for condition
                  $async$goto = 5;
                  break;
                }
                node = t3.$index(0, url);
                t2.reload$1(url);
                $async$goto = 13;
                return P._asyncAwait($async$self._recompileDownstream$1([node]), $async$watch$1);
              case 13:
                // returning from await.
                // goto after switch
                $async$goto = 9;
                break;
              case 11:
                // case
                $async$goto = 14;
                return P._asyncAwait($async$self._retryPotentialImports$1(J.get$path$x($event)), $async$watch$1);
              case 14:
                // returning from await.
                destination = $async$self._destinationFor$1(J.get$path$x($event));
                if (destination == null) {
                  // goto for condition
                  $async$goto = 5;
                  break;
                }
                t2.addCanonical$3(new F.FilesystemImporter("."), url, D.p().toUri$1(J.get$path$x($event)));
                $async$goto = 15;
                return P._asyncAwait($async$self.compile$2(J.get$path$x($event), destination), $async$watch$1);
              case 15:
                // returning from await.
                // goto after switch
                $async$goto = 9;
                break;
              case 12:
                // case
                $async$goto = 16;
                return P._asyncAwait($async$self._retryPotentialImports$1(J.get$path$x($event)), $async$watch$1);
              case 16:
                // returning from await.
                if (!t3.containsKey$1(url)) {
                  // goto for condition
                  $async$goto = 5;
                  break;
                }
                destination0 = $async$self._destinationFor$1(J.get$path$x($event));
                if (destination0 != null)
                  $async$self._delete$1(destination0);
                downstream = t3.$index(0, url).get$downstream();
                t2.remove$1(0, url);
                $async$goto = 17;
                return P._asyncAwait($async$self._recompileDownstream$1(downstream), $async$watch$1);
              case 17:
                // returning from await.
                // goto after switch
                $async$goto = 9;
                break;
              case 9:
                // after switch
                // goto for condition
                $async$goto = 5;
                break;
              case 6:
                // after for
                $async$next.push(4);
                // goto finally
                $async$goto = 3;
                break;
              case 2:
                // uncaught
                $async$next = [1];
              case 3:
                // finally
                $async$handler = 1;
                $async$goto = 18;
                return P._asyncAwait(t1.cancel$0(), $async$watch$1);
              case 18:
                // returning from await.
                // goto the next finally handler
                $async$goto = $async$next.pop();
                break;
              case 4:
                // after finally
                // implicit return
                return P._asyncReturn(null, $async$completer);
              case 1:
                // rethrow
                return P._asyncRethrow($async$currentError, $async$completer);
            }
        });
        return P._asyncStartSync($async$watch$1, $async$completer);
      },
      _debounceEvents$1: function(events) {
        var t1 = T._debounceAggregate(P.Duration$(0, 0, 0, 25, 0, 0), T.debounce___collectToList$closure()).bind$1(events);
        return new P._ExpandStream(new A._Watcher__debounceEvents_closure(), t1, [H.getRuntimeTypeArgument(t1, "Stream", 0), null]);
      },
      _recompileDownstream$1: function(nodes) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1, seen, toRecompile, node;
        var $async$_recompileDownstream$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = M.StylesheetNode;
                seen = P.LinkedHashSet_LinkedHashSet(null, null, null, t1);
                toRecompile = P.ListQueue_ListQueue$from(nodes, t1);
              case 2:
                // for condition
                if (!(toRecompile._collection$_head !== toRecompile._collection$_tail)) {
                  // goto after for
                  $async$goto = 3;
                  break;
                }
                node = toRecompile.removeFirst$0();
                if (!seen.add$1(0, node)) {
                  // goto for condition
                  $async$goto = 2;
                  break;
                }
                $async$goto = 4;
                return P._asyncAwait($async$self._compileIfEntrypoint$1(node.get$canonicalUrl()), $async$_recompileDownstream$1);
              case 4:
                // returning from await.
                toRecompile.addAll$1(0, node.get$downstream());
                // goto for condition
                $async$goto = 2;
                break;
              case 3:
                // after for
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$_recompileDownstream$1, $async$completer);
      },
      _compileIfEntrypoint$1: function(url) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$self = this, source, destination;
        var $async$_compileIfEntrypoint$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if (url.get$scheme() !== "file") {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                source = D.p().style.pathFromUri$1(M._parseUri(url));
                destination = $async$self._destinationFor$1(source);
                if (destination == null) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 3;
                return P._asyncAwait($async$self.compile$2(source, destination), $async$_compileIfEntrypoint$1);
              case 3:
                // returning from await.
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_compileIfEntrypoint$1, $async$completer);
      },
      _destinationFor$1: function(source) {
        var t1, destination, t2, sourceDir;
        t1 = this._watch$_options;
        t1._ensureSources$0();
        destination = t1._sourcesToDestinations.$index(0, source);
        if (destination != null)
          return destination;
        if (J.startsWith$1$s(X.ParsedPath_ParsedPath$parse(source, D.p().style).get$basename(), "_"))
          return;
        for (t1._ensureSources$0(), t2 = t1._sourceDirectoriesToDestinations.get$keys(), t2 = t2.get$iterator(t2); t2.moveNext$0();) {
          sourceDir = t2.get$current(t2);
          if (D.p()._isWithinOrEquals$2(sourceDir, source) === C._PathRelation_within) {
            t2 = D.p();
            t1._ensureSources$0();
            return t2.join$2(0, t1._sourceDirectoriesToDestinations.$index(0, sourceDir), D.p().withoutExtension$1(D.p().relative$2$from(source, sourceDir)) + ".css");
          }
        }
        return;
      },
      _retryPotentialImports$1: function(path) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$next = [], $async$self = this, node, url, newCanonicalUrl, $name, changed, t1, t2, t3, t4, t5, importChanged, t6, basename, exception, t7;
        var $async$_retryPotentialImports$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $name = $async$self._watch$_name$1(X.ParsedPath_ParsedPath$parse(path, D.p().style).get$basename());
                changed = H.setRuntimeTypeInfo([], [M.StylesheetNode]);
                for (t1 = $async$self._graph, t2 = t1._nodes.get$values(), t2 = t2.get$iterator(t2), t3 = t1._transitiveModificationTimes, t1 = t1.importCache, t4 = t1._canonicalizeCache; t2.moveNext$0();) {
                  node = t2.get$current(t2);
                  for (t5 = node.get$upstream()._collection$_map.get$keys(), t5 = t5.get$iterator(t5), importChanged = false; t5.moveNext$0();) {
                    url = t5.get$current(t5);
                    t6 = $.$get$url();
                    t6 = X.ParsedPath_ParsedPath$parse(J.get$path$x(url), t6.style).get$basename();
                    basename = D.p().withoutExtension$1(t6);
                    if ((C.JSString_methods.startsWith$1(basename, "_") ? C.JSString_methods.substring$1(basename, 1) : basename) !== $name)
                      continue;
                    t3.clear$0(0);
                    t4.remove$1(0, url);
                    if (!importChanged) {
                      newCanonicalUrl = null;
                      try {
                        t6 = t1.canonicalize$3(url, J.get$importer$x(node), node.get$canonicalUrl());
                        newCanonicalUrl = t6 == null ? null : t6.get$item2();
                      } catch (exception) {
                        H.unwrapException(exception);
                      }
                      t6 = newCanonicalUrl;
                      t7 = node.get$upstream()._collection$_map.$index(0, url);
                      importChanged = J.$eq$(t6, t7 == null ? null : t7.get$canonicalUrl()) !== true;
                    }
                  }
                  if (importChanged)
                    changed.push(node);
                }
                $async$goto = 2;
                return P._asyncAwait($async$self._recompileDownstream$1(changed), $async$_retryPotentialImports$1);
              case 2:
                // returning from await.
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$_retryPotentialImports$1, $async$completer);
      },
      _watch$_name$1: function(basename) {
        basename = D.p().withoutExtension$1(basename);
        return C.JSString_methods.startsWith$1(basename, "_") ? C.JSString_methods.substring$1(basename, 1) : basename;
      }
    },
    _Watcher__debounceEvents_closure: {
      "^": "Closure:0;",
      call$1: function(buffer) {
        var t1, t2, $event, t3, oldType;
        t1 = K.PathMap__create(null);
        for (t2 = J.get$iterator$ax(buffer); t2.moveNext$0();) {
          $event = t2.get$current(t2);
          t3 = J.getInterceptor$x($event);
          oldType = t1.$index(0, t3.get$path($event));
          if (oldType == null)
            t1.$indexSet(0, t3.get$path($event), $event.get$type());
          else if (J.$eq$($event.get$type(), C.ChangeType_remove) === true)
            t1.$indexSet(0, t3.get$path($event), C.ChangeType_remove);
          else if (J.$eq$(oldType, C.ChangeType_add) !== true)
            t1.$indexSet(0, t3.get$path($event), C.ChangeType_modify);
        }
        t2 = t1.get$keys();
        return H.MappedIterable_MappedIterable(t2, new A._Watcher__debounceEvents__closure(new K.PathMap(t1, [E.ChangeType])), H.getRuntimeTypeArgument(t2, "Iterable", 0), null);
      }
    },
    _Watcher__debounceEvents__closure: {
      "^": "Closure:0;typeForPath",
      call$1: [function(path) {
        return new E.WatchEvent(this.typeForPath._collection$_map.$index(0, path), path);
      }, null, null, 4, 0, null, 6, "call"]
    }
  }], ["", "package:sass/src/extend/extender.dart",, F, {
    "^": "",
    Extender: {
      "^": "Object;_selectors,_extensions,_extensionsByExtender,_mediaContexts,_sourceSpecificity,_originals,_mode",
      addSelector$3: function(selector, span, mediaContext) {
        var originalSelector, error, t1, t2, t3, _i, exception, rule;
        originalSelector = selector.get$value();
        for (t1 = originalSelector.get$components(), t2 = t1.length, t3 = this._originals, _i = 0; _i < t2; ++_i)
          t3.add$1(0, t1[_i]);
        t1 = this._extensions;
        if (t1.get$isNotEmpty(t1))
          try {
            selector = new F.CssValue(this._extendList$3(originalSelector, t1, mediaContext), selector.get$span(), [null]);
          } catch (exception) {
            t1 = H.unwrapException(exception);
            if (t1 instanceof E.SassException) {
              error = t1;
              throw H.wrapException(E.SassException$("From " + J.message$1$x(error.get$span(), "") + "\n" + H.S(J.get$message$x(error)), selector.get$span()));
            } else
              throw exception;
          }
        rule = X.CssStyleRule$(selector, span, originalSelector);
        if (mediaContext != null)
          this._mediaContexts.$indexSet(0, rule, mediaContext);
        this._registerSelector$2(selector.get$value(), rule);
        return rule;
      },
      _registerSelector$2: function(list, rule) {
        var t1, t2, t3, _i, t4, t5, _i0, component, t6, t7, _i1, simple;
        for (t1 = list.get$components(), t2 = t1.length, t3 = this._selectors, _i = 0; _i < t2; ++_i)
          for (t4 = t1[_i].get$components(), t5 = t4.length, _i0 = 0; _i0 < t5; ++_i0) {
            component = t4[_i0];
            if (component instanceof X.CompoundSelector)
              for (t6 = component.components, t7 = t6.length, _i1 = 0; _i1 < t7; ++_i1) {
                simple = t6[_i1];
                J.add$1$ax(t3.putIfAbsent$2(simple, new F.Extender__registerSelector_closure()), rule);
                if (simple instanceof D.PseudoSelector && simple.selector != null)
                  this._registerSelector$2(simple.get$selector(), rule);
              }
          }
      },
      addExtension$4: function(extender, target, extend, mediaContext) {
        var rules, t1, existingExtensions, sources, t2, t3, t4, t5, t6, t7, t8, t9, t10, newExtensions, _i, complex, existingState, t11, state, t12, _i0, component, t13, t14, _i1, simple;
        rules = this._selectors.$index(0, target);
        t1 = this._extensionsByExtender;
        existingExtensions = t1.$index(0, target);
        sources = this._extensions.putIfAbsent$2(target, new F.Extender_addExtension_closure());
        for (t2 = extender.value.get$components(), t3 = t2.length, t4 = rules == null, t5 = this._sourceSpecificity, t6 = J.getInterceptor$asx(sources), t7 = extender.span, t8 = extend.span, t9 = extend.isOptional, t10 = existingExtensions != null, newExtensions = null, _i = 0; _i < t3; ++_i) {
          complex = t2[_i];
          existingState = t6.$index(sources, complex);
          if (existingState != null) {
            existingState.addSource$3$optional(t8, mediaContext, t9);
            continue;
          }
          t11 = complex.get$maxSpecificity();
          state = new S.Extension(complex, target, t11, t9, false, mediaContext, t7, t8);
          t6.$indexSet(sources, complex, state);
          for (t11 = complex.get$components(), t12 = t11.length, _i0 = 0; _i0 < t12; ++_i0) {
            component = t11[_i0];
            if (component instanceof X.CompoundSelector)
              for (t13 = component.components, t14 = t13.length, _i1 = 0; _i1 < t14; ++_i1) {
                simple = t13[_i1];
                J.add$1$ax(t1.putIfAbsent$2(simple, new F.Extender_addExtension_closure0()), state);
                t5.putIfAbsent$2(simple, new F.Extender_addExtension_closure1(complex));
              }
          }
          if (!t4 || t10) {
            if (newExtensions == null)
              newExtensions = P.LinkedHashMap__makeEmpty();
            newExtensions.$indexSet(0, complex, state);
          }
        }
        if (newExtensions == null)
          return;
        if (t10)
          this._extendExistingExtensions$3(existingExtensions, target, newExtensions);
        if (!t4)
          this._extendExistingStyleRules$3(rules, target, newExtensions);
      },
      _extendExistingExtensions$3: function(extensions, newTarget, newExtensions) {
        var extension, lists, error, t1, t2, t3, additionalExtensions, sources, exception, containsExtension, t4, t5, t6, first, t7, complex, existingExtension, withExtender, t8, t9, _i, component, t10, t11, _i0;
        for (t1 = J.get$iterator$ax(J.toList$0$ax(extensions)), t2 = this._extensionsByExtender, t3 = this._extensions, additionalExtensions = null; t1.moveNext$0();) {
          extension = t1._current;
          sources = t3.$index(0, extension.get$target());
          lists = null;
          try {
            lists = this._extendComplex$3(extension.get$extender(), P.LinkedHashMap__makeLiteral([newTarget, newExtensions]), extension.get$mediaContext());
            if (lists == null)
              continue;
          } catch (exception) {
            t1 = H.unwrapException(exception);
            if (t1 instanceof E.SassException) {
              error = t1;
              throw H.wrapException(E.SassException$("From " + J.message$1$x(extension.get$extenderSpan(), "") + "\n" + H.S(J.get$message$x(error)), error.get$span()));
            } else
              throw exception;
          }
          containsExtension = J.$eq$(J.get$first$ax(J.get$first$ax(lists)), extension.get$extender());
          for (t4 = J.get$iterator$ax(lists), t5 = J.getInterceptor$asx(sources), t6 = containsExtension === true, first = false; t4.moveNext$0();)
            for (t7 = J.get$iterator$ax(t4._current); t7.moveNext$0();) {
              complex = t7.get$current(t7);
              if (t6 && first) {
                first = false;
                continue;
              }
              existingExtension = t5.$index(sources, complex);
              if (existingExtension != null)
                existingExtension.addSource$3$optional(extension.get$span(), extension.get$mediaContext(), extension.get$isOptional());
              else {
                withExtender = extension.withExtender$1(complex);
                t5.$indexSet(sources, complex, withExtender);
                for (t8 = complex.get$components(), t9 = t8.length, _i = 0; _i < t9; ++_i) {
                  component = t8[_i];
                  if (component instanceof X.CompoundSelector)
                    for (t10 = component.components, t11 = t10.length, _i0 = 0; _i0 < t11; ++_i0)
                      J.add$1$ax(t2.putIfAbsent$2(t10[_i0], new F.Extender__extendExistingExtensions_closure()), withExtender);
                }
                if (J.$eq$(extension.get$target(), newTarget) === true) {
                  if (additionalExtensions == null)
                    additionalExtensions = P.LinkedHashMap__makeEmpty();
                  additionalExtensions.$indexSet(0, complex, withExtender);
                }
              }
            }
          if (!t6)
            t5.remove$1(sources, extension.get$extender());
        }
        if (additionalExtensions != null)
          newExtensions.addAll$1(0, additionalExtensions);
      },
      _extendExistingStyleRules$3: function(rules, target, extensions) {
        var rule, error, t1, t2, oldValue, exception, t3;
        for (t1 = J.get$iterator$ax(rules), t2 = this._mediaContexts; t1.moveNext$0();) {
          rule = t1.get$current(t1);
          oldValue = rule.get$selector().get$value();
          try {
            rule.get$selector().set$value(this._extendList$3(rule.get$selector().get$value(), P.LinkedHashMap__makeLiteral([target, extensions]), t2.$index(0, rule)));
          } catch (exception) {
            t1 = H.unwrapException(exception);
            if (t1 instanceof E.SassException) {
              error = t1;
              throw H.wrapException(E.SassException$("From " + J.message$1$x(rule.get$selector().get$span(), "") + "\n" + H.S(J.get$message$x(error)), error.get$span()));
            } else
              throw exception;
          }
          t3 = rule.get$selector().get$value();
          if (oldValue == null ? t3 == null : oldValue === t3)
            continue;
          this._registerSelector$2(rule.get$selector().get$value(), rule);
        }
      },
      finalize$0: function() {
        this._extensions.forEach$1(0, new F.Extender_finalize_closure(this));
      },
      _extendList$3: function(list, extensions, mediaQueryContext) {
        var extended, i, t1, complex, result;
        for (extended = null, i = 0; i < list.get$components().length; ++i) {
          t1 = list.get$components();
          if (i >= t1.length)
            return H.ioore(t1, i);
          complex = t1[i];
          result = this._extendComplex$3(complex, extensions, mediaQueryContext);
          if (result == null) {
            if (extended != null)
              extended.push([complex]);
          } else {
            if (extended == null)
              if (i === 0)
                extended = [];
              else {
                t1 = C.JSArray_methods.sublist$2(list.get$components(), 0, i);
                t1 = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
                extended = [t1];
              }
            C.JSArray_methods.addAll$1(extended, result);
          }
        }
        if (extended == null)
          return list;
        t1 = this._originals;
        return D.SelectorList$(J.where$1$ax(this._trim$2(extended, t1.get$contains(t1)), new F.Extender__extendList_closure()));
      },
      _extendComplex$3: function(complex, extensions, mediaQueryContext) {
        var _box_0, isOriginal, extendedNotExpanded, i, t1, component, extended, result;
        _box_0 = {};
        isOriginal = this._originals.contains$1(0, complex);
        for (extendedNotExpanded = null, i = 0; i < complex.get$components().length; ++i) {
          t1 = complex.get$components();
          if (i >= t1.length)
            return H.ioore(t1, i);
          component = t1[i];
          if (component instanceof X.CompoundSelector) {
            extended = this._extendCompound$4$inOriginal(component, extensions, mediaQueryContext, isOriginal);
            if (extended == null) {
              if (!(extendedNotExpanded == null)) {
                result = P.List_List$from([component], false, null);
                result.fixed$length = Array;
                result.immutable$list = Array;
                t1 = result;
                if (t1.length === 0)
                  H.throwExpression(P.ArgumentError$("components may not be empty."));
                C.JSArray_methods.add$1(extendedNotExpanded, [new S.ComplexSelector(t1, false, null, null, null)]);
              }
            } else {
              if (extendedNotExpanded == null) {
                t1 = complex.get$components();
                t1 = H.SubListIterable$(t1, 0, i, H.getTypeArgumentByIndex(t1, 0));
                extendedNotExpanded = new H.MappedListIterable(t1, new F.Extender__extendComplex_closure(complex), [H.getTypeArgumentByIndex(t1, 0), null]).toList$0(0);
              }
              C.JSArray_methods.add$1(extendedNotExpanded, extended);
            }
          } else if (!(extendedNotExpanded == null)) {
            result = P.List_List$from([component], false, null);
            result.fixed$length = Array;
            result.immutable$list = Array;
            t1 = result;
            if (t1.length === 0)
              H.throwExpression(P.ArgumentError$("components may not be empty."));
            C.JSArray_methods.add$1(extendedNotExpanded, [new S.ComplexSelector(t1, false, null, null, null)]);
          }
        }
        if (extendedNotExpanded == null)
          return;
        _box_0.first = true;
        return J.toList$0$ax(J.map$1$ax(Y.paths(extendedNotExpanded), new F.Extender__extendComplex_closure0(_box_0, this, complex)));
      },
      _extendCompound$4$inOriginal: function(compound, extensions, mediaQueryContext, inOriginal) {
        var _box_1, t1, targetsUsed, t2, t3, t4, t5, options, i, simple, extended, result, t6, t7, compound0, first, unifiedPaths, isOriginal;
        _box_1 = {};
        t1 = this._mode;
        targetsUsed = t1 === C.ExtendMode_normal || extensions.get$length(extensions) < 2 ? null : P.LinkedHashSet_LinkedHashSet(null, null, null, M.SimpleSelector);
        for (t2 = compound.components, t3 = t2.length, t4 = H.getTypeArgumentByIndex(t2, 0), t5 = this._sourceSpecificity, options = null, i = 0; i < t3; ++i) {
          simple = t2[i];
          extended = this._extendSimple$4(simple, extensions, mediaQueryContext, targetsUsed);
          if (extended == null) {
            if (!(options == null)) {
              result = P.List_List$from([simple], false, null);
              result.fixed$length = Array;
              result.immutable$list = Array;
              t6 = result;
              if (t6.length === 0)
                H.throwExpression(P.ArgumentError$("components may not be empty."));
              result = P.List_List$from([new X.CompoundSelector(t6, null, null)], false, null);
              result.fixed$length = Array;
              result.immutable$list = Array;
              t6 = result;
              if (t6.length === 0)
                H.throwExpression(P.ArgumentError$("components may not be empty."));
              t7 = t5.$index(0, simple);
              if (t7 == null)
                t7 = 0;
              options.push([new S.Extension(new S.ComplexSelector(t6, false, null, null, null), null, t7, true, true, null, null, null)]);
            }
          } else {
            if (options == null) {
              options = [];
              if (i !== 0) {
                result = P.List_List$from(H.SubListIterable$(t2, 0, i, t4), false, null);
                result.fixed$length = Array;
                result.immutable$list = Array;
                t6 = result;
                compound0 = new X.CompoundSelector(t6, null, null);
                if (t6.length === 0)
                  H.throwExpression(P.ArgumentError$("components may not be empty."));
                result = P.List_List$from([compound0], false, null);
                result.fixed$length = Array;
                result.immutable$list = Array;
                t6 = result;
                if (t6.length === 0)
                  H.throwExpression(P.ArgumentError$("components may not be empty."));
                t7 = this._sourceSpecificityFor$1(compound0);
                options.push([new S.Extension(new S.ComplexSelector(t6, false, null, null, null), null, t7, true, true, null, null, null)]);
              }
            }
            C.JSArray_methods.addAll$1(options, extended);
          }
        }
        if (options == null)
          return;
        if (targetsUsed != null && targetsUsed._collection$_length !== extensions.get$length(extensions))
          return;
        if (options.length === 1)
          return J.toList$0$ax(J.map$1$ax(C.JSArray_methods.get$first(options), new F.Extender__extendCompound_closure(mediaQueryContext)));
        first = t1 !== C.ExtendMode_replace;
        _box_1.first = first;
        unifiedPaths = J.map$1$ax(Y.paths(options), new F.Extender__extendCompound_closure0(_box_1, this, compound, mediaQueryContext));
        isOriginal = new F.Extender__extendCompound_closure1();
        if (inOriginal && first)
          isOriginal = new F.Extender__extendCompound_closure2(J.get$first$ax(J.get$first$ax(unifiedPaths)));
        return this._trim$2(J.where$1$ax(unifiedPaths, new F.Extender__extendCompound_closure3()).toList$0(0), isOriginal);
      },
      _extendSimple$4: function(simple, extensions, mediaQueryContext, targetsUsed) {
        var t1, extended, result;
        t1 = new F.Extender__extendSimple_withoutPseudo(this, extensions, targetsUsed);
        if (simple instanceof D.PseudoSelector && simple.selector != null) {
          extended = this._extendPseudo$3(simple, extensions, mediaQueryContext);
          if (extended != null)
            return new H.MappedListIterable(extended, new F.Extender__extendSimple_closure(this, t1), [H.getTypeArgumentByIndex(extended, 0), null]);
        }
        result = t1.call$1(simple);
        return result == null ? null : [result];
      },
      _extensionForSimple$1: function(simple) {
        var t1, t2;
        t1 = S.ComplexSelector$([X.CompoundSelector$([simple])], false);
        t2 = this._sourceSpecificity.$index(0, simple);
        return S.Extension$oneOff(t1, true, t2 == null ? 0 : t2);
      },
      _extendPseudo$3: function(pseudo, extensions, mediaQueryContext) {
        var t1, extended, complexes, t2, t3, result;
        t1 = pseudo.selector;
        extended = this._extendList$3(t1, extensions, mediaQueryContext);
        if (extended == null ? t1 == null : extended === t1)
          return;
        complexes = extended.get$components();
        t2 = pseudo.normalizedName === "not";
        if (t2 && !C.JSArray_methods.any$1(t1.components, new F.Extender__extendPseudo_closure()) && C.JSArray_methods.any$1(extended.get$components(), new F.Extender__extendPseudo_closure0())) {
          t3 = extended.get$components();
          complexes = new H.WhereIterable(t3, new F.Extender__extendPseudo_closure1(), [H.getTypeArgumentByIndex(t3, 0)]);
        }
        complexes = J.expand$1$ax(complexes, new F.Extender__extendPseudo_closure2(pseudo));
        if (t2 && t1.components.length === 1) {
          t1 = H.MappedIterable_MappedIterable(complexes, new F.Extender__extendPseudo_closure3(pseudo), H.getRuntimeTypeArgument(complexes, "Iterable", 0), null);
          result = P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "Iterable", 0));
          return result.length === 0 ? null : result;
        } else {
          t1 = D.SelectorList$(complexes);
          t2 = pseudo.name;
          return [new D.PseudoSelector(t2, B.unvendor(t2), pseudo.isClass, pseudo.argument, t1, null, null)];
        }
      },
      _trim$2: function(lists, isOriginal) {
        var t1, result, i, numOriginals, t2, _box_0, complex1, j, t3, t4, _i, component;
        t1 = J.getInterceptor$asx(lists);
        if (t1.get$length(lists) > 100) {
          t1 = t1.expand$1(lists, new F.Extender__trim_closure());
          return P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "Iterable", 0));
        }
        result = Q.QueueList$(null, S.ComplexSelector);
        for (i = t1.get$length(lists) - 1, numOriginals = 0; i >= 0; --i)
          $label0$0:
            for (t2 = J.get$reversed$ax(t1.$index(lists, i)), t2 = new H.ListIterator(t2, t2.get$length(t2), 0, null, [H.getTypeArgumentByIndex(t2, 0)]); t2.moveNext$0();) {
              _box_0 = {};
              complex1 = t2.__internal$_current;
              if (isOriginal.call$1(complex1) === true) {
                for (j = 0; j < numOriginals; ++j)
                  if (J.$eq$(result.$index(0, j), complex1) === true) {
                    B.rotateSlice(result, 0, j + 1);
                    continue $label0$0;
                  }
                ++numOriginals;
                result.addFirst$1(complex1);
                continue $label0$0;
              }
              _box_0.maxSpecificity = 0;
              for (t3 = complex1.get$components(), t4 = t3.length, _i = 0; _i < t4; ++_i) {
                component = t3[_i];
                if (component instanceof X.CompoundSelector)
                  _box_0.maxSpecificity = Math.max(_box_0.maxSpecificity, this._sourceSpecificityFor$1(component));
              }
              if (result.any$1(result, new F.Extender__trim_closure0(_box_0, complex1)))
                continue $label0$0;
              if (t1.take$1(lists, i).any$1(0, new F.Extender__trim_closure1(_box_0, complex1)))
                continue $label0$0;
              result.addFirst$1(complex1);
            }
        return result;
      },
      _sourceSpecificityFor$1: function(compound) {
        var t1, t2, t3, specificity, _i, t4;
        for (t1 = compound.components, t2 = t1.length, t3 = this._sourceSpecificity, specificity = 0, _i = 0; _i < t2; ++_i) {
          t4 = t3.$index(0, t1[_i]);
          specificity = Math.max(specificity, H.checkNum(t4 == null ? 0 : t4));
        }
        return specificity;
      },
      static: {
        Extender__extendOrReplace: function(selector, source, targets, mode) {
          var t1, t2, map, t3, t4, t5, t6, t7, t8, t9, _i, complex, extensions, t10, t11, _i0;
          t1 = source.get$components();
          t2 = S.ComplexSelector;
          map = P.LinkedHashMap_LinkedHashMap(null, null, null, t2, S.Extension);
          P.MapBase__fillMapWithMappedIterable(map, t1, null, new F.Extender__extendOrReplace_closure());
          for (t1 = targets.get$components(), t3 = t1.length, t2 = [t2], t4 = M.SimpleSelector, t5 = [X.CssStyleRule, [P.List, F.CssMediaQuery]], t6 = [P.Set, X.CssStyleRule], t7 = [P.Map, S.ComplexSelector, S.Extension], t8 = [P.List, S.Extension], t9 = [t4, P.int], _i = 0; _i < t3; ++_i) {
            complex = t1[_i];
            if (complex.get$components().length !== 1)
              throw H.wrapException(E.SassScriptException$("Can't extend complex selector " + H.S(complex) + "."));
            extensions = P.LinkedHashMap_LinkedHashMap$_empty(t4, t7);
            for (t10 = H.interceptedTypeCast(C.JSArray_methods.get$first(complex.get$components()), "$isCompoundSelector").components, t11 = t10.length, _i0 = 0; _i0 < t11; ++_i0)
              extensions.$indexSet(0, t10[_i0], map);
            t10 = new P._LinkedIdentityHashSet(0, null, null, null, null, null, 0, t2);
            t10.addAll$1(0, selector.get$components());
            selector = new F.Extender(P.LinkedHashMap_LinkedHashMap$_empty(t4, t6), P.LinkedHashMap_LinkedHashMap$_empty(t4, t7), P.LinkedHashMap_LinkedHashMap$_empty(t4, t8), new H.JsLinkedHashMap(0, null, null, null, null, null, 0, t5), new P._LinkedIdentityHashMap(0, null, null, null, null, null, 0, t9), t10, mode)._extendList$3(selector, extensions, null);
          }
          return selector;
        }
      }
    },
    Extender__extendOrReplace_closure: {
      "^": "Closure:0;",
      call$1: function(complex) {
        return S.Extension$oneOff(H.interceptedTypeCast(complex, "$isComplexSelector"), false, null);
      }
    },
    Extender__registerSelector_closure: {
      "^": "Closure:1;",
      call$0: function() {
        return P.LinkedHashSet_LinkedHashSet(null, null, null, null);
      }
    },
    Extender_addExtension_closure: {
      "^": "Closure:1;",
      call$0: function() {
        return P.LinkedHashMap__makeEmpty();
      }
    },
    Extender_addExtension_closure0: {
      "^": "Closure:1;",
      call$0: function() {
        return [];
      }
    },
    Extender_addExtension_closure1: {
      "^": "Closure:1;complex",
      call$0: function() {
        return this.complex.get$maxSpecificity();
      }
    },
    Extender__extendExistingExtensions_closure: {
      "^": "Closure:1;",
      call$0: function() {
        return [];
      }
    },
    Extender_finalize_closure: {
      "^": "Closure:2;$this",
      call$2: function(target, extensions) {
        if (this.$this._selectors.containsKey$1(target))
          return;
        J.forEach$1$ax(extensions, new F.Extender_finalize__closure(target));
      }
    },
    Extender_finalize__closure: {
      "^": "Closure:2;target",
      call$2: function(_, extension) {
        if (extension.get$isOptional())
          return;
        throw H.wrapException(E.SassException$('The target selector was not found.\nUse "@extend ' + H.S(this.target) + ' !optional" to avoid this error.', extension.get$span()));
      }
    },
    Extender__extendList_closure: {
      "^": "Closure:0;",
      call$1: function(complex) {
        return complex != null;
      }
    },
    Extender__extendComplex_closure: {
      "^": "Closure:0;complex",
      call$1: [function(component) {
        return [S.ComplexSelector$([component], this.complex.get$lineBreak())];
      }, null, null, 4, 0, null, 31, "call"]
    },
    Extender__extendComplex_closure0: {
      "^": "Closure:0;_box_0,$this,complex",
      call$1: [function(path) {
        var t1 = Y.weave(J.toList$0$ax(J.map$1$ax(path, new F.Extender__extendComplex__closure())));
        return new H.MappedListIterable(t1, new F.Extender__extendComplex__closure0(this._box_0, this.$this, this.complex, path), [H.getTypeArgumentByIndex(t1, 0), null]).toList$0(0);
      }, null, null, 4, 0, null, 6, "call"]
    },
    Extender__extendComplex__closure: {
      "^": "Closure:0;",
      call$1: [function(complex) {
        return complex.get$components();
      }, null, null, 4, 0, null, 9, "call"]
    },
    Extender__extendComplex__closure0: {
      "^": "Closure:0;_box_0,$this,complex,path",
      call$1: [function(components) {
        var t1, outputComplex, t2;
        t1 = this.complex;
        outputComplex = S.ComplexSelector$(components, t1.get$lineBreak() || J.any$1$ax(this.path, new F.Extender__extendComplex___closure()) === true);
        t2 = this._box_0;
        if (t2.first && this.$this._originals.contains$1(0, t1))
          this.$this._originals.add$1(0, outputComplex);
        t2.first = false;
        return outputComplex;
      }, null, null, 4, 0, null, 34, "call"]
    },
    Extender__extendComplex___closure: {
      "^": "Closure:0;",
      call$1: function(inputComplex) {
        return inputComplex.get$lineBreak();
      }
    },
    Extender__extendCompound_closure: {
      "^": "Closure:0;mediaQueryContext",
      call$1: [function(state) {
        state.assertCompatibleMediaContext$1(this.mediaQueryContext);
        return state.get$extender();
      }, null, null, 4, 0, null, 87, "call"]
    },
    Extender__extendCompound_closure0: {
      "^": "Closure:0;_box_1,$this,compound,mediaQueryContext",
      call$1: [function(path) {
        var _box_0, t1, complexes, toUnify, originals, state, specificity, t2;
        _box_0 = {};
        t1 = this._box_1;
        if (t1.first) {
          t1.first = false;
          complexes = [[X.CompoundSelector$(J.expand$1$ax(path, new F.Extender__extendCompound__closure()))]];
        } else {
          toUnify = Q.QueueList$(null, [P.List, S.ComplexSelectorComponent]);
          for (t1 = J.get$iterator$ax(path), originals = null; t1.moveNext$0();) {
            state = t1.get$current(t1);
            if (state.get$isOriginal()) {
              if (originals == null)
                originals = [];
              C.JSArray_methods.addAll$1(originals, H.interceptedTypeCast(C.JSArray_methods.get$last(state.get$extender().get$components()), "$isCompoundSelector").components);
            } else
              toUnify._queue_list$_add$1(state.get$extender().get$components());
          }
          if (originals != null)
            toUnify.addFirst$1([X.CompoundSelector$(originals)]);
          complexes = Y.unifyComplex(toUnify);
          if (complexes == null)
            return;
        }
        _box_0.lineBreak = false;
        specificity = this.$this._sourceSpecificityFor$1(this.compound);
        for (t1 = J.get$iterator$ax(path), t2 = this.mediaQueryContext; t1.moveNext$0();) {
          state = t1.get$current(t1);
          state.assertCompatibleMediaContext$1(t2);
          _box_0.lineBreak = _box_0.lineBreak || state.get$extender().get$lineBreak();
          specificity = Math.max(specificity, H.checkNum(state.get$specificity()));
        }
        return J.map$1$ax(complexes, new F.Extender__extendCompound__closure0(_box_0)).toList$0(0);
      }, null, null, 4, 0, null, 6, "call"]
    },
    Extender__extendCompound__closure: {
      "^": "Closure:0;",
      call$1: function(state) {
        return H.interceptedTypeCast(C.JSArray_methods.get$last(state.get$extender().get$components()), "$isCompoundSelector").components;
      }
    },
    Extender__extendCompound__closure0: {
      "^": "Closure:0;_box_0",
      call$1: [function(components) {
        return S.ComplexSelector$(components, this._box_0.lineBreak);
      }, null, null, 4, 0, null, 34, "call"]
    },
    Extender__extendCompound_closure1: {
      "^": "Closure:57;",
      call$1: function(_) {
        return false;
      }
    },
    Extender__extendCompound_closure2: {
      "^": "Closure:0;original",
      call$1: function(complex) {
        return J.$eq$(complex, this.original);
      }
    },
    Extender__extendCompound_closure3: {
      "^": "Closure:0;",
      call$1: function(complexes) {
        return complexes != null;
      }
    },
    Extender__extendSimple_withoutPseudo: {
      "^": "Closure:54;$this,extensions,targetsUsed",
      call$1: function(simple) {
        var extenders, t1, t2, extenderList;
        extenders = this.extensions.$index(0, simple);
        if (extenders == null)
          return;
        t1 = this.targetsUsed;
        if (!(t1 == null))
          t1.add$1(0, simple);
        t1 = this.$this;
        if (t1._mode === C.ExtendMode_replace) {
          t1 = extenders.get$values();
          return P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "Iterable", 0));
        }
        t2 = J.$add$ansx(J.get$length$asx(extenders), 1);
        if (typeof t2 !== "number")
          return H.iae(t2);
        t2 = new Array(t2);
        t2.fixed$length = Array;
        extenderList = H.setRuntimeTypeInfo(t2, [S.Extension]);
        t1 = t1._extensionForSimple$1(simple);
        t2 = extenderList.length;
        if (0 >= t2)
          return H.ioore(extenderList, 0);
        extenderList[0] = t1;
        C.JSArray_methods.setRange$3(extenderList, 1, t2, extenders.get$values());
        return extenderList;
      }
    },
    Extender__extendSimple_closure: {
      "^": "Closure:0;$this,withoutPseudo",
      call$1: [function(pseudo) {
        var t1 = this.withoutPseudo.call$1(pseudo);
        return t1 == null ? [this.$this._extensionForSimple$1(pseudo)] : t1;
      }, null, null, 4, 0, null, 83, "call"]
    },
    Extender__extendPseudo_closure: {
      "^": "Closure:0;",
      call$1: function(complex) {
        return complex.get$components().length > 1;
      }
    },
    Extender__extendPseudo_closure0: {
      "^": "Closure:0;",
      call$1: function(complex) {
        return complex.get$components().length === 1;
      }
    },
    Extender__extendPseudo_closure1: {
      "^": "Closure:0;",
      call$1: function(complex) {
        return complex.get$components().length <= 1;
      }
    },
    Extender__extendPseudo_closure2: {
      "^": "Closure:0;pseudo",
      call$1: function(complex) {
        var t1, innerPseudo, t2, t3;
        if (complex.get$components().length !== 1)
          return [complex];
        if (!(C.JSArray_methods.get$first(complex.get$components()) instanceof X.CompoundSelector))
          return [complex];
        t1 = H.interceptedTypeCast(C.JSArray_methods.get$first(complex.get$components()), "$isCompoundSelector").components;
        if (t1.length !== 1)
          return [complex];
        if (!(C.JSArray_methods.get$first(t1) instanceof D.PseudoSelector))
          return [complex];
        innerPseudo = H.interceptedTypeCast(C.JSArray_methods.get$first(t1), "$isPseudoSelector");
        t1 = innerPseudo.selector;
        if (t1 == null)
          return [complex];
        t2 = this.pseudo;
        switch (t2.normalizedName) {
          case "not":
            if (innerPseudo.normalizedName !== "matches")
              return [];
            return t1.components;
          case "matches":
          case "any":
          case "current":
          case "nth-child":
          case "nth-last-child":
            if (innerPseudo.name !== t2.name)
              return [];
            t3 = innerPseudo.argument;
            t2 = t2.argument;
            if (t3 == null ? t2 != null : t3 !== t2)
              return [];
            return t1.components;
          case "has":
          case "host":
          case "host-context":
          case "slotted":
            return [complex];
          default:
            return [];
        }
      }
    },
    Extender__extendPseudo_closure3: {
      "^": "Closure:0;pseudo",
      call$1: [function(complex) {
        var t1, t2, t3;
        t1 = this.pseudo;
        t2 = D.SelectorList$([complex]);
        t3 = t1.name;
        return new D.PseudoSelector(t3, B.unvendor(t3), t1.isClass, t1.argument, t2, null, null);
      }, null, null, 4, 0, null, 9, "call"]
    },
    Extender__trim_closure: {
      "^": "Closure:0;",
      call$1: function(selectors) {
        return selectors;
      }
    },
    Extender__trim_closure0: {
      "^": "Closure:0;_box_0,complex1",
      call$1: function(complex2) {
        var t1, t2;
        t1 = complex2.get$minSpecificity();
        t2 = this._box_0.maxSpecificity;
        if (typeof t1 !== "number")
          return t1.$ge();
        return t1 >= t2 && complex2.isSuperselector$1(this.complex1) === true;
      }
    },
    Extender__trim_closure1: {
      "^": "Closure:0;_box_0,complex1",
      call$1: function(list) {
        return J.any$1$ax(list, new F.Extender__trim__closure(this._box_0, this.complex1));
      }
    },
    Extender__trim__closure: {
      "^": "Closure:0;_box_0,complex1",
      call$1: function(complex2) {
        var t1, t2;
        t1 = complex2.get$minSpecificity();
        t2 = this._box_0.maxSpecificity;
        if (typeof t1 !== "number")
          return t1.$ge();
        return t1 >= t2 && complex2.isSuperselector$1(this.complex1) === true;
      }
    }
  }], ["", "package:sass/src/extend/extension.dart",, S, {
    "^": "",
    Extension: {
      "^": "Object;extender<,target<,specificity<,_isOptional,isOriginal<,_mediaContext,extenderSpan<,_extension$_span",
      get$isOptional: function() {
        return this._isOptional;
      },
      get$mediaContext: function() {
        return this._mediaContext;
      },
      get$span: function() {
        return this._extension$_span;
      },
      assertCompatibleMediaContext$1: function(mediaContext) {
        var t1 = this._mediaContext;
        if (t1 == null)
          return;
        if (mediaContext != null && C.ListEquality_DefaultEquality.equals$2(t1, mediaContext))
          return;
        throw H.wrapException(E.SassException$("You may not @extend selectors across media queries.", this._extension$_span));
      },
      addSource$3$optional: function(span, mediaContext, optional) {
        var t1;
        if (mediaContext != null) {
          t1 = this._mediaContext;
          if (t1 == null)
            this._mediaContext = mediaContext;
          else if (!C.ListEquality_DefaultEquality.equals$2(t1, mediaContext))
            throw H.wrapException(E.SassException$("From " + J.message$1$x(this._extension$_span, "") + "\nYou may not @extend the same selector from within different media queries.", span));
        }
        if (optional || !this._isOptional)
          return;
        this._extension$_span = span;
        this._isOptional = false;
      },
      withExtender$1: function(newExtender) {
        return S.Extension$(newExtender, this.target, this.extenderSpan, this._extension$_span, this._mediaContext, this._isOptional, this.specificity);
      },
      toString$0: function(_) {
        return J.toString$0$(this.extender);
      },
      static: {
        Extension$: function(extender, target, extenderSpan, _span, _mediaContext, optional, specificity) {
          return new S.Extension(extender, target, specificity == null ? extender.get$maxSpecificity() : specificity, optional, false, _mediaContext, extenderSpan, _span);
        },
        Extension$oneOff: function(extender, isOriginal, specificity) {
          return new S.Extension(extender, null, specificity == null ? extender.get$maxSpecificity() : specificity, true, isOriginal, null, null, null);
        }
      }
    }
  }], ["", "package:sass/src/extend/functions.dart",, Y, {
    "^": "",
    unifyComplex: function(complexes) {
      var t1, t2, unifiedBase, base, t3, t4, _i, complexesWithoutBases;
      t1 = J.getInterceptor$asx(complexes);
      if (t1.get$length(complexes) === 1)
        return complexes;
      for (t2 = t1.get$iterator(complexes), unifiedBase = null; t2.moveNext$0();) {
        base = J.get$last$ax(t2.get$current(t2));
        if (base instanceof X.CompoundSelector)
          if (unifiedBase == null)
            unifiedBase = base.components;
          else
            for (t3 = base.components, t4 = t3.length, _i = 0; _i < t4; ++_i) {
              unifiedBase = t3[_i].unify$1(unifiedBase);
              if (unifiedBase == null)
                return;
            }
        else
          return;
      }
      complexesWithoutBases = t1.map$1(complexes, new Y.unifyComplex_closure()).toList$0(0);
      J.add$1$ax(C.JSArray_methods.get$last(complexesWithoutBases), X.CompoundSelector$(unifiedBase));
      return Y.weave(complexesWithoutBases);
    },
    unifyCompound: function(compound1, compound2) {
      var t1, result, _i;
      for (t1 = compound1.length, result = compound2, _i = 0; _i < t1; ++_i) {
        result = compound1[_i].unify$1(result);
        if (result == null)
          return;
      }
      return X.CompoundSelector$(result);
    },
    unifyUniversalAndElement: function(selector1, selector2) {
      var namespace1, name1, t1, namespace2, name2, namespace, $name;
      if (!!selector1.$isUniversalSelector) {
        namespace1 = selector1.namespace;
        name1 = null;
      } else if (!!selector1.$isTypeSelector) {
        t1 = selector1.name;
        namespace1 = t1.namespace;
        name1 = t1.name;
      } else
        throw H.wrapException(P.ArgumentError$value(selector1, "selector1", "must be a UniversalSelector or a TypeSelector"));
      t1 = J.getInterceptor(selector2);
      if (!!t1.$isUniversalSelector) {
        namespace2 = selector2.namespace;
        name2 = null;
      } else if (!!t1.$isTypeSelector) {
        t1 = selector2.name;
        namespace2 = t1.namespace;
        name2 = t1.name;
      } else
        throw H.wrapException(P.ArgumentError$value(selector2, "selector2", "must be a UniversalSelector or a TypeSelector"));
      if ((namespace1 == null ? namespace2 == null : namespace1 === namespace2) || namespace2 === "*")
        namespace = namespace1;
      else {
        if (!(namespace1 === "*"))
          return;
        namespace = namespace2;
      }
      if ((name1 == null ? name2 == null : name1 === name2) || name2 == null)
        $name = name1;
      else {
        if (!(name1 == null || name1 === "*"))
          return;
        $name = name2;
      }
      return $name == null ? new N.UniversalSelector(namespace) : new F.TypeSelector(new D.QualifiedName($name, namespace));
    },
    weave: function(complexes) {
      var t1, prefixes, t2, complex, t3, target, _i, parents, newPrefixes, parentPrefixes, t4, parentPrefix;
      t1 = J.getInterceptor$ax(complexes);
      prefixes = [J.toList$0$ax(t1.get$first(complexes))];
      for (t1 = t1.skip$1(complexes, 1), t1 = new H.ListIterator(t1, t1.get$length(t1), 0, null, [H.getTypeArgumentByIndex(t1, 0)]), t2 = [[P.List, S.ComplexSelectorComponent]]; t1.moveNext$0();) {
        complex = t1.__internal$_current;
        t3 = J.getInterceptor$asx(complex);
        if (t3.get$isEmpty(complex) === true)
          continue;
        target = t3.get$last(complex);
        if (J.$eq$(t3.get$length(complex), 1) === true) {
          for (t3 = prefixes.length, _i = 0; _i < prefixes.length; prefixes.length === t3 || (0, H.throwConcurrentModificationError)(prefixes), ++_i)
            J.add$1$ax(prefixes[_i], target);
          continue;
        }
        parents = J.toList$0$ax(t3.take$1(complex, J.$sub$n(t3.get$length(complex), 1)));
        newPrefixes = H.setRuntimeTypeInfo([], t2);
        for (t3 = prefixes.length, _i = 0; _i < prefixes.length; prefixes.length === t3 || (0, H.throwConcurrentModificationError)(prefixes), ++_i) {
          parentPrefixes = Y._weaveParents(prefixes[_i], parents);
          if (parentPrefixes == null)
            continue;
          for (t4 = J.get$iterator$ax(parentPrefixes); t4.moveNext$0();) {
            parentPrefix = t4.get$current(t4);
            J.add$1$ax(parentPrefix, target);
            newPrefixes.push(parentPrefix);
          }
        }
        prefixes = newPrefixes;
      }
      return prefixes;
    },
    _weaveParents: function(parents1, parents2) {
      var t1, queue1, queue2, initialCombinators, finalCombinators, root1, root2, root, groups1, groups2, lcs, choices, _i, group, t2;
      t1 = S.ComplexSelectorComponent;
      queue1 = P.ListQueue_ListQueue$from(parents1, t1);
      queue2 = P.ListQueue_ListQueue$from(parents2, t1);
      initialCombinators = Y._mergeInitialCombinators(queue1, queue2);
      if (initialCombinators == null)
        return;
      finalCombinators = Y._mergeFinalCombinators(queue1, queue2, null);
      if (finalCombinators == null)
        return;
      root1 = Y._firstIfRoot(queue1);
      root2 = Y._firstIfRoot(queue2);
      t1 = root1 != null;
      if (t1 && root2 != null) {
        root = Y.unifyCompound(root1.components, root2.components);
        if (root == null)
          return;
        queue1.addFirst$1(root);
        queue2.addFirst$1(root);
      } else if (t1)
        queue2.addFirst$1(root1);
      else if (root2 != null)
        queue1.addFirst$1(root2);
      groups1 = Y._groupSelectors(queue1);
      groups2 = Y._groupSelectors(queue2);
      lcs = B.longestCommonSubsequence(groups2, groups1, new Y._weaveParents_closure());
      choices = [H.setRuntimeTypeInfo([initialCombinators], [[P.Iterable, S.ComplexSelectorComponent]])];
      for (t1 = lcs.length, _i = 0; _i < lcs.length; lcs.length === t1 || (0, H.throwConcurrentModificationError)(lcs), ++_i) {
        group = lcs[_i];
        t2 = Y._chunks(groups1, groups2, new Y._weaveParents_closure0(group));
        choices.push(new H.MappedListIterable(t2, new Y._weaveParents_closure1(), [H.getTypeArgumentByIndex(t2, 0), null]).toList$0(0));
        choices.push([group]);
        groups1.removeFirst$0();
        groups2.removeFirst$0();
      }
      t1 = Y._chunks(groups1, groups2, new Y._weaveParents_closure2());
      choices.push(new H.MappedListIterable(t1, new Y._weaveParents_closure3(), [H.getTypeArgumentByIndex(t1, 0), null]).toList$0(0));
      C.JSArray_methods.addAll$1(choices, finalCombinators);
      return J.map$1$ax(Y.paths(new H.WhereIterable(choices, new Y._weaveParents_closure4(), [H.getTypeArgumentByIndex(choices, 0)])), new Y._weaveParents_closure5());
    },
    _firstIfRoot: function(queue) {
      var first;
      if (queue._collection$_head === queue._collection$_tail)
        return;
      first = queue.get$first(queue);
      if (first instanceof X.CompoundSelector) {
        if (!Y._hasRoot(first))
          return;
        queue.removeFirst$0();
        return first;
      } else
        return;
    },
    _mergeInitialCombinators: function(components1, components2) {
      var t1, combinators1, t2, t3, combinators2, lcs;
      t1 = [S.Combinator];
      combinators1 = H.setRuntimeTypeInfo([], t1);
      while (true) {
        if (!components1.get$isEmpty(components1)) {
          t2 = components1._collection$_head;
          if (t2 === components1._collection$_tail)
            H.throwExpression(H.IterableElementError_noElement());
          t3 = components1._collection$_table;
          if (t2 >= t3.length)
            return H.ioore(t3, t2);
          t2 = t3[t2] instanceof S.Combinator;
        } else
          t2 = false;
        if (!t2)
          break;
        combinators1.push(H.interceptedTypeCast(components1.removeFirst$0(), "$isCombinator"));
      }
      combinators2 = H.setRuntimeTypeInfo([], t1);
      while (true) {
        if (!components2.get$isEmpty(components2)) {
          t1 = components2._collection$_head;
          if (t1 === components2._collection$_tail)
            H.throwExpression(H.IterableElementError_noElement());
          t2 = components2._collection$_table;
          if (t1 >= t2.length)
            return H.ioore(t2, t1);
          t1 = t2[t1] instanceof S.Combinator;
        } else
          t1 = false;
        if (!t1)
          break;
        combinators2.push(H.interceptedTypeCast(components2.removeFirst$0(), "$isCombinator"));
      }
      lcs = B.longestCommonSubsequence(combinators1, combinators2, null);
      if (C.ListEquality_DefaultEquality.equals$2(lcs, combinators1))
        return combinators2;
      if (C.ListEquality_DefaultEquality.equals$2(lcs, combinators2))
        return combinators1;
      return;
    },
    _mergeFinalCombinators: function(components1, components2, result) {
      var t1, combinators1, combinators2, lcs, combinator1, combinator2, compound1, compound2, choices, unified, t2, followingSiblingSelector, nextSiblingSelector;
      if (result == null)
        result = Q.QueueList$(null, null);
      if (components1._collection$_head === components1._collection$_tail || !(components1.get$last(components1) instanceof S.Combinator))
        t1 = components2._collection$_head === components2._collection$_tail || !(components2.get$last(components2) instanceof S.Combinator);
      else
        t1 = false;
      if (t1)
        return result;
      t1 = [S.Combinator];
      combinators1 = H.setRuntimeTypeInfo([], t1);
      while (true) {
        if (!(!components1.get$isEmpty(components1) && components1.get$last(components1) instanceof S.Combinator))
          break;
        combinators1.push(H.interceptedTypeCast(components1.removeLast$0(0), "$isCombinator"));
      }
      combinators2 = H.setRuntimeTypeInfo([], t1);
      while (true) {
        if (!(!components2.get$isEmpty(components2) && components2.get$last(components2) instanceof S.Combinator))
          break;
        combinators2.push(H.interceptedTypeCast(components2.removeLast$0(0), "$isCombinator"));
      }
      t1 = combinators1.length;
      if (t1 > 1 || combinators2.length > 1) {
        lcs = B.longestCommonSubsequence(combinators1, combinators2, null);
        if (C.ListEquality_DefaultEquality.equals$2(lcs, combinators1))
          result.addFirst$1([P.List_List$from(new H.ReversedListIterable(combinators2, [H.getTypeArgumentByIndex(combinators2, 0)]), true, null)]);
        else if (C.ListEquality_DefaultEquality.equals$2(lcs, combinators2))
          result.addFirst$1([P.List_List$from(new H.ReversedListIterable(combinators1, [H.getTypeArgumentByIndex(combinators1, 0)]), true, null)]);
        else
          return;
        return result;
      }
      combinator1 = t1 === 0 ? null : C.JSArray_methods.get$first(combinators1);
      combinator2 = combinators2.length === 0 ? null : C.JSArray_methods.get$first(combinators2);
      t1 = combinator1 != null;
      if (t1 && combinator2 != null) {
        compound1 = H.interceptedTypeCast(components1.removeLast$0(0), "$isCompoundSelector");
        compound2 = H.interceptedTypeCast(components2.removeLast$0(0), "$isCompoundSelector");
        t1 = J.getInterceptor(combinator1);
        if (t1.$eq(combinator1, C.Combinator_CzM) === true && J.$eq$(combinator2, C.Combinator_CzM) === true) {
          compound1.toString;
          if (Y.compoundIsSuperselector(compound1, compound2, null))
            result.addFirst$1([[compound2, C.Combinator_CzM]]);
          else {
            compound2.toString;
            if (Y.compoundIsSuperselector(compound2, compound1, null))
              result.addFirst$1([[compound1, C.Combinator_CzM]]);
            else {
              choices = [[compound1, C.Combinator_CzM, compound2, C.Combinator_CzM], [compound2, C.Combinator_CzM, compound1, C.Combinator_CzM]];
              unified = Y.unifyCompound(compound1.components, compound2.components);
              if (unified != null)
                choices.push([unified, C.Combinator_CzM]);
              result.addFirst$1(choices);
            }
          }
        } else {
          if (!(t1.$eq(combinator1, C.Combinator_CzM) === true && J.$eq$(combinator2, C.Combinator_uzg) === true))
            t2 = t1.$eq(combinator1, C.Combinator_uzg) === true && J.$eq$(combinator2, C.Combinator_CzM) === true;
          else
            t2 = true;
          if (t2) {
            followingSiblingSelector = t1.$eq(combinator1, C.Combinator_CzM) === true ? compound1 : compound2;
            nextSiblingSelector = t1.$eq(combinator1, C.Combinator_CzM) === true ? compound2 : compound1;
            followingSiblingSelector.toString;
            if (Y.compoundIsSuperselector(followingSiblingSelector, nextSiblingSelector, null))
              result.addFirst$1([[nextSiblingSelector, C.Combinator_uzg]]);
            else {
              choices = [[followingSiblingSelector, C.Combinator_CzM, nextSiblingSelector, C.Combinator_uzg]];
              unified = Y.unifyCompound(compound1.components, compound2.components);
              if (unified != null)
                choices.push([unified, C.Combinator_uzg]);
              result.addFirst$1(choices);
            }
          } else {
            if (t1.$eq(combinator1, C.Combinator_sgq) === true) {
              t2 = J.getInterceptor(combinator2);
              t2 = t2.$eq(combinator2, C.Combinator_uzg) === true || t2.$eq(combinator2, C.Combinator_CzM) === true;
            } else
              t2 = false;
            if (t2) {
              result.addFirst$1([[compound2, combinator2]]);
              components1._add$1(compound1);
              components1._add$1(C.Combinator_sgq);
            } else {
              if (J.$eq$(combinator2, C.Combinator_sgq) === true)
                t2 = t1.$eq(combinator1, C.Combinator_uzg) === true || t1.$eq(combinator1, C.Combinator_CzM) === true;
              else
                t2 = false;
              if (t2) {
                result.addFirst$1([[compound1, combinator1]]);
                components2._add$1(compound2);
                components2._add$1(C.Combinator_sgq);
              } else if (t1.$eq(combinator1, combinator2) === true) {
                unified = Y.unifyCompound(compound1.components, compound2.components);
                if (unified == null)
                  return;
                result.addFirst$1([[unified, combinator1]]);
              } else
                return;
            }
          }
        }
        return Y._mergeFinalCombinators(components1, components2, result);
      } else if (t1) {
        if (J.$eq$(combinator1, C.Combinator_sgq) === true)
          if (!components2.get$isEmpty(components2)) {
            t1 = H.interceptedTypeCast(components2.get$last(components2), "$isCompoundSelector");
            t2 = H.interceptedTypeCast(components1.get$last(components1), "$isCompoundSelector");
            t1.toString;
            t2 = Y.compoundIsSuperselector(t1, t2, null);
            t1 = t2;
          } else
            t1 = false;
        else
          t1 = false;
        if (t1)
          components2.removeLast$0(0);
        result.addFirst$1([[components1.removeLast$0(0), combinator1]]);
        return Y._mergeFinalCombinators(components1, components2, result);
      } else {
        if (J.$eq$(combinator2, C.Combinator_sgq) === true)
          if (!components1.get$isEmpty(components1)) {
            t1 = H.interceptedTypeCast(components1.get$last(components1), "$isCompoundSelector");
            t2 = H.interceptedTypeCast(components2.get$last(components2), "$isCompoundSelector");
            t1.toString;
            t2 = Y.compoundIsSuperselector(t1, t2, null);
            t1 = t2;
          } else
            t1 = false;
        else
          t1 = false;
        if (t1)
          components1.removeLast$0(0);
        result.addFirst$1([[components2.removeLast$0(0), combinator2]]);
        return Y._mergeFinalCombinators(components1, components2, result);
      }
    },
    _mustUnify: function(complex1, complex2) {
      var uniqueSelectors, t1, component, t2;
      uniqueSelectors = P.LinkedHashSet_LinkedHashSet(null, null, null, M.SimpleSelector);
      for (t1 = J.get$iterator$ax(complex1); t1.moveNext$0();) {
        component = t1.get$current(t1);
        if (component instanceof X.CompoundSelector) {
          t2 = component.components;
          uniqueSelectors.addAll$1(0, new H.WhereIterable(t2, Y.functions0___isUnique$closure(), [H.getTypeArgumentByIndex(t2, 0)]));
        }
      }
      if (uniqueSelectors._collection$_length === 0)
        return false;
      return J.any$1$ax(complex2, new Y._mustUnify_closure(uniqueSelectors));
    },
    _isUnique: [function(simple) {
      var t1 = J.getInterceptor(simple);
      if (!t1.$isIDSelector)
        t1 = !!t1.$isPseudoSelector && !simple.isClass;
      else
        t1 = true;
      return t1;
    }, "call$1", "functions0___isUnique$closure", 4, 0, 92],
    _chunks: function(queue1, queue2, done) {
      var chunk1, chunk2, t1;
      chunk1 = [];
      for (; done.call$1(queue1) !== true;)
        chunk1.push(queue1.removeFirst$0());
      chunk2 = [];
      for (; done.call$1(queue2) !== true;)
        chunk2.push(queue2.removeFirst$0());
      t1 = chunk1.length === 0;
      if (t1 && chunk2.length === 0)
        return [];
      if (t1)
        return [chunk2];
      if (chunk2.length === 0)
        return [chunk1];
      t1 = H.setRuntimeTypeInfo(chunk1.slice(0), [H.getTypeArgumentByIndex(chunk1, 0)]);
      C.JSArray_methods.addAll$1(t1, chunk2);
      C.JSArray_methods.addAll$1(chunk2, chunk1);
      return [t1, chunk2];
    },
    paths: function(choices) {
      return J.fold$2$ax(choices, [[]], new Y.paths_closure());
    },
    _groupSelectors: function(complex) {
      var groups, iterator, t1, group, t2;
      groups = Q.QueueList$(null, [P.List, S.ComplexSelectorComponent]);
      iterator = new P._ListQueueIterator(complex, complex._collection$_tail, complex._modificationCount, complex._collection$_head, null, [H.getTypeArgumentByIndex(complex, 0)]);
      iterator.moveNext$0();
      for (t1 = [S.ComplexSelectorComponent]; iterator._collection$_current != null;) {
        group = H.setRuntimeTypeInfo([], t1);
        do {
          group.push(iterator._collection$_current);
          if (iterator.moveNext$0())
            t2 = iterator._collection$_current instanceof S.Combinator || C.JSArray_methods.get$last(group) instanceof S.Combinator;
          else
            t2 = false;
        } while (t2);
        groups._queue_list$_add$1(group);
      }
      return groups;
    },
    _hasRoot: function(compound) {
      return C.JSArray_methods.any$1(compound.components, new Y._hasRoot_closure());
    },
    listIsSuperslector: function(list1, list2) {
      return C.JSArray_methods.every$1(list2, new Y.listIsSuperslector_closure(list1));
    },
    complexIsParentSuperselector: function(complex1, complex2) {
      var t1, t2, base;
      t1 = J.getInterceptor$ax(complex1);
      if (t1.get$first(complex1) instanceof S.Combinator)
        return false;
      t2 = J.getInterceptor$ax(complex2);
      if (t2.get$first(complex2) instanceof S.Combinator)
        return false;
      if (J.$gt$n(t1.get$length(complex1), t2.get$length(complex2)))
        return false;
      base = X.CompoundSelector$([new N.PlaceholderSelector("<temp>")]);
      t1 = t1.toList$0(complex1);
      J.add$1$ax(t1, base);
      t2 = t2.toList$0(complex2);
      J.add$1$ax(t2, base);
      return Y.complexIsSuperselector(t1, t2);
    },
    complexIsSuperselector: function(complex1, complex2) {
      var t1, t2, i1, i2, remaining1, remaining2, compound1, afterSuperselector, afterSuperselector0, t3, compound2, i10, combinator1, combinator2;
      t1 = J.getInterceptor$ax(complex1);
      if (t1.get$last(complex1) instanceof S.Combinator)
        return false;
      t2 = J.getInterceptor$ax(complex2);
      if (t2.get$last(complex2) instanceof S.Combinator)
        return false;
      for (i1 = 0, i2 = 0; true;) {
        remaining1 = t1.get$length(complex1) - i1;
        remaining2 = t2.get$length(complex2) - i2;
        if (remaining1 === 0 || remaining2 === 0)
          return false;
        if (remaining1 > remaining2)
          return false;
        if (t1.$index(complex1, i1) instanceof S.Combinator)
          return false;
        if (t2.$index(complex2, i2) instanceof S.Combinator)
          return false;
        compound1 = H.interceptedTypeCast(t1.$index(complex1, i1), "$isCompoundSelector");
        if (remaining1 === 1)
          return Y.compoundIsSuperselector(compound1, H.interceptedTypeCast(t2.get$last(complex2), "$isCompoundSelector"), t2.skip$1(complex2, i2 + 1));
        afterSuperselector = i2 + 1;
        for (afterSuperselector0 = afterSuperselector; afterSuperselector0 < t2.get$length(complex2); ++afterSuperselector0) {
          t3 = afterSuperselector0 - 1;
          compound2 = t2.$index(complex2, t3);
          if (compound2 instanceof X.CompoundSelector)
            if (Y.compoundIsSuperselector(compound1, compound2, t2.take$1(complex2, t3).skip$1(0, afterSuperselector)))
              break;
        }
        if (afterSuperselector0 === t2.get$length(complex2))
          return false;
        i10 = i1 + 1;
        combinator1 = t1.$index(complex1, i10);
        combinator2 = t2.$index(complex2, afterSuperselector0);
        if (combinator1 instanceof S.Combinator) {
          if (!(combinator2 instanceof S.Combinator))
            return false;
          if (combinator1 === C.Combinator_CzM) {
            if (combinator2 === C.Combinator_sgq)
              return false;
          } else if (combinator2 !== combinator1)
            return false;
          if (remaining1 === 3 && remaining2 > 3)
            return false;
          i1 += 2;
          i2 = afterSuperselector0 + 1;
        } else {
          if (combinator2 instanceof S.Combinator) {
            if (combinator2 !== C.Combinator_sgq)
              return false;
            i2 = afterSuperselector0 + 1;
          } else
            i2 = afterSuperselector0;
          i1 = i10;
        }
      }
    },
    compoundIsSuperselector: function(compound1, compound2, parents) {
      var t1, t2, _i, simple1, simple2;
      for (t1 = compound1.components, t2 = t1.length, _i = 0; _i < t2; ++_i) {
        simple1 = t1[_i];
        if (simple1 instanceof D.PseudoSelector && simple1.selector != null) {
          if (!Y._selectorPseudoIsSuperselector(simple1, compound2, parents))
            return false;
        } else if (!Y._simpleIsSuperselectorOfCompound(simple1, compound2))
          return false;
      }
      for (t1 = compound2.get$components(), t2 = t1.length, _i = 0; _i < t2; ++_i) {
        simple2 = t1[_i];
        if (simple2 instanceof D.PseudoSelector && !simple2.isClass && !Y._simpleIsSuperselectorOfCompound(simple2, compound1))
          return false;
      }
      return true;
    },
    _simpleIsSuperselectorOfCompound: function(simple, compound) {
      return C.JSArray_methods.any$1(compound.get$components(), new Y._simpleIsSuperselectorOfCompound_closure(simple));
    },
    _selectorPseudoIsSuperselector: function(pseudo1, compound2, parents) {
      switch (pseudo1.normalizedName) {
        case "matches":
        case "any":
          return Y._selectorPseudosNamed(compound2, pseudo1.name).any$1(0, new Y._selectorPseudoIsSuperselector_closure(pseudo1)) || C.JSArray_methods.any$1(pseudo1.selector.components, new Y._selectorPseudoIsSuperselector_closure0(parents, compound2));
        case "has":
        case "host":
        case "host-context":
        case "slotted":
          return Y._selectorPseudosNamed(compound2, pseudo1.name).any$1(0, new Y._selectorPseudoIsSuperselector_closure1(pseudo1));
        case "not":
          return C.JSArray_methods.every$1(pseudo1.selector.components, new Y._selectorPseudoIsSuperselector_closure2(compound2, pseudo1));
        case "current":
          return Y._selectorPseudosNamed(compound2, "current").any$1(0, new Y._selectorPseudoIsSuperselector_closure3(pseudo1));
        case "nth-child":
        case "nth-last-child":
          return C.JSArray_methods.any$1(compound2.get$components(), new Y._selectorPseudoIsSuperselector_closure4(pseudo1));
        default:
          throw H.wrapException("unreachable");
      }
    },
    _selectorPseudosNamed: function(compound, $name) {
      var t1 = compound.get$components();
      return H.CastIterable_CastIterable(new H.WhereIterable(t1, new Y._selectorPseudosNamed_closure($name), [H.getTypeArgumentByIndex(t1, 0)]), null, null);
    },
    unifyComplex_closure: {
      "^": "Closure:0;",
      call$1: [function(complex) {
        var t1 = J.getInterceptor$asx(complex);
        return t1.sublist$2(complex, 0, J.$sub$n(t1.get$length(complex), 1));
      }, null, null, 4, 0, null, 9, "call"]
    },
    _weaveParents_closure: {
      "^": "Closure:2;",
      call$2: function(group1, group2) {
        var unified, t1;
        if (C.ListEquality_DefaultEquality.equals$2(group1, group2))
          return group1;
        if (!(J.get$first$ax(group1) instanceof X.CompoundSelector) || !(J.get$first$ax(group2) instanceof X.CompoundSelector))
          return;
        if (Y.complexIsParentSuperselector(group1, group2) === true)
          return group2;
        if (Y.complexIsParentSuperselector(group2, group1) === true)
          return group1;
        if (Y._mustUnify(group1, group2) !== true)
          return;
        unified = Y.unifyComplex([group1, group2]);
        if (unified == null)
          return;
        t1 = J.getInterceptor$asx(unified);
        if (t1.get$length(unified) > 1)
          return;
        return t1.get$first(unified);
      }
    },
    _weaveParents_closure0: {
      "^": "Closure:0;group",
      call$1: function(sequence) {
        return Y.complexIsParentSuperselector(sequence.get$first(sequence), this.group);
      }
    },
    _weaveParents_closure1: {
      "^": "Closure:0;",
      call$1: [function(chunk) {
        return J.expand$1$ax(chunk, new Y._weaveParents__closure1());
      }, null, null, 4, 0, null, 23, "call"]
    },
    _weaveParents__closure1: {
      "^": "Closure:0;",
      call$1: function(group) {
        return group;
      }
    },
    _weaveParents_closure2: {
      "^": "Closure:0;",
      call$1: function(sequence) {
        return sequence.get$length(sequence) === 0;
      }
    },
    _weaveParents_closure3: {
      "^": "Closure:0;",
      call$1: [function(chunk) {
        return J.expand$1$ax(chunk, new Y._weaveParents__closure0());
      }, null, null, 4, 0, null, 23, "call"]
    },
    _weaveParents__closure0: {
      "^": "Closure:0;",
      call$1: function(group) {
        return group;
      }
    },
    _weaveParents_closure4: {
      "^": "Closure:0;",
      call$1: function(choice) {
        return J.get$isNotEmpty$asx(choice);
      }
    },
    _weaveParents_closure5: {
      "^": "Closure:0;",
      call$1: [function(path) {
        return J.expand$1$ax(path, new Y._weaveParents__closure()).toList$0(0);
      }, null, null, 4, 0, null, 6, "call"]
    },
    _weaveParents__closure: {
      "^": "Closure:0;",
      call$1: function(group) {
        return group;
      }
    },
    _mustUnify_closure: {
      "^": "Closure:0;uniqueSelectors",
      call$1: function(component) {
        return component instanceof X.CompoundSelector && C.JSArray_methods.any$1(component.components, new Y._mustUnify__closure(this.uniqueSelectors));
      }
    },
    _mustUnify__closure: {
      "^": "Closure:0;uniqueSelectors",
      call$1: function(simple) {
        var t1 = J.getInterceptor(simple);
        if (!t1.$isIDSelector)
          t1 = !!t1.$isPseudoSelector && !simple.isClass;
        else
          t1 = true;
        return t1 && this.uniqueSelectors.contains$1(0, simple);
      }
    },
    paths_closure: {
      "^": "Closure:2;",
      call$2: function(paths, choice) {
        return J.expand$1$ax(choice, new Y.paths__closure(paths)).toList$0(0);
      }
    },
    paths__closure: {
      "^": "Closure:0;paths",
      call$1: function(option) {
        return J.map$1$ax(this.paths, new Y.paths___closure(option));
      }
    },
    paths___closure: {
      "^": "Closure:0;option",
      call$1: [function(path) {
        var t1 = J.toList$0$ax(path);
        J.add$1$ax(t1, this.option);
        return t1;
      }, null, null, 4, 0, null, 6, "call"]
    },
    _hasRoot_closure: {
      "^": "Closure:0;",
      call$1: function(simple) {
        return simple instanceof D.PseudoSelector && simple.isClass && simple.normalizedName === "root";
      }
    },
    listIsSuperslector_closure: {
      "^": "Closure:0;list1",
      call$1: function(complex1) {
        return C.JSArray_methods.any$1(this.list1, new Y.listIsSuperslector__closure(complex1));
      }
    },
    listIsSuperslector__closure: {
      "^": "Closure:0;complex1",
      call$1: function(complex2) {
        return complex2.isSuperselector$1(this.complex1);
      }
    },
    _simpleIsSuperselectorOfCompound_closure: {
      "^": "Closure:0;simple",
      call$1: function(theirSimple) {
        var t1 = this.simple;
        if (J.$eq$(t1, theirSimple) === true)
          return true;
        if (theirSimple instanceof D.PseudoSelector && theirSimple.selector != null && $.$get$_subselectorPseudos().contains$1(0, theirSimple.normalizedName))
          return C.JSArray_methods.every$1(theirSimple.get$selector().components, new Y._simpleIsSuperselectorOfCompound__closure(t1));
        else
          return false;
      }
    },
    _simpleIsSuperselectorOfCompound__closure: {
      "^": "Closure:0;simple",
      call$1: function(complex) {
        if (complex.get$components().length !== 1)
          return false;
        return C.JSArray_methods.contains$1(H.interceptedTypeCast(C.JSArray_methods.get$single(complex.get$components()), "$isCompoundSelector").components, this.simple);
      }
    },
    _selectorPseudoIsSuperselector_closure: {
      "^": "Closure:0;pseudo1",
      call$1: function(pseudo2) {
        var t1 = pseudo2.get$selector();
        return Y.listIsSuperslector(this.pseudo1.selector.components, t1.get$components());
      }
    },
    _selectorPseudoIsSuperselector_closure0: {
      "^": "Closure:0;parents,compound2",
      call$1: function(complex1) {
        var t1, complex2;
        t1 = this.parents;
        complex2 = t1 == null ? null : t1.toList$0(0);
        if (complex2 == null)
          complex2 = H.setRuntimeTypeInfo([], [S.ComplexSelectorComponent]);
        C.JSArray_methods.add$1(complex2, this.compound2);
        return Y.complexIsSuperselector(complex1.get$components(), complex2);
      }
    },
    _selectorPseudoIsSuperselector_closure1: {
      "^": "Closure:0;pseudo1",
      call$1: function(pseudo2) {
        var t1 = pseudo2.get$selector();
        return Y.listIsSuperslector(this.pseudo1.selector.components, t1.get$components());
      }
    },
    _selectorPseudoIsSuperselector_closure2: {
      "^": "Closure:0;compound2,pseudo1",
      call$1: function(complex) {
        return C.JSArray_methods.any$1(this.compound2.get$components(), new Y._selectorPseudoIsSuperselector__closure(complex, this.pseudo1));
      }
    },
    _selectorPseudoIsSuperselector__closure: {
      "^": "Closure:0;complex,pseudo1",
      call$1: function(simple2) {
        var t1, compound1;
        t1 = J.getInterceptor(simple2);
        if (!!t1.$isTypeSelector) {
          compound1 = C.JSArray_methods.get$last(this.complex.get$components());
          return compound1 instanceof X.CompoundSelector && C.JSArray_methods.any$1(compound1.components, new Y._selectorPseudoIsSuperselector___closure(simple2));
        } else if (!!t1.$isIDSelector) {
          compound1 = C.JSArray_methods.get$last(this.complex.get$components());
          return compound1 instanceof X.CompoundSelector && C.JSArray_methods.any$1(compound1.components, new Y._selectorPseudoIsSuperselector___closure0(simple2));
        } else if (!!t1.$isPseudoSelector && simple2.name === this.pseudo1.name && simple2.selector != null)
          return Y.listIsSuperslector(simple2.get$selector().components, [this.complex]);
        else
          return false;
      }
    },
    _selectorPseudoIsSuperselector___closure: {
      "^": "Closure:0;simple2",
      call$1: function(simple1) {
        var t1;
        if (simple1 instanceof F.TypeSelector) {
          t1 = this.simple2.name.$eq(0, simple1.name);
          t1 = !t1;
        } else
          t1 = false;
        return t1;
      }
    },
    _selectorPseudoIsSuperselector___closure0: {
      "^": "Closure:0;simple2",
      call$1: function(simple1) {
        var t1;
        if (simple1 instanceof N.IDSelector) {
          t1 = simple1.name;
          t1 = this.simple2.name !== t1;
        } else
          t1 = false;
        return t1;
      }
    },
    _selectorPseudoIsSuperselector_closure3: {
      "^": "Closure:0;pseudo1",
      call$1: function(pseudo2) {
        return J.$eq$(this.pseudo1.selector, pseudo2.get$selector());
      }
    },
    _selectorPseudoIsSuperselector_closure4: {
      "^": "Closure:0;pseudo1",
      call$1: function(pseudo2) {
        var t1, t2, t3;
        if (pseudo2 instanceof D.PseudoSelector) {
          t1 = this.pseudo1;
          if (pseudo2.name === t1.name) {
            t2 = pseudo2.argument;
            t3 = t1.argument;
            if (t2 == null ? t3 == null : t2 === t3) {
              t2 = pseudo2.selector;
              t2 = Y.listIsSuperslector(t1.selector.components, t2.components);
              t1 = t2;
            } else
              t1 = false;
          } else
            t1 = false;
        } else
          t1 = false;
        return t1;
      }
    },
    _selectorPseudosNamed_closure: {
      "^": "Closure:0;name",
      call$1: function(simple) {
        return simple instanceof D.PseudoSelector && simple.isClass && simple.selector != null && simple.name === this.name;
      }
    }
  }], ["", "package:sass/src/extend/mode.dart",, L, {
    "^": "",
    ExtendMode: {
      "^": "Object;name<",
      toString$0: function(_) {
        return this.name;
      }
    }
  }], ["", "package:sass/src/functions.dart",, Y, {
    "^": "",
    _functionString: function($name, $arguments) {
      return new D.SassString(C.JSString_methods.$add($name + "(", J.join$1$ax(J.map$1$ax($arguments, new Y._functionString_closure()), ", ")) + ")", false, null);
    },
    _percentageOrUnitless: function(number, max, $name) {
      var value, t1;
      if (!(number.numeratorUnits.length !== 0 || number.denominatorUnits.length !== 0))
        value = number.value;
      else if (number.hasUnit$1("%")) {
        t1 = number.value;
        if (typeof t1 !== "number")
          return H.iae(t1);
        value = max * t1 / 100;
      } else
        throw H.wrapException(E.SassScriptException$("$" + $name + ": Expected " + number.toString$0(0) + ' to have no units or "%".'));
      return J.clamp$2$n(value, 0, max);
    },
    _mix: function(color1, color2, weight) {
      var weightScale, normalizedWeight, t1, t2, t3, alphaDistance, t4, weight1, weight2, t5, t6, t7;
      weightScale = J.$div$n(weight.valueInRange$3(0, 100, "weight"), 100);
      normalizedWeight = weightScale * 2 - 1;
      t1 = color1.alpha;
      t2 = color2.alpha;
      t3 = J.getInterceptor$n(t1);
      alphaDistance = t3.$sub(t1, t2);
      if (typeof alphaDistance !== "number")
        return H.iae(alphaDistance);
      t4 = normalizedWeight * alphaDistance;
      weight1 = ((t4 === -1 ? normalizedWeight : (normalizedWeight + alphaDistance) / (1 + t4)) + 1) / 2;
      weight2 = 1 - weight1;
      t4 = color1.get$red();
      if (typeof t4 !== "number")
        return t4.$mul();
      t5 = color2.get$red();
      if (typeof t5 !== "number")
        return t5.$mul();
      t5 = T.fuzzyRound(t4 * weight1 + t5 * weight2);
      t4 = color1.get$green();
      if (typeof t4 !== "number")
        return t4.$mul();
      t6 = color2.get$green();
      if (typeof t6 !== "number")
        return t6.$mul();
      t6 = T.fuzzyRound(t4 * weight1 + t6 * weight2);
      t4 = color1.get$blue();
      if (typeof t4 !== "number")
        return t4.$mul();
      t7 = color2.get$blue();
      if (typeof t7 !== "number")
        return t7.$mul();
      return K.SassColor$rgb(t5, t6, T.fuzzyRound(t4 * weight1 + t7 * weight2), J.$add$ansx(t3.$mul(t1, weightScale), J.$mul$ns(t2, 1 - weightScale)), null);
    },
    _opacify: [function($arguments) {
      var t1, color;
      t1 = J.getInterceptor$asx($arguments);
      color = t1.$index($arguments, 0).assertColor$1("color");
      return color.changeAlpha$1(J.clamp$2$n(J.$add$ansx(color.alpha, t1.$index($arguments, 1).assertNumber$1("amount").valueInRange$3(0, 1, "amount")), 0, 1));
    }, "call$1", "functions___opacify$closure", 4, 0, 27, 0],
    _transparentize: [function($arguments) {
      var t1, color;
      t1 = J.getInterceptor$asx($arguments);
      color = t1.$index($arguments, 0).assertColor$1("color");
      return color.changeAlpha$1(J.clamp$2$n(J.$sub$n(color.alpha, t1.$index($arguments, 1).assertNumber$1("amount").valueInRange$3(0, 1, "amount")), 0, 1));
    }, "call$1", "functions___transparentize$closure", 4, 0, 27, 0],
    _codepointForIndex: function(index, lengthInCodepoints, allowNegative) {
      var result;
      if (index === 0)
        return 0;
      if (index > 0)
        return Math.min(index - 1, H.checkNum(lengthInCodepoints));
      if (typeof lengthInCodepoints !== "number")
        return lengthInCodepoints.$add();
      result = lengthInCodepoints + index;
      if (result < 0 && !allowNegative)
        return 0;
      return result;
    },
    _numberFunction: function($name, transform) {
      var t1, t2;
      t1 = C.JSString_methods.get$codeUnits("($number)");
      t2 = H.setRuntimeTypeInfo([0], [P.int]);
      t2 = new Y.SourceFile(null, t2, new Uint32Array(H._ensureNativeList(t1.toList$0(t1))), null);
      t2.SourceFile$decoded$2$url(t1, null);
      t1 = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t2, null, null, "($number)", 0, null, null), C.StderrLogger_false).parseArgumentDeclaration$0();
      t2 = H.setRuntimeTypeInfo([], [[S.Tuple2, B.ArgumentDeclaration, {func: 1, ret: F.Value, args: [[P.List, F.Value]]}]]);
      t2.push(new S.Tuple2(t1, new Y._numberFunction_closure(transform), [null, null]));
      return new Q.BuiltInCallable($name, t2);
    },
    _prependParent: function(compound) {
      var t1, first, t2;
      t1 = compound.components;
      first = C.JSArray_methods.get$first(t1);
      t2 = J.getInterceptor(first);
      if (!!t2.$isUniversalSelector)
        return;
      if (!!t2.$isTypeSelector) {
        t2 = first.name;
        if (t2.namespace != null)
          return;
        t2 = H.setRuntimeTypeInfo([new M.ParentSelector(t2.name)], [M.SimpleSelector]);
        C.JSArray_methods.addAll$1(t2, H.SubListIterable$(t1, 1, null, H.getTypeArgumentByIndex(t1, 0)));
        return X.CompoundSelector$(t2);
      } else {
        t2 = H.setRuntimeTypeInfo([new M.ParentSelector(null)], [M.SimpleSelector]);
        C.JSArray_methods.addAll$1(t2, t1);
        return X.CompoundSelector$(t2);
      }
    },
    closure37: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, red, green, blue;
        t1 = J.getInterceptor$asx($arguments);
        if (t1.$index($arguments, 0).get$isSpecialNumber() || t1.$index($arguments, 1).get$isSpecialNumber() || t1.$index($arguments, 2).get$isSpecialNumber())
          return Y._functionString("rgb", $arguments);
        red = t1.$index($arguments, 0).assertNumber$1("red");
        green = t1.$index($arguments, 1).assertNumber$1("green");
        blue = t1.$index($arguments, 2).assertNumber$1("blue");
        return K.SassColor$rgb(T.fuzzyRound(Y._percentageOrUnitless(red, 255, "red")), T.fuzzyRound(Y._percentageOrUnitless(green, 255, "green")), T.fuzzyRound(Y._percentageOrUnitless(blue, 255, "blue")), null, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure38: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1 = J.getInterceptor$asx($arguments);
        if (t1.$index($arguments, 0).get$isVar() || t1.$index($arguments, 1).get$isVar())
          return Y._functionString("rgb", $arguments);
        else
          throw H.wrapException(E.SassScriptException$("Missing argument $blue."));
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure39: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        if (J.get$first$ax($arguments).get$isVar())
          return Y._functionString("rgb", $arguments);
        else
          throw H.wrapException(E.SassScriptException$("Missing argument $green."));
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure40: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, red, green, blue, alpha;
        t1 = J.getInterceptor$asx($arguments);
        if (t1.$index($arguments, 0).get$isSpecialNumber() || t1.$index($arguments, 1).get$isSpecialNumber() || t1.$index($arguments, 2).get$isSpecialNumber() || t1.$index($arguments, 3).get$isSpecialNumber())
          return Y._functionString("rgba", $arguments);
        red = t1.$index($arguments, 0).assertNumber$1("red");
        green = t1.$index($arguments, 1).assertNumber$1("green");
        blue = t1.$index($arguments, 2).assertNumber$1("blue");
        alpha = t1.$index($arguments, 3).assertNumber$1("alpha");
        return K.SassColor$rgb(T.fuzzyRound(Y._percentageOrUnitless(red, 255, "red")), T.fuzzyRound(Y._percentageOrUnitless(green, 255, "green")), T.fuzzyRound(Y._percentageOrUnitless(blue, 255, "blue")), Y._percentageOrUnitless(alpha, 1, "alpha"), null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure41: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, first, color;
        t1 = J.getInterceptor$asx($arguments);
        if (t1.$index($arguments, 0).get$isVar())
          return Y._functionString("rgba", $arguments);
        else if (t1.$index($arguments, 1).get$isVar()) {
          first = t1.$index($arguments, 0);
          if (first instanceof K.SassColor)
            return new D.SassString("rgba(" + H.S(first.get$red()) + ", " + H.S(first.get$green()) + ", " + H.S(first.get$blue()) + ", " + t1.$index($arguments, 1).toCssString$0() + ")", false, null);
          else
            return Y._functionString("rgba", $arguments);
        } else if (t1.$index($arguments, 1).get$isSpecialNumber()) {
          color = t1.$index($arguments, 0).assertColor$1("color");
          return new D.SassString("rgba(" + H.S(color.get$red()) + ", " + H.S(color.get$green()) + ", " + H.S(color.get$blue()) + ", " + t1.$index($arguments, 1).toCssString$0() + ")", false, null);
        }
        return t1.$index($arguments, 0).assertColor$1("color").changeAlpha$1(Y._percentageOrUnitless(t1.$index($arguments, 1).assertNumber$1("alpha"), 1, "alpha"));
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure42: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1 = J.getInterceptor$asx($arguments);
        if (t1.$index($arguments, 0).get$isVar() || t1.$index($arguments, 1).get$isVar() || t1.$index($arguments, 2).get$isVar())
          return Y._functionString("rgba", $arguments);
        else
          throw H.wrapException(E.SassScriptException$("Missing argument $alpha."));
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure43: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        if (J.get$first$ax($arguments).get$isVar())
          return Y._functionString("rgba", $arguments);
        else
          throw H.wrapException(E.SassScriptException$("Missing argument $green."));
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure44: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1 = J.get$first$ax($arguments).assertColor$1("color").get$red();
        return new T.SassNumber(t1, C.List_empty, C.List_empty, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure45: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1 = J.get$first$ax($arguments).assertColor$1("color").get$green();
        return new T.SassNumber(t1, C.List_empty, C.List_empty, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure46: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1 = J.get$first$ax($arguments).assertColor$1("color").get$blue();
        return new T.SassNumber(t1, C.List_empty, C.List_empty, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure47: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1 = J.getInterceptor$asx($arguments);
        return Y._mix(t1.$index($arguments, 0).assertColor$1("color1"), t1.$index($arguments, 1).assertColor$1("color2"), t1.$index($arguments, 2).assertNumber$1("weight"));
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure48: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1 = J.getInterceptor$asx($arguments);
        if (t1.$index($arguments, 0).get$isSpecialNumber() || t1.$index($arguments, 1).get$isSpecialNumber() || t1.$index($arguments, 2).get$isSpecialNumber())
          return Y._functionString("hsl", $arguments);
        return K.SassColor$hsl(t1.$index($arguments, 0).assertNumber$1("hue").value, t1.$index($arguments, 1).assertNumber$1("saturation").value, t1.$index($arguments, 2).assertNumber$1("lightness").value, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure49: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1 = J.getInterceptor$asx($arguments);
        if (t1.$index($arguments, 0).get$isVar() || t1.$index($arguments, 1).get$isVar())
          return Y._functionString("hsl", $arguments);
        else
          throw H.wrapException(E.SassScriptException$("Missing argument $lightness."));
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure50: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        if (J.get$first$ax($arguments).get$isVar())
          return Y._functionString("hsl", $arguments);
        else
          throw H.wrapException(E.SassScriptException$("Missing argument $saturation."));
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure51: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1 = J.getInterceptor$asx($arguments);
        if (t1.$index($arguments, 0).get$isSpecialNumber() || t1.$index($arguments, 1).get$isSpecialNumber() || t1.$index($arguments, 2).get$isSpecialNumber() || t1.$index($arguments, 3).get$isSpecialNumber())
          return Y._functionString("hsla", $arguments);
        return K.SassColor$hsl(t1.$index($arguments, 0).assertNumber$1("hue").value, t1.$index($arguments, 1).assertNumber$1("saturation").value, t1.$index($arguments, 2).assertNumber$1("lightness").value, Y._percentageOrUnitless(t1.$index($arguments, 3).assertNumber$1("alpha"), 1, "alpha"));
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure52: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1 = J.getInterceptor$asx($arguments);
        if (t1.$index($arguments, 0).get$isVar() || t1.$index($arguments, 1).get$isVar() || t1.$index($arguments, 2).get$isVar())
          return Y._functionString("hsla", $arguments);
        else
          throw H.wrapException(E.SassScriptException$("Missing argument $alpha."));
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure53: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1 = J.getInterceptor$asx($arguments);
        if (t1.$index($arguments, 0).get$isVar() || t1.$index($arguments, 1).get$isVar())
          return Y._functionString("hsla", $arguments);
        else
          throw H.wrapException(E.SassScriptException$("Missing argument $lightness."));
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure54: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        if (J.get$first$ax($arguments).get$isVar())
          return Y._functionString("hsla", $arguments);
        else
          throw H.wrapException(E.SassScriptException$("Missing argument $saturation."));
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure55: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, t2;
        t1 = J.get$first$ax($arguments).assertColor$1("color").get$hue();
        t2 = P.List_List$unmodifiable(["deg"], null);
        return new T.SassNumber(t1, t2, C.List_empty, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure56: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, t2;
        t1 = J.get$first$ax($arguments).assertColor$1("color").get$saturation();
        t2 = P.List_List$unmodifiable(["%"], null);
        return new T.SassNumber(t1, t2, C.List_empty, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure57: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, t2;
        t1 = J.get$first$ax($arguments).assertColor$1("color").get$lightness();
        t2 = P.List_List$unmodifiable(["%"], null);
        return new T.SassNumber(t1, t2, C.List_empty, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure58: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, color, degrees, t2;
        t1 = J.getInterceptor$asx($arguments);
        color = t1.$index($arguments, 0).assertColor$1("color");
        degrees = t1.$index($arguments, 1).assertNumber$1("degrees");
        t1 = color.get$hue();
        t2 = degrees.value;
        if (typeof t1 !== "number")
          return t1.$add();
        if (typeof t2 !== "number")
          return H.iae(t2);
        return color.changeHsl$1$hue(t1 + t2);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure59: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, color, amount;
        t1 = J.getInterceptor$asx($arguments);
        color = t1.$index($arguments, 0).assertColor$1("color");
        amount = t1.$index($arguments, 1).assertNumber$1("amount");
        return color.changeHsl$1$lightness(J.clamp$2$n(J.$add$ansx(color.get$lightness(), amount.valueInRange$3(0, 100, "amount")), 0, 100));
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure60: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, color, amount;
        t1 = J.getInterceptor$asx($arguments);
        color = t1.$index($arguments, 0).assertColor$1("color");
        amount = t1.$index($arguments, 1).assertNumber$1("amount");
        return color.changeHsl$1$lightness(J.clamp$2$n(J.$sub$n(color.get$lightness(), amount.valueInRange$3(0, 100, "amount")), 0, 100));
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure61: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        return new D.SassString("saturate(" + N.serializeValue(J.$index$asx($arguments, 0).assertNumber$1("number"), false, true) + ")", false, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure62: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, color, amount;
        t1 = J.getInterceptor$asx($arguments);
        color = t1.$index($arguments, 0).assertColor$1("color");
        amount = t1.$index($arguments, 1).assertNumber$1("amount");
        return color.changeHsl$1$saturation(J.clamp$2$n(J.$add$ansx(color.get$saturation(), amount.valueInRange$3(0, 100, "amount")), 0, 100));
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure63: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, color, amount;
        t1 = J.getInterceptor$asx($arguments);
        color = t1.$index($arguments, 0).assertColor$1("color");
        amount = t1.$index($arguments, 1).assertNumber$1("amount");
        return color.changeHsl$1$saturation(J.clamp$2$n(J.$sub$n(color.get$saturation(), amount.valueInRange$3(0, 100, "amount")), 0, 100));
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure64: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1 = J.getInterceptor$asx($arguments);
        if (t1.$index($arguments, 0) instanceof T.SassNumber)
          return Y._functionString("grayscale", $arguments);
        return t1.$index($arguments, 0).assertColor$1("color").changeHsl$1$saturation(0);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure65: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var color, t1;
        color = J.$index$asx($arguments, 0).assertColor$1("color");
        t1 = color.get$hue();
        if (typeof t1 !== "number")
          return t1.$add();
        return color.changeHsl$1$hue(t1 + 180);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure66: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, color, weight, t2, t3, inverse;
        t1 = J.getInterceptor$asx($arguments);
        if (t1.$index($arguments, 0) instanceof T.SassNumber)
          return Y._functionString("invert", t1.take$1($arguments, 1));
        color = t1.$index($arguments, 0).assertColor$1("color");
        weight = t1.$index($arguments, 1).assertNumber$1("weight");
        t1 = color.get$red();
        if (typeof t1 !== "number")
          return H.iae(t1);
        t2 = color.get$green();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t3 = color.get$blue();
        if (typeof t3 !== "number")
          return H.iae(t3);
        inverse = color.changeRgb$3$blue$green$red(255 - t3, 255 - t2, 255 - t1);
        if (J.$eq$(weight.value, 50) === true)
          return inverse;
        return Y._mix(inverse, color, weight);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure67: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var argument, color;
        argument = J.$index$asx($arguments, 0);
        if (argument instanceof D.SassString && !argument.hasQuotes && J.contains$1$asx(argument.text, $.$get$_microsoftFilterStart()) === true)
          return Y._functionString("alpha", $arguments);
        color = argument.assertColor$1("color");
        return new T.SassNumber(color.alpha, C.List_empty, C.List_empty, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure68: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1 = J.getInterceptor$ax($arguments);
        if (t1.every$1($arguments, new Y._closure18()) === true)
          return Y._functionString("alpha", $arguments);
        throw H.wrapException(E.SassScriptException$("Only 1 argument allowed, but " + H.S(t1.get$length($arguments)) + " were passed."));
      }, null, null, 4, 0, null, 0, "call"]
    },
    _closure18: {
      "^": "Closure:0;",
      call$1: function(argument) {
        return argument instanceof D.SassString && !argument.hasQuotes && J.contains$1$asx(argument.text, $.$get$_microsoftFilterStart()) === true;
      }
    },
    closure69: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, color;
        t1 = J.getInterceptor$asx($arguments);
        if (t1.$index($arguments, 0) instanceof T.SassNumber)
          return Y._functionString("opacity", $arguments);
        color = t1.$index($arguments, 0).assertColor$1("color");
        return new T.SassNumber(color.alpha, C.List_empty, C.List_empty, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure70: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, color, argumentList, keywords, t2, red, green, blue, hue, saturation, lightness, alpha, hasRgb, hasHsl, t3, t4, t5;
        t1 = J.getInterceptor$asx($arguments);
        color = t1.$index($arguments, 0).assertColor$1("color");
        argumentList = H.interceptedTypeCast(t1.$index($arguments, 1), "$isSassArgumentList");
        if (argumentList._list$_contents.length !== 0)
          throw H.wrapException(E.SassScriptException$("Only only positional argument is allowed. All other arguments must be passed by name."));
        argumentList._wereKeywordsAccessed = true;
        keywords = B.normalizedMap(argumentList._keywords);
        t1 = new Y.closure_getInRange0(keywords);
        t2 = t1.call$3("red", -255, 255);
        red = t2 == null ? null : T.fuzzyRound(t2);
        t2 = t1.call$3("green", -255, 255);
        green = t2 == null ? null : T.fuzzyRound(t2);
        t2 = t1.call$3("blue", -255, 255);
        blue = t2 == null ? null : T.fuzzyRound(t2);
        t2 = keywords.remove$1(0, "hue");
        t2 = t2 == null ? null : t2.assertNumber$1("hue");
        hue = t2 == null ? null : t2.value;
        saturation = t1.call$3("saturation", -100, 100);
        lightness = t1.call$3("lightness", -100, 100);
        alpha = t1.call$3("alpha", -1, 1);
        if (keywords.get$isNotEmpty(keywords))
          throw H.wrapException(E.SassScriptException$("No " + B.pluralize("argument", keywords.get$length(keywords), null) + " named " + H.S(B.toSentence(keywords.get$keys().map$1(0, new Y._closure17()), "or")) + "."));
        t1 = red == null;
        hasRgb = !t1 || green != null || blue != null;
        t2 = hue == null;
        hasHsl = !t2 || saturation != null || lightness != null;
        if (hasRgb) {
          if (hasHsl)
            throw H.wrapException(E.SassScriptException$("RGB parameters may not be passed along with HSL parameters."));
          t2 = color.get$red();
          t1 = t1 ? 0 : red;
          if (typeof t2 !== "number")
            return t2.$add();
          t1 = H.intTypeCast(C.JSInt_methods.clamp$2(t2 + t1, 0, 255));
          t2 = color.get$green();
          t3 = green == null ? 0 : green;
          if (typeof t2 !== "number")
            return t2.$add();
          t3 = H.intTypeCast(C.JSInt_methods.clamp$2(t2 + t3, 0, 255));
          t2 = color.get$blue();
          t4 = blue == null ? 0 : blue;
          if (typeof t2 !== "number")
            return t2.$add();
          t4 = H.intTypeCast(C.JSInt_methods.clamp$2(t2 + t4, 0, 255));
          t2 = alpha == null ? 0 : alpha;
          return color.changeRgb$4$alpha$blue$green$red(J.clamp$2$n(J.$add$ansx(color.alpha, t2), 0, 1), t4, t3, t1);
        } else if (hasHsl) {
          t1 = color.get$hue();
          t2 = t2 ? 0 : hue;
          if (typeof t1 !== "number")
            return t1.$add();
          if (typeof t2 !== "number")
            return H.iae(t2);
          t3 = color.get$saturation();
          t3 = J.clamp$2$n(J.$add$ansx(t3, saturation == null ? 0 : saturation), 0, 100);
          t4 = color.get$lightness();
          t4 = J.clamp$2$n(J.$add$ansx(t4, lightness == null ? 0 : lightness), 0, 100);
          t5 = alpha == null ? 0 : alpha;
          return color.changeHsl$4$alpha$hue$lightness$saturation(J.$add$ansx(color.alpha, t5), t1 + t2, t4, t3);
        } else if (alpha != null)
          return color.changeAlpha$1(J.clamp$2$n(J.$add$ansx(color.alpha, alpha), 0, 1));
        else
          return color;
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure_getInRange0: {
      "^": "Closure:39;keywords",
      call$3: function($name, min, max) {
        var t1 = this.keywords.remove$1(0, $name);
        t1 = t1 == null ? null : t1.assertNumber$1($name);
        return t1 == null ? null : t1.valueInRange$3(min, max, $name);
      }
    },
    _closure17: {
      "^": "Closure:0;",
      call$1: [function($name) {
        return "$" + H.S($name);
      }, null, null, 4, 0, null, 8, "call"]
    },
    closure71: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, color, argumentList, keywords, t2, red, green, blue, saturation, lightness, alpha, hasRgb, hasHsl, t3, t4;
        t1 = J.getInterceptor$asx($arguments);
        color = t1.$index($arguments, 0).assertColor$1("color");
        argumentList = H.interceptedTypeCast(t1.$index($arguments, 1), "$isSassArgumentList");
        if (argumentList._list$_contents.length !== 0)
          throw H.wrapException(E.SassScriptException$("Only only positional argument is allowed. All other arguments must be passed by name."));
        argumentList._wereKeywordsAccessed = true;
        keywords = B.normalizedMap(argumentList._keywords);
        t1 = new Y.closure_getScale(keywords);
        t2 = new Y.closure_scaleValue();
        red = t1.call$1("red");
        green = t1.call$1("green");
        blue = t1.call$1("blue");
        saturation = t1.call$1("saturation");
        lightness = t1.call$1("lightness");
        alpha = t1.call$1("alpha");
        if (keywords.get$isNotEmpty(keywords))
          throw H.wrapException(E.SassScriptException$("No " + B.pluralize("argument", keywords.get$length(keywords), null) + " named " + H.S(B.toSentence(keywords.get$keys().map$1(0, new Y._closure16()), "or")) + "."));
        hasRgb = red != null || green != null || blue != null;
        hasHsl = saturation != null || lightness != null;
        if (hasRgb) {
          if (hasHsl)
            throw H.wrapException(E.SassScriptException$("RGB parameters may not be passed along with HSL parameters."));
          t1 = T.fuzzyRound(t2.call$3(color.get$red(), red, 255));
          t3 = T.fuzzyRound(t2.call$3(color.get$green(), green, 255));
          t4 = T.fuzzyRound(t2.call$3(color.get$blue(), blue, 255));
          return color.changeRgb$4$alpha$blue$green$red(t2.call$3(color.alpha, alpha, 1), t4, t3, t1);
        } else if (hasHsl) {
          t1 = t2.call$3(color.get$saturation(), saturation, 100);
          t3 = t2.call$3(color.get$lightness(), lightness, 100);
          return color.changeHsl$3$alpha$lightness$saturation(t2.call$3(color.alpha, alpha, 1), t3, t1);
        } else if (alpha != null)
          return color.changeAlpha$1(t2.call$3(color.alpha, alpha, 1));
        else
          return color;
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure_getScale: {
      "^": "Closure:14;keywords",
      call$1: function($name) {
        var value, number;
        value = this.keywords.remove$1(0, $name);
        if (value == null)
          return;
        number = value.assertNumber$1($name);
        number.assertUnit$2("%", $name);
        return J.$div$n(number.valueInRange$3(-100, 100, $name), 100);
      }
    },
    closure_scaleValue: {
      "^": "Closure:50;",
      call$3: function(current, scale, max) {
        var t1;
        if (scale == null)
          return current;
        if (scale > 0) {
          if (typeof current !== "number")
            return H.iae(current);
          t1 = max - current;
        } else
          t1 = current;
        return J.$add$ansx(current, J.$mul$ns(t1, scale));
      }
    },
    _closure16: {
      "^": "Closure:0;",
      call$1: [function($name) {
        return "$" + H.S($name);
      }, null, null, 4, 0, null, 8, "call"]
    },
    closure72: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, color, argumentList, keywords, t2, red, green, blue, hue, saturation, lightness, alpha, hasRgb, hasHsl;
        t1 = J.getInterceptor$asx($arguments);
        color = t1.$index($arguments, 0).assertColor$1("color");
        argumentList = H.interceptedTypeCast(t1.$index($arguments, 1), "$isSassArgumentList");
        if (argumentList._list$_contents.length !== 0)
          throw H.wrapException(E.SassScriptException$("Only only positional argument is allowed. All other arguments must be passed by name."));
        argumentList._wereKeywordsAccessed = true;
        keywords = B.normalizedMap(argumentList._keywords);
        t1 = new Y.closure_getInRange(keywords);
        t2 = t1.call$3("red", 0, 255);
        red = t2 == null ? null : T.fuzzyRound(t2);
        t2 = t1.call$3("green", 0, 255);
        green = t2 == null ? null : T.fuzzyRound(t2);
        t2 = t1.call$3("blue", 0, 255);
        blue = t2 == null ? null : T.fuzzyRound(t2);
        t2 = keywords.remove$1(0, "hue");
        t2 = t2 == null ? null : t2.assertNumber$1("hue");
        hue = t2 == null ? null : t2.value;
        saturation = t1.call$3("saturation", 0, 100);
        lightness = t1.call$3("lightness", 0, 100);
        alpha = t1.call$3("alpha", 0, 1);
        if (keywords.get$isNotEmpty(keywords))
          throw H.wrapException(E.SassScriptException$("No " + B.pluralize("argument", keywords.get$length(keywords), null) + " named " + H.S(B.toSentence(keywords.get$keys().map$1(0, new Y._closure15()), "or")) + "."));
        hasRgb = red != null || green != null || blue != null;
        hasHsl = hue != null || saturation != null || lightness != null;
        if (hasRgb) {
          if (hasHsl)
            throw H.wrapException(E.SassScriptException$("RGB parameters may not be passed along with HSL parameters."));
          return color.changeRgb$4$alpha$blue$green$red(alpha, blue, green, red);
        } else if (hasHsl)
          return color.changeHsl$4$alpha$hue$lightness$saturation(alpha, hue, lightness, saturation);
        else if (alpha != null)
          return color.changeAlpha$1(alpha);
        else
          return color;
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure_getInRange: {
      "^": "Closure:39;keywords",
      call$3: function($name, min, max) {
        var t1 = this.keywords.remove$1(0, $name);
        t1 = t1 == null ? null : t1.assertNumber$1($name);
        return t1 == null ? null : t1.valueInRange$3(min, max, $name);
      }
    },
    _closure15: {
      "^": "Closure:0;",
      call$1: [function($name) {
        return "$" + H.S($name);
      }, null, null, 4, 0, null, 8, "call"]
    },
    closure73: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var color, t1;
        color = J.$index$asx($arguments, 0).assertColor$1("color");
        t1 = new Y.closure_hexString();
        return new D.SassString("#" + H.S(t1.call$1(T.fuzzyRound(J.$mul$ns(color.alpha, 255)))) + H.S(t1.call$1(color.get$red())) + H.S(t1.call$1(color.get$green())) + H.S(t1.call$1(color.get$blue())), false, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure_hexString: {
      "^": "Closure:49;",
      call$1: function(component) {
        return C.JSString_methods.padLeft$2(J.toRadixString$1$n(component, 16), 2, "0").toUpperCase();
      }
    },
    closure74: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var string = J.$index$asx($arguments, 0).assertString$1("string");
        if (!string.hasQuotes)
          return string;
        return new D.SassString(string.text, false, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure75: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var string = J.$index$asx($arguments, 0).assertString$1("string");
        if (string.hasQuotes)
          return string;
        return new D.SassString(string.text, true, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure76: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1 = J.$index$asx($arguments, 0).assertString$1("string").get$sassLength();
        return new T.SassNumber(t1, C.List_empty, C.List_empty, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure77: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, string, insert, index, indexInt, codeUnitIndex;
        t1 = J.getInterceptor$asx($arguments);
        string = t1.$index($arguments, 0).assertString$1("string");
        insert = t1.$index($arguments, 1).assertString$1("insert");
        index = t1.$index($arguments, 2).assertNumber$1("index");
        index.assertNoUnits$1("index");
        indexInt = index.assertInt$1("index");
        if (indexInt < 0)
          ++indexInt;
        t1 = string.text;
        codeUnitIndex = B.codepointIndexToCodeUnitIndex(t1, Y._codepointForIndex(indexInt, string.get$sassLength(), false));
        return new D.SassString(J.replaceRange$3$asx(t1, codeUnitIndex, codeUnitIndex, insert.text), string.hasQuotes, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure78: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, t2, codeUnitIndex, codepointIndex;
        t1 = J.getInterceptor$asx($arguments);
        t2 = t1.$index($arguments, 0).assertString$1("string").text;
        codeUnitIndex = J.indexOf$1$asx(t2, t1.$index($arguments, 1).assertString$1("substring").text);
        if (codeUnitIndex === -1)
          return C.C_SassNull;
        codepointIndex = B.codeUnitIndexToCodepointIndex(t2, codeUnitIndex);
        return new T.SassNumber(codepointIndex + 1, C.List_empty, C.List_empty, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure79: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, string, start, end, lengthInCodepoints, endInt, startCodepoint, endCodepoint;
        t1 = J.getInterceptor$asx($arguments);
        string = t1.$index($arguments, 0).assertString$1("string");
        start = t1.$index($arguments, 1).assertNumber$1("start-at");
        end = t1.$index($arguments, 2).assertNumber$1("end-at");
        start.assertNoUnits$1("start");
        end.assertNoUnits$1("end");
        lengthInCodepoints = string.get$sassLength();
        endInt = end.assertInt$0();
        if (endInt === 0)
          return string.hasQuotes ? $.$get$_emptyQuoted() : $.$get$_emptyUnquoted();
        startCodepoint = Y._codepointForIndex(start.assertInt$0(), lengthInCodepoints, false);
        endCodepoint = Y._codepointForIndex(endInt, lengthInCodepoints, true);
        if (endCodepoint === lengthInCodepoints)
          --endCodepoint;
        if (endCodepoint < startCodepoint)
          return string.hasQuotes ? $.$get$_emptyQuoted() : $.$get$_emptyUnquoted();
        t1 = string.text;
        return new D.SassString(J.substring$2$s(t1, B.codepointIndexToCodeUnitIndex(t1, startCodepoint), B.codepointIndexToCodeUnitIndex(t1, endCodepoint) + 1), string.hasQuotes, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure80: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var string, t1, t2, i, t3, t4;
        string = J.$index$asx($arguments, 0).assertString$1("string");
        t1 = string.text;
        t2 = J.getInterceptor$asx(t1);
        i = 0;
        t3 = "";
        while (true) {
          t4 = t2.get$length(t1);
          if (typeof t4 !== "number")
            return H.iae(t4);
          if (!(i < t4))
            break;
          t4 = t2.codeUnitAt$1(t1, i);
          t3 += H.Primitives_stringFromCharCode(t4 >= 97 && t4 <= 122 ? t4 & 4294967263 : t4);
          ++i;
        }
        return new D.SassString(t3.charCodeAt(0) == 0 ? t3 : t3, string.hasQuotes, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure81: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var string, t1, t2, i, t3, t4;
        string = J.$index$asx($arguments, 0).assertString$1("string");
        t1 = string.text;
        t2 = J.getInterceptor$asx(t1);
        i = 0;
        t3 = "";
        while (true) {
          t4 = t2.get$length(t1);
          if (typeof t4 !== "number")
            return H.iae(t4);
          if (!(i < t4))
            break;
          t4 = t2.codeUnitAt$1(t1, i);
          t3 += H.Primitives_stringFromCharCode(t4 >= 65 && t4 <= 90 ? t4 | 32 : t4);
          ++i;
        }
        return new D.SassString(t3.charCodeAt(0) == 0 ? t3 : t3, string.hasQuotes, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure82: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var number, t1, t2;
        number = J.$index$asx($arguments, 0).assertNumber$1("number");
        number.assertNoUnits$1("number");
        t1 = J.$mul$ns(number.value, 100);
        t2 = P.List_List$unmodifiable(["%"], null);
        return new T.SassNumber(t1, t2, C.List_empty, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure83: {
      "^": "Closure:0;",
      call$1: function(value) {
        return J.ceil$0$n(value);
      }
    },
    closure84: {
      "^": "Closure:0;",
      call$1: function(value) {
        return J.floor$0$n(value);
      }
    },
    closure85: {
      "^": "Closure:0;",
      call$1: function(value) {
        return J.abs$0$in(value);
      }
    },
    closure86: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, t2, max, _i, number;
        for (t1 = J.$index$asx($arguments, 0).get$asList(), t2 = t1.length, max = null, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          number = t1[_i].assertNumber$0();
          if (max == null || max.lessThan$1(number).value)
            max = number;
        }
        if (max != null)
          return max;
        throw H.wrapException(E.SassScriptException$("At least one argument must be passed."));
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure87: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, t2, min, _i, number;
        for (t1 = J.$index$asx($arguments, 0).get$asList(), t2 = t1.length, min = null, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          number = t1[_i].assertNumber$0();
          if (min == null || min.greaterThan$1(number).value)
            min = number;
        }
        if (min != null)
          return min;
        throw H.wrapException(E.SassScriptException$("At least one argument must be passed."));
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure88: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, limit;
        t1 = J.getInterceptor$asx($arguments);
        if (J.$eq$(t1.$index($arguments, 0), C.C_SassNull) === true) {
          t1 = $.$get$_random().nextDouble$0();
          return new T.SassNumber(t1, C.List_empty, C.List_empty, null);
        }
        limit = t1.$index($arguments, 0).assertNumber$1("limit").assertInt$1("limit");
        if (limit < 1)
          throw H.wrapException(E.SassScriptException$("$limit: Must be greater than 0, was " + limit + "."));
        t1 = $.$get$_random().nextInt$1(limit);
        return new T.SassNumber(t1 + 1, C.List_empty, C.List_empty, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure89: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1 = J.$index$asx($arguments, 0).get$asList().length;
        return new T.SassNumber(t1, C.List_empty, C.List_empty, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure90: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, list, index, t2;
        t1 = J.getInterceptor$asx($arguments);
        list = t1.$index($arguments, 0);
        index = t1.$index($arguments, 1);
        t1 = list.get$asList();
        t2 = list.sassIndexToListIndex$2(index, "n");
        if (t2 >>> 0 !== t2 || t2 >= t1.length)
          return H.ioore(t1, t2);
        return t1[t2];
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure91: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, list, index, value, t2, newList;
        t1 = J.getInterceptor$asx($arguments);
        list = t1.$index($arguments, 0);
        index = t1.$index($arguments, 1);
        value = t1.$index($arguments, 2);
        t2 = list.get$asList();
        newList = H.setRuntimeTypeInfo(t2.slice(0), [H.getTypeArgumentByIndex(t2, 0)]);
        t2 = list.sassIndexToListIndex$2(index, "n");
        if (t2 >>> 0 !== t2 || t2 >= newList.length)
          return H.ioore(newList, t2);
        newList[t2] = value;
        return t1.$index($arguments, 0).changeListContents$1(newList);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure92: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, list1, list2, separatorParam, bracketedParam, t2, separator, bracketed, newList;
        t1 = J.getInterceptor$asx($arguments);
        list1 = t1.$index($arguments, 0);
        list2 = t1.$index($arguments, 1);
        separatorParam = t1.$index($arguments, 2).assertString$1("separator");
        bracketedParam = t1.$index($arguments, 3);
        t1 = separatorParam.text;
        t2 = J.getInterceptor(t1);
        if (t2.$eq(t1, "auto") === true)
          if (list1.get$separator() !== C.ListSeparator_undecided_null)
            separator = list1.get$separator();
          else
            separator = list2.get$separator() !== C.ListSeparator_undecided_null ? list2.get$separator() : C.ListSeparator_woc;
        else if (t2.$eq(t1, "space") === true)
          separator = C.ListSeparator_woc;
        else {
          if (!(t2.$eq(t1, "comma") === true))
            throw H.wrapException(E.SassScriptException$('$null: Must be "space", "comma", or "auto".'));
          separator = C.ListSeparator_kWM;
        }
        bracketed = bracketedParam instanceof D.SassString && J.$eq$(bracketedParam.text, "auto") === true ? list1.get$hasBrackets() : bracketedParam.get$isTruthy();
        t1 = list1.get$asList();
        newList = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
        C.JSArray_methods.addAll$1(newList, list2.get$asList());
        return D.SassList$(newList, separator, bracketed);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure93: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, list, value, t2, separator, newList;
        t1 = J.getInterceptor$asx($arguments);
        list = t1.$index($arguments, 0);
        value = t1.$index($arguments, 1);
        t1 = t1.$index($arguments, 2).assertString$1("separator").text;
        t2 = J.getInterceptor(t1);
        if (t2.$eq(t1, "auto") === true)
          separator = list.get$separator() === C.ListSeparator_undecided_null ? C.ListSeparator_woc : list.get$separator();
        else if (t2.$eq(t1, "space") === true)
          separator = C.ListSeparator_woc;
        else {
          if (!(t2.$eq(t1, "comma") === true))
            throw H.wrapException(E.SassScriptException$('$null: Must be "space", "comma", or "auto".'));
          separator = C.ListSeparator_kWM;
        }
        t1 = list.get$asList();
        newList = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
        newList.push(value);
        return list.changeListContents$2$separator(newList, separator);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure94: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var _box_0, t1, lists, results, result;
        _box_0 = {};
        t1 = J.$index$asx($arguments, 0).get$asList();
        lists = new H.MappedListIterable(t1, new Y._closure12(), [H.getTypeArgumentByIndex(t1, 0), null]).toList$0(0);
        _box_0.i = 0;
        results = H.setRuntimeTypeInfo([], [D.SassList]);
        for (t1 = [H.getTypeArgumentByIndex(lists, 0), null]; C.JSArray_methods.every$1(lists, new Y._closure13(_box_0));) {
          result = P.List_List$from(new H.MappedListIterable(lists, new Y._closure14(_box_0), t1), false, null);
          result.fixed$length = Array;
          result.immutable$list = Array;
          results.push(new D.SassList(result, C.ListSeparator_woc, false));
          ++_box_0.i;
        }
        return D.SassList$(results, C.ListSeparator_kWM, false);
      }, null, null, 4, 0, null, 0, "call"]
    },
    _closure12: {
      "^": "Closure:0;",
      call$1: [function(list) {
        return list.get$asList();
      }, null, null, 4, 0, null, 36, "call"]
    },
    _closure13: {
      "^": "Closure:0;_box_0",
      call$1: function(list) {
        return this._box_0.i !== J.get$length$asx(list);
      }
    },
    _closure14: {
      "^": "Closure:0;_box_0",
      call$1: [function(list) {
        return J.$index$asx(list, this._box_0.i);
      }, null, null, 4, 0, null, 36, "call"]
    },
    closure95: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, index;
        t1 = J.getInterceptor$asx($arguments);
        index = C.JSArray_methods.indexOf$1(t1.$index($arguments, 0).get$asList(), t1.$index($arguments, 1));
        if (index === -1)
          t1 = C.C_SassNull;
        else
          t1 = new T.SassNumber(index + 1, C.List_empty, C.List_empty, null);
        return t1;
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure96: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        return J.$index$asx($arguments, 0).get$separator() === C.ListSeparator_kWM ? new D.SassString("comma", false, null) : new D.SassString("space", false, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure97: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        return J.$index$asx($arguments, 0).get$hasBrackets() ? C.SassBoolean_true : C.SassBoolean_false;
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure98: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1 = J.getInterceptor$asx($arguments);
        t1 = t1.$index($arguments, 0).assertMap$1("map").contents.$index(0, t1.$index($arguments, 1));
        return t1 == null ? C.C_SassNull : t1;
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure99: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, map1, map2;
        t1 = J.getInterceptor$asx($arguments);
        map1 = t1.$index($arguments, 0).assertMap$1("map1");
        map2 = t1.$index($arguments, 1).assertMap$1("map2");
        t1 = P.LinkedHashMap_LinkedHashMap$from(map1.contents, null, null);
        t1.addAll$1(0, map2.contents);
        return new A.SassMap(H.ConstantMap_ConstantMap$from(t1, null, null));
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure100: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, map, keys, mutableMap, t2, _i;
        t1 = J.getInterceptor$asx($arguments);
        map = t1.$index($arguments, 0).assertMap$1("map");
        keys = t1.$index($arguments, 1);
        t1 = F.Value;
        mutableMap = P.LinkedHashMap_LinkedHashMap$from(map.contents, t1, t1);
        for (t1 = keys.get$asList(), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i)
          mutableMap.remove$1(0, t1[_i]);
        return new A.SassMap(H.ConstantMap_ConstantMap$from(mutableMap, null, null));
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure101: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        return D.SassList$(J.$index$asx($arguments, 0).assertMap$1("map").contents.get$keys(), C.ListSeparator_kWM, false);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure102: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        return D.SassList$(J.$index$asx($arguments, 0).assertMap$1("map").contents.get$values(), C.ListSeparator_kWM, false);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure103: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1 = J.getInterceptor$asx($arguments);
        return t1.$index($arguments, 0).assertMap$1("map").contents.containsKey$1(t1.$index($arguments, 1)) === true ? C.SassBoolean_true : C.SassBoolean_false;
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure104: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var argumentList = J.$index$asx($arguments, 0);
        if (argumentList instanceof D.SassArgumentList) {
          argumentList._wereKeywordsAccessed = true;
          return new A.SassMap(H.ConstantMap_ConstantMap$from(Y.mapMap(argumentList._keywords, new Y._closure11(), null), null, null));
        } else
          throw H.wrapException(E.SassScriptException$("$args: " + H.S(argumentList) + " is not an argument list."));
      }, null, null, 4, 0, null, 0, "call"]
    },
    _closure11: {
      "^": "Closure:10;",
      call$2: function(key, _) {
        return new D.SassString(key, false, null);
      }
    },
    closure105: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var selectors = J.$index$asx($arguments, 0).get$asList();
        if (selectors.length === 0)
          throw H.wrapException(E.SassScriptException$("$selectors: At least one selector must be passed."));
        return new H.MappedListIterable(selectors, new Y._closure9(), [H.getTypeArgumentByIndex(selectors, 0), null]).reduce$1(0, new Y._closure10()).get$asSassList();
      }, null, null, 4, 0, null, 0, "call"]
    },
    _closure9: {
      "^": "Closure:0;",
      call$1: [function(selector) {
        return selector.assertSelector$1$allowParent(true);
      }, null, null, 4, 0, null, 37, "call"]
    },
    _closure10: {
      "^": "Closure:2;",
      call$2: function($parent, child) {
        return child.resolveParentSelectors$1($parent);
      }
    },
    closure106: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var selectors = J.$index$asx($arguments, 0).get$asList();
        if (selectors.length === 0)
          throw H.wrapException(E.SassScriptException$("$selectors: At least one selector must be passed."));
        return new H.MappedListIterable(selectors, new Y._closure7(), [H.getTypeArgumentByIndex(selectors, 0), null]).reduce$1(0, new Y._closure8()).get$asSassList();
      }, null, null, 4, 0, null, 0, "call"]
    },
    _closure7: {
      "^": "Closure:0;",
      call$1: [function(selector) {
        return selector.assertSelector$0();
      }, null, null, 4, 0, null, 37, "call"]
    },
    _closure8: {
      "^": "Closure:2;",
      call$2: function($parent, child) {
        var t1 = child.get$components();
        return D.SelectorList$(new H.MappedListIterable(t1, new Y.__closure($parent), [H.getTypeArgumentByIndex(t1, 0), null])).resolveParentSelectors$1($parent);
      }
    },
    __closure: {
      "^": "Closure:0;parent",
      call$1: [function(complex) {
        var compound, newCompound, t1, t2;
        compound = C.JSArray_methods.get$first(complex.get$components());
        if (compound instanceof X.CompoundSelector) {
          newCompound = Y._prependParent(compound);
          if (newCompound == null)
            throw H.wrapException(E.SassScriptException$("Can't append " + H.S(complex) + " to " + H.S(this.parent) + "."));
          t1 = H.setRuntimeTypeInfo([newCompound], [S.ComplexSelectorComponent]);
          t2 = complex.get$components();
          C.JSArray_methods.addAll$1(t1, H.SubListIterable$(t2, 1, null, H.getTypeArgumentByIndex(t2, 0)));
          return S.ComplexSelector$(t1, false);
        } else
          throw H.wrapException(E.SassScriptException$("Can't append " + H.S(complex) + " to " + H.S(this.parent) + "."));
      }, null, null, 4, 0, null, 9, "call"]
    },
    closure107: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, selector, target;
        t1 = J.getInterceptor$asx($arguments);
        selector = t1.$index($arguments, 0).assertSelector$1$name("selector");
        target = t1.$index($arguments, 1).assertSelector$1$name("extendee");
        return F.Extender__extendOrReplace(selector, t1.$index($arguments, 2).assertSelector$1$name("extender"), target, C.ExtendMode_allTargets).get$asSassList();
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure108: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, selector, target;
        t1 = J.getInterceptor$asx($arguments);
        selector = t1.$index($arguments, 0).assertSelector$1$name("selector");
        target = t1.$index($arguments, 1).assertSelector$1$name("original");
        return F.Extender__extendOrReplace(selector, t1.$index($arguments, 2).assertSelector$1$name("replacement"), target, C.ExtendMode_replace).get$asSassList();
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure109: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, result;
        t1 = J.getInterceptor$asx($arguments);
        result = t1.$index($arguments, 0).assertSelector$1$name("selector1").unify$1(t1.$index($arguments, 1).assertSelector$1$name("selector2"));
        return result == null ? C.C_SassNull : result.get$asSassList();
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure110: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1 = J.getInterceptor$asx($arguments);
        return t1.$index($arguments, 0).assertSelector$1$name("super").isSuperselector$1(t1.$index($arguments, 1).assertSelector$1$name("sub")) === true ? C.SassBoolean_true : C.SassBoolean_false;
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure111: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1 = J.$index$asx($arguments, 0).assertCompoundSelector$1$name("selector").get$components();
        return D.SassList$(new H.MappedListIterable(t1, new Y._closure6(), [H.getTypeArgumentByIndex(t1, 0), null]), C.ListSeparator_kWM, false);
      }, null, null, 4, 0, null, 0, "call"]
    },
    _closure6: {
      "^": "Closure:0;",
      call$1: [function(simple) {
        return new D.SassString(J.toString$0$(simple), false, null);
      }, null, null, 4, 0, null, 32, "call"]
    },
    closure112: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        return J.$index$asx($arguments, 0).assertSelector$1$name("selector").get$asSassList();
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure113: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var feature = J.$index$asx($arguments, 0).assertString$1("feature");
        return $.$get$_features().contains$1(0, feature.text) ? C.SassBoolean_true : C.SassBoolean_false;
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure114: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        return new D.SassString(J.toString$0$(J.get$first$ax($arguments)), false, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure115: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1 = J.getInterceptor(J.$index$asx($arguments, 0));
        if (!!t1.$isSassArgumentList)
          return new D.SassString("arglist", false, null);
        if (!!t1.$isSassBoolean)
          return new D.SassString("bool", false, null);
        if (!!t1.$isSassColor)
          return new D.SassString("color", false, null);
        if (!!t1.$isSassList)
          return new D.SassString("list", false, null);
        if (!!t1.$isSassMap)
          return new D.SassString("map", false, null);
        if (!!t1.$isSassNull)
          return new D.SassString("null", false, null);
        if (!!t1.$isSassNumber)
          return new D.SassString("number", false, null);
        if (!!t1.$isSassFunction)
          return new D.SassString("function", false, null);
        return new D.SassString("string", false, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure116: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        return new D.SassString(J.$index$asx($arguments, 0).assertNumber$1("number").get$unitString(), true, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure117: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var number = J.$index$asx($arguments, 0).assertNumber$1("number");
        return !(number.numeratorUnits.length !== 0 || number.denominatorUnits.length !== 0) ? C.SassBoolean_true : C.SassBoolean_false;
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure118: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1 = J.getInterceptor$asx($arguments);
        return t1.$index($arguments, 0).assertNumber$1("number1").isComparableTo$1(t1.$index($arguments, 1).assertNumber$1("number2")) === true ? C.SassBoolean_true : C.SassBoolean_false;
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure119: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1 = J.getInterceptor$asx($arguments);
        return t1.$index($arguments, 0).get$isTruthy() ? t1.$index($arguments, 1) : t1.$index($arguments, 2);
      }, null, null, 4, 0, null, 0, "call"]
    },
    closure120: {
      "^": "Closure:0;",
      call$1: [function($arguments) {
        var t1, t2;
        t1 = $.$get$_uniqueID();
        t2 = $.$get$_random().nextInt$1(36);
        if (typeof t1 !== "number")
          return t1.$add();
        t2 = t1 + (t2 + 1);
        $._uniqueID = t2;
        if (t2 > Math.pow(36, 6)) {
          t1 = $.$get$_uniqueID();
          t2 = H.intTypeCast(Math.pow(36, 6));
          if (typeof t1 !== "number")
            return t1.$mod();
          $._uniqueID = C.JSInt_methods.$mod(t1, t2);
        }
        return new D.SassString("u" + C.JSString_methods.padLeft$2(J.toRadixString$1$n($.$get$_uniqueID(), 36), 6, "0"), false, null);
      }, null, null, 4, 0, null, 0, "call"]
    },
    _functionString_closure: {
      "^": "Closure:0;",
      call$1: [function(argument) {
        return argument.toCssString$0();
      }, null, null, 4, 0, null, 30, "call"]
    },
    _numberFunction_closure: {
      "^": "Closure:0;transform",
      call$1: [function($arguments) {
        var number = J.$index$asx($arguments, 0).assertNumber$1("number");
        return T.SassNumber$withUnits(this.transform.call$1(number.value), number.denominatorUnits, number.numeratorUnits);
      }, null, null, 4, 0, null, 0, "call"]
    }
  }], ["", "package:sass/src/import_cache.dart",, R, {
    "^": "",
    ImportCache: {
      "^": "Object;_importers,_import_cache$_logger,_canonicalizeCache,_import_cache$_importCache",
      canonicalize$3: function(url, baseImporter, baseUrl) {
        var canonicalUrl;
        if (baseImporter != null) {
          canonicalUrl = baseImporter.canonicalize$1(baseUrl != null ? baseUrl.resolveUri$1(url) : url);
          if (canonicalUrl != null)
            return new S.Tuple2(baseImporter, canonicalUrl, [null, null]);
        }
        return this._canonicalizeCache.putIfAbsent$2(url, new R.ImportCache_canonicalize_closure(this, url));
      },
      canonicalize$1: function(url) {
        return this.canonicalize$3(url, null, null);
      },
      import$3: function(url, baseImporter, baseUrl) {
        var tuple, t1, t2, stylesheet;
        tuple = this.canonicalize$3(url, baseImporter, baseUrl);
        if (tuple == null)
          return;
        t1 = tuple.get$item1();
        t2 = tuple.get$item2();
        stylesheet = this.importCanonical$3(t1, t2, baseUrl != null ? baseUrl.resolveUri$1(url) : url);
        return new S.Tuple2(tuple.get$item1(), stylesheet, [null, null]);
      },
      importCanonical$3: function(importer, canonicalUrl, originalUrl) {
        return this._import_cache$_importCache.putIfAbsent$2(canonicalUrl, new R.ImportCache_importCanonical_closure(this, importer, canonicalUrl, originalUrl));
      },
      importCanonical$2: function(importer, canonicalUrl) {
        return this.importCanonical$3(importer, canonicalUrl, null);
      },
      static: {
        ImportCache$: function(importers, loadPaths, logger, packageResolver) {
          var t1, t2;
          t1 = R.ImportCache__toImporters(importers, loadPaths, packageResolver);
          t2 = logger == null ? C.StderrLogger_false : logger;
          return new R.ImportCache(t1, t2, P.LinkedHashMap__makeEmpty(), P.LinkedHashMap__makeEmpty());
        },
        ImportCache__toImporters: function(importers, loadPaths, packageResolver) {
          var list, t1;
          if (importers == null)
            list = null;
          else {
            t1 = H.setRuntimeTypeInfo(importers.slice(0), [H.getTypeArgumentByIndex(importers, 0)]);
            list = t1;
          }
          if (list == null)
            list = [];
          if (loadPaths != null)
            C.JSArray_methods.addAll$1(list, J.map$1$ax(loadPaths, new R.ImportCache__toImporters_closure()));
          return list;
        }
      }
    },
    ImportCache__toImporters_closure: {
      "^": "Closure:0;",
      call$1: [function(path) {
        return new F.FilesystemImporter(path);
      }, null, null, 4, 0, null, 6, "call"]
    },
    ImportCache_canonicalize_closure: {
      "^": "Closure:1;$this,url",
      call$0: function() {
        var t1, t2, t3, _i, importer, canonicalUrl;
        for (t1 = this.$this._importers, t2 = t1.length, t3 = this.url, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          importer = t1[_i];
          canonicalUrl = importer.canonicalize$1(t3);
          if (canonicalUrl != null)
            return new S.Tuple2(importer, canonicalUrl, [null, null]);
        }
        return;
      }
    },
    ImportCache_importCanonical_closure: {
      "^": "Closure:1;$this,importer,canonicalUrl,originalUrl",
      call$0: function() {
        var displayUrl, result, t1, t2, t3, t4, t5, t6;
        displayUrl = this.canonicalUrl;
        result = this.importer.load$1(displayUrl);
        if (result == null)
          return;
        t1 = this.originalUrl;
        if (!(t1 == null)) {
          t2 = $.$get$url();
          displayUrl = t1.resolve$1(X.ParsedPath_ParsedPath$parse(J.get$path$x(displayUrl), t2.style).get$basename());
        }
        t1 = result.isIndented;
        t2 = result.contents;
        t3 = this.$this._import_cache$_logger;
        t4 = [P.int];
        if (t1 === true) {
          t1 = J.get$codeUnits$s(t2);
          t4 = H.setRuntimeTypeInfo([0], t4);
          t5 = typeof displayUrl === "string";
          t6 = t5 ? P.Uri_parse(displayUrl, 0, null) : displayUrl;
          t4 = new Y.SourceFile(t6, t4, new Uint32Array(H._ensureNativeList(t1.toList$0(t1))), null);
          t4.SourceFile$decoded$2$url(t1, displayUrl);
          t1 = t5 ? P.Uri_parse(displayUrl, 0, null) : displayUrl;
          t1 = new U.SassParser(0, null, null, null, false, null, false, false, false, false, false, new S.SpanScanner(t4, null, t1, t2, 0, null, null), t3).parse$0();
        } else {
          t1 = J.get$codeUnits$s(t2);
          t4 = H.setRuntimeTypeInfo([0], t4);
          t5 = typeof displayUrl === "string";
          t6 = t5 ? P.Uri_parse(displayUrl, 0, null) : displayUrl;
          t4 = new Y.SourceFile(t6, t4, new Uint32Array(H._ensureNativeList(t1.toList$0(t1))), null);
          t4.SourceFile$decoded$2$url(t1, displayUrl);
          t1 = t5 ? P.Uri_parse(displayUrl, 0, null) : displayUrl;
          t1 = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t4, null, t1, t2, 0, null, null), t3).parse$0();
        }
        return t1;
      }
    }
  }], ["", "package:sass/src/importer.dart",, M, {
    "^": "",
    Importer: {
      "^": "AsyncImporter;",
      modificationTime$1: function(url) {
        return new P.DateTime(Date.now(), false);
      }
    }
  }], ["", "package:sass/src/importer/async.dart",, B, {
    "^": "",
    AsyncImporter: {
      "^": "Object;",
      modificationTime$1: function(url) {
        return new P.DateTime(Date.now(), false);
      }
    }
  }], ["", "package:sass/src/importer/filesystem.dart",, F, {
    "^": "",
    FilesystemImporter: {
      "^": "Importer;_loadPath",
      canonicalize$1: function(url) {
        var resolved;
        if (url.get$scheme() !== "file" && url.get$scheme() !== "")
          return;
        resolved = B.resolveImportPath(D.p().join$2(0, this._loadPath, D.p().style.pathFromUri$1(M._parseUri(url))));
        return resolved == null ? null : D.p().toUri$1(D.p().canonicalize$1(resolved));
      },
      load$1: function(url) {
        var path, t1, t2;
        path = D.p().style.pathFromUri$1(M._parseUri(url));
        t1 = B.readFile(path);
        t2 = J.$eq$(X.ParsedPath_ParsedPath$parse(path, D.p().style)._splitExtension$0()[1], ".sass");
        if ((url == null ? null : url.get$scheme()) === "")
          H.throwExpression(P.ArgumentError$value(url, "sourceMapUrl", "must be absolute"));
        return new E.ImporterResult(t1, url, t2);
      },
      modificationTime$1: function(url) {
        return B.modificationTime(D.p().style.pathFromUri$1(M._parseUri(url)));
      },
      toString$0: function(_) {
        return this._loadPath;
      }
    }
  }], ["", "package:sass/src/importer/no_op.dart",, B, {
    "^": "",
    NoOpImporter: {
      "^": "Importer;",
      canonicalize$1: function(url) {
        return;
      },
      load$1: function(url) {
        return;
      },
      toString$0: function(_) {
        return "(unknown)";
      }
    }
  }], ["", "package:sass/src/importer/node/implementation.dart",, F, {
    "^": "",
    NodeImporter: {
      "^": "Object;_context,_includePaths,_implementation$_importers",
      load$2: function(url, previous) {
        var parsed, result, previousString, t1, t2, t3, _i, value;
        parsed = P.Uri_parse(url, 0, null);
        if (parsed.get$scheme() === "" || parsed.get$scheme() === "file") {
          result = this._resolvePath$2(D.p().style.pathFromUri$1(M._parseUri(parsed)), previous);
          if (result != null)
            return result;
        }
        previousString = previous.get$scheme() === "file" ? D.p().style.pathFromUri$1(M._parseUri(previous)) : J.toString$0$(previous);
        for (t1 = this._implementation$_importers, t2 = t1.length, t3 = this._context, _i = 0; _i < t2; ++_i) {
          value = J.apply$2$x(H.interceptedTypeCast(t1[_i], "$isJSFunction"), t3, [url, previousString]);
          if (value != null)
            return this._handleImportResult$3(url, previous, value);
        }
        return;
      },
      loadAsync$2: function(url, previous) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter([S.Tuple2, P.String, P.String]), $async$returnValue, $async$self = this, parsed, result, previousString, t1, t2, _i, value;
        var $async$loadAsync$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                parsed = P.Uri_parse(url, 0, null);
                if (parsed.get$scheme() === "" || parsed.get$scheme() === "file") {
                  result = $async$self._resolvePath$2(D.p().style.pathFromUri$1(M._parseUri(parsed)), previous);
                  if (result != null) {
                    $async$returnValue = result;
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                }
                previousString = previous.get$scheme() === "file" ? D.p().style.pathFromUri$1(M._parseUri(previous)) : J.toString$0$(previous);
                t1 = $async$self._implementation$_importers, t2 = t1.length, _i = 0;
              case 3:
                // for condition
                if (!(_i < t2)) {
                  // goto after for
                  $async$goto = 5;
                  break;
                }
                $async$goto = 6;
                return P._asyncAwait($async$self._callImporterAsync$3(t1[_i], url, previousString), $async$loadAsync$2);
              case 6:
                // returning from await.
                value = $async$result;
                if (value != null) {
                  $async$returnValue = $async$self._handleImportResult$3(url, previous, value);
                  // goto return
                  $async$goto = 1;
                  break;
                }
              case 4:
                // for update
                ++_i;
                // goto for condition
                $async$goto = 3;
                break;
              case 5:
                // after for
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$loadAsync$2, $async$completer);
      },
      _resolvePath$2: function(path, previous) {
        var result, cwdResult, t1, t2, t3, _i, includePath, resolved;
        if (J.$gt$n(D.p().style.rootLength$1(path), 0))
          return this._tryPath$1(path);
        if (previous.get$scheme() === "file") {
          result = this._tryPath$1(D.p().join$2(0, D.p().dirname$1(D.p().style.pathFromUri$1(M._parseUri(previous))), path));
          if (result != null)
            return result;
        }
        cwdResult = this._tryPath$1(D.p().absolute$1(path));
        if (cwdResult != null)
          return cwdResult;
        for (t1 = this._includePaths, t2 = t1.length, t3 = [null, null], _i = 0; _i < t2; ++_i) {
          includePath = t1[_i];
          resolved = B.resolveImportPath(D.p().absolute$1(D.p().join$2(0, includePath, path)));
          result = resolved == null ? null : new S.Tuple2(B.readFile(resolved), J.toString$0$(D.p().toUri$1(resolved)), t3);
          if (result != null)
            return result;
        }
        return;
      },
      _tryPath$1: function(path) {
        var resolved = B.resolveImportPath(path);
        return resolved == null ? null : new S.Tuple2(B.readFile(resolved), J.toString$0$(D.p().toUri$1(resolved)), [null, null]);
      },
      _handleImportResult$3: function(url, previous, value) {
        var result, exception, resolved, t1;
        if (value instanceof self.Error)
          throw H.wrapException(value);
        result = null;
        try {
          result = H.interceptedTypeCast(value, "$isNodeImporterResult");
        } catch (exception) {
          if (!!J.getInterceptor(H.unwrapException(exception)).$isCastError)
            return;
          else
            throw exception;
        }
        if (J.get$file$x(result) != null) {
          resolved = this._resolvePath$2(J.get$file$x(result), previous);
          if (resolved != null)
            return resolved;
          throw H.wrapException("Can't find stylesheet to import.");
        } else {
          t1 = J.get$contents$x(result);
          if (t1 == null)
            t1 = "";
          return new S.Tuple2(t1, url, [null, null]);
        }
      },
      _callImporterAsync$3: function(importer, url, previousString) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(P.Object), $async$returnValue, $async$self = this, t1, result;
        var $async$_callImporterAsync$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = new P._Future(0, $.Zone__current, null, [null]);
                result = B.call3(importer, $async$self._context, url, previousString, P.allowInterop(new P._AsyncCompleter(t1, [null]).get$complete()));
                $async$goto = H.boolTypeCast($.$get$_isUndefined().call$1(result)) === true ? 3 : 4;
                break;
              case 3:
                // then
                $async$goto = 5;
                return P._asyncAwait(t1, $async$_callImporterAsync$3);
              case 5:
                // returning from await.
                $async$returnValue = $async$result;
                // goto return
                $async$goto = 1;
                break;
              case 4:
                // join
                $async$returnValue = result;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_callImporterAsync$3, $async$completer);
      }
    }
  }], ["", "package:sass/src/importer/result.dart",, E, {
    "^": "",
    ImporterResult: {
      "^": "Object;contents>,_sourceMapUrl,isIndented<"
    }
  }], ["", "package:sass/src/importer/utils.dart",, B, {
    "^": "",
    resolveImportPath: function(path) {
      var extension, t1;
      extension = X.ParsedPath_ParsedPath$parse(path, D.p().style)._splitExtension$0()[1];
      t1 = J.getInterceptor(extension);
      if (t1.$eq(extension, ".sass") === true || t1.$eq(extension, ".scss") === true)
        return B._exactlyOne(B._tryPath(path));
      t1 = B._exactlyOne(B._tryPathWithExtensions(path));
      if (t1 == null)
        t1 = B.dirExists(path) === true ? B._exactlyOne(B._tryPathWithExtensions(D.p().join$2(0, path, "index"))) : null;
      return t1;
    },
    _tryPathWithExtensions: function(path) {
      var t1, t2;
      t1 = J.getInterceptor$ansx(path);
      t2 = B._tryPath(t1.$add(path, ".sass"));
      C.JSArray_methods.addAll$1(t2, B._tryPath(t1.$add(path, ".scss")));
      return t2;
    },
    _tryPath: function(path) {
      var paths, partial;
      paths = H.setRuntimeTypeInfo([], [P.String]);
      partial = D.p().join$2(0, D.p().dirname$1(path), "_" + H.S(X.ParsedPath_ParsedPath$parse(path, D.p().style).get$basename()));
      if (B.fileExists(partial) === true)
        paths.push(partial);
      if (B.fileExists(path) === true)
        paths.push(path);
      return paths;
    },
    _exactlyOne: function(paths) {
      var t1 = paths.length;
      if (t1 === 0)
        return;
      if (t1 === 1)
        return C.JSArray_methods.get$first(paths);
      throw H.wrapException("It's not clear which file to import. Found:\n" + C.JSArray_methods.map$1(paths, new B._exactlyOne_closure()).join$1(0, "\n"));
    },
    _exactlyOne_closure: {
      "^": "Closure:0;",
      call$1: [function(path) {
        return C.JSString_methods.$add("  ", D.p().prettyUri$1(D.p().toUri$1(path)));
      }, null, null, 4, 0, null, 6, "call"]
    }
  }], ["", "package:sass/src/interpolation_buffer.dart",, Z, {
    "^": "",
    InterpolationBuffer: {
      "^": "Object;_interpolation_buffer$_text<,_interpolation_buffer$_contents",
      get$isEmpty: function(_) {
        return this._interpolation_buffer$_contents.length === 0 && this._interpolation_buffer$_text._contents.length === 0;
      },
      write$1: function(_, obj) {
        this._interpolation_buffer$_text._contents += H.S(obj);
        return;
      },
      add$1: function(_, expression) {
        this._flushText$0();
        this._interpolation_buffer$_contents.push(expression);
      },
      addInterpolation$1: function(interpolation) {
        var toAdd, first, t1, t2;
        toAdd = interpolation.contents;
        if (toAdd.length === 0)
          return;
        first = C.JSArray_methods.get$first(toAdd);
        if (typeof first === "string") {
          this._interpolation_buffer$_text._contents += first;
          toAdd = H.SubListIterable$(toAdd, 1, null, H.getTypeArgumentByIndex(toAdd, 0));
        }
        this._flushText$0();
        t1 = this._interpolation_buffer$_contents;
        C.JSArray_methods.addAll$1(t1, toAdd);
        t2 = C.JSArray_methods.get$last(t1);
        if (typeof t2 === "string") {
          if (0 >= t1.length)
            return H.ioore(t1, -1);
          this._interpolation_buffer$_text._contents += H.S(t1.pop());
        }
      },
      _flushText$0: function() {
        var t1, t2;
        t1 = this._interpolation_buffer$_text;
        t2 = t1._contents;
        if (t2.length === 0)
          return;
        this._interpolation_buffer$_contents.push(t2.charCodeAt(0) == 0 ? t2 : t2);
        t1._contents = "";
      },
      interpolation$1: function(span) {
        var t1, contents;
        t1 = this._interpolation_buffer$_contents;
        contents = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
        t1 = this._interpolation_buffer$_text._contents;
        if (t1.length !== 0)
          contents.push(t1.charCodeAt(0) == 0 ? t1 : t1);
        return X.Interpolation$(contents, span);
      },
      toString$0: function(_) {
        var t1, t2, _i, t3, element;
        for (t1 = this._interpolation_buffer$_contents, t2 = t1.length, _i = 0, t3 = ""; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          element = t1[_i];
          t3 = typeof element === "string" ? t3 + element : t3 + "#{" + H.S(element) + H.Primitives_stringFromCharCode(125);
        }
        t1 = t3 + this._interpolation_buffer$_text.toString$0(0);
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }
    }
  }], ["", "package:sass/src/io/node.dart",, B, {
    "^": "",
    readFile: function(path) {
      var contents, t1, t2, t3, sourceFile, i;
      contents = H.stringTypeCast(B._readFile(path, "utf8"));
      if (!J.getInterceptor$asx(contents).contains$1(contents, "\ufffd"))
        return contents;
      t1 = D.p().toUri$1(path);
      t2 = C.JSString_methods.get$codeUnits(contents);
      t3 = H.setRuntimeTypeInfo([0], [P.int]);
      sourceFile = new Y.SourceFile(t1, t3, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
      sourceFile.SourceFile$decoded$2$url(t2, t1);
      for (t1 = contents.length, i = 0; i < t1; ++i) {
        if (C.JSString_methods._codeUnitAt$1(contents, i) !== 65533)
          continue;
        throw H.wrapException(E.SassException$("Invalid UTF-8.", sourceFile.location$1(i).pointSpan$0()));
      }
      return contents;
    },
    _readFile: function(path, encoding) {
      return B._systemErrorToFileSystemException(new B._readFile_closure(path, encoding));
    },
    writeFile: function(path, contents) {
      return B._systemErrorToFileSystemException(new B.writeFile_closure(path, contents));
    },
    deleteFile: function(path) {
      return B._systemErrorToFileSystemException(new B.deleteFile_closure(path));
    },
    readStdin: function() {
      var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(P.String), $async$returnValue, t1, t2, t3, completer, sink;
      var $async$readStdin = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = {};
              t2 = P.String;
              t3 = new P._Future(0, $.Zone__current, null, [t2]);
              completer = new P._AsyncCompleter(t3, [t2]);
              t1.contents = null;
              sink = new P.Utf8Decoder(false).startChunkedConversion$1(new P._StringCallbackSink(new B.readStdin_closure(t1, completer), new P.StringBuffer("")));
              J.on$2$x(self.process.stdin, "data", P.allowInterop(new B.readStdin_closure0(sink)));
              J.on$2$x(self.process.stdin, "end", P.allowInterop(new B.readStdin_closure1(sink)));
              J.on$2$x(self.process.stdin, "error", P.allowInterop(new B.readStdin_closure2(completer)));
              $async$returnValue = t3;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$readStdin, $async$completer);
    },
    fileExists: function(path) {
      var error, systemError, t1, exception;
      try {
        t1 = J.isFile$0$x(J.statSync$1$x($.$get$_fs(), path));
        return t1;
      } catch (exception) {
        error = H.unwrapException(exception);
        systemError = H.interceptedTypeCast(error, "$is_SystemError");
        if (J.$eq$(J.get$code$x(systemError), "ENOENT") === true)
          return false;
        throw exception;
      }
    },
    dirExists: function(path) {
      var error, systemError, t1, exception;
      try {
        t1 = J.isDirectory$0$x(J.statSync$1$x($.$get$_fs(), path));
        return t1;
      } catch (exception) {
        error = H.unwrapException(exception);
        systemError = H.interceptedTypeCast(error, "$is_SystemError");
        if (J.$eq$(J.get$code$x(systemError), "ENOENT") === true)
          return false;
        throw exception;
      }
    },
    ensureDir: function(path) {
      return B._systemErrorToFileSystemException(new B.ensureDir_closure(path));
    },
    listDir: function(path) {
      return B._systemErrorToFileSystemException(new B.listDir_closure(new B.listDir_list(), path));
    },
    modificationTime: function(path) {
      return B._systemErrorToFileSystemException(new B.modificationTime_closure(path));
    },
    _systemErrorToFileSystemException: function(callback) {
      var error, systemError, t1, exception, t2;
      try {
        t1 = callback.call$0();
        return t1;
      } catch (exception) {
        error = H.unwrapException(exception);
        systemError = H.interceptedTypeCast(error, "$is_SystemError");
        t1 = systemError;
        t2 = J.getInterceptor$x(t1);
        t1 = J.substring$2$s(t2.get$message(t1), (H.S(t2.get$code(t1)) + ": ").length, J.$sub$n(J.get$length$asx(t2.get$message(t1)), (", " + H.S(t2.get$syscall(t1)) + " '" + H.S(t2.get$path(t1)) + "'").length));
        t2 = J.get$path$x(systemError);
        throw H.wrapException(new B.FileSystemException(t1, t2));
      }
    },
    isWindows: function() {
      return J.$eq$(J.get$platform$x(self.process), "win32");
    },
    watchDir: function(path) {
      var t1, watcher, t2, t3, t4;
      t1 = {};
      watcher = J.watch$2$x($.$get$chokidar(), path, {disableGlobbing: true});
      t1.controller = null;
      t2 = J.getInterceptor$x(watcher);
      t2.on$2(watcher, "add", P.allowInterop(new B.watchDir_closure(t1)));
      t2.on$2(watcher, "change", P.allowInterop(new B.watchDir_closure0(t1)));
      t2.on$2(watcher, "unlink", P.allowInterop(new B.watchDir_closure1(t1)));
      t2.on$2(watcher, "error", P.allowInterop(new B.watchDir_closure2(t1)));
      t3 = [P.Stream, E.WatchEvent];
      t4 = new P._Future(0, $.Zone__current, null, [t3]);
      t2.on$2(watcher, "ready", P.allowInterop(new B.watchDir_closure3(t1, new P._AsyncCompleter(t4, [t3]))));
      return t4;
    },
    _FS: {
      "^": "JavaScriptObject;",
      "%": ""
    },
    _Stat: {
      "^": "JavaScriptObject;",
      "%": ""
    },
    _Date: {
      "^": "JavaScriptObject;",
      "%": ""
    },
    _Stderr: {
      "^": "JavaScriptObject;",
      "%": ""
    },
    _Stdin: {
      "^": "JavaScriptObject;",
      "%": ""
    },
    _SystemError: {
      "^": "JavaScriptObject;",
      "%": ""
    },
    _Process: {
      "^": "JavaScriptObject;",
      "%": ""
    },
    FileSystemException: {
      "^": "Object;message>,path>"
    },
    Stderr: {
      "^": "Object;_stderr",
      write$1: function(_, object) {
        return J.write$1$x(this._stderr, object);
      },
      writeln$1: function(object) {
        J.write$1$x(this._stderr, H.S(object == null ? "" : object) + "\n");
      },
      writeln$0: function() {
        return this.writeln$1(null);
      }
    },
    _readFile_closure: {
      "^": "Closure:1;path,encoding",
      call$0: function() {
        return J.readFileSync$2$x($.$get$_fs(), this.path, this.encoding);
      }
    },
    writeFile_closure: {
      "^": "Closure:1;path,contents",
      call$0: function() {
        return J.writeFileSync$2$x($.$get$_fs(), this.path, this.contents);
      }
    },
    deleteFile_closure: {
      "^": "Closure:1;path",
      call$0: function() {
        return J.unlinkSync$1$x($.$get$_fs(), this.path);
      }
    },
    readStdin_closure: {
      "^": "Closure:14;_box_0,completer",
      call$1: function(result) {
        this._box_0.contents = result;
        this.completer.complete$1(result);
      }
    },
    readStdin_closure0: {
      "^": "Closure:5;sink",
      call$1: [function(chunk) {
        this.sink.add$1(0, H.subtypeCast(chunk, "$isList", [P.int], "$asList"));
      }, function() {
        return this.call$1(null);
      }, "call$0", null, null, null, 0, 2, null, 2, 23, "call"]
    },
    readStdin_closure1: {
      "^": "Closure:5;sink",
      call$1: [function(_) {
        this.sink.close$0(0);
      }, function() {
        return this.call$1(null);
      }, "call$0", null, null, null, 0, 2, null, 2, 7, "call"]
    },
    readStdin_closure2: {
      "^": "Closure:5;completer",
      call$1: [function(e) {
        var t1 = $.$get$stderr();
        t1.writeln$1("Failed to read from stdin");
        t1.writeln$1(e);
        this.completer.completeError$1(e);
      }, function() {
        return this.call$1(null);
      }, "call$0", null, null, null, 0, 2, null, 2, 20, "call"]
    },
    ensureDir_closure: {
      "^": "Closure:1;path",
      call$0: function() {
        var error, systemError, exception, t1;
        try {
          J.mkdirSync$1$x($.$get$_fs(), this.path);
        } catch (exception) {
          error = H.unwrapException(exception);
          systemError = H.interceptedTypeCast(error, "$is_SystemError");
          if (J.$eq$(J.get$code$x(systemError), "EEXIST") === true)
            return;
          if (J.$eq$(J.get$code$x(systemError), "ENOENT") !== true)
            throw exception;
          t1 = this.path;
          B.ensureDir(D.p().dirname$1(t1));
          J.mkdirSync$1$x($.$get$_fs(), t1);
        }
      }
    },
    listDir_list: {
      "^": "Closure:43;",
      call$1: function($parent) {
        return J.expand$1$ax(J.readdirSync$1$x($.$get$_fs(), $parent), new B.listDir_list_closure($parent));
      }
    },
    listDir_list_closure: {
      "^": "Closure:0;parent",
      call$1: function(child) {
        var path = D.p().join$2(0, this.parent, child);
        return B.dirExists(path) === true ? B.listDir(path) : [path];
      }
    },
    listDir_closure: {
      "^": "Closure:1;list,path",
      call$0: function() {
        return this.list.call$1(this.path);
      }
    },
    modificationTime_closure: {
      "^": "Closure:1;path",
      call$0: function() {
        var t1, t2;
        t1 = J.getTime$0$x(J.get$mtime$x(J.statSync$1$x($.$get$_fs(), this.path)));
        if (typeof t1 !== "number")
          return H.iae(t1);
        t1 = 0 + t1;
        t2 = new P.DateTime(t1, false);
        t2.DateTime$_withValue$2$isUtc(t1, false);
        return t2;
      }
    },
    watchDir_closure: {
      "^": "Closure:22;_box_0",
      call$2: [function(path, _) {
        var t1 = this._box_0.controller;
        return t1 == null ? null : t1.add$1(0, new E.WatchEvent(C.ChangeType_add, path));
      }, null, null, 8, 0, null, 6, 7, "call"]
    },
    watchDir_closure0: {
      "^": "Closure:22;_box_0",
      call$2: [function(path, _) {
        var t1 = this._box_0.controller;
        return t1 == null ? null : t1.add$1(0, new E.WatchEvent(C.ChangeType_modify, path));
      }, null, null, 8, 0, null, 6, 7, "call"]
    },
    watchDir_closure1: {
      "^": "Closure:14;_box_0",
      call$1: [function(path) {
        var t1 = this._box_0.controller;
        return t1 == null ? null : t1.add$1(0, new E.WatchEvent(C.ChangeType_remove, path));
      }, null, null, 4, 0, null, 6, "call"]
    },
    watchDir_closure2: {
      "^": "Closure:0;_box_0",
      call$1: [function(error) {
        var t1 = this._box_0.controller;
        return t1 == null ? null : t1.addError$1(error);
      }, null, null, 4, 0, null, 4, "call"]
    },
    watchDir_closure3: {
      "^": "Closure:1;_box_0,completer",
      call$0: [function() {
        var controller = P.StreamController_StreamController(null, null, null, null, false, E.WatchEvent);
        this._box_0.controller = controller;
        this.completer.complete$1(new P._ControllerStream(controller, [H.getTypeArgumentByIndex(controller, 0)]));
      }, null, null, 0, 0, null, "call"]
    }
  }], ["", "package:sass/src/logger.dart",, F, {
    "^": "",
    _QuietLogger: {
      "^": "Object;",
      warn$4$deprecation$span$trace: function(message, deprecation, span, trace) {
      },
      warn$2$span: function(message, span) {
        return this.warn$4$deprecation$span$trace(message, false, span, null);
      },
      warn$2$trace: function(message, trace) {
        return this.warn$4$deprecation$span$trace(message, false, null, trace);
      },
      warn$3$deprecation$span: function(message, deprecation, span) {
        return this.warn$4$deprecation$span$trace(message, deprecation, span, null);
      },
      debug$2: function(message, span) {
      }
    }
  }], ["", "package:sass/src/logger/stderr.dart",, S, {
    "^": "",
    StderrLogger: {
      "^": "Object;color<",
      warn$4$deprecation$span$trace: function(message, deprecation, span, trace) {
        var t1, t2, t3;
        t1 = this.color;
        if (t1 === true) {
          t2 = $.$get$stderr();
          t3 = t2._stderr;
          J.write$1$x(t3, "\x1b[33m\x1b[1m");
          if (deprecation)
            J.write$1$x(t3, "Deprecation ");
          J.write$1$x(t3, "Warning\x1b[0m");
        } else {
          if (deprecation)
            J.write$1$x($.$get$stderr()._stderr, "DEPRECATION ");
          t2 = $.$get$stderr();
          J.write$1$x(t2._stderr, "WARNING");
        }
        if (span == null)
          t2.writeln$1(": " + H.S(message));
        else if (trace != null)
          t2.writeln$1(": " + H.S(message) + "\n\n" + span.highlight$1$color(t1));
        else
          t2.writeln$1(" on " + span.message$2$color(0, C.JSString_methods.$add("\n", message), t1));
        if (trace != null)
          t2.writeln$1(B.indent(C.JSString_methods.trimRight$0(trace.toString$0(0)), 4));
        t2.writeln$0();
      },
      warn$2$span: function(message, span) {
        return this.warn$4$deprecation$span$trace(message, false, span, null);
      },
      warn$2$trace: function(message, trace) {
        return this.warn$4$deprecation$span$trace(message, false, null, trace);
      },
      warn$3$deprecation$span: function(message, deprecation, span) {
        return this.warn$4$deprecation$span$trace(message, deprecation, span, null);
      },
      debug$2: function(message, span) {
        var t1, t2, t3, t4;
        t1 = $.$get$stderr();
        t2 = span.file;
        t3 = span._file$_start;
        t4 = H.S(D.p().prettyUri$1(Y.FileLocation$_(t2, t3).file.url)) + ":";
        t3 = Y.FileLocation$_(t2, t3);
        t3 = t3.file.getLine$1(t3.offset);
        if (typeof t3 !== "number")
          return t3.$add();
        t3 = t4 + (t3 + 1) + " ";
        t4 = t1._stderr;
        J.write$1$x(t4, t3);
        J.write$1$x(t4, this.color === true ? "\x1b[1mDebug\x1b[0m" : "DEBUG");
        t1.writeln$1(": " + H.S(message));
      }
    }
  }], ["", "package:sass/src/logger/tracking.dart",, T, {
    "^": "",
    TrackingLogger: {
      "^": "Object;_tracking$_logger,_emittedWarning,_emittedDebug",
      warn$4$deprecation$span$trace: function(message, deprecation, span, trace) {
        this._emittedWarning = true;
        this._tracking$_logger.warn$4$deprecation$span$trace(message, deprecation, span, trace);
      },
      warn$2$span: function(message, span) {
        return this.warn$4$deprecation$span$trace(message, false, span, null);
      },
      warn$2$trace: function(message, trace) {
        return this.warn$4$deprecation$span$trace(message, false, null, trace);
      },
      warn$3$deprecation$span: function(message, deprecation, span) {
        return this.warn$4$deprecation$span$trace(message, deprecation, span, null);
      },
      debug$2: function(message, span) {
        this._emittedDebug = true;
        this._tracking$_logger.debug$2(message, span);
      }
    }
  }], ["", "package:sass/src/node.dart",, B, {
    "^": "",
    main0: function() {
      J.set$run_$x(self.exports, P.allowInterop(F.executable__main$closure()));
      J.set$render$x(self.exports, P.allowInterop(B.node___render$closure()));
      J.set$renderSync$x(self.exports, P.allowInterop(B.node___renderSync$closure()));
      J.set$info$x(self.exports, "dart-sass\t1.6.0\t(Sass Compiler)\t[Dart]\ndart2js\t2.0.0-dev.62.0\t(Dart Compiler)\t[Dart]");
      J.set$types$x(self.exports, {Boolean: $.$get$booleanConstructor(), Color: $.$get$colorConstructor(), List: $.$get$listConstructor(), Map: $.$get$mapConstructor(), Null: $.$get$nullConstructor(), Number: $.$get$numberConstructor(), String: $.$get$stringConstructor()});
    },
    _render: [function(options, callback) {
      var t1 = J.getInterceptor$x(options);
      if (t1.get$fiber(options) != null)
        J.run$0$x(t1.get$fiber(options).call$1(P.allowInterop(new B._render_closure(callback, options))));
      else
        B._renderAsync(options).then$2$onError(new B._render_closure0(callback), new B._render_closure1(callback));
    }, "call$2", "node___render$closure", 8, 0, 94, 38, 24],
    _renderAsync: function(options) {
      var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(U.RenderResult), $async$returnValue, start, t1, file, t2, t3, t4, t5, t6, t7, t8, t9, result;
      var $async$_renderAsync = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              start = new P.DateTime(Date.now(), false);
              t1 = J.getInterceptor$x(options);
              file = t1.get$file(options) == null ? null : D.p().absolute$1(t1.get$file(options));
              $async$goto = t1.get$data(options) != null ? 3 : 5;
              break;
            case 3:
              // then
              t2 = t1.get$data(options);
              t3 = B._parseImporter(options, start);
              t4 = B._parseFunctions(options, true);
              t5 = t1.get$indentedSyntax(options);
              t5 = J.$eq$(t5, false) !== true && t5 != null;
              t6 = B._parseOutputStyle(t1.get$outputStyle(options));
              t7 = J.$eq$(t1.get$indentType(options), "tab");
              t8 = B._parseIndentWidth(t1.get$indentWidth(options));
              t9 = B._parseLineFeed(t1.get$linefeed(options));
              t1 = t1.get$file(options) == null ? "stdin" : J.toString$0$(D.p().toUri$1(file));
              $async$goto = 6;
              return P._asyncAwait(U.compileStringAsync(t2, t4, null, null, t8, t5, t9, null, null, t3, null, B._enableSourceMaps(options), t6, t1, t7 !== true), $async$_renderAsync);
            case 6:
              // returning from await.
              result = $async$result;
              // goto join
              $async$goto = 4;
              break;
            case 5:
              // else
              $async$goto = t1.get$file(options) != null ? 7 : 9;
              break;
            case 7:
              // then
              t2 = B._parseImporter(options, start);
              t3 = B._parseFunctions(options, true);
              t4 = t1.get$indentedSyntax(options);
              t5 = B._parseOutputStyle(t1.get$outputStyle(options));
              t6 = J.$eq$(t1.get$indentType(options), "tab");
              t7 = B._parseIndentWidth(t1.get$indentWidth(options));
              t1 = B._parseLineFeed(t1.get$linefeed(options));
              t8 = B._enableSourceMaps(options);
              t9 = B.readFile(file);
              if (t4 == null)
                t4 = J.$eq$(X.ParsedPath_ParsedPath$parse(file, D.p().style)._splitExtension$0()[1], ".sass");
              $async$goto = 10;
              return P._asyncAwait(U.compileStringAsync(t9, t3, new F.FilesystemImporter("."), null, t7, t4, t1, null, null, t2, null, t8, t5, D.p().toUri$1(file), t6 !== true), $async$_renderAsync);
            case 10:
              // returning from await.
              result = $async$result;
              // goto join
              $async$goto = 8;
              break;
            case 9:
              // else
              throw H.wrapException(P.ArgumentError$("Either options.data or options.file must be set."));
            case 8:
              // join
            case 4:
              // join
              $async$returnValue = B._newRenderResult(options, result, start);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$_renderAsync, $async$completer);
    },
    _renderSync: [function(options) {
      var start, file, result, error, error0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, exception;
      try {
        start = new P.DateTime(Date.now(), false);
        t1 = J.getInterceptor$x(options);
        file = t1.get$file(options) == null ? null : D.p().absolute$1(t1.get$file(options));
        result = null;
        if (t1.get$data(options) != null) {
          t2 = t1.get$data(options);
          t3 = B._parseImporter(options, start);
          t4 = C.JSArray_methods.cast$0(B._parseFunctions(options, false));
          t5 = t1.get$indentedSyntax(options);
          t5 = J.$eq$(t5, false) !== true && t5 != null;
          t6 = B._parseOutputStyle(t1.get$outputStyle(options));
          t7 = J.$eq$(t1.get$indentType(options), "tab");
          t8 = B._parseIndentWidth(t1.get$indentWidth(options));
          t9 = B._parseLineFeed(t1.get$linefeed(options));
          t1 = t1.get$file(options) == null ? "stdin" : J.toString$0$(D.p().toUri$1(file));
          result = U.compileString(t2, t4, null, null, t8, t5, t9, null, null, t3, null, B._enableSourceMaps(options), t6, t1, t7 !== true);
        } else if (t1.get$file(options) != null) {
          t2 = file;
          t3 = B._parseImporter(options, start);
          t4 = C.JSArray_methods.cast$0(B._parseFunctions(options, false));
          t5 = t1.get$indentedSyntax(options);
          t6 = B._parseOutputStyle(t1.get$outputStyle(options));
          t7 = J.$eq$(t1.get$indentType(options), "tab");
          t8 = B._parseIndentWidth(t1.get$indentWidth(options));
          t1 = B._parseLineFeed(t1.get$linefeed(options));
          t9 = B._enableSourceMaps(options);
          t10 = B.readFile(t2);
          if (t5 == null)
            t5 = J.$eq$(X.ParsedPath_ParsedPath$parse(t2, D.p().style)._splitExtension$0()[1], ".sass");
          result = U.compileString(t10, t4, new F.FilesystemImporter("."), null, t8, t5, t1, null, null, t3, null, t9, t6, D.p().toUri$1(t2), t7 !== true);
        } else {
          t1 = P.ArgumentError$("Either options.data or options.file must be set.");
          throw H.wrapException(t1);
        }
        t1 = B._newRenderResult(options, result, start);
        return t1;
      } catch (exception) {
        t1 = H.unwrapException(exception);
        if (t1 instanceof E.SassException) {
          error = t1;
          t1 = B._wrapException(error);
          $.$get$_jsThrow().call$1(t1);
        } else {
          error0 = t1;
          t1 = B._newRenderError(J.toString$0$(error0), null, null, null, null, 3);
          $.$get$_jsThrow().call$1(t1);
        }
      }
      throw H.wrapException("unreachable");
    }, "call$1", "node___renderSync$closure", 4, 0, 95, 38],
    _wrapException: function(exception) {
      var t1, trace, t2, t3, t4, t5, t6;
      if (!!exception.$isSassRuntimeException) {
        t1 = H.setRuntimeTypeInfo(C.JSString_methods.trimRight$0(exception.trace.toString$0(0)).split("\n"), [P.String]);
        trace = "\n" + new H.MappedListIterable(t1, new B._wrapException_closure(), [H.getTypeArgumentByIndex(t1, 0), null]).join$1(0, "\n");
      } else {
        t1 = D.p();
        t2 = H.interceptedTypeCast(G.SourceSpanException.prototype.get$span.call(exception), "$isFileSpan").file.url;
        t1 = "\n  " + H.S(t1.prettyUri$1(t2 == null ? "-" : t2)) + " ";
        t2 = H.interceptedTypeCast(G.SourceSpanException.prototype.get$span.call(exception), "$isFileSpan");
        t2 = Y.FileLocation$_(t2.file, t2._file$_start);
        t2 = t2.file.getLine$1(t2.offset);
        if (typeof t2 !== "number")
          return t2.$add();
        t2 = t1 + (t2 + 1) + ":";
        t1 = H.interceptedTypeCast(G.SourceSpanException.prototype.get$span.call(exception), "$isFileSpan");
        t1 = Y.FileLocation$_(t1.file, t1._file$_start);
        trace = t2 + H.S(J.$add$ansx(t1.file.getColumn$1(t1.offset), 1)) + "  root stylesheet";
      }
      t1 = J.$add$ansx(exception._span_exception$_message, trace);
      t2 = exception.toString$0(0);
      t3 = H.interceptedTypeCast(G.SourceSpanException.prototype.get$span.call(exception), "$isFileSpan");
      t3 = Y.FileLocation$_(t3.file, t3._file$_start);
      t3 = t3.file.getLine$1(t3.offset);
      if (typeof t3 !== "number")
        return t3.$add();
      t4 = H.interceptedTypeCast(G.SourceSpanException.prototype.get$span.call(exception), "$isFileSpan");
      t4 = Y.FileLocation$_(t4.file, t4._file$_start);
      t4 = J.$add$ansx(t4.file.getColumn$1(t4.offset), 1);
      if (H.interceptedTypeCast(G.SourceSpanException.prototype.get$span.call(exception), "$isFileSpan").file.url == null)
        t5 = "stdin";
      else {
        t5 = D.p();
        t6 = H.interceptedTypeCast(G.SourceSpanException.prototype.get$span.call(exception), "$isFileSpan").file;
        t6 = t5.style.pathFromUri$1(M._parseUri(t6.url));
        t5 = t6;
      }
      return B._newRenderError(t1, t4, t5, t2, t3 + 1, 1);
    },
    _parseFunctions: function(options, asynch) {
      var t1, result;
      t1 = J.getInterceptor$x(options);
      if (t1.get$functions(options) == null)
        return C.List_empty;
      result = H.setRuntimeTypeInfo([], [B.AsyncCallable]);
      B.jsForEach(t1.get$functions(options), new B._parseFunctions_closure(options, result, asynch));
      return result;
    },
    _parseImporter: function(options, start) {
      var t1, importers, includePaths, t2, t3, t4, t5, t6, t7, t8, t9, context;
      t1 = J.getInterceptor$x(options);
      if (t1.get$importer(options) == null)
        importers = [];
      else
        importers = !!J.getInterceptor(t1.get$importer(options)).$isList ? J.cast$0$ax(H.listTypeCast(t1.get$importer(options))) : [H.functionTypeCast(t1.get$importer(options), {func: 1, args: [P.String, P.String], opt: [{func: 1, v: true, args: [,]}]})];
      includePaths = t1.get$includePaths(options);
      if (includePaths == null)
        includePaths = [];
      t2 = J.getInterceptor$asx(importers);
      if (t2.get$isNotEmpty(importers)) {
        t3 = t1.get$file(options);
        t4 = t1.get$data(options);
        t5 = D.p()._context$_current;
        t5 = [t5 != null ? t5 : D.current()];
        C.JSArray_methods.addAll$1(t5, includePaths);
        t5 = C.JSArray_methods.join$1(t5, ":");
        t6 = J.$eq$(t1.get$indentType(options), "tab") === true ? 1 : 0;
        t7 = B._parseIndentWidth(t1.get$indentWidth(options));
        if (t7 == null)
          t7 = 2;
        t8 = B._parseLineFeed(t1.get$linefeed(options));
        t9 = t1.get$file(options);
        if (t9 == null)
          t9 = "data";
        context = {options: {data: t4, file: t3, includePaths: t5, indentType: t6, indentWidth: t7, linefeed: t8.text, precision: 10, result: {stats: {entry: t9, start: start._core$_value}}, style: 1}};
        J.set$context$x(J.get$options$x(context), context);
      } else
        context = null;
      if (t1.get$fiber(options) != null)
        importers = t2.map$1(importers, new B._parseImporter_closure(options)).toList$0(0);
      return new F.NodeImporter(context, P.List_List$unmodifiable(includePaths, null), P.List_List$unmodifiable(importers, null));
    },
    _parseOutputStyle: function(style) {
      if (style == null || J.$eq$(style, "expanded") === true)
        return C.OutputStyle_expanded;
      if (J.$eq$(style, "compressed") === true)
        return C.OutputStyle_compressed;
      throw H.wrapException(P.ArgumentError$('Unsupported output style "' + H.S(style) + '".'));
    },
    _parseIndentWidth: function(width) {
      if (width == null)
        return;
      return typeof width === "number" && Math.floor(width) === width ? width : P.int_parse(J.toString$0$(width), null, null);
    },
    _parseLineFeed: function(str) {
      switch (str) {
        case "cr":
          return C.LineFeed_kMT;
        case "crlf":
          return C.LineFeed_Mss;
        case "lfcr":
          return C.LineFeed_a1Y;
        default:
          return C.LineFeed_D6m;
      }
    },
    _newRenderResult: function(options, result, start) {
      var t1, t2, css, t3, t4, sourceMapPath, sourceMapDir, sourceMapDirUrl, i, source, t5, sourceMapBytes, buffer, indices, url;
      t1 = Date.now();
      t2 = J.getInterceptor$x(result);
      css = t2.get$css(result);
      if (B._enableSourceMaps(options)) {
        t3 = J.getInterceptor$x(options);
        t4 = t3.get$sourceMap(options);
        sourceMapPath = typeof t4 === "string" ? H.stringTypeCast(t3.get$sourceMap(options)) : J.$add$ansx(t3.get$outFile(options), ".map");
        sourceMapDir = D.p().dirname$1(sourceMapPath);
        t2.get$sourceMap(result).set$sourceRoot(t3.get$sourceMapRoot(options));
        if (t3.get$outFile(options) == null)
          if (t3.get$file(options) == null)
            t2.get$sourceMap(result).set$targetUrl("stdin.css");
          else
            t2.get$sourceMap(result).set$targetUrl(J.toString$0$(D.p().toUri$1(D.p().withoutExtension$1(t3.get$file(options)) + ".css")));
        else
          t2.get$sourceMap(result).set$targetUrl(J.toString$0$(D.p().toUri$1(D.p().relative$2$from(t3.get$outFile(options), sourceMapDir))));
        sourceMapDirUrl = J.toString$0$(D.p().toUri$1(sourceMapDir));
        for (i = 0; i < t2.get$sourceMap(result).get$urls().length; ++i) {
          t4 = t2.get$sourceMap(result).get$urls();
          if (i >= t4.length)
            return H.ioore(t4, i);
          source = t4[i];
          if (J.$eq$(source, "stdin") === true)
            continue;
          t4 = t2.get$sourceMap(result).get$urls();
          t5 = $.$get$url().relative$2$from(source, sourceMapDirUrl);
          if (i >= t4.length)
            return H.ioore(t4, i);
          t4[i] = t5;
        }
        t4 = C.JsonCodec_null_null.encode$1(t2.get$sourceMap(result).toJson$1$includeSourceContents(t3.get$sourceMapContents(options)));
        sourceMapBytes = self.Buffer.from(t4, "utf8");
        t4 = t3.get$omitSourceMapUrl(options);
        if (!(J.$eq$(t4, false) !== true && t4 != null)) {
          if (t3.get$sourceMapEmbed(options) === true) {
            buffer = new P.StringBuffer("");
            indices = [-1];
            P.UriData__writeUri("application/json", null, null, buffer, indices);
            indices.push(buffer._contents.length);
            t3 = buffer._contents += ";base64,";
            indices.push(t3.length - 1);
            C.Base64Encoder_false.startChunkedConversion$1(new P._StringSinkConversionSink(buffer)).addSlice$4(sourceMapBytes, 0, J.get$length$asx(sourceMapBytes), true);
            t3 = buffer._contents;
            url = new P.UriData(t3.charCodeAt(0) == 0 ? t3 : t3, indices, null).get$uri();
          } else {
            t4 = D.p();
            url = t4.toUri$1(t3.get$outFile(options) == null ? sourceMapPath : D.p().relative$2$from(sourceMapPath, D.p().dirname$1(t3.get$outFile(options))));
          }
          css = J.$add$ansx(css, "\n\n/*# sourceMappingURL=" + H.S(url) + " */");
        }
      } else
        sourceMapBytes = null;
      t3 = self.Buffer.from(css, "utf8");
      t4 = J.get$file$x(options);
      if (t4 == null)
        t4 = "data";
      t5 = start._core$_value;
      t1 = new P.DateTime(t1, false)._core$_value;
      return {css: t3, map: sourceMapBytes, stats: {duration: C.JSNumber_methods._tdivFast$1(P.Duration$(0, 0, 0, t1 - t5, 0, 0)._duration, 1000), end: t1, entry: t4, includedFiles: J.toList$0$ax(t2.get$includedFiles(result)), start: t5}};
    },
    _enableSourceMaps: function(options) {
      var t1, t2;
      t1 = J.getInterceptor$x(options);
      t2 = t1.get$sourceMap(options);
      if (typeof t2 !== "string") {
        t2 = t1.get$sourceMap(options);
        t1 = J.$eq$(t2, false) !== true && t2 != null && t1.get$outFile(options) != null;
      } else
        t1 = true;
      return t1;
    },
    _newRenderError: function(message, column, file, formatted, line, $status) {
      var error = new self.Error(message);
      if (formatted != null)
        error.formatted = formatted;
      if (line != null)
        error.line = line;
      if (column != null)
        error.column = column;
      if (file != null)
        error.file = file;
      error.status = $status;
      return error;
    },
    _render_closure: {
      "^": "Closure:1;callback,options",
      call$0: [function() {
        var error, exception;
        try {
          this.callback.call$2(null, B._renderSync(this.options));
        } catch (exception) {
          error = H.unwrapException(exception);
          this.callback.call$2(H.interceptedTypeCast(error, "$isJSError"), null);
        }
      }, null, null, 0, 0, null, "call"]
    },
    _render_closure0: {
      "^": "Closure:0;callback",
      call$1: [function(result) {
        this.callback.call$2(null, result);
      }, null, null, 4, 0, null, 15, "call"]
    },
    _render_closure1: {
      "^": "Closure:2;callback",
      call$2: [function(error, stackTrace) {
        var t1, t2;
        t1 = J.getInterceptor(error);
        t2 = this.callback;
        if (!!t1.$isSassException)
          t2.call$2(B._wrapException(error), null);
        else
          t2.call$2(B._newRenderError(t1.toString$0(error), null, null, null, null, 3), null);
      }, null, null, 8, 0, null, 4, 5, "call"]
    },
    _wrapException_closure: {
      "^": "Closure:0;",
      call$1: [function(frame) {
        return "  " + H.S(frame);
      }, null, null, 4, 0, null, 12, "call"]
    },
    _parseFunctions_closure: {
      "^": "Closure:2;options,result,asynch",
      call$2: function(signature, callback) {
        var tuple, error, t1, t2, exception;
        tuple = null;
        try {
          H.stringTypeCast(signature);
          t1 = J.get$codeUnits$s(signature);
          t2 = H.setRuntimeTypeInfo([0], [P.int]);
          t2 = new Y.SourceFile(null, t2, new Uint32Array(H._ensureNativeList(t1.toList$0(t1))), null);
          t2.SourceFile$decoded$2$url(t1, null);
          tuple = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t2, null, null, signature, 0, null, null), C.StderrLogger_false).parseSignature$0();
        } catch (exception) {
          t1 = H.unwrapException(exception);
          if (t1 instanceof E.SassFormatException) {
            error = t1;
            throw H.wrapException(E.SassFormatException$('Invalid signature "' + H.S(signature) + '": ' + H.S(J.get$message$x(error)), error.get$span()));
          } else
            throw exception;
        }
        t1 = this.options;
        if (J.get$fiber$x(t1) != null)
          this.result.push(Q.BuiltInCallable$parsed(tuple.get$item1(), tuple.get$item2(), new B._parseFunctions__closure(t1, callback)));
        else {
          t1 = this.result;
          if (!this.asynch)
            t1.push(Q.BuiltInCallable$parsed(tuple.get$item1(), tuple.get$item2(), new B._parseFunctions__closure0(callback)));
          else
            t1.push(S.AsyncBuiltInCallable$parsed(tuple.get$item1(), tuple.get$item2(), new B._parseFunctions__closure1(callback)));
        }
      }
    },
    _parseFunctions__closure: {
      "^": "Closure:0;options,callback",
      call$1: [function($arguments) {
        var t1, t2, fiber, jsArguments, result;
        t1 = this.options;
        t2 = J.getInterceptor$x(t1);
        fiber = J.get$current$x(t2.get$fiber(t1));
        jsArguments = J.toList$0$ax(J.map$1$ax($arguments, F.value0__wrapValue$closure()));
        J.add$1$ax(jsArguments, P.allowInterop(new B._parseFunctions___closure0(fiber)));
        result = P.Function_apply(H.interceptedTypeCast(this.callback, "$isFunction"), jsArguments, null);
        return F.unwrapValue(H.boolTypeCast($.$get$_isUndefined().call$1(result)) === true ? J.yield$0$x(t2.get$fiber(t1)) : result);
      }, null, null, 4, 0, null, 0, "call"]
    },
    _parseFunctions___closure0: {
      "^": "Closure:5;fiber",
      call$1: [function(result) {
        P.scheduleMicrotask(new B._parseFunctions____closure(this.fiber, result));
      }, function() {
        return this.call$1(null);
      }, "call$0", null, null, null, 0, 2, null, 2, 15, "call"]
    },
    _parseFunctions____closure: {
      "^": "Closure:1;fiber,result",
      call$0: function() {
        return J.run$1$x(this.fiber, this.result);
      }
    },
    _parseFunctions__closure0: {
      "^": "Closure:0;callback",
      call$1: [function($arguments) {
        return F.unwrapValue(P.Function_apply(H.interceptedTypeCast(this.callback, "$isFunction"), J.toList$0$ax(J.map$1$ax($arguments, F.value0__wrapValue$closure())), null));
      }, null, null, 4, 0, null, 0, "call"]
    },
    _parseFunctions__closure1: {
      "^": "Closure:6;callback",
      call$1: [function($arguments) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$self = this, t1, jsArguments, result, $async$temp1;
        var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = new P._Future(0, $.Zone__current, null, [null]);
                jsArguments = J.toList$0$ax(J.map$1$ax($arguments, F.value0__wrapValue$closure()));
                J.add$1$ax(jsArguments, P.allowInterop(new B._parseFunctions___closure(new P._AsyncCompleter(t1, [null]))));
                result = P.Function_apply(H.interceptedTypeCast($async$self.callback, "$isFunction"), jsArguments, null);
                $async$temp1 = F;
                $async$goto = H.boolTypeCast($.$get$_isUndefined().call$1(result)) === true ? 3 : 5;
                break;
              case 3:
                // then
                $async$goto = 6;
                return P._asyncAwait(t1, $async$call$1);
              case 6:
                // returning from await.
                // goto join
                $async$goto = 4;
                break;
              case 5:
                // else
                $async$result = result;
              case 4:
                // join
                $async$returnValue = $async$temp1.unwrapValue($async$result);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$1, $async$completer);
      }, null, null, 4, 0, null, 0, "call"]
    },
    _parseFunctions___closure: {
      "^": "Closure:5;completer",
      call$1: [function(result) {
        return this.completer.complete$1(result);
      }, function() {
        return this.call$1(null);
      }, "call$0", null, null, null, 0, 2, null, 2, 15, "call"]
    },
    _parseImporter_closure: {
      "^": "Closure:0;options",
      call$1: [function(importer) {
        return H.functionTypeCast(P.allowInteropCaptureThis(new B._parseImporter__closure(this.options, importer)), {func: 1, args: [P.String, P.String], opt: [{func: 1, v: true, args: [,]}]});
      }, null, null, 4, 0, null, 52, "call"]
    },
    _parseImporter__closure: {
      "^": "Closure:45;options,importer",
      call$4: [function(thisArg, url, previous, _) {
        var t1, t2, result;
        t1 = this.options;
        t2 = J.getInterceptor$x(t1);
        result = B.call3(this.importer, thisArg, url, previous, P.allowInterop(new B._parseImporter___closure(J.get$current$x(t2.get$fiber(t1)))));
        if (H.boolTypeCast($.$get$_isUndefined().call$1(result)) === true)
          return J.yield$0$x(t2.get$fiber(t1));
        return result;
      }, function(thisArg, url, previous) {
        return this.call$4(thisArg, url, previous, null);
      }, "call$3", null, null, null, 12, 2, null, 2, 1, 54, 55, 7, "call"]
    },
    _parseImporter___closure: {
      "^": "Closure:0;fiber",
      call$1: [function(result) {
        P.scheduleMicrotask(new B._parseImporter____closure(this.fiber, result));
      }, null, null, 4, 0, null, 15, "call"]
    },
    _parseImporter____closure: {
      "^": "Closure:1;fiber,result",
      call$0: function() {
        return J.run$1$x(this.fiber, this.result);
      }
    }
  }, 1], ["", "package:sass/src/node/chokidar.dart",, Y, {
    "^": "",
    Chokidar: {
      "^": "JavaScriptObject;",
      "%": ""
    },
    ChokidarOptions: {
      "^": "JavaScriptObject;",
      "%": ""
    },
    ChokidarWatcher: {
      "^": "JavaScriptObject;",
      "%": ""
    }
  }], ["", "package:sass/src/node/error.dart",, V, {
    "^": "",
    JSError: {
      "^": "JavaScriptObject;",
      "%": ""
    }
  }], ["", "package:sass/src/node/exports.dart",, D, {
    "^": "",
    Exports: {
      "^": "JavaScriptObject;",
      "%": ""
    }
  }], ["", "package:sass/src/node/fiber.dart",, E, {
    "^": "",
    FiberClass: {
      "^": "JavaScriptObject:46;",
      "%": ""
    },
    Fiber: {
      "^": "JavaScriptObject;",
      "%": ""
    }
  }], ["", "package:sass/src/node/function.dart",, F, {
    "^": "",
    JSFunction: {
      "^": "JavaScriptObject:47;",
      "%": ""
    }
  }], ["", "package:sass/src/node/importer_result.dart",, F, {
    "^": "",
    NodeImporterResult: {
      "^": "JavaScriptObject;",
      "%": ""
    }
  }], ["", "package:sass/src/node/render_context.dart",, Z, {
    "^": "",
    RenderContext: {
      "^": "JavaScriptObject;",
      "%": ""
    }
  }], ["", "package:sass/src/node/render_context_options.dart",, L, {
    "^": "",
    RenderContextOptions: {
      "^": "JavaScriptObject;",
      "%": ""
    }
  }], ["", "package:sass/src/node/render_options.dart",, R, {
    "^": "",
    RenderOptions: {
      "^": "JavaScriptObject;",
      "%": ""
    }
  }], ["", "package:sass/src/node/render_result.dart",, U, {
    "^": "",
    RenderResult: {
      "^": "JavaScriptObject;",
      "%": ""
    },
    RenderResultStats: {
      "^": "JavaScriptObject;",
      "%": ""
    }
  }], ["", "package:sass/src/node/types.dart",, G, {
    "^": "",
    Types: {
      "^": "JavaScriptObject;",
      "%": ""
    }
  }], ["", "package:sass/src/node/utils.dart",, B, {
    "^": "",
    forwardToString: function(klass) {
      klass.prototype.toString = P.allowInteropCaptureThis(new B.forwardToString_closure());
    },
    call3: function($function, thisArg, arg1, arg2, arg3) {
      return J.apply$2$x(H.interceptedTypeCast($function, "$isJSFunction"), thisArg, [arg1, arg2, arg3]);
    },
    jsForEach: function(object, callback) {
      var t1, key;
      for (t1 = J.get$iterator$ax(self.Object.keys(object)); t1.moveNext$0();) {
        key = t1.get$current(t1);
        callback.call$2(key, object[key]);
      }
    },
    createClass: function($constructor, methods) {
      var klass = P.allowInteropCaptureThis($constructor);
      methods.forEach$1(0, new B.createClass_closure(klass.prototype));
      return klass;
    },
    injectSuperclass: function(object, $constructor) {
      var $prototype, $parent, t1;
      $prototype = self.Object.getPrototypeOf(object);
      $parent = self.Object.getPrototypeOf($prototype);
      if ($parent != null) {
        t1 = $constructor.prototype;
        self.Object.setPrototypeOf(t1, $parent);
      }
      t1 = $constructor.prototype;
      t1 = self.Object.create(t1);
      self.Object.setPrototypeOf($prototype, t1);
    },
    forwardToString_closure: {
      "^": "Closure:0;",
      call$1: [function(thisArg) {
        return J.toString$0$(thisArg);
      }, null, null, 4, 0, null, 1, "call"]
    },
    createClass_closure: {
      "^": "Closure:2;$prototype",
      call$2: function($name, body) {
        this.$prototype[$name] = P.allowInteropCaptureThis(body);
      }
    }
  }], ["", "package:sass/src/node/value.dart",, F, {
    "^": "",
    unwrapValue: function(object) {
      var value;
      if (object != null) {
        if (object instanceof F.Value)
          return object;
        value = object.dartValue;
        if (value != null && value instanceof F.Value)
          return value;
      }
      throw H.wrapException(H.S(object) + " must be a Sass value type.");
    },
    wrapValue: [function(value) {
      var t1 = J.getInterceptor(value);
      if (!!t1.$isSassColor)
        return P.callConstructor($.$get$colorConstructor(), [null, null, null, null, value]);
      if (!!t1.$isSassList)
        return P.callConstructor($.$get$listConstructor(), [null, null, value]);
      if (!!t1.$isSassMap)
        return P.callConstructor($.$get$mapConstructor(), [null, value]);
      if (!!t1.$isSassNumber)
        return P.callConstructor($.$get$numberConstructor(), [null, null, value]);
      if (!!t1.$isSassString)
        return P.callConstructor($.$get$stringConstructor(), [null, value]);
      return value;
    }, "call$1", "value0__wrapValue$closure", 4, 0, 98, 3]
  }], ["", "package:sass/src/node/value/boolean.dart",, Z, {
    "^": "",
    closure36: {
      "^": "Closure:1;",
      call$0: function() {
        var $constructor = P.allowInterop(new Z._closure4());
        B.injectSuperclass(C.SassBoolean_true, $constructor);
        B.forwardToString($constructor);
        $constructor.prototype.getValue = P.allowInteropCaptureThis(new Z._closure5());
        $constructor.TRUE = C.SassBoolean_true;
        $constructor.FALSE = C.SassBoolean_false;
        return $constructor;
      }
    },
    _closure4: {
      "^": "Closure:5;",
      call$1: [function(_) {
        throw H.wrapException("new sass.types.Boolean() isn't allowed.\nUse sass.types.Boolean.TRUE or sass.types.Boolean.FALSE instead.");
      }, function() {
        return this.call$1(null);
      }, "call$0", null, null, null, 0, 2, null, 2, 7, "call"]
    },
    _closure5: {
      "^": "Closure:0;",
      call$1: [function(thisArg) {
        return thisArg === C.SassBoolean_true;
      }, null, null, 4, 0, null, 1, "call"]
    }
  }], ["", "package:sass/src/node/value/color.dart",, K, {
    "^": "",
    _NodeSassColor: {
      "^": "JavaScriptObject;",
      "%": ""
    },
    closure24: {
      "^": "Closure:48;",
      call$6: [function(thisArg, red, green, blue, alpha, dartValue) {
        var t1, t2, t3, t4;
        if (dartValue == null) {
          t1 = C.JSNumber_methods.round$0(J.clamp$2$n(red, 0, 255));
          t2 = C.JSNumber_methods.round$0(J.clamp$2$n(green, 0, 255));
          t3 = C.JSNumber_methods.round$0(J.clamp$2$n(blue, 0, 255));
          t4 = alpha == null ? null : J.clamp$2$n(alpha, 0, 1);
          t1 = K.SassColor$rgb(t1, t2, t3, t4 == null ? 1 : t4, null);
        } else
          t1 = dartValue;
        J.set$dartValue$x(thisArg, t1);
      }, function(thisArg, red, green, blue) {
        return this.call$6(thisArg, red, green, blue, null, null);
      }, "call$4", null, null, null, 16, 4, null, 2, 2, 1, 56, 73, 58, 59, 17, "call"]
    },
    closure25: {
      "^": "Closure:11;",
      call$1: [function(thisArg) {
        return J.get$dartValue$x(thisArg).get$red();
      }, null, null, 4, 0, null, 1, "call"]
    },
    closure26: {
      "^": "Closure:11;",
      call$1: [function(thisArg) {
        return J.get$dartValue$x(thisArg).get$green();
      }, null, null, 4, 0, null, 1, "call"]
    },
    closure27: {
      "^": "Closure:11;",
      call$1: [function(thisArg) {
        return J.get$dartValue$x(thisArg).get$blue();
      }, null, null, 4, 0, null, 1, "call"]
    },
    closure28: {
      "^": "Closure:11;",
      call$1: [function(thisArg) {
        return J.get$dartValue$x(thisArg).get$alpha();
      }, null, null, 4, 0, null, 1, "call"]
    },
    closure29: {
      "^": "Closure:12;",
      call$2: [function(thisArg, value) {
        var t1 = J.getInterceptor$x(thisArg);
        t1.set$dartValue(thisArg, t1.get$dartValue(thisArg).changeRgb$1$red(C.JSNumber_methods.round$0(J.clamp$2$n(value, 0, 255))));
      }, null, null, 8, 0, null, 1, 3, "call"]
    },
    closure30: {
      "^": "Closure:12;",
      call$2: [function(thisArg, value) {
        var t1 = J.getInterceptor$x(thisArg);
        t1.set$dartValue(thisArg, t1.get$dartValue(thisArg).changeRgb$1$green(C.JSNumber_methods.round$0(J.clamp$2$n(value, 0, 255))));
      }, null, null, 8, 0, null, 1, 3, "call"]
    },
    closure31: {
      "^": "Closure:12;",
      call$2: [function(thisArg, value) {
        var t1 = J.getInterceptor$x(thisArg);
        t1.set$dartValue(thisArg, t1.get$dartValue(thisArg).changeRgb$1$blue(C.JSNumber_methods.round$0(J.clamp$2$n(value, 0, 255))));
      }, null, null, 8, 0, null, 1, 3, "call"]
    },
    closure32: {
      "^": "Closure:12;",
      call$2: [function(thisArg, value) {
        var t1 = J.getInterceptor$x(thisArg);
        t1.set$dartValue(thisArg, t1.get$dartValue(thisArg).changeRgb$1$alpha(J.clamp$2$n(value, 0, 1)));
      }, null, null, 8, 0, null, 1, 3, "call"]
    },
    closure33: {
      "^": "Closure:11;",
      call$1: [function(thisArg) {
        return J.toString$0$(J.get$dartValue$x(thisArg));
      }, null, null, 4, 0, null, 1, "call"]
    }
  }], ["", "package:sass/src/node/value/list.dart",, D, {
    "^": "",
    _NodeSassList: {
      "^": "JavaScriptObject;",
      "%": ""
    },
    closure17: {
      "^": "Closure:51;",
      call$4: [function(thisArg, $length, commaSeparator, dartValue) {
        var t1;
        if (dartValue == null) {
          t1 = P.Iterable_Iterable$generate($length, new D._closure3(), null);
          t1 = D.SassList$(t1, (commaSeparator == null ? true : commaSeparator) === true ? C.ListSeparator_kWM : C.ListSeparator_woc, false);
        } else
          t1 = dartValue;
        J.set$dartValue$x(thisArg, t1);
      }, function(thisArg, $length) {
        return this.call$4(thisArg, $length, null, null);
      }, "call$2", function(thisArg, $length, commaSeparator) {
        return this.call$4(thisArg, $length, commaSeparator, null);
      }, "call$3", null, null, null, null, 8, 4, null, 2, 2, 1, 19, 62, 17, "call"]
    },
    _closure3: {
      "^": "Closure:0;",
      call$1: [function(_) {
        return C.C_SassNull;
      }, null, null, 4, 0, null, 7, "call"]
    },
    closure18: {
      "^": "Closure:52;",
      call$2: [function(thisArg, index) {
        var t1 = J.get$dartValue$x(thisArg).get$asList();
        if (index >>> 0 !== index || index >= t1.length)
          return H.ioore(t1, index);
        return F.wrapValue(t1[index]);
      }, null, null, 8, 0, null, 1, 10, "call"]
    },
    closure19: {
      "^": "Closure:53;",
      call$3: [function(thisArg, index, value) {
        var t1, t2, mutable;
        t1 = J.getInterceptor$x(thisArg);
        t2 = t1.get$dartValue(thisArg).get$asList();
        mutable = H.setRuntimeTypeInfo(t2.slice(0), [H.getTypeArgumentByIndex(t2, 0)]);
        t2 = F.unwrapValue(value);
        if (index >>> 0 !== index || index >= mutable.length)
          return H.ioore(mutable, index);
        mutable[index] = t2;
        t1.set$dartValue(thisArg, t1.get$dartValue(thisArg).changeListContents$1(mutable));
      }, null, null, 12, 0, null, 1, 10, 3, "call"]
    },
    closure20: {
      "^": "Closure:24;",
      call$1: [function(thisArg) {
        return J.get$dartValue$x(thisArg).get$separator() === C.ListSeparator_kWM;
      }, null, null, 4, 0, null, 1, "call"]
    },
    closure21: {
      "^": "Closure:55;",
      call$2: [function(thisArg, isComma) {
        var t1, t2, t3;
        t1 = J.getInterceptor$x(thisArg);
        t2 = t1.get$dartValue(thisArg).get$asList();
        t3 = isComma === true ? C.ListSeparator_kWM : C.ListSeparator_woc;
        t1.set$dartValue(thisArg, D.SassList$(t2, t3, t1.get$dartValue(thisArg).get$hasBrackets()));
      }, null, null, 8, 0, null, 1, 86, "call"]
    },
    closure22: {
      "^": "Closure:24;",
      call$1: [function(thisArg) {
        return J.get$dartValue$x(thisArg).get$asList().length;
      }, null, null, 4, 0, null, 1, "call"]
    },
    closure23: {
      "^": "Closure:24;",
      call$1: [function(thisArg) {
        return J.toString$0$(J.get$dartValue$x(thisArg));
      }, null, null, 4, 0, null, 1, "call"]
    }
  }], ["", "package:sass/src/node/value/map.dart",, A, {
    "^": "",
    _NodeSassMap: {
      "^": "JavaScriptObject;",
      "%": ""
    },
    closure10: {
      "^": "Closure:56;",
      call$3: [function(thisArg, $length, dartValue) {
        var t1, t2, map;
        if (dartValue == null) {
          t1 = P.Iterable_Iterable$generate($length, new A._closure1(), null);
          t2 = P.Iterable_Iterable$generate($length, new A._closure2(), null);
          map = P.LinkedHashMap_LinkedHashMap(null, null, null, null, null);
          P.MapBase__fillMapWithIterables(map, t1, t2);
          t2 = new A.SassMap(H.ConstantMap_ConstantMap$from(map, null, null));
          t1 = t2;
        } else
          t1 = dartValue;
        J.set$dartValue$x(thisArg, t1);
      }, function(thisArg, $length) {
        return this.call$3(thisArg, $length, null);
      }, "call$2", null, null, null, 8, 2, null, 2, 1, 19, 17, "call"]
    },
    _closure1: {
      "^": "Closure:0;",
      call$1: [function(i) {
        return new T.SassNumber(i, C.List_empty, C.List_empty, null);
      }, null, null, 4, 0, null, 40, "call"]
    },
    _closure2: {
      "^": "Closure:0;",
      call$1: [function(_) {
        return C.C_SassNull;
      }, null, null, 4, 0, null, 7, "call"]
    },
    closure11: {
      "^": "Closure:38;",
      call$2: [function(thisArg, index) {
        var t1 = J.get$contents$x(J.get$dartValue$x(thisArg)).get$keys();
        return F.wrapValue(t1.elementAt$1(t1, index));
      }, null, null, 8, 0, null, 1, 10, "call"]
    },
    closure12: {
      "^": "Closure:38;",
      call$2: [function(thisArg, index) {
        return F.wrapValue(J.get$contents$x(J.get$dartValue$x(thisArg)).get$values().elementAt$1(0, index));
      }, null, null, 8, 0, null, 1, 10, "call"]
    },
    closure13: {
      "^": "Closure:37;",
      call$1: [function(thisArg) {
        return J.get$length$asx(J.get$contents$x(J.get$dartValue$x(thisArg)));
      }, null, null, 4, 0, null, 1, "call"]
    },
    closure14: {
      "^": "Closure:36;",
      call$3: [function(thisArg, index, key) {
        var t1, oldMap, newKey, t2, newMap, t3, i, oldKey;
        t1 = J.getInterceptor$x(thisArg);
        oldMap = J.get$contents$x(t1.get$dartValue(thisArg));
        P.RangeError_checkValidIndex(index, oldMap, "index", null, null);
        newKey = F.unwrapValue(key);
        t2 = F.Value;
        newMap = P.LinkedHashMap_LinkedHashMap$_empty(t2, t2);
        for (t2 = J.get$contents$x(t1.get$dartValue(thisArg)).get$keys(), t2 = t2.get$iterator(t2), t3 = J.getInterceptor$asx(oldMap), i = 0; t2.moveNext$0();) {
          oldKey = t2.get$current(t2);
          if (i === index)
            newMap.$indexSet(0, newKey, t3.$index(oldMap, oldKey));
          else {
            if (newKey.$eq(0, oldKey) === true)
              throw H.wrapException(P.ArgumentError$value(key, "key", "is already in the map"));
            newMap.$indexSet(0, oldKey, t3.$index(oldMap, oldKey));
          }
          ++i;
        }
        t1.set$dartValue(thisArg, new A.SassMap(H.ConstantMap_ConstantMap$from(newMap, null, null)));
      }, null, null, 12, 0, null, 1, 10, 39, "call"]
    },
    closure15: {
      "^": "Closure:36;",
      call$3: [function(thisArg, index, value) {
        var t1, t2, key, mutable;
        t1 = J.getInterceptor$x(thisArg);
        t2 = J.get$contents$x(t1.get$dartValue(thisArg)).get$keys();
        key = t2.elementAt$1(t2, index);
        t2 = F.Value;
        mutable = P.LinkedHashMap_LinkedHashMap$from(J.get$contents$x(t1.get$dartValue(thisArg)), t2, t2);
        mutable.$indexSet(0, key, F.unwrapValue(value));
        t1.set$dartValue(thisArg, new A.SassMap(H.ConstantMap_ConstantMap$from(mutable, null, null)));
      }, null, null, 12, 0, null, 1, 10, 3, "call"]
    },
    closure16: {
      "^": "Closure:37;",
      call$1: [function(thisArg) {
        return J.toString$0$(J.get$dartValue$x(thisArg));
      }, null, null, 4, 0, null, 1, "call"]
    }
  }], ["", "package:sass/src/node/value/null.dart",, O, {
    "^": "",
    closure9: {
      "^": "Closure:1;",
      call$0: function() {
        var $constructor = P.allowInterop(new O._closure());
        B.injectSuperclass(C.C_SassNull, $constructor);
        B.forwardToString($constructor);
        $constructor.NULL = C.C_SassNull;
        C.C_SassNull.toString = P.allowInterop(new O._closure0());
        return $constructor;
      }
    },
    _closure: {
      "^": "Closure:5;",
      call$1: [function(_) {
        throw H.wrapException("new sass.types.Null() isn't allowed. Use sass.types.Null.NULL instead.");
      }, function() {
        return this.call$1(null);
      }, "call$0", null, null, null, 0, 2, null, 2, 7, "call"]
    },
    _closure0: {
      "^": "Closure:1;",
      call$0: [function() {
        return "null";
      }, null, null, 0, 0, null, "call"]
    }
  }], ["", "package:sass/src/node/value/number.dart",, T, {
    "^": "",
    _parseNumber: function(value, unit) {
      var t1, t2, invalidUnit, operands, numerator, denominator, numeratorUnits, denominatorUnits;
      t1 = unit == null;
      if (t1 || J.get$isEmpty$asx(unit) === true)
        return new T.SassNumber(value, C.List_empty, C.List_empty, null);
      t2 = J.getInterceptor$asx(unit);
      if (t2.contains$1(unit, "*") !== true && t2.contains$1(unit, "/") !== true) {
        t1 = t1 ? null : [unit];
        t1 = t1 == null ? C.List_empty : P.List_List$unmodifiable(t1, null);
        return new T.SassNumber(value, t1, C.List_empty, null);
      }
      invalidUnit = new P.ArgumentError(true, unit, "unit", "is invalid.");
      operands = t2.split$1(unit, "/");
      t1 = operands.length;
      if (t1 > 2)
        throw H.wrapException(invalidUnit);
      numerator = operands[0];
      denominator = t1 === 1 ? null : operands[1];
      t1 = J.getInterceptor$asx(numerator);
      numeratorUnits = t1.get$isEmpty(numerator) === true ? H.setRuntimeTypeInfo([], [P.String]) : t1.split$1(numerator, "*");
      if (C.JSArray_methods.any$1(numeratorUnits, new T._parseNumber_closure()))
        throw H.wrapException(invalidUnit);
      denominatorUnits = denominator == null ? H.setRuntimeTypeInfo([], [P.String]) : J.split$1$s(denominator, "*");
      if (C.JSArray_methods.any$1(denominatorUnits, new T._parseNumber_closure0()))
        throw H.wrapException(invalidUnit);
      return T.SassNumber$withUnits(value, denominatorUnits, numeratorUnits);
    },
    _NodeSassNumber: {
      "^": "JavaScriptObject;",
      "%": ""
    },
    closure3: {
      "^": "Closure:60;",
      call$4: [function(thisArg, value, unit, dartValue) {
        J.set$dartValue$x(thisArg, dartValue == null ? T._parseNumber(value, unit) : dartValue);
      }, function(thisArg, value) {
        return this.call$4(thisArg, value, null, null);
      }, "call$2", function(thisArg, value, unit) {
        return this.call$4(thisArg, value, unit, null);
      }, "call$3", null, null, null, null, 8, 4, null, 2, 2, 1, 3, 41, 17, "call"]
    },
    closure4: {
      "^": "Closure:23;",
      call$1: [function(thisArg) {
        return J.get$dartValue$x(thisArg).get$value();
      }, null, null, 4, 0, null, 1, "call"]
    },
    closure5: {
      "^": "Closure:62;",
      call$2: [function(thisArg, value) {
        var t1, t2;
        t1 = J.getInterceptor$x(thisArg);
        t2 = t1.get$dartValue(thisArg).get$numeratorUnits();
        t1.set$dartValue(thisArg, T.SassNumber$withUnits(value, t1.get$dartValue(thisArg).get$denominatorUnits(), t2));
      }, null, null, 8, 0, null, 1, 3, "call"]
    },
    closure6: {
      "^": "Closure:23;",
      call$1: [function(thisArg) {
        var t1, t2;
        t1 = J.getInterceptor$x(thisArg);
        t2 = C.JSArray_methods.join$1(t1.get$dartValue(thisArg).get$numeratorUnits(), "*");
        return t2 + (t1.get$dartValue(thisArg).get$denominatorUnits().length === 0 ? "" : "/") + C.JSArray_methods.join$1(t1.get$dartValue(thisArg).get$denominatorUnits(), "*");
      }, null, null, 4, 0, null, 1, "call"]
    },
    closure7: {
      "^": "Closure:63;",
      call$2: [function(thisArg, unit) {
        var t1 = J.getInterceptor$x(thisArg);
        t1.set$dartValue(thisArg, T._parseNumber(t1.get$dartValue(thisArg).get$value(), unit));
      }, null, null, 8, 0, null, 1, 41, "call"]
    },
    closure8: {
      "^": "Closure:23;",
      call$1: [function(thisArg) {
        return J.toString$0$(J.get$dartValue$x(thisArg));
      }, null, null, 4, 0, null, 1, "call"]
    },
    _parseNumber_closure: {
      "^": "Closure:0;",
      call$1: function(unit) {
        return J.get$isEmpty$asx(unit);
      }
    },
    _parseNumber_closure0: {
      "^": "Closure:0;",
      call$1: function(unit) {
        return J.get$isEmpty$asx(unit);
      }
    }
  }], ["", "package:sass/src/node/value/string.dart",, D, {
    "^": "",
    _NodeSassString: {
      "^": "JavaScriptObject;",
      "%": ""
    },
    closure: {
      "^": "Closure:64;",
      call$3: [function(thisArg, value, dartValue) {
        J.set$dartValue$x(thisArg, dartValue == null ? new D.SassString(value, false, null) : dartValue);
      }, function(thisArg, value) {
        return this.call$3(thisArg, value, null);
      }, "call$2", null, null, null, 8, 2, null, 2, 1, 3, 17, "call"]
    },
    closure0: {
      "^": "Closure:32;",
      call$1: [function(thisArg) {
        return J.get$dartValue$x(thisArg).get$text();
      }, null, null, 4, 0, null, 1, "call"]
    },
    closure1: {
      "^": "Closure:66;",
      call$2: [function(thisArg, value) {
        var t1 = J.getInterceptor$x(thisArg);
        t1.set$dartValue(thisArg, new D.SassString(value, t1.get$dartValue(thisArg).get$hasQuotes(), null));
      }, null, null, 8, 0, null, 1, 3, "call"]
    },
    closure2: {
      "^": "Closure:32;",
      call$1: [function(thisArg) {
        return J.toString$0$(J.get$dartValue$x(thisArg));
      }, null, null, 4, 0, null, 1, "call"]
    }
  }], ["", "package:sass/src/parse/at_root_query.dart",, V, {
    "^": "",
    AtRootQueryParser: {
      "^": "Parser0;scanner,logger",
      parse$0: function() {
        return this.wrapSpanFormatException$1(new V.AtRootQueryParser_parse_closure(this));
      }
    },
    AtRootQueryParser_parse_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        var t1, t2, include, atRules;
        t1 = this.$this;
        t2 = t1.scanner;
        t2.expectChar$1(40);
        t1.whitespace$0();
        include = t1.scanIdentifier$1("with");
        if (!include)
          t1.expectIdentifier$2$name("without", '"with" or "without"');
        t1.whitespace$0();
        t2.expectChar$1(58);
        t1.whitespace$0();
        atRules = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
        do {
          atRules.add$1(0, t1.identifier$0().toLowerCase());
          t1.whitespace$0();
        } while (t1.lookingAtIdentifier$0());
        t2.expectChar$1(41);
        t2.expectDone$0();
        return new V.AtRootQuery(include, atRules, atRules.contains$1(0, "all"), atRules.contains$1(0, "rule"));
      }
    }
  }], ["", "package:sass/src/parse/keyframe_selector.dart",, E, {
    "^": "",
    KeyframeSelectorParser: {
      "^": "Parser0;scanner,logger",
      parse$0: function() {
        return this.wrapSpanFormatException$1(new E.KeyframeSelectorParser_parse_closure(this));
      },
      _percentage$0: function() {
        var t1, t2, second, t3, next;
        t1 = this.scanner;
        t2 = t1.scanChar$1(43) ? H.Primitives_stringFromCharCode(43) : "";
        second = t1.peekChar$0();
        if (!T.isDigit(second) && second !== 46)
          t1.error$1("Expected number.");
        while (true) {
          t3 = t1.peekChar$0();
          if (!(t3 != null && t3 >= 48 && t3 <= 57))
            break;
          t2 += H.Primitives_stringFromCharCode(t1.readChar$0());
        }
        if (t1.peekChar$0() === 46) {
          t2 += H.Primitives_stringFromCharCode(t1.readChar$0());
          while (true) {
            t3 = t1.peekChar$0();
            if (!(t3 != null && t3 >= 48 && t3 <= 57))
              break;
            t2 += H.Primitives_stringFromCharCode(t1.readChar$0());
          }
        }
        if (this.scanIdentifier$2$ignoreCase("e", true)) {
          t2 += t1.readChar$0();
          next = t1.peekChar$0();
          if (next === 43 || next === 45)
            t2 += t1.readChar$0();
          if (!T.isDigit(t1.peekChar$0()))
            t1.error$1("Expected digit.");
          while (true) {
            t3 = t1.peekChar$0();
            if (!(t3 != null && t3 >= 48 && t3 <= 57))
              break;
            t2 += H.Primitives_stringFromCharCode(t1.readChar$0());
          }
        }
        t1.expectChar$1(37);
        t2 += H.Primitives_stringFromCharCode(37);
        return t2.charCodeAt(0) == 0 ? t2 : t2;
      }
    },
    KeyframeSelectorParser_parse_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        var selectors, t1, t2;
        selectors = H.setRuntimeTypeInfo([], [P.String]);
        t1 = this.$this;
        t2 = t1.scanner;
        do {
          t1.whitespace$0();
          if (t1.lookingAtIdentifier$0())
            if (t1.scanIdentifier$1("from"))
              selectors.push("from");
            else {
              t1.expectIdentifier$2$name("to", '"to" or "from"');
              selectors.push("to");
            }
          else
            selectors.push(t1._percentage$0());
          t1.whitespace$0();
        } while (t2.scanChar$1(44));
        t2.expectDone$0();
        return selectors;
      }
    }
  }], ["", "package:sass/src/parse/media_query.dart",, F, {
    "^": "",
    MediaQueryParser: {
      "^": "Parser0;scanner,logger",
      parse$0: function() {
        return this.wrapSpanFormatException$1(new F.MediaQueryParser_parse_closure(this));
      },
      _mediaQuery$0: function() {
        var t1, identifier1, identifier2, type, modifier, features;
        t1 = this.scanner;
        if (t1.peekChar$0() !== 40) {
          identifier1 = this.identifier$0();
          this.whitespace$0();
          if (!this.lookingAtIdentifier$0())
            return F.CssMediaQuery$(identifier1, null, null);
          identifier2 = this.identifier$0();
          this.whitespace$0();
          if (B.equalsIgnoreCase(identifier2, "and")) {
            type = identifier1;
            modifier = null;
          } else {
            if (this.scanIdentifier$2$ignoreCase("and", true))
              this.whitespace$0();
            else
              return F.CssMediaQuery$(identifier2, null, identifier1);
            type = identifier2;
            modifier = identifier1;
          }
        } else {
          modifier = null;
          type = null;
        }
        features = H.setRuntimeTypeInfo([], [P.String]);
        do {
          this.whitespace$0();
          t1.expectChar$1(40);
          features.push("(" + this.declarationValue$0() + ")");
          t1.expectChar$1(41);
          this.whitespace$0();
        } while (this.scanIdentifier$2$ignoreCase("and", true));
        if (type == null)
          return new F.CssMediaQuery(null, null, P.List_List$unmodifiable(features, null));
        else
          return F.CssMediaQuery$(type, features, modifier);
      }
    },
    MediaQueryParser_parse_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        var queries, t1, t2;
        queries = H.setRuntimeTypeInfo([], [F.CssMediaQuery]);
        t1 = this.$this;
        t2 = t1.scanner;
        do {
          t1.whitespace$0();
          queries.push(t1._mediaQuery$0());
        } while (t2.scanChar$1(44));
        t2.expectDone$0();
        return queries;
      }
    }
  }], ["", "package:sass/src/parse/parser.dart",, G, {
    "^": "",
    Parser0: {
      "^": "Object;",
      whitespace$0: [function() {
        do
          this.whitespaceWithoutComments$0();
        while (this.scanComment$0());
      }, "call$0", "get$whitespace", 0, 0, 3],
      whitespaceWithoutComments$0: function() {
        var t1, t2, t3, t4;
        t1 = this.scanner;
        t2 = t1.string;
        t3 = J.getInterceptor$asx(t2);
        while (true) {
          if (!J.$eq$(t1._position, t3.get$length(t2))) {
            t4 = t1.peekChar$0();
            t4 = t4 === 32 || t4 === 9 || t4 === 10 || t4 === 13 || t4 === 12;
          } else
            t4 = false;
          if (!t4)
            break;
          t1.readChar$0();
        }
      },
      spaces$0: function() {
        var t1, t2, t3, t4;
        t1 = this.scanner;
        t2 = t1.string;
        t3 = J.getInterceptor$asx(t2);
        while (true) {
          if (!J.$eq$(t1._position, t3.get$length(t2))) {
            t4 = t1.peekChar$0();
            t4 = t4 === 32 || t4 === 9;
          } else
            t4 = false;
          if (!t4)
            break;
          t1.readChar$0();
        }
      },
      scanComment$0: function() {
        var t1, next;
        t1 = this.scanner;
        if (t1.peekChar$0() !== 47)
          return false;
        next = t1.peekChar$1(1);
        if (next === 47) {
          this.silentComment$0();
          return true;
        } else if (next === 42) {
          this.loudComment$0();
          return true;
        } else
          return false;
      },
      silentComment$0: function() {
        var t1, t2, t3, t4;
        t1 = this.scanner;
        t1.expect$1("//");
        t2 = t1.string;
        t3 = J.getInterceptor$asx(t2);
        while (true) {
          if (!J.$eq$(t1._position, t3.get$length(t2))) {
            t4 = t1.peekChar$0();
            t4 = !(t4 === 10 || t4 === 13 || t4 === 12);
          } else
            t4 = false;
          if (!t4)
            break;
          t1.readChar$0();
        }
      },
      loudComment$0: [function() {
        var t1, next;
        t1 = this.scanner;
        t1.expect$1("/*");
        for (; true;) {
          if (t1.readChar$0() !== 42)
            continue;
          do
            next = t1.readChar$0();
          while (next === 42);
          if (next === 47)
            break;
        }
      }, "call$0", "get$loudComment", 0, 0, 3],
      identifier$1$unit: function(unit) {
        var text, t1, first;
        text = new P.StringBuffer("");
        for (t1 = this.scanner; t1.scanChar$1(45);)
          text._contents += H.Primitives_stringFromCharCode(45);
        first = t1.peekChar$0();
        if (first == null)
          t1.error$1("Expected identifier.");
        else if (first === 95 || T.isAlphabetic0(first) || first >= 128)
          text._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
        else if (first === 92)
          text._contents += H.S(this.escape$0());
        else
          t1.error$1("Expected identifier.");
        this._identifierBody$2$unit(text, unit);
        t1 = text._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      },
      identifier$0: function() {
        return this.identifier$1$unit(false);
      },
      _identifierBody$2$unit: function(text, unit) {
        var t1, next, second, t2;
        for (t1 = this.scanner; true;) {
          next = t1.peekChar$0();
          if (next == null)
            break;
          else if (unit && next === 45) {
            second = t1.peekChar$1(1);
            if (second != null)
              if (second !== 46)
                t2 = second >= 48 && second <= 57;
              else
                t2 = true;
            else
              t2 = false;
            if (t2)
              break;
            text._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
          } else {
            if (next !== 95) {
              if (!(next >= 97 && next <= 122))
                t2 = next >= 65 && next <= 90;
              else
                t2 = true;
              t2 = t2 || next >= 128;
            } else
              t2 = true;
            if (!t2) {
              t2 = next >= 48 && next <= 57;
              t2 = t2 || next === 45;
            } else
              t2 = true;
            if (t2)
              text._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
            else if (next === 92)
              text._contents += H.S(this.escape$0());
            else
              break;
          }
        }
      },
      _identifierBody$1: function(text) {
        return this._identifierBody$2$unit(text, false);
      },
      string$0: [function() {
        var t1, quote, t2, buffer, next;
        t1 = this.scanner;
        quote = t1.readChar$0();
        if (quote !== 39 && quote !== 34) {
          t2 = J.$sub$n(t1._position, 1);
          t1.error$2$position("Expected string.", t2);
        }
        buffer = new P.StringBuffer("");
        for (; true;) {
          next = t1.peekChar$0();
          if (next === quote) {
            t1.readChar$0();
            break;
          } else if (next == null || next === 10 || next === 13 || next === 12)
            t1.error$1("Expected " + H.Primitives_stringFromCharCode(quote) + ".");
          else if (next === 92) {
            t2 = t1.peekChar$1(1);
            if (t2 === 10 || t2 === 13 || t2 === 12) {
              t1.readChar$0();
              t1.readChar$0();
            } else
              buffer._contents += H.Primitives_stringFromCharCode(this.escapeCharacter$0());
          } else
            buffer._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
        }
        t1 = buffer._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, "call$0", "get$string", 0, 0, 84],
      declarationValue$1$allowEmpty: function(allowEmpty) {
        var buffer, brackets, t1, t2, t3, wroteNewline, next, start, end, t4, url;
        buffer = new P.StringBuffer("");
        brackets = H.setRuntimeTypeInfo([], [P.int]);
        $label0$1:
          for (t1 = this.scanner, t2 = this.get$loudComment(), t3 = this.get$string(), wroteNewline = false; true;) {
            next = t1.peekChar$0();
            switch (next) {
              case 92:
                buffer._contents += H.S(this.escape$0());
                wroteNewline = false;
                break;
              case 34:
              case 39:
                start = t1._position;
                t3.call$0();
                end = t1._position;
                buffer._contents += J.substring$2$s(t1.string, start, end);
                wroteNewline = false;
                break;
              case 47:
                if (t1.peekChar$1(1) === 42) {
                  start = t1._position;
                  t2.call$0();
                  end = t1._position;
                  buffer._contents += J.substring$2$s(t1.string, start, end);
                } else
                  buffer._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                wroteNewline = false;
                break;
              case 32:
              case 9:
                if (!wroteNewline) {
                  t4 = t1.peekChar$1(1);
                  t4 = !(t4 === 32 || t4 === 9 || t4 === 10 || t4 === 13 || t4 === 12);
                } else
                  t4 = true;
                if (t4)
                  buffer._contents += H.Primitives_stringFromCharCode(32);
                t1.readChar$0();
                break;
              case 10:
              case 13:
              case 12:
                t4 = t1.peekChar$1(-1);
                if (!(t4 === 10 || t4 === 13 || t4 === 12))
                  buffer._contents += "\n";
                t1.readChar$0();
                wroteNewline = true;
                break;
              case 40:
              case 123:
              case 91:
                buffer._contents += H.Primitives_stringFromCharCode(next);
                brackets.push(T.opposite(t1.readChar$0()));
                wroteNewline = false;
                break;
              case 41:
              case 125:
              case 93:
                if (brackets.length === 0)
                  break $label0$1;
                buffer._contents += H.Primitives_stringFromCharCode(next);
                if (0 >= brackets.length)
                  return H.ioore(brackets, -1);
                t1.expectChar$1(brackets.pop());
                wroteNewline = false;
                break;
              case 59:
                if (brackets.length === 0)
                  break $label0$1;
                buffer._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                break;
              case 117:
              case 85:
                url = this.tryUrl$0();
                if (url != null)
                  buffer._contents += url;
                else
                  buffer._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                wroteNewline = false;
                break;
              default:
                if (next == null)
                  break $label0$1;
                if (this.lookingAtIdentifier$0())
                  buffer._contents += this.identifier$0();
                else
                  buffer._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                wroteNewline = false;
                break;
            }
          }
        if (brackets.length !== 0)
          t1.expectChar$1(C.JSArray_methods.get$last(brackets));
        if (!allowEmpty && buffer._contents.length === 0)
          t1.error$1("Expected token.");
        t1 = buffer._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      },
      declarationValue$0: function() {
        return this.declarationValue$1$allowEmpty(false);
      },
      tryUrl$0: function() {
        var t1, start, buffer, next, t2;
        t1 = this.scanner;
        start = new S._SpanScannerState(t1, t1._position);
        if (!this.scanIdentifier$2$ignoreCase("url", true))
          return;
        if (!t1.scanChar$1(40)) {
          t1.set$state(start);
          return;
        }
        this.whitespace$0();
        buffer = new P.StringBuffer("");
        buffer._contents = "url(";
        for (; true;) {
          next = t1.peekChar$0();
          if (next == null)
            break;
          else {
            if (next !== 37)
              if (next !== 38)
                if (next !== 35)
                  t2 = next >= 42 && next <= 126 || next >= 128;
                else
                  t2 = true;
              else
                t2 = true;
            else
              t2 = true;
            if (t2)
              buffer._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
            else if (next === 92)
              buffer._contents += H.S(this.escape$0());
            else if (next === 32 || next === 9 || next === 10 || next === 13 || next === 12) {
              this.whitespace$0();
              if (t1.peekChar$0() !== 41)
                break;
            } else if (next === 41) {
              t2 = buffer._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              return t2.charCodeAt(0) == 0 ? t2 : t2;
            } else
              break;
          }
        }
        t1.set$state(start);
        return;
      },
      escape$0: function() {
        var t1, t2, first, i, next, t3;
        t1 = this.scanner;
        t1.expectChar$1(92);
        t2 = H.Primitives_stringFromCharCode(92);
        first = t1.peekChar$0();
        if (first == null)
          t1 = t2;
        else if (T.isNewline(first)) {
          t1.error$1("Expected escape sequence.");
          t1 = t2;
        } else if (T.isHex(first)) {
          for (i = 0; i < 6; ++i) {
            next = t1.peekChar$0();
            if (next != null) {
              t3 = next >= 48 && next <= 57;
              if (!t3)
                if (!(next >= 97 && next <= 102))
                  t3 = next >= 65 && next <= 70;
                else
                  t3 = true;
              else
                t3 = true;
              t3 = !t3;
            } else
              t3 = true;
            if (t3)
              break;
            t2 += H.Primitives_stringFromCharCode(t1.readChar$0());
          }
          t3 = t1.peekChar$0();
          t1 = t3 === 32 || t3 === 9 || T.isNewline(t3) ? t2 + H.Primitives_stringFromCharCode(t1.readChar$0()) : t2;
        } else
          t1 = t2 + H.Primitives_stringFromCharCode(t1.readChar$0());
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      },
      escapeCharacter$0: function() {
        var t1, first, value, i, next, t2;
        t1 = this.scanner;
        t1.expectChar$1(92);
        first = t1.peekChar$0();
        if (first == null)
          return 65533;
        else if (T.isNewline(first))
          t1.error$1("Expected escape sequence.");
        else if (T.isHex(first)) {
          for (value = 0, i = 0; i < 6; ++i) {
            next = t1.peekChar$0();
            if (next != null) {
              t2 = next >= 48 && next <= 57;
              if (!t2)
                if (!(next >= 97 && next <= 102))
                  t2 = next >= 65 && next <= 70;
                else
                  t2 = true;
              else
                t2 = true;
              t2 = !t2;
            } else
              t2 = true;
            if (t2)
              break;
            value = (value << 4 >>> 0) + T.asHex(t1.readChar$0());
          }
          t2 = t1.peekChar$0();
          if (t2 === 32 || t2 === 9 || T.isNewline(t2))
            t1.readChar$0();
          if (value !== 0)
            t1 = value >= 55296 && value <= 57343 || value >= 1114111;
          else
            t1 = true;
          if (t1)
            return 65533;
          else
            return value;
        } else
          return t1.readChar$0();
      },
      scanCharIf$1: function(condition) {
        var t1 = this.scanner;
        if (condition.call$1(t1.peekChar$0()) !== true)
          return false;
        t1.readChar$0();
        return true;
      },
      scanCharIgnoreCase$1: function(letter) {
        var t1, t2;
        t1 = this.scanner;
        t2 = t1.peekChar$0();
        if (typeof t2 !== "number")
          return t2.$or();
        if ((t2 | 32) !== letter)
          return false;
        t1.readChar$0();
        return true;
      },
      expectCharIgnoreCase$1: function(letter) {
        var t1, t2, t3;
        t1 = this.scanner;
        if ((t1.readChar$0() | 32) === letter)
          return;
        t2 = 'Expected "' + H.Primitives_stringFromCharCode(letter) + '".';
        t3 = J.$sub$n(t1._position, 1);
        t1.error$2$position(t2, t3);
      },
      lookingAtNumber$0: function() {
        var t1, first, second, third;
        t1 = this.scanner;
        first = t1.peekChar$0();
        if (first == null)
          return false;
        if (T.isDigit(first))
          return true;
        if (first === 46) {
          second = t1.peekChar$1(1);
          return second != null && T.isDigit(second);
        } else if (first === 43 || first === 45) {
          second = t1.peekChar$1(1);
          if (second == null)
            return false;
          if (T.isDigit(second))
            return true;
          if (second !== 46)
            return false;
          third = t1.peekChar$1(2);
          return third != null && T.isDigit(third);
        } else
          return false;
      },
      lookingAtIdentifier$1: function($forward) {
        var t1, first, second, third;
        if ($forward == null)
          $forward = 0;
        t1 = this.scanner;
        first = t1.peekChar$1($forward);
        if (first == null)
          return false;
        if (first === 95 || T.isAlphabetic0(first) || first >= 128 || first === 92)
          return true;
        if (first !== 45)
          return false;
        second = t1.peekChar$1($forward + 1);
        if (second == null)
          return false;
        if (second === 95 || T.isAlphabetic0(second) || second >= 128 || second === 92)
          return true;
        if (second !== 45)
          return false;
        third = t1.peekChar$1($forward + 2);
        if (third != null)
          t1 = third === 95 || T.isAlphabetic0(third) || third >= 128;
        else
          t1 = false;
        return t1;
      },
      lookingAtIdentifier$0: function() {
        return this.lookingAtIdentifier$1(null);
      },
      lookingAtIdentifierBody$0: function() {
        var next, t1;
        next = this.scanner.peekChar$0();
        if (next != null)
          t1 = next === 95 || T.isAlphabetic0(next) || next >= 128 || T.isDigit(next) || next === 45 || next === 92;
        else
          t1 = false;
        return t1;
      },
      scanIdentifier$2$ignoreCase: function(text, ignoreCase) {
        var t1, start, t2, i, t3;
        if (!this.lookingAtIdentifier$0())
          return false;
        t1 = this.scanner;
        start = new S._SpanScannerState(t1, t1._position);
        for (t2 = text.length, i = 0; i < t2; ++i) {
          if (this.scanCharIgnoreCase$1(C.JSString_methods._codeUnitAt$1(text, i)))
            continue;
          if (start._scanner !== t1)
            H.throwExpression(P.ArgumentError$("The given LineScannerState was not returned by this LineScanner."));
          t2 = start.position;
          t3 = J.getInterceptor$n(t2);
          if (t3.$lt(t2, 0) || t3.$gt(t2, J.get$length$asx(t1.string)))
            H.throwExpression(P.ArgumentError$("Invalid position " + H.S(t2)));
          t1._position = t2;
          t1._lastMatch = null;
          return false;
        }
        if (!this.lookingAtIdentifierBody$0())
          return true;
        t1.set$state(start);
        return false;
      },
      scanIdentifier$1: function(text) {
        return this.scanIdentifier$2$ignoreCase(text, false);
      },
      expectIdentifier$3$ignoreCase$name: function(text, ignoreCase, $name) {
        var t1, start, t2, i;
        if ($name == null)
          $name = '"' + text + '"';
        t1 = this.scanner;
        start = t1._position;
        for (t2 = text.length, i = 0; i < t2; ++i) {
          if (this.scanCharIgnoreCase$1(C.JSString_methods._codeUnitAt$1(text, i)))
            continue;
          t1.error$2$position("Expected " + $name + ".", start);
        }
        if (!this.lookingAtIdentifierBody$0())
          return;
        t1.error$2$position("Expected " + $name, start);
      },
      expectIdentifier$2$ignoreCase: function(text, ignoreCase) {
        return this.expectIdentifier$3$ignoreCase$name(text, ignoreCase, null);
      },
      expectIdentifier$2$name: function(text, $name) {
        return this.expectIdentifier$3$ignoreCase$name(text, false, $name);
      },
      expectIdentifier$1: function(text) {
        return this.expectIdentifier$3$ignoreCase$name(text, false, null);
      },
      rawText$1: function(consumer) {
        var t1, start;
        t1 = this.scanner;
        start = t1._position;
        consumer.call$0();
        return t1.substring$1(0, start);
      },
      wrapSpanFormatException$1: function(callback) {
        var error, span, startPosition, t1, exception;
        try {
          t1 = callback.call$0();
          return t1;
        } catch (exception) {
          t1 = H.unwrapException(exception);
          if (t1 instanceof G.SourceSpanFormatException) {
            error = t1;
            span = H.interceptedTypeCast(error.get$_span(), "$isFileSpan");
            if (J.startsWith$1$s(error.get$_span_exception$_message(), "Expected")) {
              t1 = span;
              t1 = J.$eq$(J.$sub$n(t1.get$_end(), t1.get$_file$_start()), 0);
            } else
              t1 = false;
            if (t1) {
              t1 = span;
              startPosition = this._firstNewlineBefore$1(Y.FileLocation$_(J.get$file$x(t1), t1.get$_file$_start()).offset);
              t1 = span;
              if (J.$eq$(startPosition, Y.FileLocation$_(J.get$file$x(t1), t1.get$_file$_start()).offset) !== true)
                span = J.get$file$x(span).span$2(startPosition, startPosition);
            }
            throw H.wrapException(E.SassFormatException$(J.get$message$x(error), span));
          } else
            throw exception;
        }
      },
      _firstNewlineBefore$1: function(position) {
        var index, t1, t2, lastNewline, t3, codeUnit;
        index = J.$sub$n(position, 1);
        for (t1 = this.scanner.string, t2 = J.getInterceptor$s(t1), lastNewline = null; t3 = J.getInterceptor$n(index), t3.$ge(index, 0);) {
          codeUnit = t2.codeUnitAt$1(t1, index);
          if (!(codeUnit === 32 || codeUnit === 9 || codeUnit === 10 || codeUnit === 13 || codeUnit === 12))
            return lastNewline == null ? position : lastNewline;
          if (codeUnit === 10 || codeUnit === 13 || codeUnit === 12)
            lastNewline = index;
          index = t3.$sub(index, 1);
        }
        return position;
      }
    }
  }], ["", "package:sass/src/parse/sass.dart",, U, {
    "^": "",
    SassParser: {
      "^": "StylesheetParser;_currentIndentation,_nextIndentation,_nextIndentationEnd,_spaces,_stylesheet$_inMixin,_mixinHasContent,_inContentBlock,_inControlDirective,_inUnknownAtRule,_inStyleRule,_inParentheses,scanner,logger",
      get$currentIndentation: function() {
        return this._currentIndentation;
      },
      get$indented: function() {
        return true;
      },
      styleRuleSelector$0: function() {
        var t1, t2, t3, buffer, t4;
        t1 = this.scanner;
        t2 = t1._position;
        t3 = new P.StringBuffer("");
        buffer = new Z.InterpolationBuffer(t3, []);
        do {
          buffer.addInterpolation$1(this.almostAnyValue$0());
          t4 = t3._contents += H.Primitives_stringFromCharCode(10);
        } while (C.JSString_methods.endsWith$1(C.JSString_methods.trimRight$0(t4.charCodeAt(0) == 0 ? t4 : t4), ",") && this.scanCharIf$1(T.character__isNewline$closure()));
        return buffer.interpolation$1(t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
      },
      expectStatementSeparator$1: function($name) {
        var t1, t2;
        if (!this.atEndOfStatement$0())
          this._expectNewline$0();
        t1 = this._peekIndentation$0();
        t2 = this._currentIndentation;
        if (typeof t1 !== "number")
          return t1.$le();
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (t1 <= t2)
          return;
        this.scanner.error$2$position("Nothing may be indented " + ($name == null ? "here" : "beneath a " + $name) + ".", this._nextIndentationEnd.position);
      },
      expectStatementSeparator$0: function() {
        return this.expectStatementSeparator$1(null);
      },
      atEndOfStatement$0: function() {
        var next = this.scanner.peekChar$0();
        return next == null || T.isNewline(next);
      },
      lookingAtChildren$0: function() {
        var t1, t2;
        if (this.atEndOfStatement$0()) {
          t1 = this._peekIndentation$0();
          t2 = this._currentIndentation;
          if (typeof t1 !== "number")
            return t1.$gt();
          if (typeof t2 !== "number")
            return H.iae(t2);
          t2 = t1 > t2;
          t1 = t2;
        } else
          t1 = false;
        return t1;
      },
      importArgument$0: function() {
        var t1, start, next, t2;
        t1 = this.scanner;
        switch (t1.peekChar$0()) {
          case 117:
          case 85:
            start = new S._SpanScannerState(t1, t1._position);
            if (this.scanIdentifier$2$ignoreCase("url", true))
              if (t1.scanChar$1(40)) {
                t1.set$state(start);
                return this.super$StylesheetParser$importArgument();
              } else
                t1.set$state(start);
            break;
          case 39:
          case 34:
            return this.super$StylesheetParser$importArgument();
        }
        start = new S._SpanScannerState(t1, t1._position);
        next = t1.peekChar$0();
        while (true) {
          if (next != null)
            if (next !== 44)
              if (next !== 59)
                t2 = !(next === 10 || next === 13 || next === 12);
              else
                t2 = false;
            else
              t2 = false;
          else
            t2 = false;
          if (!t2)
            break;
          t1.readChar$0();
          next = t1.peekChar$0();
        }
        return new B.DynamicImport(this.parseImportUrl$1(t1.substring$1(0, start.position)), t1.spanFrom$1(start));
      },
      scanElse$1: function(ifIndentation) {
        var t1, t2, startIndentation, startNextIndentation, startNextIndentationEnd;
        t1 = this._peekIndentation$0();
        if (t1 == null ? ifIndentation != null : t1 !== ifIndentation)
          return false;
        t1 = this.scanner;
        t2 = t1._position;
        startIndentation = this._currentIndentation;
        startNextIndentation = this._nextIndentation;
        startNextIndentationEnd = this._nextIndentationEnd;
        this._readIndentation$0();
        if (t1.scanChar$1(64) && this.scanIdentifier$1("else"))
          return true;
        t1.set$state(new S._SpanScannerState(t1, t2));
        this._currentIndentation = startIndentation;
        this._nextIndentation = startNextIndentation;
        this._nextIndentationEnd = startNextIndentationEnd;
        return false;
      },
      children$1: [function(child) {
        var children = H.setRuntimeTypeInfo([], [O.Statement]);
        this._whileIndentedLower$1(new U.SassParser_children_closure(this, children, child));
        return children;
      }, "call$1", "get$children", 4, 0, 30],
      statements$1: function(statement) {
        var t1, first, statements, t2, t3, child;
        t1 = this.scanner;
        first = t1.peekChar$0();
        if (first === 9 || first === 32)
          t1.error$3$length$position("Indenting at the beginning of the document is illegal.", t1._position, 0);
        statements = H.setRuntimeTypeInfo([], [O.Statement]);
        for (t2 = t1.string, t3 = J.getInterceptor$asx(t2); !J.$eq$(t1._position, t3.get$length(t2));) {
          child = this._child$1(statement);
          if (child != null)
            statements.push(child);
          this._readIndentation$0();
        }
        return statements;
      },
      _child$1: function(child) {
        var t1 = this.scanner;
        switch (t1.peekChar$0()) {
          case 13:
          case 10:
            return;
          case 36:
            return this.variableDeclaration$0();
          case 47:
            switch (t1.peekChar$1(1)) {
              case 47:
                return this._sass$_silentComment$0();
              case 42:
                return this._sass$_loudComment$0();
              default:
                return child.call$0();
            }
          default:
            return child.call$0();
        }
      },
      _sass$_silentComment$0: function() {
        var t1, t2, parentIndentation, t3, t4, t5, i, t6;
        t1 = this.scanner;
        t2 = t1._position;
        t1.expect$1("//");
        parentIndentation = this._currentIndentation;
        t3 = t1.string;
        t4 = J.getInterceptor$asx(t3);
        t5 = "";
        while (true) {
          if (!true) {
            t3 = t5;
            break;
          }
          t5 += "//";
          i = 2;
          while (true) {
            t6 = this._currentIndentation;
            if (typeof t6 !== "number")
              return t6.$sub();
            if (typeof parentIndentation !== "number")
              return H.iae(parentIndentation);
            if (!(i < t6 - parentIndentation))
              break;
            t5 += H.Primitives_stringFromCharCode(32);
            ++i;
          }
          while (true) {
            if (!J.$eq$(t1._position, t4.get$length(t3))) {
              t6 = t1.peekChar$0();
              t6 = !(t6 === 10 || t6 === 13 || t6 === 12);
            } else
              t6 = false;
            if (!t6)
              break;
            t5 += H.Primitives_stringFromCharCode(t1.readChar$0());
          }
          t5 += "\n";
          t6 = this._peekIndentation$0();
          if (typeof t6 !== "number")
            return t6.$le();
          if (t6 <= parentIndentation) {
            t3 = t5;
            break;
          }
          this._readIndentation$0();
        }
        return new B.SilentComment(t3.charCodeAt(0) == 0 ? t3 : t3, t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
      },
      _sass$_loudComment$0: function() {
        var t1, t2, t3, t4, buffer, parentIndentation, t5, t6, first, beginningOfComment, t7, end, i, expression;
        t1 = this.scanner;
        t2 = t1._position;
        t1.expect$1("/*");
        t3 = new P.StringBuffer("");
        t4 = [];
        buffer = new Z.InterpolationBuffer(t3, t4);
        t3._contents = "/*";
        parentIndentation = this._currentIndentation;
        for (t5 = t1.string, t6 = J.getInterceptor$asx(t5), first = true; true; first = false) {
          if (first) {
            beginningOfComment = t1._position;
            this.spaces$0();
            t7 = t1.peekChar$0();
            if (t7 === 10 || t7 === 13 || t7 === 12) {
              this._readIndentation$0();
              t3._contents += H.Primitives_stringFromCharCode(32);
            } else {
              end = t1._position;
              t3._contents += t6.substring$2(t5, beginningOfComment, end);
            }
          } else {
            t7 = t3._contents += "\n";
            t3._contents = t7 + " * ";
          }
          i = 3;
          while (true) {
            t7 = this._currentIndentation;
            if (typeof t7 !== "number")
              return t7.$sub();
            if (typeof parentIndentation !== "number")
              return H.iae(parentIndentation);
            if (!(i < t7 - parentIndentation))
              break;
            t3._contents += H.Primitives_stringFromCharCode(32);
            ++i;
          }
          $label0$1:
            for (; !J.$eq$(t1._position, t6.get$length(t5));)
              switch (t1.peekChar$0()) {
                case 10:
                case 13:
                case 12:
                  break $label0$1;
                case 35:
                  if (t1.peekChar$1(1) === 123) {
                    t1.expect$1("#{");
                    this.whitespace$0();
                    expression = this._expression$0();
                    t1.expectChar$1(125);
                    buffer._flushText$0();
                    t4.push(expression);
                  } else
                    t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                  break;
                default:
                  t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                  break;
              }
          t7 = this._peekIndentation$0();
          if (typeof t7 !== "number")
            return t7.$le();
          if (t7 <= parentIndentation)
            break;
          while (true) {
            t7 = t1.peekChar$1(1);
            if (!(t7 === 10 || t7 === 13 || t7 === 12))
              break;
            t1.readChar$0();
            t7 = t3._contents += "\n";
            t3._contents = t7 + " *";
          }
          this._readIndentation$0();
        }
        t4 = t3._contents;
        if (!C.JSString_methods.endsWith$1(C.JSString_methods.trimRight$0(t4.charCodeAt(0) == 0 ? t4 : t4), "*/"))
          t3._contents += " */";
        return new L.LoudComment(buffer.interpolation$1(t1.spanFrom$1(new S._SpanScannerState(t1, t2))));
      },
      whitespace$0: [function() {
        var t1, t2, t3, next;
        for (t1 = this.scanner, t2 = t1.string, t3 = J.getInterceptor$asx(t2); !J.$eq$(t1._position, t3.get$length(t2));) {
          next = t1.peekChar$0();
          if (next !== 9 && next !== 32)
            break;
          t1.readChar$0();
        }
        if (t1.peekChar$0() === 47 && t1.peekChar$1(1) === 47)
          this.silentComment$0();
      }, "call$0", "get$whitespace", 0, 0, 3],
      _expectNewline$0: function() {
        var t1 = this.scanner;
        switch (t1.peekChar$0()) {
          case 59:
            t1.error$1("semicolons aren't allowed in the indented syntax.");
            break;
          case 10:
            t1.readChar$0();
            return;
          default:
            t1.error$1("expected newline.");
        }
      },
      _whileIndentedLower$1: function(body) {
        var parentIndentation, t1, t2, childIndentation, t3, indentation, t4;
        parentIndentation = this._currentIndentation;
        t1 = this.scanner;
        t2 = t1._sourceFile;
        childIndentation = null;
        while (true) {
          t3 = this._peekIndentation$0();
          if (typeof t3 !== "number")
            return t3.$gt();
          if (typeof parentIndentation !== "number")
            return H.iae(parentIndentation);
          if (!(t3 > parentIndentation))
            break;
          indentation = this._readIndentation$0();
          if (childIndentation == null)
            childIndentation = indentation;
          if (childIndentation == null ? indentation != null : childIndentation !== indentation) {
            t3 = "Inconsistent indentation, expected " + H.S(childIndentation) + " spaces.";
            t4 = t1._position;
            t4 = J.$sub$n(t4, t2.getColumn$1(t4));
            t1.error$3$length$position(t3, t2.getColumn$1(t1._position), t4);
          }
          body.call$0();
        }
      },
      _readIndentation$0: function() {
        if (this._nextIndentation == null)
          this._peekIndentation$0();
        this._currentIndentation = this._nextIndentation;
        this.scanner.set$state(this._nextIndentationEnd);
        this._nextIndentation = null;
        this._nextIndentationEnd = null;
        return this._currentIndentation;
      },
      _peekIndentation$0: function() {
        var t1, t2, t3, start, containsTab, containsSpace, next, t4;
        t1 = this._nextIndentation;
        if (t1 != null)
          return t1;
        t1 = this.scanner;
        t2 = t1.string;
        t3 = J.getInterceptor$asx(t2);
        if (J.$eq$(t1._position, t3.get$length(t2))) {
          this._nextIndentation = 0;
          this._nextIndentationEnd = new S._SpanScannerState(t1, t1._position);
          return 0;
        }
        start = new S._SpanScannerState(t1, t1._position);
        if (!this.scanCharIf$1(T.character__isNewline$closure()))
          t1.error$2$position("Expected newline.", t1._position);
        do {
          this._nextIndentation = 0;
          for (containsTab = false, containsSpace = false; true;) {
            next = t1.peekChar$0();
            if (next === 32)
              containsSpace = true;
            else {
              if (!(next === 9))
                break;
              containsTab = true;
            }
            t4 = this._nextIndentation;
            if (typeof t4 !== "number")
              return t4.$add();
            this._nextIndentation = t4 + 1;
            t1.readChar$0();
          }
          if (J.$eq$(t1._position, t3.get$length(t2))) {
            this._nextIndentation = 0;
            this._nextIndentationEnd = new S._SpanScannerState(t1, t1._position);
            t1.set$state(start);
            return 0;
          }
        } while (this.scanCharIf$1(T.character__isNewline$closure()));
        if (containsTab) {
          if (containsSpace) {
            t2 = t1._position;
            t3 = t1._sourceFile;
            t2 = J.$sub$n(t2, t3.getColumn$1(t2));
            t1.error$3$length$position("Tabs and spaces may not be mixed.", t3.getColumn$1(t1._position), t2);
          } else if (this._spaces === true) {
            t2 = t1._position;
            t3 = t1._sourceFile;
            t2 = J.$sub$n(t2, t3.getColumn$1(t2));
            t1.error$3$length$position("Expected spaces, was tabs.", t3.getColumn$1(t1._position), t2);
          }
        } else if (containsSpace && this._spaces === false) {
          t2 = t1._position;
          t3 = t1._sourceFile;
          t2 = J.$sub$n(t2, t3.getColumn$1(t2));
          t1.error$3$length$position("Expected tabs, was spaces.", t3.getColumn$1(t1._position), t2);
        }
        t2 = this._nextIndentation;
        if (typeof t2 !== "number")
          return t2.$gt();
        if (t2 > 0)
          if (this._spaces == null)
            this._spaces = containsSpace;
        this._nextIndentationEnd = new S._SpanScannerState(t1, t1._position);
        t1.set$state(start);
        return this._nextIndentation;
      }
    },
    SassParser_children_closure: {
      "^": "Closure:1;$this,children,child",
      call$0: function() {
        this.children.push(this.$this._child$1(this.child));
      }
    }
  }], ["", "package:sass/src/parse/scss.dart",, L, {
    "^": "",
    ScssParser: {
      "^": "StylesheetParser;_stylesheet$_inMixin,_mixinHasContent,_inContentBlock,_inControlDirective,_inUnknownAtRule,_inStyleRule,_inParentheses,scanner,logger",
      get$indented: function() {
        return false;
      },
      get$currentIndentation: function() {
        return;
      },
      styleRuleSelector$0: function() {
        return this.almostAnyValue$0();
      },
      expectStatementSeparator$1: function($name) {
        var t1, next;
        this.whitespaceWithoutComments$0();
        t1 = this.scanner;
        if (J.$eq$(t1._position, J.get$length$asx(t1.string)))
          return;
        next = t1.peekChar$0();
        if (next === 59 || next === 125)
          return;
        t1.expectChar$1(59);
      },
      expectStatementSeparator$0: function() {
        return this.expectStatementSeparator$1(null);
      },
      atEndOfStatement$0: function() {
        var next = this.scanner.peekChar$0();
        return next == null || next === 59 || next === 125 || next === 123;
      },
      lookingAtChildren$0: function() {
        return this.scanner.peekChar$0() === 123;
      },
      scanElse$1: function(_) {
        var t1, t2, t3;
        t1 = this.scanner;
        t2 = t1._position;
        this.whitespace$0();
        t3 = t1._position;
        if (t1.scanChar$1(64)) {
          if (this.scanIdentifier$1("else"))
            return true;
          if (this.scanIdentifier$1("elseif")) {
            this.logger.warn$3$deprecation$span('@elseif is deprecated and will not be supported in future Sass versions.\nUse "@else if" instead.', true, t1.spanFrom$1(new S._SpanScannerState(t1, t3)));
            t1.set$position(J.$sub$n(t1._position, 2));
            return true;
          }
        }
        t1.set$state(new S._SpanScannerState(t1, t2));
        return false;
      },
      children$1: [function(child) {
        var t1, children;
        t1 = this.scanner;
        t1.expectChar$1(123);
        this.whitespaceWithoutComments$0();
        children = H.setRuntimeTypeInfo([], [O.Statement]);
        for (; true;)
          switch (t1.peekChar$0()) {
            case 36:
              children.push(this.variableDeclaration$0());
              break;
            case 47:
              switch (t1.peekChar$1(1)) {
                case 47:
                  children.push(this._silentComment$0());
                  this.whitespaceWithoutComments$0();
                  break;
                case 42:
                  children.push(this._loudComment$0());
                  this.whitespaceWithoutComments$0();
                  break;
                default:
                  children.push(child.call$0());
                  break;
              }
              break;
            case 59:
              t1.readChar$0();
              this.whitespaceWithoutComments$0();
              break;
            case 125:
              t1.expectChar$1(125);
              this.whitespaceWithoutComments$0();
              return children;
            default:
              children.push(child.call$0());
              break;
          }
      }, "call$1", "get$children", 4, 0, 30],
      statements$1: function(statement) {
        var statements, t1, t2, t3, child;
        statements = H.setRuntimeTypeInfo([], [O.Statement]);
        this.whitespaceWithoutComments$0();
        for (t1 = this.scanner, t2 = t1.string, t3 = J.getInterceptor$asx(t2); !J.$eq$(t1._position, t3.get$length(t2));)
          switch (t1.peekChar$0()) {
            case 36:
              statements.push(this.variableDeclaration$0());
              break;
            case 47:
              switch (t1.peekChar$1(1)) {
                case 47:
                  statements.push(this._silentComment$0());
                  this.whitespaceWithoutComments$0();
                  break;
                case 42:
                  statements.push(this._loudComment$0());
                  this.whitespaceWithoutComments$0();
                  break;
                default:
                  child = statement.call$0();
                  if (child != null)
                    statements.push(child);
                  break;
              }
              break;
            case 59:
              t1.readChar$0();
              this.whitespaceWithoutComments$0();
              break;
            default:
              child = statement.call$0();
              if (child != null)
                statements.push(child);
              break;
          }
        return statements;
      },
      _silentComment$0: function() {
        var t1, start, t2, t3, t4;
        t1 = this.scanner;
        start = new S._SpanScannerState(t1, t1._position);
        t1.expect$1("//");
        t2 = t1.string;
        t3 = J.getInterceptor$asx(t2);
        do {
          while (true) {
            if (!J.$eq$(t1._position, t3.get$length(t2))) {
              t4 = t1.readChar$0();
              t4 = !(t4 === 10 || t4 === 13 || t4 === 12);
            } else
              t4 = false;
            if (!t4)
              break;
          }
          if (J.$eq$(t1._position, t3.get$length(t2)))
            break;
          this.whitespaceWithoutComments$0();
        } while (t1.scan$1("//"));
        return new B.SilentComment(t1.substring$1(0, start.position), t1.spanFrom$1(start));
      },
      _loudComment$0: function() {
        var t1, t2, t3, t4, buffer, expression, endPosition, end, t5, contents;
        t1 = this.scanner;
        t2 = t1._position;
        t1.expect$1("/*");
        t3 = new P.StringBuffer("");
        t4 = [];
        buffer = new Z.InterpolationBuffer(t3, t4);
        t3._contents = "/*";
        for (; true;)
          switch (t1.peekChar$0()) {
            case 35:
              if (t1.peekChar$1(1) === 123) {
                t1.expect$1("#{");
                this.whitespace$0();
                expression = this._expression$0();
                t1.expectChar$1(125);
                buffer._flushText$0();
                t4.push(expression);
              } else
                t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              break;
            case 42:
              t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              if (t1.peekChar$0() !== 47)
                break;
              t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              endPosition = t1._position;
              end = endPosition;
              t5 = Y._FileSpan$(t1._sourceFile, new S._SpanScannerState(t1, t2).position, end);
              contents = H.setRuntimeTypeInfo(t4.slice(0), [H.getTypeArgumentByIndex(t4, 0)]);
              t1 = t3._contents;
              if (t1.length !== 0)
                contents.push(t1.charCodeAt(0) == 0 ? t1 : t1);
              return new L.LoudComment(X.Interpolation$(contents, t5));
            default:
              t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              break;
          }
      }
    }
  }], ["", "package:sass/src/parse/selector.dart",, T, {
    "^": "",
    SelectorParser: {
      "^": "Parser0;_allowParent,scanner,logger",
      parse$0: function() {
        return this.wrapSpanFormatException$1(new T.SelectorParser_parse_closure(this));
      },
      parseCompoundSelector$0: function() {
        return this.wrapSpanFormatException$1(new T.SelectorParser_parseCompoundSelector_closure(this));
      },
      parseSimpleSelector$0: function() {
        return this.wrapSpanFormatException$1(new T.SelectorParser_parseSimpleSelector_closure(this));
      },
      _selectorList$0: function() {
        var t1, t2, previousLine, components, t3, t4, t5, lineBreak;
        t1 = this.scanner;
        t2 = t1._sourceFile;
        previousLine = t2.getLine$1(t1._position);
        components = H.setRuntimeTypeInfo([this._complexSelector$0()], [S.ComplexSelector]);
        this.whitespace$0();
        for (t3 = t1.string, t4 = J.getInterceptor$asx(t3); t1.scanChar$1(44);) {
          this.whitespace$0();
          if (t1.peekChar$0() === 44)
            continue;
          if (J.$eq$(t1._position, t4.get$length(t3)))
            break;
          t5 = t2.getLine$1(t1._position);
          lineBreak = t5 == null ? previousLine != null : t5 !== previousLine;
          if (lineBreak)
            previousLine = t2.getLine$1(t1._position);
          components.push(this._complexSelector$1$lineBreak(lineBreak));
        }
        return D.SelectorList$(components);
      },
      _complexSelector$1$lineBreak: function(lineBreak) {
        var components, t1, next;
        components = H.setRuntimeTypeInfo([], [S.ComplexSelectorComponent]);
        $label0$1:
          for (t1 = this.scanner; true;) {
            this.whitespace$0();
            next = t1.peekChar$0();
            switch (next) {
              case 43:
                t1.readChar$0();
                components.push(C.Combinator_uzg);
                break;
              case 62:
                t1.readChar$0();
                components.push(C.Combinator_sgq);
                break;
              case 126:
                t1.readChar$0();
                components.push(C.Combinator_CzM);
                break;
              case 91:
              case 46:
              case 35:
              case 37:
              case 58:
              case 38:
              case 42:
              case 124:
                components.push(this._compoundSelector$0());
                if (t1.peekChar$0() === 38)
                  t1.error$1('"&" may only used at the beginning of a compound selector.');
                break;
              default:
                if (next == null || !this.lookingAtIdentifier$0())
                  break $label0$1;
                components.push(this._compoundSelector$0());
                if (t1.peekChar$0() === 38)
                  t1.error$1('"&" may only used at the beginning of a compound selector.');
                break;
            }
          }
        if (components.length === 0)
          t1.error$1("expected selector.");
        return S.ComplexSelector$(components, lineBreak);
      },
      _complexSelector$0: function() {
        return this._complexSelector$1$lineBreak(false);
      },
      _compoundSelector$0: function() {
        var components, t1, t2;
        components = H.setRuntimeTypeInfo([this._simpleSelector$0()], [M.SimpleSelector]);
        t1 = this.scanner;
        while (true) {
          t2 = t1.peekChar$0();
          if (!(t2 === 42 || t2 === 91 || t2 === 46 || t2 === 35 || t2 === 37 || t2 === 58))
            break;
          components.push(this._simpleSelector$1$allowParent(false));
        }
        return X.CompoundSelector$(components);
      },
      _simpleSelector$1$allowParent: function(allowParent) {
        var t1, text, suffix;
        if (allowParent == null)
          allowParent = this._allowParent;
        t1 = this.scanner;
        switch (t1.peekChar$0()) {
          case 91:
            return this._attributeSelector$0();
          case 46:
            t1.expectChar$1(46);
            return new X.ClassSelector(this.identifier$0());
          case 35:
            t1.expectChar$1(35);
            return new N.IDSelector(this.identifier$0());
          case 37:
            t1.expectChar$1(37);
            return new N.PlaceholderSelector(this.identifier$0());
          case 58:
            return this._pseudoSelector$0();
          case 38:
            if (!allowParent)
              return this._typeOrUniversalSelector$0();
            t1.expectChar$1(38);
            if (this.lookingAtIdentifierBody$0()) {
              text = new P.StringBuffer("");
              this._identifierBody$1(text);
              if (text._contents.length === 0)
                t1.error$1("Expected identifier body.");
              t1 = text._contents;
              suffix = t1.charCodeAt(0) == 0 ? t1 : t1;
            } else
              suffix = null;
            return new M.ParentSelector(suffix);
          default:
            return this._typeOrUniversalSelector$0();
        }
      },
      _simpleSelector$0: function() {
        return this._simpleSelector$1$allowParent(null);
      },
      _attributeSelector$0: function() {
        var t1, $name, operator, next, value;
        t1 = this.scanner;
        t1.expectChar$1(91);
        this.whitespace$0();
        $name = this._attributeName$0();
        this.whitespace$0();
        if (t1.scanChar$1(93))
          return new N.AttributeSelector($name, null, null);
        operator = this._attributeOperator$0();
        this.whitespace$0();
        next = t1.peekChar$0();
        value = next === 39 || next === 34 ? this.string$0() : this.identifier$0();
        this.whitespace$0();
        t1.expectChar$1(93);
        return new N.AttributeSelector($name, operator, value);
      },
      _attributeName$0: function() {
        var t1, nameOrNamespace;
        t1 = this.scanner;
        if (t1.scanChar$1(42)) {
          t1.expectChar$1(124);
          return new D.QualifiedName(this.identifier$0(), "*");
        }
        nameOrNamespace = this.identifier$0();
        if (t1.peekChar$0() !== 124 || t1.peekChar$1(1) === 61)
          return new D.QualifiedName(nameOrNamespace, null);
        t1.readChar$0();
        return new D.QualifiedName(this.identifier$0(), nameOrNamespace);
      },
      _attributeOperator$0: function() {
        var t1, t2;
        t1 = this.scanner;
        t2 = t1._position;
        switch (t1.readChar$0()) {
          case 61:
            return C.AttributeOperator_sEs;
          case 126:
            t1.expectChar$1(61);
            return C.AttributeOperator_fz1;
          case 124:
            t1.expectChar$1(61);
            return C.AttributeOperator_AuK;
          case 94:
            t1.expectChar$1(61);
            return C.AttributeOperator_4L5;
          case 36:
            t1.expectChar$1(61);
            return C.AttributeOperator_mOX;
          case 42:
            t1.expectChar$1(61);
            return C.AttributeOperator_gqZ;
          default:
            t1.error$2$position('Expected "]".', t2);
        }
      },
      _pseudoSelector$0: function() {
        var t1, element, $name, unvendored, selector, argument, t2;
        t1 = this.scanner;
        t1.expectChar$1(58);
        element = t1.scanChar$1(58);
        $name = this.identifier$0();
        if (!t1.scanChar$1(40))
          return new D.PseudoSelector($name, B.unvendor($name), !element, null, null, null, null);
        this.whitespace$0();
        unvendored = B.unvendor($name);
        if (element)
          if ($.$get$_selectorPseudoElements().contains$1(0, unvendored)) {
            selector = this._selectorList$0();
            argument = null;
          } else {
            argument = this.declarationValue$1$allowEmpty(true);
            selector = null;
          }
        else if ($.$get$_selectorPseudoClasses().contains$1(0, unvendored)) {
          selector = this._selectorList$0();
          argument = null;
        } else if (unvendored === "nth-child" || unvendored === "nth-last-child") {
          argument = this.rawText$1(this.get$_aNPlusB());
          this.whitespace$0();
          t2 = t1.peekChar$1(-1);
          if (t2 === 32 || t2 === 9 || T.isNewline(t2)) {
            this.expectIdentifier$2$ignoreCase("of", true);
            argument += "of";
            this.whitespace$0();
            selector = this._selectorList$0();
          } else
            selector = null;
        } else {
          argument = C.JSString_methods.trimRight$0(this.declarationValue$1$allowEmpty(true));
          selector = null;
        }
        t1.expectChar$1(41);
        return new D.PseudoSelector($name, B.unvendor($name), !element, argument, selector, null, null);
      },
      _aNPlusB$0: [function() {
        var t1, first, t2, next, last;
        t1 = this.scanner;
        switch (t1.peekChar$0()) {
          case 101:
          case 69:
            this.expectIdentifier$2$ignoreCase("even", true);
            return;
          case 111:
          case 79:
            this.expectIdentifier$2$ignoreCase("odd", true);
            return;
          case 43:
          case 45:
            t1.readChar$0();
            break;
        }
        first = t1.peekChar$0();
        if (first != null && T.isDigit(first)) {
          while (true) {
            t2 = t1.peekChar$0();
            if (!(t2 != null && t2 >= 48 && t2 <= 57))
              break;
            t1.readChar$0();
          }
          this.whitespace$0();
          if (!this.scanCharIgnoreCase$1(110))
            return;
        } else
          this.expectCharIgnoreCase$1(110);
        this.whitespace$0();
        next = t1.peekChar$0();
        if (next !== 43 && next !== 45)
          return;
        t1.readChar$0();
        this.whitespace$0();
        last = t1.peekChar$0();
        if (last == null || !T.isDigit(last))
          t1.error$1("Expected a number.");
        while (true) {
          t2 = t1.peekChar$0();
          if (!(t2 != null && t2 >= 48 && t2 <= 57))
            break;
          t1.readChar$0();
        }
      }, "call$0", "get$_aNPlusB", 0, 0, 3],
      _typeOrUniversalSelector$0: function() {
        var t1, first, nameOrNamespace;
        t1 = this.scanner;
        first = t1.peekChar$0();
        if (first === 42) {
          t1.readChar$0();
          if (!t1.scanChar$1(124))
            return new N.UniversalSelector(null);
          if (t1.scanChar$1(42))
            return new N.UniversalSelector("*");
          else
            return new F.TypeSelector(new D.QualifiedName(this.identifier$0(), "*"));
        } else if (first === 124) {
          t1.readChar$0();
          if (t1.scanChar$1(42))
            return new N.UniversalSelector("");
          else
            return new F.TypeSelector(new D.QualifiedName(this.identifier$0(), ""));
        }
        nameOrNamespace = this.identifier$0();
        if (!t1.scanChar$1(124))
          return new F.TypeSelector(new D.QualifiedName(nameOrNamespace, null));
        else if (t1.scanChar$1(42))
          return new N.UniversalSelector(nameOrNamespace);
        else
          return new F.TypeSelector(new D.QualifiedName(this.identifier$0(), nameOrNamespace));
      }
    },
    SelectorParser_parse_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        var t1, selector;
        t1 = this.$this;
        selector = t1._selectorList$0();
        t1 = t1.scanner;
        if (!J.$eq$(t1._position, J.get$length$asx(t1.string)))
          t1.error$1("expected selector.");
        return selector;
      }
    },
    SelectorParser_parseCompoundSelector_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        var t1, compound;
        t1 = this.$this;
        compound = t1._compoundSelector$0();
        t1 = t1.scanner;
        if (!J.$eq$(t1._position, J.get$length$asx(t1.string)))
          t1.error$1("expected selector.");
        return compound;
      }
    },
    SelectorParser_parseSimpleSelector_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        var t1, simple;
        t1 = this.$this;
        simple = t1._simpleSelector$0();
        t1 = t1.scanner;
        if (!J.$eq$(t1._position, J.get$length$asx(t1.string)))
          t1.error$1("unexpected token.");
        return simple;
      }
    }
  }], ["", "package:sass/src/parse/stylesheet.dart",, V, {
    "^": "",
    StylesheetParser: {
      "^": "Parser0;",
      parse$0: function() {
        return this.wrapSpanFormatException$1(new V.StylesheetParser_parse_closure(this));
      },
      parseArgumentDeclaration$0: function() {
        return this.wrapSpanFormatException$1(new V.StylesheetParser_parseArgumentDeclaration_closure(this));
      },
      parseExpression$0: function() {
        return this.wrapSpanFormatException$1(new V.StylesheetParser_parseExpression_closure(this));
      },
      parseVariableDeclaration$0: function() {
        return this.wrapSpanFormatException$1(new V.StylesheetParser_parseVariableDeclaration_closure(this));
      },
      parseSignature$0: function() {
        return this.wrapSpanFormatException$1(new V.StylesheetParser_parseSignature_closure(this));
      },
      _statement$1$root: [function(root) {
        var t1, t2;
        t1 = this.scanner;
        switch (t1.peekChar$0()) {
          case 64:
            return this._atRule$2$root(new V.StylesheetParser__statement_closure(this), root);
          case 43:
            if (!this.get$indented() || !this.lookingAtIdentifier$1(1))
              return this._stylesheet$_styleRule$0();
            t2 = t1._position;
            t1.readChar$0();
            return this._includeRule$1(new S._SpanScannerState(t1, t2));
          case 61:
            if (!this.get$indented())
              return this._stylesheet$_styleRule$0();
            t2 = t1._position;
            t1.readChar$0();
            this.whitespace$0();
            return this._mixinRule$1(new S._SpanScannerState(t1, t2));
          default:
            return this._inStyleRule || this._inUnknownAtRule || this._stylesheet$_inMixin || this._inContentBlock ? this._declarationOrStyleRule$0() : this._stylesheet$_styleRule$0();
        }
      }, function() {
        return this._statement$1$root(false);
      }, "_statement$0", "call$1$root", "call$0", "get$_statement", 0, 3, 69],
      variableDeclaration$0: function() {
        var t1, t2, $name, expression, guarded, global, flagStart, flag;
        t1 = this.scanner;
        t2 = t1._position;
        t1.expectChar$1(36);
        $name = this.identifier$0();
        this.whitespace$0();
        t1.expectChar$1(58);
        this.whitespace$0();
        expression = this._expression$0();
        for (guarded = false, global = false; t1.scanChar$1(33);) {
          flagStart = J.$sub$n(t1._position, 1);
          flag = this.identifier$0();
          if (flag === "default")
            guarded = true;
          else if (flag === "global")
            global = true;
          else
            t1.error$3$length$position("Invalid flag name.", J.$sub$n(t1._position, flagStart), flagStart);
          this.whitespace$0();
        }
        this.expectStatementSeparator$1("variable declaration");
        return new Z.VariableDeclaration($name, expression, guarded, global, t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
      },
      _stylesheet$_styleRule$0: function() {
        var wasInStyleRule, t1, t2, selector, children, t3;
        wasInStyleRule = this._inStyleRule;
        this._inStyleRule = true;
        if (this.get$indented())
          this.scanner.scanChar$1(92);
        t1 = this.scanner;
        t2 = t1._position;
        selector = this.styleRuleSelector$0();
        children = this.children$1(this.get$_statement());
        t2 = t1.spanFrom$1(new S._SpanScannerState(t1, t2));
        t1 = P.List_List$unmodifiable(children, null);
        t3 = C.JSArray_methods.any$1(t1, new M.ParentStatement_closure());
        this._inStyleRule = wasInStyleRule;
        return new X.StyleRule(selector, t2, t1, t3);
      },
      _declarationOrStyleRule$0: function() {
        var t1, start, declarationOrBuffer, selectorSpan, wasInStyleRule, children, t2, t3, t4;
        if (this.get$indented() && this.scanner.scanChar$1(92))
          return this._stylesheet$_styleRule$0();
        t1 = this.scanner;
        start = new S._SpanScannerState(t1, t1._position);
        declarationOrBuffer = this._declarationOrBuffer$0();
        if (!!declarationOrBuffer.$isDeclaration)
          return declarationOrBuffer;
        H.interceptedTypeCast(declarationOrBuffer, "$isInterpolationBuffer");
        declarationOrBuffer.addInterpolation$1(this.styleRuleSelector$0());
        selectorSpan = t1.spanFrom$1(start);
        wasInStyleRule = this._inStyleRule;
        this._inStyleRule = true;
        children = this.children$1(this.get$_statement());
        if (this.get$indented() && children.length === 0)
          this.logger.warn$2$span("This selector doesn't have any properties and won't be rendered.", selectorSpan);
        this._inStyleRule = wasInStyleRule;
        t2 = declarationOrBuffer.interpolation$1(selectorSpan);
        t1 = t1.spanFrom$1(start);
        t3 = P.List_List$unmodifiable(children, null);
        t4 = C.JSArray_methods.any$1(t3, new M.ParentStatement_closure());
        return new X.StyleRule(t2, t1, t3, t4);
      },
      _declarationOrBuffer$0: function() {
        var nameBuffer, midBuffer, couldBeSelector, beforeDeclaration, value, additional, t1, start, first, t2, t3, t4, $name, postColonWhitespace, children, exception;
        t1 = this.scanner;
        start = new S._SpanScannerState(t1, t1._position);
        nameBuffer = new Z.InterpolationBuffer(new P.StringBuffer(""), []);
        first = t1.peekChar$0();
        if (first !== 58)
          if (first !== 42)
            if (first !== 46)
              t2 = first === 35 && t1.peekChar$1(1) !== 123;
            else
              t2 = true;
          else
            t2 = true;
        else
          t2 = true;
        if (t2) {
          t2 = t1.readChar$0();
          nameBuffer.get$_interpolation_buffer$_text()._contents += H.Primitives_stringFromCharCode(t2);
          t2 = this.rawText$1(this.get$whitespace());
          nameBuffer.get$_interpolation_buffer$_text()._contents += t2;
        }
        if (!this._lookingAtInterpolatedIdentifier$0())
          return nameBuffer;
        nameBuffer.addInterpolation$1(this._interpolatedIdentifier$0());
        if (t1.matches$1("/*")) {
          t2 = this.rawText$1(this.get$loudComment());
          nameBuffer.get$_interpolation_buffer$_text()._contents += t2;
        }
        midBuffer = new P.StringBuffer("");
        t2 = midBuffer;
        t3 = this.rawText$1(this.get$whitespace());
        t2.set$_contents(t2.get$_contents() + t3);
        t3 = t1._position;
        if (!t1.scanChar$1(58)) {
          if (midBuffer.get$_contents().length !== 0)
            nameBuffer.get$_interpolation_buffer$_text()._contents += H.Primitives_stringFromCharCode(32);
          return nameBuffer;
        }
        t2 = midBuffer;
        t4 = H.Primitives_stringFromCharCode(58);
        t2.set$_contents(t2.get$_contents() + t4);
        $name = nameBuffer.interpolation$1(t1.spanFrom$2(start, new S._SpanScannerState(t1, t3)));
        first = C.JSArray_methods.get$first($name.contents);
        if (C.JSString_methods.startsWith$1(typeof first === "string" ? first : "", "--")) {
          value = this._interpolatedDeclarationValue$0();
          this.expectStatementSeparator$1("custom property");
          return L.Declaration$($name, t1.spanFrom$1(start), null, value);
        }
        if (t1.scanChar$1(58)) {
          t1 = nameBuffer;
          t1.get$_interpolation_buffer$_text()._contents += H.S(midBuffer);
          t1.get$_interpolation_buffer$_text()._contents += H.Primitives_stringFromCharCode(58);
          return t1;
        } else if (this.get$indented() && this._lookingAtInterpolatedIdentifier$0()) {
          t1 = nameBuffer;
          t1.get$_interpolation_buffer$_text()._contents += H.S(midBuffer);
          return t1;
        }
        postColonWhitespace = this.rawText$1(this.get$whitespace());
        if (this.lookingAtChildren$0()) {
          children = this.children$1(this.get$_declarationChild());
          return L.Declaration$($name, t1.spanFrom$1(start), children, null);
        }
        t2 = midBuffer;
        t2.set$_contents(t2.get$_contents() + postColonWhitespace);
        couldBeSelector = postColonWhitespace.length === 0 && this._lookingAtInterpolatedIdentifier$0();
        beforeDeclaration = new S._SpanScannerState(t1, t1._position);
        value = null;
        try {
          value = this._declarationExpression$0();
          if (this.lookingAtChildren$0()) {
            if (couldBeSelector === true)
              this.expectStatementSeparator$0();
          } else if (!this.atEndOfStatement$0())
            this.expectStatementSeparator$0();
        } catch (exception) {
          if (!!J.getInterceptor(H.unwrapException(exception)).$isFormatException) {
            if (couldBeSelector !== true)
              throw exception;
            t1.set$state(beforeDeclaration);
            additional = this.almostAnyValue$0();
            if (!this.get$indented() && t1.peekChar$0() === 59)
              throw exception;
            nameBuffer.get$_interpolation_buffer$_text()._contents += H.S(midBuffer);
            nameBuffer.addInterpolation$1(additional);
            return nameBuffer;
          } else
            throw exception;
        }
        children = this.lookingAtChildren$0() ? this.children$1(this.get$_declarationChild()) : null;
        if (children == null)
          this.expectStatementSeparator$0();
        return L.Declaration$($name, t1.spanFrom$1(start), children, value);
      },
      _declaration$0: function() {
        var t1, start, $name, value, children;
        t1 = this.scanner;
        start = new S._SpanScannerState(t1, t1._position);
        $name = this._interpolatedIdentifier$0();
        this.whitespace$0();
        t1.expectChar$1(58);
        this.whitespace$0();
        if (this.lookingAtChildren$0())
          return L.Declaration$($name, t1.spanFrom$1(start), this.children$1(this.get$_declarationChild()), null);
        value = this._declarationExpression$0();
        children = this.lookingAtChildren$0() ? this.children$1(this.get$_declarationChild()) : null;
        if (children == null)
          this.expectStatementSeparator$0();
        return L.Declaration$($name, t1.spanFrom$1(start), children, value);
      },
      _declarationExpression$0: function() {
        var t1, t2;
        if (this.lookingAtChildren$0()) {
          t1 = this.scanner;
          t1 = Y.FileLocation$_(t1._sourceFile, t1._position);
          t2 = t1.offset;
          return new D.StringExpression(X.Interpolation$([], Y._FileSpan$(t1.file, t2, t2)), true);
        }
        return this._expression$0();
      },
      _declarationChild$0: [function() {
        if (this.scanner.peekChar$0() === 64)
          return this._declarationAtRule$0();
        return this._declaration$0();
      }, "call$0", "get$_declarationChild", 0, 0, 21],
      _atRule$2$root: function(child, root) {
        var t1, t2, start, $name, value, optional, $arguments, children, t3, query, condition, wasInUnknownAtRule, rule;
        t1 = this.scanner;
        t2 = t1._position;
        start = new S._SpanScannerState(t1, t2);
        $name = this._atRuleName$0();
        switch ($name) {
          case "at-root":
            return this._atRootRule$1(start);
          case "charset":
            if (!root)
              this._disallowedAtRule$1(start);
            this.string$0();
            return;
          case "content":
            return this._contentRule$1(start);
          case "debug":
            return this._debugRule$1(start);
          case "each":
            return this._eachRule$2(start, child);
          case "else":
            return this._disallowedAtRule$1(start);
          case "error":
            return this._errorRule$1(start);
          case "extend":
            if (!this._inStyleRule && !this._stylesheet$_inMixin && !this._inContentBlock)
              t1.error$3$length$position("@extend may only be used within style rules.", 7, t2);
            value = this.almostAnyValue$0();
            optional = t1.scanChar$1(33);
            if (optional)
              this.expectIdentifier$1("optional");
            this.expectStatementSeparator$1("@extend rule");
            return new X.ExtendRule(value, optional, t1.spanFrom$1(start));
          case "for":
            return this._forRule$2(start, child);
          case "function":
            $name = this.identifier$0();
            this.whitespace$0();
            $arguments = this._argumentDeclaration$0();
            if (this._stylesheet$_inMixin || this._inContentBlock)
              H.throwExpression(E.StringScannerException$("Mixins may not contain function declarations.", t1.spanFrom$1(start), t1.string));
            else if (this._inControlDirective)
              H.throwExpression(E.StringScannerException$("Functions may not be declared in control directives.", t1.spanFrom$1(start), t1.string));
            switch (B.unvendor($name)) {
              case "calc":
              case "element":
              case "expression":
              case "url":
              case "and":
              case "or":
              case "not":
                t1.error$3$length$position("Invalid function name.", J.$sub$n(t1._position, t2), t2);
                break;
            }
            this.whitespace$0();
            children = this.children$1(this.get$_functionAtRule());
            t1 = t1.spanFrom$1(start);
            t2 = P.List_List$unmodifiable(children, null);
            t3 = C.JSArray_methods.any$1(t2, new M.ParentStatement_closure());
            return new M.FunctionRule($name, $arguments, t1, t2, t3);
          case "if":
            return this._ifRule$2(start, child);
          case "import":
            return this._importRule$1(start);
          case "include":
            return this._includeRule$1(start);
          case "media":
            query = this._mediaQueryList$0();
            children = this.children$1(this.get$_statement());
            t1 = t1.spanFrom$1(start);
            t2 = P.List_List$unmodifiable(children, null);
            t3 = C.JSArray_methods.any$1(t2, new M.ParentStatement_closure());
            return new G.MediaRule(query, t1, t2, t3);
          case "mixin":
            return this._mixinRule$1(start);
          case "-moz-document":
            return this._mozDocumentRule$1(start);
          case "return":
            return this._disallowedAtRule$1(start);
          case "supports":
            condition = this._supportsCondition$0();
            this.whitespace$0();
            t2 = this.children$1(this.get$_statement());
            t1 = t1.spanFrom$1(start);
            t2 = P.List_List$unmodifiable(t2, null);
            t3 = C.JSArray_methods.any$1(t2, new M.ParentStatement_closure());
            return new B.SupportsRule(condition, t1, t2, t3);
          case "warn":
            return this._warnRule$1(start);
          case "while":
            return this._whileRule$2(start, child);
          default:
            wasInUnknownAtRule = this._inUnknownAtRule;
            this._inUnknownAtRule = true;
            value = t1.peekChar$0() !== 33 && !this.atEndOfStatement$0() ? this.almostAnyValue$0() : null;
            children = this.lookingAtChildren$0() ? this.children$1(this.get$_statement()) : null;
            if (children == null)
              this.expectStatementSeparator$0();
            rule = U.AtRule$($name, t1.spanFrom$1(start), children, value);
            this._inUnknownAtRule = wasInUnknownAtRule;
            return rule;
        }
      },
      _declarationAtRule$0: [function() {
        var t1, start;
        t1 = this.scanner;
        start = new S._SpanScannerState(t1, t1._position);
        switch (this._atRuleName$0()) {
          case "content":
            return this._contentRule$1(start);
          case "debug":
            return this._debugRule$1(start);
          case "each":
            return this._eachRule$2(start, this.get$_declarationChild());
          case "else":
            return this._disallowedAtRule$1(start);
          case "error":
            return this._errorRule$1(start);
          case "for":
            return this._forRule$2(start, this.get$_declarationAtRule());
          case "if":
            return this._ifRule$2(start, this.get$_declarationChild());
          case "include":
            return this._includeRule$1(start);
          case "warn":
            return this._warnRule$1(start);
          case "while":
            return this._whileRule$2(start, this.get$_declarationChild());
          default:
            return this._disallowedAtRule$1(start);
        }
      }, "call$0", "get$_declarationAtRule", 0, 0, 21],
      _functionAtRule$0: [function() {
        var t1, start, expression;
        t1 = this.scanner;
        start = new S._SpanScannerState(t1, t1._position);
        switch (this._atRuleName$0()) {
          case "debug":
            return this._debugRule$1(start);
          case "each":
            return this._eachRule$2(start, this.get$_functionAtRule());
          case "else":
            return this._disallowedAtRule$1(start);
          case "error":
            return this._errorRule$1(start);
          case "for":
            return this._forRule$2(start, this.get$_functionAtRule());
          case "if":
            return this._ifRule$2(start, this.get$_functionAtRule());
          case "return":
            expression = this._expression$0();
            this.expectStatementSeparator$1("@return rule");
            return new B.ReturnRule(expression, t1.spanFrom$1(start));
          case "warn":
            return this._warnRule$1(start);
          case "while":
            return this._whileRule$2(start, this.get$_functionAtRule());
          default:
            return this._disallowedAtRule$1(start);
        }
      }, "call$0", "get$_functionAtRule", 0, 0, 21],
      _atRuleName$0: function() {
        this.scanner.expectChar$1(64);
        var $name = this.identifier$0();
        this.whitespace$0();
        return $name;
      },
      _atRootRule$1: function(start) {
        var t1, query, t2, t3, child;
        t1 = this.scanner;
        if (t1.peekChar$0() === 40) {
          query = this._queryExpression$0();
          this.whitespace$0();
          t2 = this.children$1(this.get$_statement());
          t1 = t1.spanFrom$1(start);
          t2 = P.List_List$unmodifiable(t2, null);
          t3 = C.JSArray_methods.any$1(t2, new M.ParentStatement_closure());
          return new V.AtRootRule(query, t1, t2, t3);
        } else if (this.lookingAtChildren$0()) {
          t2 = this.children$1(this.get$_statement());
          t1 = t1.spanFrom$1(start);
          t2 = P.List_List$unmodifiable(t2, null);
          t3 = C.JSArray_methods.any$1(t2, new M.ParentStatement_closure());
          return new V.AtRootRule(null, t1, t2, t3);
        } else {
          child = this._stylesheet$_styleRule$0();
          t1 = t1.spanFrom$1(start);
          t2 = P.List_List$unmodifiable([child], null);
          t3 = C.JSArray_methods.any$1(t2, new M.ParentStatement_closure());
          return new V.AtRootRule(null, t1, t2, t3);
        }
      },
      _contentRule$1: function(start) {
        if (this._stylesheet$_inMixin) {
          this._mixinHasContent = true;
          this.expectStatementSeparator$1("@content rule");
          return new Q.ContentRule(this.scanner.spanFrom$1(start));
        }
        this.scanner.error$3$length$position("@content is only allowed within mixin declarations.", 8, start.position);
      },
      _debugRule$1: function(start) {
        var expression = this._expression$0();
        this.expectStatementSeparator$1("@debug rule");
        return new Q.DebugRule(expression, this.scanner.spanFrom$1(start));
      },
      _eachRule$2: function(start, child) {
        var wasInControlDirective, t1, variables, list, children, t2, t3, t4;
        wasInControlDirective = this._inControlDirective;
        this._inControlDirective = true;
        t1 = this.scanner;
        t1.expectChar$1(36);
        variables = [this.identifier$0()];
        this.whitespace$0();
        for (; t1.scanChar$1(44);) {
          this.whitespace$0();
          t1.expectChar$1(36);
          variables.push(this.identifier$0());
          this.whitespace$0();
        }
        this.expectIdentifier$1("in");
        this.whitespace$0();
        list = this._expression$0();
        children = this.children$1(child);
        this._inControlDirective = wasInControlDirective;
        t1 = t1.spanFrom$1(start);
        t2 = P.List_List$unmodifiable(variables, null);
        t3 = P.List_List$unmodifiable(children, null);
        t4 = C.JSArray_methods.any$1(t3, new M.ParentStatement_closure());
        return new V.EachRule(t2, list, t1, t3, t4);
      },
      _errorRule$1: function(start) {
        var expression = this._expression$0();
        this.expectStatementSeparator$1("@error rule");
        return new D.ErrorRule(expression, this.scanner.spanFrom$1(start));
      },
      _forRule$2: function(start, child) {
        var t1, wasInControlDirective, t2, variable, from, to, children, t3, t4;
        t1 = {};
        wasInControlDirective = this._inControlDirective;
        this._inControlDirective = true;
        t2 = this.scanner;
        t2.expectChar$1(36);
        variable = this.identifier$0();
        this.whitespace$0();
        this.expectIdentifier$1("from");
        this.whitespace$0();
        t1.exclusive = null;
        from = this._expression$1$until(new V.StylesheetParser__forRule_closure(t1, this));
        if (t1.exclusive == null)
          t2.error$1('Expected "to" or "through".');
        this.whitespace$0();
        to = this._expression$0();
        children = this.children$1(child);
        this._inControlDirective = wasInControlDirective;
        t2 = t2.spanFrom$1(start);
        t1 = t1.exclusive;
        t3 = P.List_List$unmodifiable(children, null);
        t4 = C.JSArray_methods.any$1(t3, new M.ParentStatement_closure());
        return new B.ForRule(variable, from, to, t1, t2, t3, t4);
      },
      _ifRule$2: function(start, child) {
        var ifIndentation, wasInControlDirective, expression, t1, clauses, lastClause, result, t2;
        ifIndentation = this.get$currentIndentation();
        wasInControlDirective = this._inControlDirective;
        this._inControlDirective = true;
        expression = this._expression$0();
        t1 = P.List_List$unmodifiable(this.children$1(child), null);
        clauses = [new V.IfClause(expression, t1, C.JSArray_methods.any$1(t1, new V.IfClause$__closure()))];
        while (true) {
          if (!this.scanElse$1(ifIndentation)) {
            lastClause = null;
            break;
          }
          this.whitespace$0();
          if (this.scanIdentifier$1("if")) {
            this.whitespace$0();
            t1 = this._expression$0();
            result = P.List_List$from(this.children$1(child), false, null);
            result.fixed$length = Array;
            result.immutable$list = Array;
            t2 = result;
            clauses.push(new V.IfClause(t1, t2, C.JSArray_methods.any$1(t2, new V.IfClause$__closure())));
          } else {
            result = P.List_List$from(this.children$1(child), false, null);
            result.fixed$length = Array;
            result.immutable$list = Array;
            t1 = result;
            lastClause = new V.IfClause(null, t1, C.JSArray_methods.any$1(t1, new V.IfClause$__closure()));
            break;
          }
        }
        this._inControlDirective = wasInControlDirective;
        t1 = this.scanner.spanFrom$1(start);
        return new V.IfRule(P.List_List$unmodifiable(clauses, null), lastClause, t1);
      },
      _importRule$1: function(start) {
        var imports, t1, argument;
        imports = H.setRuntimeTypeInfo([], [F.Import]);
        t1 = this.scanner;
        do {
          this.whitespace$0();
          argument = this.importArgument$0();
          if ((this._inControlDirective || this._stylesheet$_inMixin) && argument instanceof B.DynamicImport)
            this._disallowedAtRule$1(start);
          imports.push(argument);
          this.whitespace$0();
        } while (t1.scanChar$1(44));
        this.expectStatementSeparator$1("@import rule");
        t1 = t1.spanFrom$1(start);
        return new B.ImportRule(P.List_List$unmodifiable(imports, null), t1);
      },
      importArgument$0: ["super$StylesheetParser$importArgument", function() {
        var url, urlSpan, error, t1, start, next, queries, t2, t3, t4, exception;
        t1 = this.scanner;
        start = new S._SpanScannerState(t1, t1._position);
        next = t1.peekChar$0();
        if (next === 117 || next === 85) {
          url = this._dynamicUrl$0();
          this.whitespace$0();
          queries = this._tryImportQueries$0();
          t2 = X.Interpolation$([url], t1.spanFrom$1(start));
          t1 = t1.spanFrom$1(start);
          t3 = queries == null;
          t4 = t3 ? null : queries.item1;
          return new Q.StaticImport(t2, t4, t3 ? null : queries.item2, t1);
        }
        url = this.string$0();
        urlSpan = t1.spanFrom$1(start);
        this.whitespace$0();
        queries = this._tryImportQueries$0();
        if (this._isPlainImportUrl$1(url) || queries != null) {
          t2 = urlSpan;
          t3 = J.get$file$x(t2);
          t4 = t2.get$_file$_start();
          t2 = t2.get$_end();
          t2 = X.Interpolation$([P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(t3._decodedChars, t4, t2), 0, null)], urlSpan);
          t1 = t1.spanFrom$1(start);
          t3 = queries == null;
          t4 = t3 ? null : queries.item1;
          return new Q.StaticImport(t2, t4, t3 ? null : queries.item2, t1);
        } else
          try {
            t1 = this.parseImportUrl$1(url);
            return new B.DynamicImport(t1, urlSpan);
          } catch (exception) {
            t1 = H.unwrapException(exception);
            if (!!J.getInterceptor(t1).$isFormatException) {
              error = t1;
              throw H.wrapException(E.SassFormatException$("Invalid URL: " + H.S(J.get$message$x(error)), urlSpan));
            } else
              throw exception;
          }
      }],
      parseImportUrl$1: function(url) {
        var t1 = $.$get$windows();
        if (J.$gt$n(t1.style.rootLength$1(url), 0))
          return J.toString$0$(t1.toUri$1(url));
        P.Uri_parse(url, 0, null);
        return url;
      },
      _isPlainImportUrl$1: function(url) {
        var first;
        if (url.length < 5)
          return false;
        if (C.JSString_methods.endsWith$1(url, ".css"))
          return true;
        first = C.JSString_methods._codeUnitAt$1(url, 0);
        if (first === 47)
          return C.JSString_methods._codeUnitAt$1(url, 1) === 47;
        if (first !== 104)
          return false;
        return C.JSString_methods.startsWith$1(url, "http://") || C.JSString_methods.startsWith$1(url, "https://");
      },
      _tryImportQueries$0: function() {
        var t1, start, supports, $name, media;
        if (this.scanIdentifier$2$ignoreCase("supports", true)) {
          t1 = this.scanner;
          t1.expectChar$1(40);
          start = new S._SpanScannerState(t1, t1._position);
          if (this.scanIdentifier$2$ignoreCase("not", true)) {
            this.whitespace$0();
            supports = new M.SupportsNegation(this._supportsConditionInParens$0(), t1.spanFrom$1(start));
          } else if (t1.peekChar$0() === 40)
            supports = this._supportsCondition$0();
          else {
            $name = this._expression$0();
            t1.expectChar$1(58);
            this.whitespace$0();
            supports = new L.SupportsDeclaration($name, this._expression$0(), t1.spanFrom$1(start));
          }
          t1.expectChar$1(41);
          this.whitespace$0();
        } else
          supports = null;
        media = this._lookingAtInterpolatedIdentifier$0() || this.scanner.peekChar$0() === 40 ? this._mediaQueryList$0() : null;
        if (supports == null && media == null)
          return;
        return new S.Tuple2(supports, media, [null, null]);
      },
      _includeRule$1: function(start) {
        var $name, t1, $arguments, t2, t3, children;
        $name = this.identifier$0();
        this.whitespace$0();
        t1 = this.scanner;
        if (t1.peekChar$0() === 40)
          $arguments = this._argumentInvocation$1$mixin(true);
        else {
          t2 = Y.FileLocation$_(t1._sourceFile, t1._position);
          t3 = t2.offset;
          $arguments = new X.ArgumentInvocation(C.List_empty, C.Map_empty0, null, null, Y._FileSpan$(t2.file, t3, t3));
        }
        this.whitespace$0();
        if (this.lookingAtChildren$0()) {
          this._inContentBlock = true;
          children = this.children$1(this.get$_statement());
          this._inContentBlock = false;
        } else {
          this.expectStatementSeparator$0();
          children = null;
        }
        t1 = t1.spanFrom$1(start);
        t2 = children == null ? null : P.List_List$unmodifiable(children, null);
        t3 = t2 == null ? null : C.JSArray_methods.any$1(t2, new M.ParentStatement_closure());
        return new A.IncludeRule($name, $arguments, t1, t2, t3 == null ? false : t3);
      },
      _mixinRule$1: function(start) {
        var $name, t1, $arguments, t2, t3, children, hadContent;
        $name = this.identifier$0();
        this.whitespace$0();
        t1 = this.scanner;
        if (t1.peekChar$0() === 40)
          $arguments = this._argumentDeclaration$0();
        else {
          t2 = Y.FileLocation$_(t1._sourceFile, t1._position);
          t3 = t2.offset;
          $arguments = new B.ArgumentDeclaration(C.List_empty, null, Y._FileSpan$(t2.file, t3, t3));
        }
        if (this._stylesheet$_inMixin || this._inContentBlock)
          throw H.wrapException(E.StringScannerException$("Mixins may not contain mixin declarations.", t1.spanFrom$1(start), t1.string));
        else if (this._inControlDirective)
          throw H.wrapException(E.StringScannerException$("Mixins may not be declared in control directives.", t1.spanFrom$1(start), t1.string));
        this.whitespace$0();
        this._stylesheet$_inMixin = true;
        this._mixinHasContent = false;
        children = this.children$1(this.get$_statement());
        hadContent = this._mixinHasContent;
        this._stylesheet$_inMixin = false;
        this._mixinHasContent = null;
        t1 = t1.spanFrom$1(start);
        t2 = P.List_List$unmodifiable(children, null);
        t3 = C.JSArray_methods.any$1(t2, new M.ParentStatement_closure());
        return new T.MixinRule(hadContent, $name, $arguments, t1, t2, t3);
      },
      _mozDocumentRule$1: function(start) {
        var t1, t2, t3, t4, buffer, expression, t5, identifier, start0, end, value, children;
        t1 = this.scanner;
        t2 = t1._position;
        t3 = new P.StringBuffer("");
        t4 = [];
        buffer = new Z.InterpolationBuffer(t3, t4);
        for (; true;) {
          if (t1.peekChar$0() === 35) {
            t1.expect$1("#{");
            this.whitespace$0();
            expression = this._expression$0();
            t1.expectChar$1(125);
            buffer._flushText$0();
            t4.push(expression);
          } else {
            t5 = t1._position;
            identifier = this.identifier$0();
            switch (identifier) {
              case "url":
              case "url-prefix":
              case "domain":
                buffer.addInterpolation$1(this._urlContents$2$name(new S._SpanScannerState(t1, t5), identifier));
                break;
              case "regexp":
                t3._contents += "regexp(";
                t1.expectChar$1(40);
                buffer.addInterpolation$1(this.interpolatedString$0().asInterpolation$0());
                t1.expectChar$1(41);
                t3._contents += H.Primitives_stringFromCharCode(41);
                break;
              default:
                t1.error$3$length$position("Invalid function name.", identifier.length, t5);
            }
          }
          this.whitespace$0();
          if (!t1.scanChar$1(44))
            break;
          t3._contents += H.Primitives_stringFromCharCode(44);
          t5 = this.get$whitespace();
          start0 = t1._position;
          t5.call$0();
          end = t1._position;
          t3._contents += J.substring$2$s(t1.string, start0, end);
        }
        value = buffer.interpolation$1(t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
        children = this.children$1(this.get$_statement());
        return U.AtRule$("-moz-document", t1.spanFrom$1(start), children, value);
      },
      _warnRule$1: function(start) {
        var expression = this._expression$0();
        this.expectStatementSeparator$1("@warn rule");
        return new Y.WarnRule(expression, this.scanner.spanFrom$1(start));
      },
      _whileRule$2: function(start, child) {
        var wasInControlDirective, expression, children, t1, t2, t3;
        wasInControlDirective = this._inControlDirective;
        this._inControlDirective = true;
        expression = this._expression$0();
        children = this.children$1(child);
        this._inControlDirective = wasInControlDirective;
        t1 = this.scanner.spanFrom$1(start);
        t2 = P.List_List$unmodifiable(children, null);
        t3 = C.JSArray_methods.any$1(t2, new M.ParentStatement_closure());
        return new G.WhileRule(expression, t1, t2, t3);
      },
      _disallowedAtRule$1: function(start) {
        var t1, t2;
        this.almostAnyValue$0();
        t1 = this.scanner;
        t2 = start.position;
        t1.error$3$length$position("This at-rule is not allowed here.", J.$sub$n(t1._position, t2), t2);
      },
      _argumentDeclaration$0: function() {
        var t1, t2, $arguments, named, restArgument, t3, $name, defaultValue, endPosition, end, t4;
        t1 = this.scanner;
        t2 = t1._position;
        t1.expectChar$1(40);
        this.whitespace$0();
        $arguments = H.setRuntimeTypeInfo([], [Z.Argument]);
        named = B.normalizedSet(null);
        while (true) {
          if (!(t1.peekChar$0() === 36)) {
            restArgument = null;
            break;
          }
          t3 = t1._position;
          t1.expectChar$1(36);
          $name = this.identifier$0();
          this.whitespace$0();
          if (t1.scanChar$1(58)) {
            this.whitespace$0();
            defaultValue = this._expressionUntilComma$0();
          } else {
            if (t1.scanChar$1(46)) {
              t1.expectChar$1(46);
              t1.expectChar$1(46);
              this.whitespace$0();
              restArgument = $name;
              break;
            }
            defaultValue = null;
          }
          endPosition = t1._position;
          end = endPosition;
          $arguments.push(new Z.Argument($name, defaultValue, Y._FileSpan$(t1._sourceFile, t3, end)));
          if (!named.add$1(0, $name)) {
            t3 = C.JSArray_methods.get$last($arguments).span;
            t3 = Y.FileLocation$_(t3.file, t3._file$_start);
            t4 = C.JSArray_methods.get$last($arguments).span;
            t1.error$3$length$position("Duplicate argument.", J.$sub$n(t4._end, t4._file$_start), t3.offset);
          }
          if (!t1.scanChar$1(44)) {
            restArgument = null;
            break;
          }
          this.whitespace$0();
        }
        t1.expectChar$1(41);
        t1 = t1.spanFrom$1(new S._SpanScannerState(t1, t2));
        return new B.ArgumentDeclaration(P.List_List$unmodifiable($arguments, null), restArgument, t1);
      },
      _argumentInvocation$1$mixin: function(mixin) {
        var t1, t2, positional, named, keywordRest, t3, rest, expression, t4, t5;
        t1 = this.scanner;
        t2 = t1._position;
        t1.expectChar$1(40);
        this.whitespace$0();
        positional = H.setRuntimeTypeInfo([], [T.Expression]);
        named = B.normalizedMap(null);
        t3 = !mixin;
        rest = null;
        while (true) {
          if (!this._lookingAtExpression$0()) {
            keywordRest = null;
            break;
          }
          expression = this._expressionUntilComma$1$singleEquals(t3);
          this.whitespace$0();
          if (expression instanceof S.VariableExpression && t1.scanChar$1(58)) {
            this.whitespace$0();
            if (named.containsKey$1(expression.get$name())) {
              t4 = expression.get$span();
              t4 = Y.FileLocation$_(t4.file, t4._file$_start);
              t5 = expression.get$span();
              t1.error$3$length$position("Duplicate argument.", J.$sub$n(t5._end, t5._file$_start), t4.offset);
            }
            named.$indexSet(0, expression.get$name(), this._expressionUntilComma$1$singleEquals(t3));
          } else if (t1.scanChar$1(46)) {
            t1.expectChar$1(46);
            t1.expectChar$1(46);
            if (!(rest == null)) {
              this.whitespace$0();
              keywordRest = expression;
              break;
            }
            rest = expression;
          } else if (named.get$isNotEmpty(named))
            t1.expect$1("...");
          else
            positional.push(expression);
          this.whitespace$0();
          if (!t1.scanChar$1(44)) {
            keywordRest = null;
            break;
          }
          this.whitespace$0();
        }
        t1.expectChar$1(41);
        return X.ArgumentInvocation$(positional, named, t1.spanFrom$1(new S._SpanScannerState(t1, t2)), keywordRest, rest);
      },
      _argumentInvocation$0: function() {
        return this._argumentInvocation$1$mixin(false);
      },
      _expression$3$bracketList$singleEquals$until: function(bracketList, singleEquals, until) {
        var _box_0, t1, t2, beforeBracket, t3, wasInParentheses, resetState, resolveOneOperation, resolveOperations, addSingleExpression, addOperator, resolveSpaceExpressions, first, t4, endPosition, end, next;
        _box_0 = {};
        t1 = until != null;
        if (t1 && until.call$0() === true)
          this.scanner.error$1("Expected expression.");
        if (bracketList) {
          t2 = this.scanner;
          beforeBracket = new S._SpanScannerState(t2, t2._position);
          t2.expectChar$1(91);
          this.whitespace$0();
          if (t2.scanChar$1(93)) {
            t1 = t2.spanFrom$1(beforeBracket);
            t2 = P.List_List$unmodifiable([], null);
            return new D.ListExpression(t2, C.ListSeparator_undecided_null, true, t1);
          }
        } else
          beforeBracket = null;
        t2 = this.scanner;
        t3 = t2._position;
        wasInParentheses = this._inParentheses;
        _box_0.commaExpressions = null;
        _box_0.singleEqualsOperand = null;
        _box_0.spaceExpressions = null;
        _box_0.operators = null;
        _box_0.operands = null;
        _box_0.allowSlash = this.lookingAtNumber$0();
        _box_0.singleExpression = this._singleExpression$0();
        resetState = new V.StylesheetParser__expression_resetState(_box_0, this, new S._SpanScannerState(t2, t3));
        resolveOneOperation = new V.StylesheetParser__expression_resolveOneOperation(_box_0, this);
        resolveOperations = new V.StylesheetParser__expression_resolveOperations(_box_0, resolveOneOperation);
        addSingleExpression = new V.StylesheetParser__expression_addSingleExpression(_box_0, this, resetState, resolveOperations);
        addOperator = new V.StylesheetParser__expression_addOperator(_box_0, this, resolveOneOperation);
        resolveSpaceExpressions = new V.StylesheetParser__expression_resolveSpaceExpressions(_box_0, resolveOperations);
        $label0$0:
          for (; true;) {
            this.whitespace$0();
            if (t1 && until.call$0() === true)
              break $label0$0;
            first = t2.peekChar$0();
            switch (first) {
              case 40:
                addSingleExpression.call$1(this._parentheses$0());
                break;
              case 91:
                addSingleExpression.call$1(this._expression$1$bracketList(true));
                break;
              case 36:
                t3 = t2._position;
                t2.expectChar$1(36);
                t4 = this.identifier$0();
                endPosition = t2._position;
                end = endPosition;
                addSingleExpression.call$1(new S.VariableExpression(t4, Y._FileSpan$(t2._sourceFile, t3, end)));
                break;
              case 38:
                addSingleExpression.call$1(this._selector$0());
                break;
              case 39:
              case 34:
                addSingleExpression.call$1(this.interpolatedString$0());
                break;
              case 35:
                addSingleExpression.call$1(this._hashExpression$0());
                break;
              case 61:
                t2.readChar$0();
                if (singleEquals && t2.peekChar$0() !== 61) {
                  resolveSpaceExpressions.call$0();
                  _box_0.singleEqualsOperand = _box_0.singleExpression;
                  _box_0.singleExpression = null;
                } else {
                  t2.expectChar$1(61);
                  addOperator.call$1(C.BinaryOperator_YlX);
                }
                break;
              case 33:
                next = t2.peekChar$1(1);
                if (next === 61) {
                  t2.readChar$0();
                  t2.readChar$0();
                  addOperator.call$1(C.BinaryOperator_i5H);
                } else {
                  if (next != null)
                    if ((next | 32) !== 105)
                      t3 = next === 32 || next === 9 || next === 10 || next === 13 || next === 12;
                    else
                      t3 = true;
                  else
                    t3 = true;
                  if (t3)
                    addSingleExpression.call$1(this._importantExpression$0());
                  else
                    break $label0$0;
                }
                break;
              case 60:
                t2.readChar$0();
                addOperator.call$1(t2.scanChar$1(61) ? C.BinaryOperator_33h : C.BinaryOperator_8qt);
                break;
              case 62:
                t2.readChar$0();
                addOperator.call$1(t2.scanChar$1(61) ? C.BinaryOperator_1da : C.BinaryOperator_AcR0);
                break;
              case 42:
                t2.readChar$0();
                addOperator.call$1(C.BinaryOperator_O1M);
                break;
              case 43:
                if (_box_0.singleExpression == null)
                  addSingleExpression.call$1(this._unaryOperation$0());
                else {
                  t2.readChar$0();
                  addOperator.call$1(C.BinaryOperator_AcR);
                }
                break;
              case 45:
                next = t2.peekChar$1(1);
                if (next != null && next >= 48 && next <= 57 || next === 46)
                  if (_box_0.singleExpression != null) {
                    t3 = t2.peekChar$1(-1);
                    t3 = t3 === 32 || t3 === 9 || t3 === 10 || t3 === 13 || t3 === 12;
                  } else
                    t3 = true;
                else
                  t3 = false;
                if (t3)
                  addSingleExpression.call$2$number(this._number$0(), true);
                else if (this._lookingAtInterpolatedIdentifier$0())
                  addSingleExpression.call$1(this._identifierLike$0());
                else if (_box_0.singleExpression == null)
                  addSingleExpression.call$1(this._unaryOperation$0());
                else {
                  t2.readChar$0();
                  addOperator.call$1(C.BinaryOperator_iyO);
                }
                break;
              case 47:
                if (_box_0.singleExpression == null)
                  addSingleExpression.call$1(this._unaryOperation$0());
                else {
                  t2.readChar$0();
                  addOperator.call$1(C.BinaryOperator_RTB);
                }
                break;
              case 37:
                t2.readChar$0();
                addOperator.call$1(C.BinaryOperator_2ad);
                break;
              case 48:
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                addSingleExpression.call$2$number(this._number$0(), true);
                break;
              case 46:
                if (t2.peekChar$1(1) === 46)
                  break $label0$0;
                addSingleExpression.call$2$number(this._number$0(), true);
                break;
              case 97:
                if (this.scanIdentifier$1("and"))
                  addOperator.call$1(C.BinaryOperator_and_and_2);
                else
                  addSingleExpression.call$1(this._identifierLike$0());
                break;
              case 111:
                if (this.scanIdentifier$1("or"))
                  addOperator.call$1(C.BinaryOperator_or_or_1);
                else
                  addSingleExpression.call$1(this._identifierLike$0());
                break;
              case 117:
              case 85:
                if (t2.peekChar$1(1) === 43)
                  addSingleExpression.call$1(this._unicodeRange$0());
                else
                  addSingleExpression.call$1(this._identifierLike$0());
                break;
              case 98:
              case 99:
              case 100:
              case 101:
              case 102:
              case 103:
              case 104:
              case 105:
              case 106:
              case 107:
              case 108:
              case 109:
              case 110:
              case 112:
              case 113:
              case 114:
              case 115:
              case 116:
              case 118:
              case 119:
              case 120:
              case 121:
              case 122:
              case 65:
              case 66:
              case 67:
              case 68:
              case 69:
              case 70:
              case 71:
              case 72:
              case 73:
              case 74:
              case 75:
              case 76:
              case 77:
              case 78:
              case 79:
              case 80:
              case 81:
              case 82:
              case 83:
              case 84:
              case 86:
              case 87:
              case 88:
              case 89:
              case 90:
              case 95:
              case 92:
                addSingleExpression.call$1(this._identifierLike$0());
                break;
              case 44:
                if (this._inParentheses) {
                  this._inParentheses = false;
                  if (_box_0.allowSlash) {
                    resetState.call$0();
                    break;
                  }
                }
                if (_box_0.commaExpressions == null)
                  _box_0.commaExpressions = [];
                if (_box_0.singleExpression == null)
                  t2.error$1("Expected expression.");
                resolveSpaceExpressions.call$0();
                _box_0.commaExpressions.push(_box_0.singleExpression);
                t2.readChar$0();
                _box_0.allowSlash = true;
                _box_0.singleExpression = null;
                break;
              default:
                if (first != null && first >= 128) {
                  addSingleExpression.call$1(this._identifierLike$0());
                  break;
                } else
                  break $label0$0;
            }
          }
        if (bracketList)
          t2.expectChar$1(93);
        if (_box_0.commaExpressions != null) {
          resolveSpaceExpressions.call$0();
          this._inParentheses = wasInParentheses;
          t1 = _box_0.singleExpression;
          if (t1 != null)
            _box_0.commaExpressions.push(t1);
          t1 = _box_0.commaExpressions;
          t2 = bracketList ? t2.spanFrom$1(beforeBracket) : null;
          t1 = P.List_List$unmodifiable(t1, null);
          return new D.ListExpression(t1, C.ListSeparator_kWM, bracketList, t2 == null ? B.spanForList(t1) : t2);
        } else if (bracketList && _box_0.spaceExpressions != null && _box_0.singleEqualsOperand == null) {
          resolveOperations.call$0();
          t1 = _box_0.spaceExpressions;
          t1.push(_box_0.singleExpression);
          t2 = t2.spanFrom$1(beforeBracket);
          t1 = P.List_List$unmodifiable(t1, null);
          return new D.ListExpression(t1, C.ListSeparator_woc, true, t2);
        } else {
          resolveSpaceExpressions.call$0();
          if (bracketList) {
            t1 = _box_0.singleExpression;
            t2 = t2.spanFrom$1(beforeBracket);
            t1 = P.List_List$unmodifiable([t1], null);
            _box_0.singleExpression = new D.ListExpression(t1, C.ListSeparator_undecided_null, true, t2);
          }
          return _box_0.singleExpression;
        }
      },
      _expression$0: function() {
        return this._expression$3$bracketList$singleEquals$until(false, false, null);
      },
      _expression$1$bracketList: function(bracketList) {
        return this._expression$3$bracketList$singleEquals$until(bracketList, false, null);
      },
      _expression$2$singleEquals$until: function(singleEquals, until) {
        return this._expression$3$bracketList$singleEquals$until(false, singleEquals, until);
      },
      _expression$1$until: function(until) {
        return this._expression$3$bracketList$singleEquals$until(false, false, until);
      },
      _expressionUntilComma$1$singleEquals: function(singleEquals) {
        return this._expression$2$singleEquals$until(singleEquals, new V.StylesheetParser__expressionUntilComma_closure(this));
      },
      _expressionUntilComma$0: function() {
        return this._expressionUntilComma$1$singleEquals(false);
      },
      _singleExpression$0: function() {
        var t1, first, next;
        t1 = this.scanner;
        first = t1.peekChar$0();
        switch (first) {
          case 40:
            return this._parentheses$0();
          case 47:
            return this._unaryOperation$0();
          case 46:
            return this._number$0();
          case 91:
            return this._expression$1$bracketList(true);
          case 36:
            return this._variable$0();
          case 38:
            return this._selector$0();
          case 39:
          case 34:
            return this.interpolatedString$0();
          case 35:
            return this._hashExpression$0();
          case 43:
            next = t1.peekChar$1(1);
            return T.isDigit(next) || next === 46 ? this._number$0() : this._unaryOperation$0();
          case 45:
            return this._minusExpression$0();
          case 33:
            return this._importantExpression$0();
          case 117:
          case 85:
            if (t1.peekChar$1(1) === 43)
              return this._unicodeRange$0();
            else
              return this._identifierLike$0();
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this._number$0();
          case 97:
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
          case 65:
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
          case 95:
          case 92:
            return this._identifierLike$0();
          default:
            if (first != null && first >= 128)
              return this._identifierLike$0();
            t1.error$1("Expected expression.");
        }
      },
      _parentheses$0: function() {
        var wasInParentheses, start, first, expressions, t1, t2;
        wasInParentheses = this._inParentheses;
        this._inParentheses = true;
        try {
          t1 = this.scanner;
          start = new S._SpanScannerState(t1, t1._position);
          t1.expectChar$1(40);
          this.whitespace$0();
          if (!this._lookingAtExpression$0()) {
            t1.expectChar$1(41);
            t1 = t1.spanFrom$1(start);
            t2 = P.List_List$unmodifiable([], null);
            return new D.ListExpression(t2, C.ListSeparator_undecided_null, false, t1);
          }
          first = this._expressionUntilComma$0();
          if (t1.scanChar$1(58)) {
            this.whitespace$0();
            t1 = this._stylesheet$_map$2(first, start);
            return t1;
          }
          if (!t1.scanChar$1(44)) {
            t1.expectChar$1(41);
            return first;
          }
          this.whitespace$0();
          expressions = [first];
          for (; true;) {
            if (!this._lookingAtExpression$0())
              break;
            J.add$1$ax(expressions, this._expressionUntilComma$0());
            if (!t1.scanChar$1(44))
              break;
            this.whitespace$0();
          }
          t1.expectChar$1(41);
          t1 = t1.spanFrom$1(start);
          t2 = P.List_List$unmodifiable(expressions, null);
          return new D.ListExpression(t2, C.ListSeparator_kWM, false, t1);
        } finally {
          this._inParentheses = wasInParentheses;
        }
      },
      _stylesheet$_map$2: function(first, start) {
        var t1, pairs, t2, key;
        t1 = [null, null];
        pairs = [new S.Tuple2(first, this._expressionUntilComma$0(), t1)];
        for (t2 = this.scanner; t2.scanChar$1(44);) {
          this.whitespace$0();
          if (!this._lookingAtExpression$0())
            break;
          key = this._expressionUntilComma$0();
          t2.expectChar$1(58);
          this.whitespace$0();
          pairs.push(new S.Tuple2(key, this._expressionUntilComma$0(), t1));
        }
        t2.expectChar$1(41);
        t1 = t2.spanFrom$1(start);
        return new A.MapExpression(P.List_List$unmodifiable(pairs, null), t1);
      },
      _hashExpression$0: function() {
        var t1, start, first, t2, identifier, buffer;
        t1 = this.scanner;
        if (t1.peekChar$1(1) === 123)
          return this._identifierLike$0();
        start = new S._SpanScannerState(t1, t1._position);
        t1.expectChar$1(35);
        first = t1.peekChar$0();
        if (first != null && T.isDigit(first))
          return new K.ColorExpression(this._hexColorContents$1(start));
        t2 = t1._position;
        identifier = this._interpolatedIdentifier$0();
        if (this._isHexColor$1(identifier)) {
          t1.set$state(new S._SpanScannerState(t1, t2));
          return new K.ColorExpression(this._hexColorContents$1(start));
        }
        t2 = new P.StringBuffer("");
        buffer = new Z.InterpolationBuffer(t2, []);
        t2._contents += H.Primitives_stringFromCharCode(35);
        buffer.addInterpolation$1(identifier);
        return new D.StringExpression(buffer.interpolation$1(t1.spanFrom$1(start)), false);
      },
      _hexColorContents$1: function(start) {
        var red, green, blue, t1, next, t2, t3, t4;
        red = this._hexDigit$0();
        green = this._hexDigit$0();
        blue = this._hexDigit$0();
        t1 = this.scanner;
        next = t1.peekChar$0();
        t2 = next != null && T.isHex(next);
        t3 = blue << 4 >>> 0;
        t4 = red << 4 >>> 0;
        if (t2) {
          red = t4 + green;
          green = t3 + this._hexDigit$0();
          blue = (this._hexDigit$0() << 4 >>> 0) + this._hexDigit$0();
        } else {
          red = t4 + red;
          green = (green << 4 >>> 0) + green;
          blue = t3 + blue;
        }
        return K.SassColor$rgb(red, green, blue, 1, t1.spanFrom$1(start));
      },
      _isHexColor$1: function(interpolation) {
        var plain, t1;
        plain = interpolation.get$asPlain();
        if (plain == null)
          return false;
        t1 = plain.length;
        if (t1 !== 3 && t1 !== 6)
          return false;
        t1 = new H.CodeUnits(plain);
        return t1.every$1(t1, T.character__isHex$closure());
      },
      _hexDigit$0: function() {
        var t1, char;
        t1 = this.scanner;
        char = t1.peekChar$0();
        if (char == null || !T.isHex(char))
          t1.error$1("Expected hex digit.");
        return T.asHex(t1.readChar$0());
      },
      _minusExpression$0: function() {
        var next = this.scanner.peekChar$1(1);
        if (T.isDigit(next) || next === 46)
          return this._number$0();
        if (this._lookingAtInterpolatedIdentifier$0())
          return this._identifierLike$0();
        return this._unaryOperation$0();
      },
      _importantExpression$0: function() {
        var t1, t2;
        t1 = this.scanner;
        t2 = t1._position;
        t1.readChar$0();
        this.whitespace$0();
        this.expectIdentifier$2$ignoreCase("important", true);
        return new D.StringExpression(X.Interpolation$(["!important"], t1.spanFrom$1(new S._SpanScannerState(t1, t2))), false);
      },
      _unaryOperation$0: function() {
        var t1, t2, operator;
        t1 = this.scanner;
        t2 = t1._position;
        operator = this._unaryOperatorFor$1(t1.readChar$0());
        if (operator == null)
          t1.error$2$position("Expected unary operator", J.$sub$n(t1._position, 1));
        this.whitespace$0();
        return new X.UnaryOperationExpression(operator, this._singleExpression$0(), t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
      },
      _unaryOperatorFor$1: function(character) {
        switch (character) {
          case 43:
            return C.UnaryOperator_j2w;
          case 45:
            return C.UnaryOperator_U4G;
          case 47:
            return C.UnaryOperator_zDx;
          default:
            return;
        }
      },
      _number$0: function() {
        var t1, start, first, t2, sign, second, number, t3, unit, t4;
        t1 = this.scanner;
        start = new S._SpanScannerState(t1, t1._position);
        first = t1.peekChar$0();
        t2 = first === 45;
        sign = t2 ? -1 : 1;
        if (first === 43 || t2)
          t1.readChar$0();
        second = t1.peekChar$0();
        if (!T.isDigit(second) && second !== 46)
          t1.error$1("Expected number.");
        number = 0;
        while (true) {
          t2 = t1.peekChar$0();
          if (!(t2 != null && t2 >= 48 && t2 <= 57))
            break;
          number = number * 10 + (t1.readChar$0() - 48);
        }
        t2 = this._tryDecimal$1$allowTrailingDot(!J.$eq$(t1._position, start.position));
        t3 = this._tryExponent$0();
        if (t1.scanChar$1(37))
          unit = "%";
        else {
          if (this.lookingAtIdentifier$0())
            t4 = t1.peekChar$0() !== 45 || t1.peekChar$1(1) !== 45;
          else
            t4 = false;
          unit = t4 ? this.identifier$1$unit(true) : null;
        }
        return new T.NumberExpression(sign * ((number + t2) * t3), unit, t1.spanFrom$1(start));
      },
      _tryDecimal$1$allowTrailingDot: function(allowTrailingDot) {
        var t1, number, decimal, t2;
        t1 = this.scanner;
        if (t1.peekChar$0() !== 46)
          return 0;
        if (!T.isDigit(t1.peekChar$1(1))) {
          if (allowTrailingDot)
            return 0;
          t1.error$2$position("Expected digit.", J.$add$ansx(t1._position, 1));
        }
        t1.readChar$0();
        number = 0;
        decimal = 0.1;
        while (true) {
          t2 = t1.peekChar$0();
          if (!(t2 != null && t2 >= 48 && t2 <= 57))
            break;
          number += (t1.readChar$0() - 48) * decimal;
          decimal /= 10;
        }
        return number;
      },
      _tryExponent$0: function() {
        var t1, first, next, t2, exponentSign, exponent;
        t1 = this.scanner;
        first = t1.peekChar$0();
        if (first !== 101 && first !== 69)
          return 1;
        next = t1.peekChar$1(1);
        if (!T.isDigit(next) && next !== 45 && next !== 43)
          return 1;
        t1.readChar$0();
        t2 = next === 45;
        exponentSign = t2 ? -1 : 1;
        if (next === 43 || t2)
          t1.readChar$0();
        if (!T.isDigit(t1.peekChar$0()))
          t1.error$1("Expected digit.");
        exponent = 0;
        while (true) {
          t2 = t1.peekChar$0();
          if (!(t2 != null && t2 >= 48 && t2 <= 57))
            break;
          exponent = exponent * 10 + (t1.readChar$0() - 48);
        }
        return Math.pow(10, exponentSign * exponent);
      },
      _unicodeRange$0: function() {
        var t1, start, i, j;
        t1 = this.scanner;
        start = new S._SpanScannerState(t1, t1._position);
        this.expectCharIgnoreCase$1(117);
        t1.expectChar$1(43);
        for (i = 0; i < 6; ++i)
          if (!this.scanCharIf$1(new V.StylesheetParser__unicodeRange_closure()))
            break;
        if (t1.scanChar$1(63)) {
          ++i;
          for (; i < 6; ++i)
            if (!t1.scanChar$1(63))
              break;
          return new D.StringExpression(X.Interpolation$([t1.substring$1(0, start.position)], t1.spanFrom$1(start)), false);
        }
        if (i === 0)
          t1.error$1('Expected hex digit or "?".');
        if (t1.scanChar$1(45)) {
          for (j = 0; j < 6; ++j)
            if (!this.scanCharIf$1(new V.StylesheetParser__unicodeRange_closure0()))
              break;
          if (j === 0)
            t1.error$1("Expected hex digit.");
        }
        if (this._lookingAtInterpolatedIdentifierBody$0())
          t1.error$1("Expected end of identifier.");
        return new D.StringExpression(X.Interpolation$([t1.substring$1(0, start.position)], t1.spanFrom$1(start)), false);
      },
      _variable$0: function() {
        var t1, t2;
        t1 = this.scanner;
        t2 = t1._position;
        t1.expectChar$1(36);
        return new S.VariableExpression(this.identifier$0(), t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
      },
      _selector$0: function() {
        var t1, start;
        t1 = this.scanner;
        start = new S._SpanScannerState(t1, t1._position);
        t1.expectChar$1(38);
        if (t1.scanChar$1(38)) {
          this.logger.warn$2$span('In Sass, "&&" means two copies of the parent selector. You probably want to use "and" instead.', t1.spanFrom$1(start));
          t1.set$position(J.$sub$n(t1._position, 1));
        }
        return new T.SelectorExpression(t1.spanFrom$1(start));
      },
      interpolatedString$0: function() {
        var t1, t2, quote, t3, t4, buffer, next, second, expression;
        t1 = this.scanner;
        t2 = t1._position;
        quote = t1.readChar$0();
        if (quote !== 39 && quote !== 34)
          t1.error$2$position("Expected string.", t2);
        t3 = new P.StringBuffer("");
        t4 = [];
        buffer = new Z.InterpolationBuffer(t3, t4);
        for (; true;) {
          next = t1.peekChar$0();
          if (next === quote) {
            t1.readChar$0();
            break;
          } else if (next == null || next === 10 || next === 13 || next === 12)
            t1.error$1("Expected " + H.Primitives_stringFromCharCode(quote) + ".");
          else if (next === 92) {
            second = t1.peekChar$1(1);
            if (second === 10 || second === 13 || second === 12) {
              t1.readChar$0();
              t1.readChar$0();
              if (second === 13)
                t1.scanChar$1(10);
            } else
              t3._contents += H.Primitives_stringFromCharCode(this.escapeCharacter$0());
          } else if (next === 35)
            if (t1.peekChar$1(1) === 123) {
              t1.expect$1("#{");
              this.whitespace$0();
              expression = this._expression$0();
              t1.expectChar$1(125);
              buffer._flushText$0();
              t4.push(expression);
            } else
              t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
          else
            t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
        }
        return new D.StringExpression(buffer.interpolation$1(t1.spanFrom$1(new S._SpanScannerState(t1, t2))), true);
      },
      _identifierLike$0: function() {
        var t1, t2, identifier, plain, invocation, lower, color, specialFunction;
        t1 = this.scanner;
        t2 = t1._position;
        identifier = this._interpolatedIdentifier$0();
        plain = identifier.get$asPlain();
        if (plain != null) {
          if (plain === "if") {
            invocation = this._argumentInvocation$0();
            return new L.IfExpression(invocation, B.spanForList([identifier, invocation]));
          } else if (plain === "not") {
            this.whitespace$0();
            return new X.UnaryOperationExpression(C.UnaryOperator_not_not, this._singleExpression$0(), identifier.span);
          }
          lower = plain.toLowerCase();
          if (t1.peekChar$0() !== 40) {
            switch (plain) {
              case "false":
                return new Z.BooleanExpression(false, identifier.span);
              case "null":
                return new O.NullExpression(identifier.span);
              case "true":
                return new Z.BooleanExpression(true, identifier.span);
            }
            color = $.$get$colorsByName().$index(0, lower);
            if (color != null)
              return new K.ColorExpression(K.SassColor$rgb(color.get$red(), color.get$green(), color.get$blue(), color.get$alpha(), identifier.span));
          }
          specialFunction = this._trySpecialFunction$2(lower, new S._SpanScannerState(t1, t2));
          if (specialFunction != null)
            return specialFunction;
        }
        return t1.peekChar$0() === 40 ? new F.FunctionExpression(identifier, this._argumentInvocation$0()) : new D.StringExpression(identifier, false);
      },
      _trySpecialFunction$2: function($name, start) {
        var t1, buffer, t2, next, t3, contents;
        switch (B.unvendor($name)) {
          case "calc":
          case "element":
          case "expression":
            if (!this.scanner.scanChar$1(40))
              return;
            t1 = new P.StringBuffer("");
            buffer = new Z.InterpolationBuffer(t1, []);
            t1._contents = $name;
            t1._contents += H.Primitives_stringFromCharCode(40);
            break;
          case "progid":
            t1 = this.scanner;
            if (!t1.scanChar$1(58))
              return;
            t2 = new P.StringBuffer("");
            buffer = new Z.InterpolationBuffer(t2, []);
            t2._contents = $name;
            t2._contents += H.Primitives_stringFromCharCode(58);
            next = t1.peekChar$0();
            while (true) {
              if (next != null) {
                if (!(next >= 97 && next <= 122))
                  t3 = next >= 65 && next <= 90;
                else
                  t3 = true;
                t3 = t3 || next === 46;
              } else
                t3 = false;
              if (!t3)
                break;
              t2._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              next = t1.peekChar$0();
            }
            t1.expectChar$1(40);
            t2._contents += H.Primitives_stringFromCharCode(40);
            break;
          case "url":
            contents = this._tryUrlContents$1(start);
            if (contents != null)
              return new D.StringExpression(contents, false);
            t1 = this.scanner;
            if (t1.peekChar$0() !== 40)
              return;
            return new F.FunctionExpression(X.Interpolation$(["url"], t1.spanFrom$1(start)), this._argumentInvocation$0());
          default:
            return;
        }
        buffer.addInterpolation$1(this._interpolatedDeclarationValue$1$allowEmpty(true).text);
        t1 = this.scanner;
        t1.expectChar$1(41);
        buffer._interpolation_buffer$_text._contents += H.Primitives_stringFromCharCode(41);
        return new D.StringExpression(buffer.interpolation$1(t1.spanFrom$1(start)), false);
      },
      _urlContents$2$name: function(start, $name) {
        var t1, t2, t3, buffer, next, t4, expression;
        t1 = this.scanner;
        t1.expectChar$1(40);
        this.whitespaceWithoutComments$0();
        t2 = new P.StringBuffer("");
        t3 = [];
        buffer = new Z.InterpolationBuffer(t2, t3);
        t2._contents = $name + "(";
        for (; true;) {
          next = t1.peekChar$0();
          if (next == null)
            break;
          else {
            if (next !== 37)
              if (next !== 38)
                t4 = next >= 42 && next <= 126 || next >= 128;
              else
                t4 = true;
            else
              t4 = true;
            if (t4)
              t2._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
            else if (next === 92)
              t2._contents += H.S(this.escape$0());
            else if (next === 35)
              if (t1.peekChar$1(1) === 123) {
                t1.expect$1("#{");
                this.whitespace$0();
                expression = this._expression$0();
                t1.expectChar$1(125);
                buffer._flushText$0();
                t3.push(expression);
              } else
                t2._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
            else if (next === 32 || next === 9 || next === 10 || next === 13 || next === 12) {
              this.whitespaceWithoutComments$0();
              t1.expectChar$1(41);
              t2._contents += H.Primitives_stringFromCharCode(41);
              break;
            } else if (next === 41) {
              t2._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              break;
            } else
              t1.expectChar$1(41);
          }
        }
        return buffer.interpolation$1(t1.spanFrom$1(start));
      },
      _tryUrlContents$1: function(start) {
        var t1, t2, t3, t4, buffer, next, t5, expression, endPosition, end, contents;
        t1 = this.scanner;
        t2 = t1._position;
        if (!t1.scanChar$1(40))
          return;
        this.whitespaceWithoutComments$0();
        t3 = new P.StringBuffer("");
        t4 = [];
        buffer = new Z.InterpolationBuffer(t3, t4);
        t3._contents = "url(";
        for (; true;) {
          next = t1.peekChar$0();
          if (next == null)
            break;
          else {
            if (next !== 37)
              if (next !== 38)
                t5 = next >= 42 && next <= 126 || next >= 128;
              else
                t5 = true;
            else
              t5 = true;
            if (t5)
              t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
            else if (next === 92)
              t3._contents += H.S(this.escape$0());
            else if (next === 35)
              if (t1.peekChar$1(1) === 123) {
                t1.expect$1("#{");
                this.whitespace$0();
                expression = this._expression$0();
                t1.expectChar$1(125);
                buffer._flushText$0();
                t4.push(expression);
              } else
                t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
            else if (next === 32 || next === 9 || next === 10 || next === 13 || next === 12) {
              this.whitespaceWithoutComments$0();
              if (t1.peekChar$0() !== 41)
                break;
            } else if (next === 41) {
              t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
              endPosition = t1._position;
              end = endPosition;
              t2 = Y._FileSpan$(t1._sourceFile, start.position, end);
              contents = H.setRuntimeTypeInfo(t4.slice(0), [H.getTypeArgumentByIndex(t4, 0)]);
              t1 = t3._contents;
              if (t1.length !== 0)
                contents.push(t1.charCodeAt(0) == 0 ? t1 : t1);
              return X.Interpolation$(contents, t2);
            } else
              break;
          }
        }
        t1.set$state(new S._SpanScannerState(t1, t2));
        return;
      },
      _dynamicUrl$0: function() {
        var t1, start, contents;
        t1 = this.scanner;
        start = new S._SpanScannerState(t1, t1._position);
        this.expectIdentifier$2$ignoreCase("url", true);
        contents = this._tryUrlContents$1(start);
        if (contents != null)
          return new D.StringExpression(contents, false);
        return new F.FunctionExpression(X.Interpolation$(["url"], t1.spanFrom$1(start)), this._argumentInvocation$0());
      },
      almostAnyValue$0: function() {
        var t1, t2, t3, buffer, t4, t5, next, commentStart, end, t6, contents, t7;
        t1 = this.scanner;
        t2 = t1._position;
        t3 = new P.StringBuffer("");
        buffer = new Z.InterpolationBuffer(t3, []);
        $label0$1:
          for (t4 = t1.string, t5 = J.getInterceptor$asx(t4); true;) {
            next = t1.peekChar$0();
            switch (next) {
              case 92:
                t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                break;
              case 34:
              case 39:
                buffer.addInterpolation$1(this.interpolatedString$0().asInterpolation$0());
                break;
              case 47:
                commentStart = t1._position;
                if (this.scanComment$0()) {
                  end = t1._position;
                  t3._contents += t5.substring$2(t4, commentStart, end);
                } else
                  t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                break;
              case 35:
                if (t1.peekChar$1(1) === 123)
                  buffer.addInterpolation$1(this._interpolatedIdentifier$0());
                else
                  t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                break;
              case 13:
              case 10:
              case 12:
                if (this.get$indented())
                  break $label0$1;
                t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                break;
              case 33:
              case 59:
              case 123:
              case 125:
                break $label0$1;
              case 117:
              case 85:
                t6 = t1._position;
                if (!this.scanIdentifier$2$ignoreCase("url", true)) {
                  t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                  break;
                }
                contents = this._tryUrlContents$1(new S._SpanScannerState(t1, t6));
                if (contents == null) {
                  t7 = J.getInterceptor$n(t6);
                  if (t7.$lt(t6, 0) || t7.$gt(t6, t5.get$length(t4)))
                    H.throwExpression(P.ArgumentError$("Invalid position " + H.S(t6)));
                  t1._position = t6;
                  t1._lastMatch = null;
                  t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                } else
                  buffer.addInterpolation$1(contents);
                break;
              default:
                if (next == null)
                  break $label0$1;
                if (this.lookingAtIdentifier$0())
                  t3._contents += this.identifier$0();
                else
                  t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                break;
            }
          }
        return buffer.interpolation$1(t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
      },
      _interpolatedDeclarationValue$1$allowEmpty: function(allowEmpty) {
        var t1, t2, t3, buffer, brackets, t4, t5, t6, wroteNewline, next, start, end, t7, contents, t8;
        t1 = this.scanner;
        t2 = t1._position;
        t3 = new P.StringBuffer("");
        buffer = new Z.InterpolationBuffer(t3, []);
        brackets = H.setRuntimeTypeInfo([], [P.int]);
        $label0$1:
          for (t4 = t1.string, t5 = J.getInterceptor$asx(t4), t6 = this.get$loudComment(), wroteNewline = false; true;) {
            next = t1.peekChar$0();
            switch (next) {
              case 92:
                t3._contents += H.S(this.escape$0());
                wroteNewline = false;
                break;
              case 34:
              case 39:
                buffer.addInterpolation$1(this.interpolatedString$0().asInterpolation$0());
                wroteNewline = false;
                break;
              case 47:
                if (t1.peekChar$1(1) === 42) {
                  start = t1._position;
                  t6.call$0();
                  end = t1._position;
                  t3._contents += t5.substring$2(t4, start, end);
                } else
                  t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                wroteNewline = false;
                break;
              case 35:
                if (t1.peekChar$1(1) === 123)
                  buffer.addInterpolation$1(this._interpolatedIdentifier$0());
                else
                  t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                wroteNewline = false;
                break;
              case 32:
              case 9:
                if (!wroteNewline) {
                  t7 = t1.peekChar$1(1);
                  t7 = !(t7 === 32 || t7 === 9 || t7 === 10 || t7 === 13 || t7 === 12);
                } else
                  t7 = true;
                if (t7)
                  t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                else
                  t1.readChar$0();
                break;
              case 10:
              case 13:
              case 12:
                if (this.get$indented())
                  break $label0$1;
                t7 = t1.peekChar$1(-1);
                if (!(t7 === 10 || t7 === 13 || t7 === 12))
                  t3._contents += "\n";
                t1.readChar$0();
                wroteNewline = true;
                break;
              case 40:
              case 123:
              case 91:
                t3._contents += H.Primitives_stringFromCharCode(next);
                brackets.push(T.opposite(t1.readChar$0()));
                wroteNewline = false;
                break;
              case 41:
              case 125:
              case 93:
                if (brackets.length === 0)
                  break $label0$1;
                t3._contents += H.Primitives_stringFromCharCode(next);
                if (0 >= brackets.length)
                  return H.ioore(brackets, -1);
                t1.expectChar$1(brackets.pop());
                wroteNewline = false;
                break;
              case 59:
                if (brackets.length === 0)
                  break $label0$1;
                t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                break;
              case 117:
              case 85:
                t7 = t1._position;
                if (!this.scanIdentifier$2$ignoreCase("url", true)) {
                  t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                  wroteNewline = false;
                  break;
                }
                contents = this._tryUrlContents$1(new S._SpanScannerState(t1, t7));
                if (contents == null) {
                  t8 = J.getInterceptor$n(t7);
                  if (t8.$lt(t7, 0) || t8.$gt(t7, t5.get$length(t4)))
                    H.throwExpression(P.ArgumentError$("Invalid position " + H.S(t7)));
                  t1._position = t7;
                  t1._lastMatch = null;
                  t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                } else
                  buffer.addInterpolation$1(contents);
                wroteNewline = false;
                break;
              default:
                if (next == null)
                  break $label0$1;
                if (this.lookingAtIdentifier$0())
                  t3._contents += this.identifier$0();
                else
                  t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
                wroteNewline = false;
                break;
            }
          }
        if (brackets.length !== 0)
          t1.expectChar$1(C.JSArray_methods.get$last(brackets));
        if (!allowEmpty && buffer._interpolation_buffer$_contents.length === 0 && t3._contents.length === 0)
          t1.error$1("Expected token.");
        return new D.StringExpression(buffer.interpolation$1(t1.spanFrom$1(new S._SpanScannerState(t1, t2))), false);
      },
      _interpolatedDeclarationValue$0: function() {
        return this._interpolatedDeclarationValue$1$allowEmpty(false);
      },
      _interpolatedIdentifier$0: function() {
        var t1, t2, t3, buffer, first, t4, next, t5, expression;
        t1 = this.scanner;
        t2 = t1._position;
        t3 = new P.StringBuffer("");
        buffer = new Z.InterpolationBuffer(t3, []);
        for (; t1.scanChar$1(45);)
          t3._contents += H.Primitives_stringFromCharCode(45);
        first = t1.peekChar$0();
        if (first == null)
          t1.error$1("Expected identifier.");
        else if (first === 95 || T.isAlphabetic0(first) || first >= 128)
          t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
        else if (first === 92)
          t3._contents += H.S(this.escape$0());
        else if (first === 35 && t1.peekChar$1(1) === 123) {
          t4 = this.singleInterpolation$0();
          buffer._flushText$0();
          buffer._interpolation_buffer$_contents.push(t4);
        }
        for (t4 = buffer._interpolation_buffer$_contents; true;) {
          next = t1.peekChar$0();
          if (next == null)
            break;
          else {
            if (next !== 95)
              if (next !== 45) {
                if (!(next >= 97 && next <= 122))
                  t5 = next >= 65 && next <= 90;
                else
                  t5 = true;
                if (!t5)
                  t5 = next >= 48 && next <= 57;
                else
                  t5 = true;
                t5 = t5 || next >= 128;
              } else
                t5 = true;
            else
              t5 = true;
            if (t5)
              t3._contents += H.Primitives_stringFromCharCode(t1.readChar$0());
            else if (next === 92)
              t3._contents += H.S(this.escape$0());
            else if (next === 35 && t1.peekChar$1(1) === 123) {
              t1.expect$1("#{");
              this.whitespace$0();
              expression = this._expression$0();
              t1.expectChar$1(125);
              buffer._flushText$0();
              t4.push(expression);
            } else
              break;
          }
        }
        return buffer.interpolation$1(t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
      },
      singleInterpolation$0: function() {
        var t1, expression;
        t1 = this.scanner;
        t1.expect$1("#{");
        this.whitespace$0();
        expression = this._expression$0();
        t1.expectChar$1(125);
        return expression;
      },
      _queryExpression$0: function() {
        var t1, interpolation, t2, t3, t4, buffer, t5;
        t1 = this.scanner;
        if (t1.peekChar$0() === 35) {
          interpolation = this.singleInterpolation$0();
          return X.Interpolation$([interpolation], interpolation.get$span());
        }
        t2 = t1._position;
        t3 = new P.StringBuffer("");
        t4 = [];
        buffer = new Z.InterpolationBuffer(t3, t4);
        t1.expectChar$1(40);
        t3._contents += H.Primitives_stringFromCharCode(40);
        this.whitespace$0();
        t5 = this._expression$0();
        buffer._flushText$0();
        t4.push(t5);
        if (t1.scanChar$1(58)) {
          this.whitespace$0();
          t3._contents += H.Primitives_stringFromCharCode(58);
          t3._contents += H.Primitives_stringFromCharCode(32);
          t5 = this._expression$0();
          buffer._flushText$0();
          t4.push(t5);
        }
        t1.expectChar$1(41);
        this.whitespace$0();
        t3._contents += H.Primitives_stringFromCharCode(41);
        return buffer.interpolation$1(t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
      },
      _mediaQueryList$0: function() {
        var t1, t2, t3, buffer;
        t1 = this.scanner;
        t2 = t1._position;
        t3 = new P.StringBuffer("");
        buffer = new Z.InterpolationBuffer(t3, []);
        for (; true;) {
          this.whitespace$0();
          this._stylesheet$_mediaQuery$1(buffer);
          if (!t1.scanChar$1(44))
            break;
          t3._contents += H.Primitives_stringFromCharCode(44);
          t3._contents += H.Primitives_stringFromCharCode(32);
        }
        return buffer.interpolation$1(t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
      },
      _stylesheet$_mediaQuery$1: function(buffer) {
        var t1, identifier;
        if (this.scanner.peekChar$0() !== 40) {
          buffer.addInterpolation$1(this._interpolatedIdentifier$0());
          this.whitespace$0();
          if (!this._lookingAtInterpolatedIdentifier$0())
            return;
          t1 = buffer._interpolation_buffer$_text;
          t1._contents += H.Primitives_stringFromCharCode(32);
          identifier = this._interpolatedIdentifier$0();
          this.whitespace$0();
          if (B.equalsIgnoreCase(identifier.get$asPlain(), "and"))
            t1._contents += " and ";
          else {
            buffer.addInterpolation$1(identifier);
            if (this.scanIdentifier$2$ignoreCase("and", true)) {
              this.whitespace$0();
              t1._contents += " and ";
            } else
              return;
          }
        }
        for (t1 = buffer._interpolation_buffer$_text; true;) {
          this.whitespace$0();
          buffer.addInterpolation$1(this._queryExpression$0());
          this.whitespace$0();
          if (!this.scanIdentifier$2$ignoreCase("and", true))
            break;
          t1._contents += " and ";
        }
      },
      _supportsCondition$0: function() {
        var t1, t2, first, condition, operator, right, endPosition, end, lowerOperator;
        t1 = this.scanner;
        t2 = t1._position;
        first = t1.peekChar$0();
        if (first !== 40 && first !== 35) {
          t2 = t1._position;
          this.expectIdentifier$2$ignoreCase("not", true);
          this.whitespace$0();
          return new M.SupportsNegation(this._supportsConditionInParens$0(), t1.spanFrom$1(new S._SpanScannerState(t1, t2)));
        }
        condition = this._supportsConditionInParens$0();
        this.whitespace$0();
        for (; this.lookingAtIdentifier$0();) {
          if (this.scanIdentifier$2$ignoreCase("or", true))
            operator = "or";
          else {
            this.expectIdentifier$2$ignoreCase("and", true);
            operator = "and";
          }
          this.whitespace$0();
          right = this._supportsConditionInParens$0();
          endPosition = t1._position;
          end = endPosition;
          condition = new U.SupportsOperation(condition, right, operator, Y._FileSpan$(t1._sourceFile, t2, end));
          lowerOperator = operator.toLowerCase();
          if (lowerOperator !== "and" && lowerOperator !== "or")
            H.throwExpression(P.ArgumentError$value(operator, "operator", 'may only be "and" or "or".'));
          this.whitespace$0();
        }
        return condition;
      },
      _supportsConditionInParens$0: function() {
        var t1, start, next, condition, negation, $name, value;
        t1 = this.scanner;
        start = new S._SpanScannerState(t1, t1._position);
        if (t1.peekChar$0() === 35)
          return new X.SupportsInterpolation(this.singleInterpolation$0(), t1.spanFrom$1(start));
        t1.expectChar$1(40);
        this.whitespace$0();
        next = t1.peekChar$0();
        if (next === 40 || next === 35) {
          condition = this._supportsCondition$0();
          this.whitespace$0();
          t1.expectChar$1(41);
          return condition;
        }
        if (next === 110 || next === 78) {
          negation = this._trySupportsNegation$0();
          if (negation != null) {
            t1.expectChar$1(41);
            return negation;
          }
        }
        $name = this._expression$0();
        t1.expectChar$1(58);
        this.whitespace$0();
        value = this._expression$0();
        t1.expectChar$1(41);
        return new L.SupportsDeclaration($name, value, t1.spanFrom$1(start));
      },
      _trySupportsNegation$0: function() {
        var t1, start, next;
        t1 = this.scanner;
        start = new S._SpanScannerState(t1, t1._position);
        if (!this.scanIdentifier$2$ignoreCase("not", true) || J.$eq$(t1._position, J.get$length$asx(t1.string))) {
          t1.set$state(start);
          return;
        }
        next = t1.peekChar$0();
        if (!(next === 32 || next === 9 || T.isNewline(next)) && next !== 40) {
          t1.set$state(start);
          return;
        }
        this.whitespace$0();
        return new M.SupportsNegation(this._supportsConditionInParens$0(), t1.spanFrom$1(start));
      },
      _lookingAtInterpolatedIdentifier$0: function() {
        var t1, first, second, third;
        t1 = this.scanner;
        first = t1.peekChar$0();
        if (first == null)
          return false;
        if (first === 95 || T.isAlphabetic0(first) || first >= 128 || first === 92)
          return true;
        if (first === 35)
          return t1.peekChar$1(1) === 123;
        if (first !== 45)
          return false;
        second = t1.peekChar$1(1);
        if (second == null)
          return false;
        if (second === 95 || T.isAlphabetic0(second) || second >= 128 || second === 92)
          return true;
        if (second === 35)
          return t1.peekChar$1(2) === 123;
        if (second !== 45)
          return false;
        third = t1.peekChar$1(2);
        if (third == null)
          return false;
        if (third === 35)
          return t1.peekChar$1(3) === 123;
        return third === 95 || T.isAlphabetic0(third) || third >= 128;
      },
      _lookingAtInterpolatedIdentifierBody$0: function() {
        var t1, first;
        t1 = this.scanner;
        first = t1.peekChar$0();
        if (first == null)
          return false;
        if (first === 95 || T.isAlphabetic0(first) || first >= 128 || T.isDigit(first) || first === 45 || first === 92)
          return true;
        return first === 35 && t1.peekChar$1(1) === 123;
      },
      _lookingAtExpression$0: function() {
        var t1, character, next;
        t1 = this.scanner;
        character = t1.peekChar$0();
        if (character == null)
          return false;
        if (character === 46)
          return t1.peekChar$1(1) !== 46;
        if (character === 33) {
          next = t1.peekChar$1(1);
          if (next != null)
            if ((next | 32) !== 105)
              t1 = next === 32 || next === 9 || T.isNewline(next);
            else
              t1 = true;
          else
            t1 = true;
          return t1;
        }
        if (character !== 40)
          if (character !== 47)
            if (character !== 91)
              if (character !== 39)
                if (character !== 34)
                  if (character !== 35)
                    if (character !== 43)
                      if (character !== 45)
                        if (character !== 92)
                          if (character !== 36)
                            if (character !== 38)
                              t1 = character === 95 || T.isAlphabetic0(character) || character >= 128 || T.isDigit(character);
                            else
                              t1 = true;
                          else
                            t1 = true;
                        else
                          t1 = true;
                      else
                        t1 = true;
                    else
                      t1 = true;
                  else
                    t1 = true;
                else
                  t1 = true;
              else
                t1 = true;
            else
              t1 = true;
          else
            t1 = true;
        else
          t1 = true;
        return t1;
      }
    },
    StylesheetParser_parse_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        var t1, t2, t3, statements;
        t1 = this.$this;
        t2 = t1.scanner;
        t3 = t2._position;
        statements = t1.statements$1(new V.StylesheetParser_parse__closure(t1));
        t2.expectDone$0();
        t3 = t2.spanFrom$1(new S._SpanScannerState(t2, t3));
        t2 = P.List_List$unmodifiable(statements, null);
        t1 = C.JSArray_methods.any$1(t2, new M.ParentStatement_closure());
        return new V.Stylesheet(t3, t2, t1);
      }
    },
    StylesheetParser_parse__closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        return this.$this._statement$1$root(true);
      }
    },
    StylesheetParser_parseArgumentDeclaration_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        var t1, declaration;
        t1 = this.$this;
        declaration = t1._argumentDeclaration$0();
        t1.scanner.expectDone$0();
        return declaration;
      }
    },
    StylesheetParser_parseExpression_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        var t1, expression;
        t1 = this.$this;
        expression = t1._expression$0();
        t1.scanner.expectDone$0();
        return expression;
      }
    },
    StylesheetParser_parseVariableDeclaration_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        var t1, declaration;
        t1 = this.$this;
        declaration = t1.variableDeclaration$0();
        t1.scanner.expectDone$0();
        return declaration;
      }
    },
    StylesheetParser_parseSignature_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        var t1, $name, t2, $arguments, t3;
        t1 = this.$this;
        $name = t1.identifier$0();
        t1.whitespace$0();
        t2 = t1.scanner;
        if (t2.peekChar$0() === 40)
          $arguments = t1._argumentDeclaration$0();
        else {
          t1 = Y.FileLocation$_(t2._sourceFile, t2._position);
          t3 = t1.offset;
          $arguments = new B.ArgumentDeclaration(C.List_empty, null, Y._FileSpan$(t1.file, t3, t3));
        }
        t2.expectDone$0();
        return new S.Tuple2($name, $arguments, [null, null]);
      }
    },
    StylesheetParser__statement_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        return this.$this._statement$0();
      }
    },
    StylesheetParser__forRule_closure: {
      "^": "Closure:1;_box_0,$this",
      call$0: function() {
        var t1 = this.$this;
        if (!t1.lookingAtIdentifier$0())
          return false;
        if (t1.scanIdentifier$1("to")) {
          this._box_0.exclusive = true;
          return true;
        } else if (t1.scanIdentifier$1("through")) {
          this._box_0.exclusive = false;
          return true;
        } else
          return false;
      }
    },
    StylesheetParser__expression_resetState: {
      "^": "Closure:1;_box_0,$this,start",
      call$0: function() {
        var t1, t2;
        t1 = this._box_0;
        t1.commaExpressions = null;
        t1.spaceExpressions = null;
        t1.operators = null;
        t1.operands = null;
        t2 = this.$this;
        t2.scanner.set$state(this.start);
        t1.allowSlash = t2.lookingAtNumber$0();
        t1.singleExpression = t2._singleExpression$0();
      }
    },
    StylesheetParser__expression_resolveOneOperation: {
      "^": "Closure:1;_box_0,$this",
      call$0: function() {
        var t1, t2, operator, t3;
        t1 = this._box_0;
        t2 = t1.operators;
        if (0 >= t2.length)
          return H.ioore(t2, -1);
        operator = t2.pop();
        if (operator !== C.BinaryOperator_RTB)
          t1.allowSlash = false;
        t2 = t1.allowSlash && !this.$this._inParentheses;
        t3 = t1.operands;
        if (t2) {
          if (0 >= t3.length)
            return H.ioore(t3, -1);
          t1.singleExpression = new V.BinaryOperationExpression(C.BinaryOperator_RTB, t3.pop(), t1.singleExpression, true);
        } else {
          if (0 >= t3.length)
            return H.ioore(t3, -1);
          t1.singleExpression = new V.BinaryOperationExpression(operator, t3.pop(), t1.singleExpression, false);
        }
      }
    },
    StylesheetParser__expression_resolveOperations: {
      "^": "Closure:1;_box_0,resolveOneOperation",
      call$0: function() {
        var t1, t2;
        t1 = this._box_0;
        if (t1.operators == null)
          return;
        for (t2 = this.resolveOneOperation; t1.operators.length !== 0;)
          t2.call$0();
      }
    },
    StylesheetParser__expression_addSingleExpression: {
      "^": "Closure:71;_box_0,$this,resetState,resolveOperations",
      call$2$number: function(expression, number) {
        var t1, t2;
        t1 = this._box_0;
        if (t1.singleExpression != null) {
          t2 = this.$this;
          if (t2._inParentheses) {
            t2._inParentheses = false;
            if (t1.allowSlash) {
              this.resetState.call$0();
              return;
            }
          }
          if (t1.spaceExpressions == null)
            t1.spaceExpressions = [];
          this.resolveOperations.call$0();
          t1.spaceExpressions.push(t1.singleExpression);
          t1.allowSlash = number;
        } else if (!number)
          t1.allowSlash = false;
        t1.singleExpression = expression;
      },
      call$1: function(expression) {
        return this.call$2$number(expression, false);
      }
    },
    StylesheetParser__expression_addOperator: {
      "^": "Closure:72;_box_0,$this,resolveOneOperation",
      call$1: function(operator) {
        var t1, t2, t3, t4, singleExpression;
        t1 = this._box_0;
        if (t1.operators == null)
          t1.operators = [];
        if (t1.operands == null)
          t1.operands = [];
        t2 = this.resolveOneOperation;
        t3 = operator.precedence;
        while (true) {
          t4 = t1.operators;
          if (!(t4.length !== 0 && (t4 && C.JSArray_methods).get$last(t4).precedence >= t3))
            break;
          t2.call$0();
        }
        t1.operators.push(operator);
        t1.operands.push(t1.singleExpression);
        t2 = this.$this;
        t2.whitespace$0();
        t1.allowSlash = t1.allowSlash && t2.lookingAtNumber$0();
        singleExpression = t2._singleExpression$0();
        t1.singleExpression = singleExpression;
        t1.allowSlash = t1.allowSlash && singleExpression instanceof T.NumberExpression;
      }
    },
    StylesheetParser__expression_resolveSpaceExpressions: {
      "^": "Closure:1;_box_0,resolveOperations",
      call$0: function() {
        var t1, t2, t3;
        this.resolveOperations.call$0();
        t1 = this._box_0;
        t2 = t1.spaceExpressions;
        if (t2 != null) {
          t2.push(t1.singleExpression);
          t2 = P.List_List$unmodifiable(t1.spaceExpressions, null);
          t3 = B.spanForList(t2);
          t1.singleExpression = new D.ListExpression(t2, C.ListSeparator_woc, false, t3);
          t1.spaceExpressions = null;
        }
        t2 = t1.singleEqualsOperand;
        if (t2 != null) {
          t1.singleExpression = new V.BinaryOperationExpression(C.BinaryOperator_kjl, t2, t1.singleExpression, false);
          t1.singleEqualsOperand = null;
        }
      }
    },
    StylesheetParser__expressionUntilComma_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        return this.$this.scanner.peekChar$0() === 44;
      }
    },
    StylesheetParser__unicodeRange_closure: {
      "^": "Closure:0;",
      call$1: function(char) {
        return char != null && T.isHex(char);
      }
    },
    StylesheetParser__unicodeRange_closure0: {
      "^": "Closure:0;",
      call$1: function(char) {
        return char != null && T.isHex(char);
      }
    }
  }], ["", "package:sass/src/stylesheet_graph.dart",, M, {
    "^": "",
    StylesheetGraph: {
      "^": "Object;_nodes,importCache,_transitiveModificationTimes",
      modifiedSince$4: function(url, since, baseImporter, baseUrl) {
        var node = this._stylesheet_graph$_add$3(url, baseImporter, baseUrl);
        if (node == null)
          return true;
        return new M.StylesheetGraph_modifiedSince_transitiveModificationTime(this).call$1(node).isAfter$1(since);
      },
      modifiedSince$3: function(url, since, baseImporter) {
        return this.modifiedSince$4(url, since, baseImporter, null);
      },
      _stylesheet_graph$_add$3: function(url, baseImporter, baseUrl) {
        var tuple = this._ignoreErrors$1(new M.StylesheetGraph__add_closure(this, url, baseImporter, baseUrl));
        if (tuple == null)
          return;
        return this.addCanonical$3(tuple.get$item1(), tuple.get$item2(), url);
      },
      addCanonical$3: function(importer, canonicalUrl, originalUrl) {
        return this._nodes.putIfAbsent$2(canonicalUrl, new M.StylesheetGraph_addCanonical_closure(this, importer, canonicalUrl, originalUrl));
      },
      _upstreamNodes$3: function(stylesheet, baseImporter, baseUrl) {
        var t1, active, upstream, t2, _i, url;
        t1 = P.Uri;
        active = P.LinkedHashSet_LinkedHashSet$from([baseUrl], t1);
        upstream = P.LinkedHashMap_LinkedHashMap$_empty(t1, M.StylesheetNode);
        for (t1 = H.setRuntimeTypeInfo([], [B.DynamicImport]), new L._FindImportsVisitor(t1).visitChildren$1(stylesheet), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          url = P.Uri_parse(t1[_i].get$url(), 0, null);
          upstream.$indexSet(0, url, this._nodeFor$4(url, baseImporter, baseUrl, active));
        }
        return upstream;
      },
      reload$1: function(canonicalUrl) {
        var node, t1, t2, stylesheet;
        node = this._nodes.$index(0, canonicalUrl);
        if (node == null)
          throw H.wrapException(P.StateError$(H.S(canonicalUrl) + " is not in the dependency graph."));
        this._transitiveModificationTimes.clear$0(0);
        t1 = this.importCache;
        t1._import_cache$_importCache.remove$1(0, canonicalUrl);
        t2 = J.getInterceptor$x(node);
        stylesheet = t1.importCanonical$2(t2.get$importer(node), canonicalUrl);
        if (stylesheet == null) {
          this.remove$1(0, canonicalUrl);
          return;
        }
        node.set$_stylesheet(stylesheet);
        node.set$_stylesheet(stylesheet);
        node._replaceUpstream$1(this._upstreamNodes$3(stylesheet, t2.get$importer(node), canonicalUrl));
        return node;
      },
      remove$1: function(_, canonicalUrl) {
        var node = this._nodes.remove$1(0, canonicalUrl);
        if (node == null)
          throw H.wrapException(P.StateError$(H.S(canonicalUrl) + " is not in the dependency graph."));
        this._transitiveModificationTimes.clear$0(0);
        this.importCache._import_cache$_importCache.remove$1(0, canonicalUrl);
        node._stylesheet_graph$_remove$0();
      },
      _nodeFor$4: function(url, baseImporter, baseUrl, active) {
        var tuple, importer, canonicalUrl, t1, stylesheet, node;
        tuple = this._ignoreErrors$1(new M.StylesheetGraph__nodeFor_closure(this, url, baseImporter, baseUrl));
        if (tuple == null)
          return;
        importer = tuple.get$item1();
        canonicalUrl = tuple.get$item2();
        t1 = this._nodes;
        if (t1.containsKey$1(canonicalUrl))
          return t1.$index(0, canonicalUrl);
        if (active.contains$1(0, canonicalUrl))
          return;
        stylesheet = this._ignoreErrors$1(new M.StylesheetGraph__nodeFor_closure0(this, importer, canonicalUrl, url));
        if (stylesheet == null)
          return;
        active.add$1(0, canonicalUrl);
        node = M.StylesheetNode$_(stylesheet, importer, canonicalUrl, this._upstreamNodes$3(stylesheet, importer, canonicalUrl));
        active.remove$1(0, canonicalUrl);
        t1.$indexSet(0, canonicalUrl, node);
        return node;
      },
      _ignoreErrors$1: function(callback) {
        var t1, exception;
        try {
          t1 = callback.call$0();
          return t1;
        } catch (exception) {
          H.unwrapException(exception);
          return;
        }
      }
    },
    StylesheetGraph_modifiedSince_transitiveModificationTime: {
      "^": "Closure:73;$this",
      call$1: function(node) {
        return this.$this._transitiveModificationTimes.putIfAbsent$2(node.get$canonicalUrl(), new M.StylesheetGraph_modifiedSince_transitiveModificationTime_closure(node, this));
      }
    },
    StylesheetGraph_modifiedSince_transitiveModificationTime_closure: {
      "^": "Closure:1;node,transitiveModificationTime",
      call$0: function() {
        var t1, latest, t2, upstream, upstreamTime;
        t1 = this.node;
        latest = J.get$importer$x(t1).modificationTime$1(t1.get$canonicalUrl());
        for (t1 = t1.get$upstream()._collection$_map.get$values(), t1 = t1.get$iterator(t1), t2 = this.transitiveModificationTime; t1.moveNext$0();) {
          upstream = t1.get$current(t1);
          upstreamTime = upstream == null ? new P.DateTime(Date.now(), false) : t2.call$1(upstream);
          if (upstreamTime.isAfter$1(latest))
            latest = upstreamTime;
        }
        return latest;
      }
    },
    StylesheetGraph__add_closure: {
      "^": "Closure:1;$this,url,baseImporter,baseUrl",
      call$0: function() {
        return this.$this.importCache.canonicalize$3(this.url, this.baseImporter, this.baseUrl);
      }
    },
    StylesheetGraph_addCanonical_closure: {
      "^": "Closure:1;$this,importer,canonicalUrl,originalUrl",
      call$0: function() {
        var t1, t2, t3, stylesheet;
        t1 = this.$this;
        t2 = this.importer;
        t3 = this.canonicalUrl;
        stylesheet = t1._ignoreErrors$1(new M.StylesheetGraph_addCanonical__closure(t1, t2, t3, this.originalUrl));
        if (stylesheet == null)
          return;
        return M.StylesheetNode$_(stylesheet, t2, t3, t1._upstreamNodes$3(stylesheet, t2, t3));
      }
    },
    StylesheetGraph_addCanonical__closure: {
      "^": "Closure:1;$this,importer,canonicalUrl,originalUrl",
      call$0: function() {
        return this.$this.importCache.importCanonical$3(this.importer, this.canonicalUrl, this.originalUrl);
      }
    },
    StylesheetGraph__nodeFor_closure: {
      "^": "Closure:1;$this,url,baseImporter,baseUrl",
      call$0: function() {
        return this.$this.importCache.canonicalize$3(this.url, this.baseImporter, this.baseUrl);
      }
    },
    StylesheetGraph__nodeFor_closure0: {
      "^": "Closure:1;$this,importer,canonicalUrl,url",
      call$0: function() {
        return this.$this.importCache.importCanonical$3(this.importer, this.canonicalUrl, this.url);
      }
    },
    StylesheetNode: {
      "^": "Object;_stylesheet?,importer>,canonicalUrl<,_upstream<,_downstream<",
      get$stylesheet: function() {
        return this._stylesheet;
      },
      get$upstream: function() {
        return new P.UnmodifiableMapView(this._upstream, [null, null]);
      },
      get$downstream: function() {
        return new L.UnmodifiableSetView(this._downstream, [null]);
      },
      StylesheetNode$_$4: function(_stylesheet, importer, canonicalUrl, _upstream) {
        var t1, node;
        for (t1 = this._upstream.get$values(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
          node = t1.get$current(t1);
          if (node != null)
            node.get$_downstream().add$1(0, this);
        }
      },
      _replaceUpstream$1: function(newUpstream) {
        var t1, oldUpstream, newUpstreamSet, t2, t3;
        t1 = M.StylesheetNode;
        oldUpstream = P.LinkedHashSet_LinkedHashSet$from(this._upstream.get$values(), t1);
        oldUpstream.remove$1(0, null);
        newUpstreamSet = P.LinkedHashSet_LinkedHashSet$from(newUpstream.get$values(), t1);
        newUpstreamSet.remove$1(0, null);
        for (t1 = oldUpstream.difference$1(newUpstreamSet), t2 = [null], t3 = new P._LinkedHashSetIterator(t1, t1._collection$_modifications, null, null, t2), t3._collection$_cell = t1._collection$_first; t3.moveNext$0();)
          t3._collection$_current.get$_downstream().remove$1(0, this);
        for (t1 = newUpstreamSet.difference$1(oldUpstream), t2 = new P._LinkedHashSetIterator(t1, t1._collection$_modifications, null, null, t2), t2._collection$_cell = t1._collection$_first; t2.moveNext$0();)
          t2._collection$_current.get$_downstream().add$1(0, this);
        this._upstream = newUpstream;
      },
      _stylesheet_graph$_remove$0: function() {
        var t1, node, t2, t3, _i, url;
        for (t1 = this._upstream.get$values(), t1 = t1.get$iterator(t1); t1.moveNext$0();) {
          node = t1.get$current(t1);
          if (node == null)
            continue;
          node.get$_downstream().remove$1(0, this);
        }
        for (t1 = this._downstream, t1 = t1.get$iterator(t1); t1.moveNext$0();) {
          node = t1.get$current(t1);
          for (t2 = node.get$_upstream().get$keys(), t2 = P.List_List$from(t2, true, H.getRuntimeTypeArgument(t2, "Iterable", 0)), t3 = t2.length, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i) {
            url = t2[_i];
            if (J.$eq$(node.get$_upstream().$index(0, url), this) === true) {
              node.get$_upstream().$indexSet(0, url, null);
              break;
            }
          }
        }
      },
      static: {
        StylesheetNode$_: function(_stylesheet, importer, canonicalUrl, _upstream) {
          var t1 = new M.StylesheetNode(_stylesheet, importer, canonicalUrl, _upstream, P.LinkedHashSet_LinkedHashSet(null, null, null, M.StylesheetNode));
          t1.StylesheetNode$_$4(_stylesheet, importer, canonicalUrl, _upstream);
          return t1;
        }
      }
    }
  }], ["", "package:sass/src/util/character.dart",, T, {
    "^": "",
    isNewline: [function(character) {
      return character === 10 || character === 13 || character === 12;
    }, "call$1", "character__isNewline$closure", 4, 0, 26],
    isAlphabetic0: function(character) {
      var t1;
      if (!(character >= 97 && character <= 122))
        t1 = character >= 65 && character <= 90;
      else
        t1 = true;
      return t1;
    },
    isDigit: function(character) {
      var t1;
      if (character != null) {
        t1 = J.getInterceptor$n(character);
        t1 = t1.$ge(character, 48) && t1.$le(character, 57);
      } else
        t1 = false;
      return t1;
    },
    isHex: [function(character) {
      var t1;
      if (!T.isDigit(character)) {
        t1 = J.getInterceptor$n(character);
        if (!(t1.$ge(character, 97) && t1.$le(character, 102)))
          t1 = t1.$ge(character, 65) && t1.$le(character, 70);
        else
          t1 = true;
      } else
        t1 = true;
      return t1;
    }, "call$1", "character__isHex$closure", 4, 0, 26],
    asHex: function(character) {
      if (character <= 57)
        return character - 48;
      if (character <= 70)
        return 10 + character - 65;
      return 10 + character - 97;
    },
    hexCharFor: function(number) {
      return number < 10 ? 48 + number : 87 + number;
    },
    opposite: function(character) {
      switch (character) {
        case 40:
          return 41;
        case 123:
          return 125;
        case 91:
          return 93;
        default:
          return;
      }
    }
  }], ["", "package:sass/src/util/multi_dir_watcher.dart",, U, {
    "^": "",
    MultiDirWatcher: {
      "^": "Object;_watchers,_group",
      watch$1: function(_, directory) {
        var t1, t2, t3, t4, isParentOfExistingDir, _i, existingDir, t5, future, completer;
        for (t1 = this._watchers, t2 = t1.get$keys(), t2 = P.List_List$from(t2, true, H.getRuntimeTypeArgument(t2, "Iterable", 0)), t3 = t2.length, t4 = this._group, isParentOfExistingDir = false, _i = 0; _i < t2.length; t2.length === t3 || (0, H.throwConcurrentModificationError)(t2), ++_i) {
          existingDir = t2[_i];
          if (!isParentOfExistingDir)
            t5 = D.p()._isWithinOrEquals$2(existingDir, directory) === C._PathRelation_equal || D.p()._isWithinOrEquals$2(existingDir, directory) === C._PathRelation_within;
          else
            t5 = false;
          if (t5) {
            t1 = new P._Future(0, $.Zone__current, null, [null]);
            t1._asyncComplete$1(null);
            return t1;
          }
          if (D.p()._isWithinOrEquals$2(directory, existingDir) === C._PathRelation_within) {
            t4.remove$1(0, t1.remove$1(0, existingDir));
            isParentOfExistingDir = true;
          }
        }
        future = B.watchDir(directory);
        t2 = new Y._CompleterStream(null, null, [null]);
        completer = new Y.StreamCompleter(t2, [null]);
        future.then$2$onError(completer.get$setSourceStream(), completer.get$setError());
        t1.$indexSet(0, directory, t2);
        t4.add$1(0, t2);
        return future;
      }
    }
  }], ["", "package:sass/src/util/no_source_map_buffer.dart",, N, {
    "^": "",
    NoSourceMapBuffer: {
      "^": "Object;_no_source_map_buffer$_buffer",
      get$isEmpty: function(_) {
        return this._no_source_map_buffer$_buffer._contents.length === 0;
      },
      get$isNotEmpty: function(_) {
        return this._no_source_map_buffer$_buffer._contents.length !== 0;
      },
      get$length: function(_) {
        return this._no_source_map_buffer$_buffer._contents.length;
      },
      get$sourceFiles: function() {
        return C.Map_empty0;
      },
      forSpan$2: function(span, callback) {
        return callback.call$0();
      },
      write$1: [function(_, object) {
        this._no_source_map_buffer$_buffer._contents += H.S(object);
        return;
      }, "call$1", "get$write", 5, 0, 20],
      writeCharCode$1: function(charCode) {
        this._no_source_map_buffer$_buffer._contents += H.Primitives_stringFromCharCode(charCode);
        return;
      },
      toString$0: function(_) {
        var t1 = this._no_source_map_buffer$_buffer._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      },
      buildSourceMap$0: function() {
        return H.throwExpression(P.UnsupportedError$("NoSourceMapBuffer.clear() is not supported."));
      },
      $isStringBuffer: 1
    }
  }], ["", "package:sass/src/util/number.dart",, T, {
    "^": "",
    fuzzyEquals: [function(number1, number2) {
      return J.$lt$n(J.abs$0$in(J.$sub$n(number1, number2)), $.$get$epsilon());
    }, "call$2", "number__fuzzyEquals$closure", 8, 0, 8, 85, 63],
    fuzzyLessThan: [function(number1, number2) {
      var t1 = J.getInterceptor$n(number1);
      return t1.$lt(number1, number2) && !J.$lt$n(J.abs$0$in(t1.$sub(number1, number2)), $.$get$epsilon());
    }, "call$2", "number__fuzzyLessThan$closure", 8, 0, 8],
    fuzzyLessThanOrEquals: [function(number1, number2) {
      var t1 = J.getInterceptor$n(number1);
      return t1.$lt(number1, number2) || J.$lt$n(J.abs$0$in(t1.$sub(number1, number2)), $.$get$epsilon());
    }, "call$2", "number__fuzzyLessThanOrEquals$closure", 8, 0, 8],
    fuzzyGreaterThan: [function(number1, number2) {
      var t1 = J.getInterceptor$n(number1);
      return t1.$gt(number1, number2) && !J.$lt$n(J.abs$0$in(t1.$sub(number1, number2)), $.$get$epsilon());
    }, "call$2", "number__fuzzyGreaterThan$closure", 8, 0, 8],
    fuzzyGreaterThanOrEquals: [function(number1, number2) {
      var t1 = J.getInterceptor$n(number1);
      return t1.$gt(number1, number2) || J.$lt$n(J.abs$0$in(t1.$sub(number1, number2)), $.$get$epsilon());
    }, "call$2", "number__fuzzyGreaterThanOrEquals$closure", 8, 0, 8],
    fuzzyIsInt: function(number) {
      var t1, t2;
      if (typeof number === "number" && Math.floor(number) === number)
        return true;
      t1 = J.$mod$n(J.abs$0$in(J.$sub$n(number, 0.5)), 1);
      t2 = $.$get$epsilon();
      if (typeof t2 !== "number")
        return H.iae(t2);
      return Math.abs(t1 - 0.5) < t2;
    },
    fuzzyRound: [function(number) {
      var t1, t2, t3;
      t1 = J.getInterceptor$n(number);
      if (t1.$gt(number, 0)) {
        t2 = t1.$mod(number, 1);
        if (t2 < 0.5) {
          t3 = $.$get$epsilon();
          if (typeof t3 !== "number")
            return H.iae(t3);
          t3 = !(Math.abs(t2 - 0.5) < t3);
          t2 = t3;
        } else
          t2 = false;
        return t2 ? t1.floor$0(number) : t1.ceil$0(number);
      } else {
        t2 = t1.$mod(number, 1);
        if (!(t2 < 0.5)) {
          t3 = $.$get$epsilon();
          if (typeof t3 !== "number")
            return H.iae(t3);
          t3 = Math.abs(t2 - 0.5) < t3;
          t2 = t3;
        } else
          t2 = true;
        return t2 ? t1.floor$0(number) : t1.ceil$0(number);
      }
    }, "call$1", "number__fuzzyRound$closure", 4, 0, 67, 57],
    fuzzyCheckRange: function(number, min, max) {
      var t1, t2, t3;
      t1 = J.getInterceptor$n(number);
      t2 = J.abs$0$in(t1.$sub(number, min));
      t3 = $.$get$epsilon();
      if (J.$lt$n(t2, t3))
        return min;
      if (J.$lt$n(J.abs$0$in(t1.$sub(number, max)), t3))
        return max;
      if (t1.$gt(number, min) && t1.$lt(number, max))
        return number;
      return;
    },
    fuzzyAssertRange: function(number, min, max, $name) {
      var result = T.fuzzyCheckRange(number, min, max);
      if (result != null)
        return result;
      throw H.wrapException(P.RangeError$value(number, $name, "must be between " + min + " and " + max + "."));
    }
  }], ["", "package:sass/src/util/path.dart",, D, {
    "^": "",
    p: function() {
      var t1 = $._p;
      if (t1 != null) {
        t1 = t1._context$_current;
        t1 = t1 != null ? t1 : D.current();
        t1 = J.$eq$(t1, J.cwd$0$x(self.process)) === true;
      } else
        t1 = false;
      if (t1)
        return $._p;
      t1 = J.$eq$(J.get$platform$x(self.process), "win32") === true ? $.$get$Style_windows() : $.$get$Style_posix();
      t1 = M.Context_Context(J.cwd$0$x(self.process), t1);
      $._p = t1;
      return t1;
    }
  }], ["", "package:sass/src/util/path_map.dart",, K, {
    "^": "",
    PathMap: {
      "^": "MapView;_collection$_map,$ti",
      $asMapView: function($V) {
        return [P.String, $V];
      },
      $asMap: function($V) {
        return [P.String, $V];
      },
      static: {
        PathMap__create: function(context) {
          var t1 = {};
          t1.context = context;
          t1.context = $.$get$context();
          return P.LinkedHashMap_LinkedHashMap(new K.PathMap__create_closure(t1), new K.PathMap__create_closure0(t1), new K.PathMap__create_closure1(), null, null);
        }
      }
    },
    PathMap__create_closure: {
      "^": "Closure:2;_box_0",
      call$2: [function(path1, path2) {
        if (path1 == null)
          return path2 == null;
        if (path2 == null)
          return false;
        return this._box_0.context._isWithinOrEquals$2(path1, path2) === C._PathRelation_equal;
      }, null, null, 8, 0, null, 66, 67, "call"]
    },
    PathMap__create_closure0: {
      "^": "Closure:0;_box_0",
      call$1: [function(path) {
        return path == null ? 0 : this._box_0.context.hash$1(path);
      }, null, null, 4, 0, null, 6, "call"]
    },
    PathMap__create_closure1: {
      "^": "Closure:0;",
      call$1: function(path) {
        return typeof path === "string" || path == null;
      }
    }
  }], ["", "package:sass/src/util/source_map_buffer.dart",, D, {
    "^": "",
    SourceMapBuffer: {
      "^": "Object;_source_map_buffer$_buffer,_entries,_sourceFiles,_line,_column,_inSpan",
      get$sourceFiles: function() {
        return new P.UnmodifiableMapView(Y.mapMap(this._sourceFiles, new D.SourceMapBuffer_sourceFiles_closure(), null), [null, null]);
      },
      get$_targetLocation: function() {
        var t1, t2, t3;
        t1 = this._source_map_buffer$_buffer._contents;
        t2 = this._line;
        t3 = this._column;
        return new V.SourceLocation(null, t1.length, t2, t3);
      },
      get$isEmpty: function(_) {
        return this._source_map_buffer$_buffer._contents.length === 0;
      },
      get$isNotEmpty: function(_) {
        return this._source_map_buffer$_buffer._contents.length !== 0;
      },
      get$length: function(_) {
        return this._source_map_buffer$_buffer._contents.length;
      },
      forSpan$2: function(span, callback) {
        var wasInSpan, t1;
        wasInSpan = this._inSpan;
        this._inSpan = true;
        this._addEntry$2(J.get$start$x(span), this.get$_targetLocation());
        try {
          t1 = callback.call$0();
          return t1;
        } finally {
          this._inSpan = wasInSpan;
        }
      },
      _addEntry$2: function(source, target) {
        var t1, entry;
        t1 = this._entries;
        if (t1.length !== 0) {
          entry = C.JSArray_methods.get$last(t1);
          if (J.$eq$(entry.source.get$line(), source.get$line()) === true && entry.target.line === target.line)
            return;
          if (entry.target.offset === target.offset)
            return;
        }
        this._sourceFiles.putIfAbsent$2(source.get$sourceUrl(), new D.SourceMapBuffer__addEntry_closure(source));
        t1.push(new L.Entry(source, target, null));
      },
      write$1: [function(_, object) {
        var string, t1, i, t2;
        string = J.toString$0$(object);
        this._source_map_buffer$_buffer._contents += H.S(string);
        t1 = J.getInterceptor$asx(string);
        i = 0;
        while (true) {
          t2 = t1.get$length(string);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          if (t1.codeUnitAt$1(string, i) === 10)
            this._writeLine$0();
          else
            ++this._column;
          ++i;
        }
      }, "call$1", "get$write", 5, 0, 20],
      writeCharCode$1: function(charCode) {
        this._source_map_buffer$_buffer._contents += H.Primitives_stringFromCharCode(charCode);
        if (charCode === 10)
          this._writeLine$0();
        else
          ++this._column;
      },
      _writeLine$0: function() {
        var t1 = this._entries;
        if (C.JSArray_methods.get$last(t1).target.line === this._line && C.JSArray_methods.get$last(t1).target.column === this._column) {
          if (0 >= t1.length)
            return H.ioore(t1, -1);
          t1.pop();
        }
        ++this._line;
        this._column = 0;
        if (this._inSpan)
          t1.push(new L.Entry(C.JSArray_methods.get$last(t1).source, this.get$_targetLocation(), null));
      },
      toString$0: function(_) {
        var t1 = this._source_map_buffer$_buffer._contents;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      },
      buildSourceMap$0: function() {
        return T.SingleMapping_SingleMapping$fromEntries(this._entries, null);
      },
      $isStringBuffer: 1
    },
    SourceMapBuffer_sourceFiles_closure: {
      "^": "Closure:2;",
      call$2: function(url, _) {
        return J.toString$0$(url);
      }
    },
    SourceMapBuffer__addEntry_closure: {
      "^": "Closure:1;source",
      call$0: function() {
        return J.get$file$x(this.source);
      }
    }
  }], ["", "package:sass/src/utils.dart",, B, {
    "^": "",
    toSentence: function(iter, conjunction) {
      if (J.$eq$(iter.get$length(iter), 1) === true)
        return J.toString$0$(iter.get$first(iter));
      return iter.take$1(0, J.$sub$n(iter.get$length(iter), 1)).join$1(0, ", ") + (" " + conjunction + " " + H.S(iter.get$last(iter)));
    },
    indent: function(string, indentation) {
      var t1 = H.setRuntimeTypeInfo(string.split("\n"), [P.String]);
      return new H.MappedListIterable(t1, new B.indent_closure(indentation), [H.getTypeArgumentByIndex(t1, 0), null]).join$1(0, "\n");
    },
    pluralize: function($name, number, plural) {
      if (J.$eq$(number, 1) === true)
        return $name;
      if (plural != null)
        return plural;
      return $name + "s";
    },
    flattenVertically: function(iterable) {
      var queues, result, t1;
      queues = new H.MappedListIterable(iterable, new B.flattenVertically_closure(), [H.getRuntimeTypeArgument(iterable, "ListIterable", 0), null]).toList$0(0);
      if (queues.length === 1)
        return C.JSArray_methods.get$first(queues);
      result = [];
      for (t1 = !!queues.fixed$length; queues.length !== 0;) {
        if (t1)
          H.throwExpression(P.UnsupportedError$("removeWhere"));
        C.JSArray_methods._removeWhere$2(queues, new B.flattenVertically_closure0(result), true);
      }
      return result;
    },
    codepointIndexToCodeUnitIndex: function(string, codepointIndex) {
      var t1, codeUnitIndex, i, codeUnitIndex0, t2;
      for (t1 = J.getInterceptor$s(string), codeUnitIndex = 0, i = 0; i < codepointIndex; ++i) {
        codeUnitIndex0 = codeUnitIndex + 1;
        t2 = t1.codeUnitAt$1(string, codeUnitIndex);
        codeUnitIndex = t2 >= 55296 && t2 <= 56319 ? codeUnitIndex0 + 1 : codeUnitIndex0;
      }
      return codeUnitIndex;
    },
    codeUnitIndexToCodepointIndex: function(string, codeUnitIndex) {
      var t1, codepointIndex, i, t2;
      for (t1 = J.getInterceptor$s(string), codepointIndex = 0, i = 0; i < codeUnitIndex; i = (t2 >= 55296 && t2 <= 56319 ? i + 1 : i) + 1) {
        ++codepointIndex;
        t2 = t1.codeUnitAt$1(string, i);
      }
      return codepointIndex;
    },
    frameForSpan: function(span, member) {
      var t1, t2, t3;
      t1 = span.get$sourceUrl();
      if (t1 == null)
        t1 = $.$get$_noSourceUrl();
      t2 = J.getInterceptor$x(span);
      t3 = t2.get$start(span);
      t3 = t3.file.getLine$1(t3.offset);
      if (typeof t3 !== "number")
        return t3.$add();
      t2 = t2.get$start(span);
      return new A.Frame(t1, t3 + 1, J.$add$ansx(t2.file.getColumn$1(t2.offset), 1), member);
    },
    spanForList: function(nodes) {
      if (nodes.length === 0)
        return;
      if (C.JSArray_methods.get$first(nodes).get$span() == null)
        return;
      if (C.JSArray_methods.get$last(nodes).get$span() == null)
        return;
      return J.expand$1$ax(C.JSArray_methods.get$first(nodes).get$span(), C.JSArray_methods.get$last(nodes).get$span());
    },
    unvendor: function($name) {
      var t1, i;
      t1 = $name.length;
      if (t1 < 2)
        return $name;
      if (C.JSString_methods._codeUnitAt$1($name, 0) !== 45)
        return $name;
      if (C.JSString_methods._codeUnitAt$1($name, 1) === 45)
        return $name;
      for (i = 2; i < t1; ++i)
        if (C.JSString_methods._codeUnitAt$1($name, i) === 45)
          return C.JSString_methods.substring$1($name, i + 1);
      return $name;
    },
    equalsIgnoreSeparator: [function(string1, string2) {
      var t1, t2, i, t3, codeUnit1, codeUnit2;
      if (string1 == null ? string2 == null : string1 === string2)
        return true;
      if (string1 == null || string2 == null)
        return false;
      t1 = J.getInterceptor$asx(string1);
      t2 = J.getInterceptor$asx(string2);
      if (J.$eq$(t1.get$length(string1), t2.get$length(string2)) !== true)
        return false;
      i = 0;
      while (true) {
        t3 = t1.get$length(string1);
        if (typeof t3 !== "number")
          return H.iae(t3);
        if (!(i < t3))
          break;
        c$0: {
          codeUnit1 = t1.codeUnitAt$1(string1, i);
          codeUnit2 = t2.codeUnitAt$1(string2, i);
          if (codeUnit1 === codeUnit2)
            break c$0;
          if (codeUnit1 === 45) {
            if (codeUnit2 !== 95)
              return false;
          } else if (codeUnit1 === 95) {
            if (codeUnit2 !== 45)
              return false;
          } else
            return false;
        }
        ++i;
      }
      return true;
    }, "call$2", "utils__equalsIgnoreSeparator$closure", 8, 0, 96, 68, 69],
    hashCodeIgnoreSeparator: [function(string) {
      var t1, hash, i, t2, codeUnit;
      t1 = J.getInterceptor$asx(string);
      hash = 4603;
      i = 0;
      while (true) {
        t2 = t1.get$length(string);
        if (typeof t2 !== "number")
          return H.iae(t2);
        if (!(i < t2))
          break;
        codeUnit = t1.codeUnitAt$1(string, i);
        if (codeUnit === 95)
          codeUnit = 45;
        hash = ((hash & 67108863) * 33 ^ codeUnit) >>> 0;
        ++i;
      }
      return hash;
    }, "call$1", "utils__hashCodeIgnoreSeparator$closure", 4, 0, 97, 70],
    equalsIgnoreCase: function(string1, string2) {
      if (string1 === string2)
        return true;
      if (string1 == null || false)
        return false;
      if (string1.length !== string2.length)
        return false;
      return string1.toUpperCase() === string2.toUpperCase();
    },
    normalizedMap: function(source) {
      var map = P.LinkedHashMap_LinkedHashMap(B.utils__equalsIgnoreSeparator$closure(), B.utils__hashCodeIgnoreSeparator$closure(), null, P.String, null);
      if (source != null)
        map.addAll$1(0, source);
      return map;
    },
    normalizedSet: function(source) {
      var set = P.LinkedHashSet_LinkedHashSet(B.utils__equalsIgnoreSeparator$closure(), B.utils__hashCodeIgnoreSeparator$closure(), null, null);
      if (source != null)
        set.addAll$1(0, source);
      return set;
    },
    normalizedMapMap: function(map, key, value) {
      var t1, result;
      t1 = {};
      t1.key = key;
      t1.value = value;
      t1.key = new B.normalizedMapMap_closure();
      result = B.normalizedMap(null);
      map.forEach$1(0, new B.normalizedMapMap_closure0(t1, result));
      return result;
    },
    longestCommonSubsequence: function(list1, list2, select) {
      var t1, lengths, selections, t2, i, i0, j, selection, t3, t4, j0, t5;
      if (select == null)
        select = new B.longestCommonSubsequence_closure();
      t1 = J.getInterceptor$asx(list1);
      lengths = P.List_List$generate(t1.get$length(list1) + 1, new B.longestCommonSubsequence_closure0(list2), false, null);
      selections = P.List_List$generate(t1.get$length(list1), new B.longestCommonSubsequence_closure1(list2), false, P.List);
      for (t2 = J.getInterceptor$asx(list2), i = 0; i < t1.get$length(list1); i = i0)
        for (i0 = i + 1, j = 0; j < t2.get$length(list2); j = j0) {
          selection = select.call$2(t1.$index(list1, i), t2.$index(list2, j));
          if (i >= selections.length)
            return H.ioore(selections, i);
          J.$indexSet$ax(selections[i], j, selection);
          t3 = lengths.length;
          if (i0 >= t3)
            return H.ioore(lengths, i0);
          t4 = lengths[i0];
          j0 = j + 1;
          if (selection == null) {
            t3 = J.$index$asx(t4, j);
            if (i >= lengths.length)
              return H.ioore(lengths, i);
            t5 = J.$index$asx(lengths[i], j0);
            t5 = Math.max(H.checkNum(t3), H.checkNum(t5));
            t3 = t5;
          } else {
            if (i >= t3)
              return H.ioore(lengths, i);
            t3 = J.$add$ansx(J.$index$asx(lengths[i], j), 1);
          }
          J.$indexSet$ax(t4, j0, t3);
        }
      return new B.longestCommonSubsequence_backtrack(selections, lengths).call$2(t1.get$length(list1) - 1, t2.get$length(list2) - 1);
    },
    removeFirstWhere: function(list, test, orElse) {
      var toRemove, t1, _i, element;
      t1 = list.length;
      _i = 0;
      while (true) {
        if (!(_i < list.length)) {
          toRemove = null;
          break;
        }
        c$0: {
          element = list[_i];
          if (test.call$1(element) !== true)
            break c$0;
          toRemove = element;
          break;
        }
        list.length === t1 || (0, H.throwConcurrentModificationError)(list);
        ++_i;
      }
      if (toRemove == null)
        return orElse.call$0();
      else {
        C.JSArray_methods.remove$1(list, toRemove);
        return toRemove;
      }
    },
    rotateSlice: function(list, start, end) {
      var element, i, next;
      element = list.$index(0, end - 1);
      for (i = start; i < end; ++i, element = next) {
        next = list.$index(0, i);
        list.$indexSet(0, i, element);
      }
    },
    mapAsync: function(iterable, callback) {
      var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(P.Iterable), $async$returnValue, result, t1, $async$temp1;
      var $async$mapAsync = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              result = [];
              t1 = J.get$iterator$ax(iterable);
            case 3:
              // for condition
              if (!t1.moveNext$0()) {
                // goto after for
                $async$goto = 4;
                break;
              }
              $async$temp1 = result;
              $async$goto = 5;
              return P._asyncAwait(callback.call$1(t1.get$current(t1)), $async$mapAsync);
            case 5:
              // returning from await.
              $async$temp1.push($async$result);
              // goto for condition
              $async$goto = 3;
              break;
            case 4:
              // after for
              $async$returnValue = result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$mapAsync, $async$completer);
    },
    putIfAbsentAsync: function(map, key, ifAbsent) {
      var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, value;
      var $async$putIfAbsentAsync = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (map.containsKey$1(key) === true) {
                $async$returnValue = map.$index(0, key);
                // goto return
                $async$goto = 1;
                break;
              }
              $async$goto = 3;
              return P._asyncAwait(ifAbsent.call$0(), $async$putIfAbsentAsync);
            case 3:
              // returning from await.
              value = $async$result;
              map.$indexSet(0, key, value);
              $async$returnValue = value;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$putIfAbsentAsync, $async$completer);
    },
    normalizedMapMapAsync: function(map, key, value) {
      var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter([P.Map, P.String,,]), $async$returnValue, result, t1, mapKey, mapValue, $async$temp1, $async$temp2;
      var $async$normalizedMapMapAsync = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return P._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              key = new B.normalizedMapMapAsync_closure();
              result = B.normalizedMap(null);
              t1 = map.get$keys(), t1 = t1.get$iterator(t1);
            case 3:
              // for condition
              if (!t1.moveNext$0()) {
                // goto after for
                $async$goto = 4;
                break;
              }
              mapKey = t1.get$current(t1);
              mapValue = map.$index(0, mapKey);
              $async$temp1 = result;
              $async$goto = 5;
              return P._asyncAwait(key.call$2(mapKey, mapValue), $async$normalizedMapMapAsync);
            case 5:
              // returning from await.
              $async$temp2 = $async$result;
              $async$goto = 6;
              return P._asyncAwait(value.call$2(mapKey, mapValue), $async$normalizedMapMapAsync);
            case 6:
              // returning from await.
              $async$temp1.$indexSet(0, $async$temp2, $async$result);
              // goto for condition
              $async$goto = 3;
              break;
            case 4:
              // after for
              $async$returnValue = result;
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return P._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return P._asyncStartSync($async$normalizedMapMapAsync, $async$completer);
    },
    indent_closure: {
      "^": "Closure:0;indentation",
      call$1: [function(line) {
        return C.JSString_methods.$add(C.JSString_methods.$mul(" ", this.indentation), line);
      }, null, null, 4, 0, null, 13, "call"]
    },
    flattenVertically_closure: {
      "^": "Closure:0;",
      call$1: [function(inner) {
        return Q.QueueList_QueueList$from(inner, null);
      }, null, null, 4, 0, null, 72, "call"]
    },
    flattenVertically_closure0: {
      "^": "Closure:0;result",
      call$1: function(queue) {
        this.result.push(queue.removeFirst$0());
        return J.get$isEmpty$asx(queue);
      }
    },
    normalizedMapMap_closure: {
      "^": "Closure:2;",
      call$2: function(mapKey, _) {
        return H.stringTypeCast(mapKey);
      }
    },
    normalizedMapMap_closure0: {
      "^": "Closure:2;_box_0,result",
      call$2: function(mapKey, mapValue) {
        var t1 = this._box_0;
        this.result.$indexSet(0, t1.key.call$2(mapKey, mapValue), t1.value.call$2(mapKey, mapValue));
      }
    },
    longestCommonSubsequence_closure: {
      "^": "Closure:2;",
      call$2: function(element1, element2) {
        return J.$eq$(element1, element2) === true ? element1 : null;
      }
    },
    longestCommonSubsequence_closure0: {
      "^": "Closure:0;list2",
      call$1: function(_) {
        return P.List_List$filled(J.get$length$asx(this.list2) + 1, 0, false, null);
      }
    },
    longestCommonSubsequence_closure1: {
      "^": "Closure:0;list2",
      call$1: function(_) {
        var t1 = new Array(J.get$length$asx(this.list2));
        t1.fixed$length = Array;
        return t1;
      }
    },
    longestCommonSubsequence_backtrack: {
      "^": "Closure;selections,lengths",
      call$2: function(i, j) {
        var t1, selection, t2;
        if (i === -1 || j === -1)
          return [];
        t1 = this.selections;
        if (i < 0 || i >= t1.length)
          return H.ioore(t1, i);
        selection = J.$index$asx(t1[i], j);
        if (selection != null) {
          t1 = this.call$2(i - 1, j - 1);
          J.add$1$ax(t1, selection);
          return t1;
        }
        t1 = this.lengths;
        t2 = i + 1;
        if (t2 >= t1.length)
          return H.ioore(t1, t2);
        t2 = J.$index$asx(t1[t2], j);
        if (i >= t1.length)
          return H.ioore(t1, i);
        return J.$gt$n(t2, J.$index$asx(t1[i], j + 1)) ? this.call$2(i, j - 1) : this.call$2(i - 1, j);
      },
      $signature: function() {
        return {func: 1, ret: P.List, args: [P.int, P.int]};
      }
    },
    normalizedMapMapAsync_closure: {
      "^": "Closure:75;",
      call$2: function(mapKey, _) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue;
        var $async$call$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$returnValue = H.stringTypeCast(mapKey);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$2, $async$completer);
      }
    }
  }], ["", "package:sass/src/value.dart",, F, {
    "^": "",
    Value: {
      "^": "Object;",
      get$isTruthy: function() {
        return true;
      },
      get$separator: function() {
        return C.ListSeparator_undecided_null;
      },
      get$hasBrackets: function() {
        return false;
      },
      get$asList: function() {
        return [this];
      },
      get$lengthAsList: function() {
        return 1;
      },
      get$isBlank: function() {
        return false;
      },
      get$isSpecialNumber: function() {
        return false;
      },
      get$isVar: function() {
        return false;
      },
      sassIndexToListIndex$2: function(sassIndex, $name) {
        var index, t1;
        index = sassIndex.assertNumber$1($name).assertInt$1($name);
        if (index === 0)
          throw H.wrapException(this._value$_exception$2("List index may not be 0.", $name));
        t1 = this.get$lengthAsList();
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (Math.abs(index) > t1)
          throw H.wrapException(this._value$_exception$2("Invalid index " + H.S(sassIndex) + " for a list with " + H.S(this.get$lengthAsList()) + " elements.", $name));
        return index < 0 ? J.$add$ansx(this.get$lengthAsList(), index) : index - 1;
      },
      assertColor$1: function($name) {
        return H.throwExpression(this._value$_exception$2(this.toString$0(0) + " is not a color.", $name));
      },
      assertFunction$1: function($name) {
        return H.throwExpression(this._value$_exception$2(this.toString$0(0) + " is not a function reference.", $name));
      },
      assertMap$1: ["super$Value$assertMap", function($name) {
        return H.throwExpression(this._value$_exception$2(this.toString$0(0) + " is not a map.", $name));
      }],
      assertNumber$1: function($name) {
        return H.throwExpression(this._value$_exception$2(this.toString$0(0) + " is not a number.", $name));
      },
      assertNumber$0: function() {
        return this.assertNumber$1(null);
      },
      assertString$1: function($name) {
        return H.throwExpression(this._value$_exception$2(this.toString$0(0) + " is not a string.", $name));
      },
      assertSelector$2$allowParent$name: function(allowParent, $name) {
        var string, error, t1, t2, t3, exception;
        string = this._selectorString$1($name);
        try {
          t1 = string;
          t2 = J.get$codeUnits$s(t1);
          t3 = H.setRuntimeTypeInfo([0], [P.int]);
          t3 = new Y.SourceFile(null, t3, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
          t3.SourceFile$decoded$2$url(t2, null);
          t1 = new T.SelectorParser(allowParent, new S.SpanScanner(t3, null, null, t1, 0, null, null), C.StderrLogger_false).parse$0();
          return t1;
        } catch (exception) {
          t1 = H.unwrapException(exception);
          if (t1 instanceof E.SassFormatException) {
            error = t1;
            throw H.wrapException(this._value$_exception$1(J.toString$0$(error)));
          } else
            throw exception;
        }
      },
      assertSelector$1$name: function($name) {
        return this.assertSelector$2$allowParent$name(false, $name);
      },
      assertSelector$0: function() {
        return this.assertSelector$2$allowParent$name(false, null);
      },
      assertSelector$1$allowParent: function(allowParent) {
        return this.assertSelector$2$allowParent$name(allowParent, null);
      },
      assertCompoundSelector$2$allowParent$name: function(allowParent, $name) {
        var string, error, t1, t2, t3, exception;
        string = this._selectorString$1($name);
        try {
          t1 = string;
          t2 = J.get$codeUnits$s(t1);
          t3 = H.setRuntimeTypeInfo([0], [P.int]);
          t3 = new Y.SourceFile(null, t3, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
          t3.SourceFile$decoded$2$url(t2, null);
          t1 = new T.SelectorParser(false, new S.SpanScanner(t3, null, null, t1, 0, null, null), C.StderrLogger_false).parseCompoundSelector$0();
          return t1;
        } catch (exception) {
          t1 = H.unwrapException(exception);
          if (t1 instanceof E.SassFormatException) {
            error = t1;
            throw H.wrapException(this._value$_exception$1(J.toString$0$(error)));
          } else
            throw exception;
        }
      },
      assertCompoundSelector$1$name: function($name) {
        return this.assertCompoundSelector$2$allowParent$name(false, $name);
      },
      _selectorString$1: function($name) {
        var string = this._selectorStringOrNull$0();
        if (string != null)
          return string;
        throw H.wrapException(this._value$_exception$2(this.toString$0(0) + " is not a valid selector: it must be a string,\na list of strings, or a list of lists of strings.", $name));
      },
      _selectorString$0: function() {
        return this._selectorString$1(null);
      },
      _selectorStringOrNull$0: function() {
        var t1, t2, result, t3, _i, complex, t4, string, compound;
        if (!!this.$isSassString)
          return this.text;
        if (!this.$isSassList)
          return;
        t1 = this._list$_contents;
        t2 = t1.length;
        if (t2 === 0)
          return;
        result = H.setRuntimeTypeInfo([], [P.String]);
        t3 = this.separator === C.ListSeparator_kWM;
        if (t3)
          for (_i = 0; _i < t2; ++_i) {
            complex = t1[_i];
            t4 = J.getInterceptor(complex);
            if (!!t4.$isSassString)
              result.push(complex.text);
            else if (!!t4.$isSassList && complex.separator === C.ListSeparator_woc) {
              string = complex._selectorString$0();
              if (string == null)
                return;
              result.push(string);
            } else
              return;
          }
        else
          for (_i = 0; _i < t2; ++_i) {
            compound = t1[_i];
            if (compound instanceof D.SassString)
              result.push(compound.text);
            else
              return;
          }
        return C.JSArray_methods.join$1(result, t3 ? ", " : " ");
      },
      changeListContents$3$brackets$separator: function(contents, brackets, separator) {
        var t1, t2;
        t1 = separator == null ? this.get$separator() : separator;
        t2 = this.get$hasBrackets();
        return D.SassList$(contents, t1, t2);
      },
      changeListContents$1: function(contents) {
        return this.changeListContents$3$brackets$separator(contents, null, null);
      },
      changeListContents$2$separator: function(contents, separator) {
        return this.changeListContents$3$brackets$separator(contents, null, separator);
      },
      singleEquals$1: function(other) {
        return new D.SassString(N.serializeValue(this, false, true) + "=" + other.toCssString$0(), false, null);
      },
      greaterThan$1: function(other) {
        return H.throwExpression(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " > " + H.S(other) + '".'));
      },
      greaterThanOrEquals$1: function(other) {
        return H.throwExpression(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " >= " + H.S(other) + '".'));
      },
      lessThan$1: function(other) {
        return H.throwExpression(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " < " + H.S(other) + '".'));
      },
      lessThanOrEquals$1: function(other) {
        return H.throwExpression(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " <= " + H.S(other) + '".'));
      },
      times$1: function(other) {
        return H.throwExpression(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " * " + H.S(other) + '".'));
      },
      modulo$1: function(other) {
        return H.throwExpression(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " % " + H.S(other) + '".'));
      },
      plus$1: ["super$Value$plus", function(other) {
        if (other instanceof D.SassString)
          return new D.SassString(C.JSString_methods.$add(N.serializeValue(this, false, true), other.text), other.hasQuotes, null);
        else
          return new D.SassString(N.serializeValue(this, false, true) + other.toCssString$0(), false, null);
      }],
      minus$1: ["super$Value$minus", function(other) {
        return new D.SassString(N.serializeValue(this, false, true) + "-" + other.toCssString$0(), false, null);
      }],
      dividedBy$1: ["super$Value$dividedBy", function(other) {
        return new D.SassString(N.serializeValue(this, false, true) + "/" + other.toCssString$0(), false, null);
      }],
      unaryPlus$0: function() {
        return new D.SassString("+" + N.serializeValue(this, false, true), false, null);
      },
      unaryMinus$0: function() {
        return new D.SassString("-" + N.serializeValue(this, false, true), false, null);
      },
      unaryDivide$0: function() {
        return new D.SassString("/" + N.serializeValue(this, false, true), false, null);
      },
      unaryNot$0: function() {
        return C.SassBoolean_false;
      },
      withoutSlash$0: function() {
        return this;
      },
      toCssString$1$quote: function(quote) {
        return N.serializeValue(this, false, quote);
      },
      toCssString$0: function() {
        return this.toCssString$1$quote(true);
      },
      toString$0: function(_) {
        return N.serializeValue(this, true, true);
      },
      _value$_exception$2: function(message, $name) {
        return new E.SassScriptException($name == null ? message : "$" + $name + ": " + message);
      },
      _value$_exception$1: function(message) {
        return this._value$_exception$2(message, null);
      }
    }
  }], ["", "package:sass/src/value/argument_list.dart",, D, {
    "^": "",
    SassArgumentList: {
      "^": "SassList;_keywords,_wereKeywordsAccessed,_list$_contents,separator,hasBrackets"
    }
  }], ["", "package:sass/src/value/boolean.dart",, Z, {
    "^": "",
    SassBoolean: {
      "^": "Value;value<",
      get$isTruthy: function() {
        return this.value;
      },
      accept$1: function(visitor) {
        return visitor.visitBoolean$1(this);
      },
      unaryNot$0: function() {
        return this.value ? C.SassBoolean_false : C.SassBoolean_true;
      }
    }
  }], ["", "package:sass/src/value/color.dart",, K, {
    "^": "",
    SassColor: {
      "^": "Value;_red,_green,_blue,_hue,_saturation,_lightness,alpha<,originalSpan",
      get$red: function() {
        if (this._red == null)
          this._hslToRgb$0();
        return this._red;
      },
      get$green: function() {
        if (this._green == null)
          this._hslToRgb$0();
        return this._green;
      },
      get$blue: function() {
        if (this._blue == null)
          this._hslToRgb$0();
        return this._blue;
      },
      get$hue: function() {
        if (this._hue == null)
          this._rgbToHsl$0();
        return this._hue;
      },
      get$saturation: function() {
        if (this._saturation == null)
          this._rgbToHsl$0();
        return this._saturation;
      },
      get$lightness: function() {
        if (this._lightness == null)
          this._rgbToHsl$0();
        return this._lightness;
      },
      get$original: function() {
        var t1 = this.originalSpan;
        return t1 == null ? null : P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(t1.file._decodedChars, t1._file$_start, t1._end), 0, null);
      },
      SassColor$rgb$5: function(_red, _green, _blue, alpha, originalSpan) {
        P.RangeError_checkValueInInterval(this.get$red(), 0, 255, "red", null);
        P.RangeError_checkValueInInterval(this.get$green(), 0, 255, "green", null);
        P.RangeError_checkValueInInterval(this.get$blue(), 0, 255, "blue", null);
      },
      accept$1: function(visitor) {
        return visitor.visitColor$1(this);
      },
      assertColor$1: function($name) {
        return this;
      },
      changeRgb$4$alpha$blue$green$red: function(alpha, blue, green, red) {
        var t1, t2, t3;
        t1 = red == null ? this.get$red() : red;
        t2 = green == null ? this.get$green() : green;
        t3 = blue == null ? this.get$blue() : blue;
        return K.SassColor$rgb(t1, t2, t3, alpha == null ? this.alpha : alpha, null);
      },
      changeRgb$1$alpha: function(alpha) {
        return this.changeRgb$4$alpha$blue$green$red(alpha, null, null, null);
      },
      changeRgb$1$blue: function(blue) {
        return this.changeRgb$4$alpha$blue$green$red(null, blue, null, null);
      },
      changeRgb$1$green: function(green) {
        return this.changeRgb$4$alpha$blue$green$red(null, null, green, null);
      },
      changeRgb$1$red: function(red) {
        return this.changeRgb$4$alpha$blue$green$red(null, null, null, red);
      },
      changeRgb$3$blue$green$red: function(blue, green, red) {
        return this.changeRgb$4$alpha$blue$green$red(null, blue, green, red);
      },
      changeHsl$4$alpha$hue$lightness$saturation: function(alpha, hue, lightness, saturation) {
        var t1, t2, t3;
        t1 = hue == null ? this.get$hue() : hue;
        t2 = saturation == null ? this.get$saturation() : saturation;
        t3 = lightness == null ? this.get$lightness() : lightness;
        return K.SassColor$hsl(t1, t2, t3, alpha == null ? this.alpha : alpha);
      },
      changeHsl$3$alpha$lightness$saturation: function(alpha, lightness, saturation) {
        return this.changeHsl$4$alpha$hue$lightness$saturation(alpha, null, lightness, saturation);
      },
      changeHsl$1$hue: function(hue) {
        return this.changeHsl$4$alpha$hue$lightness$saturation(null, hue, null, null);
      },
      changeHsl$1$saturation: function(saturation) {
        return this.changeHsl$4$alpha$hue$lightness$saturation(null, null, null, saturation);
      },
      changeHsl$1$lightness: function(lightness) {
        return this.changeHsl$4$alpha$hue$lightness$saturation(null, null, lightness, null);
      },
      changeAlpha$1: function(alpha) {
        return new K.SassColor(this._red, this._green, this._blue, this._hue, this._saturation, this._lightness, T.fuzzyAssertRange(alpha, 0, 1, "alpha"), null);
      },
      plus$1: function(other) {
        var t1 = J.getInterceptor(other);
        if (!t1.$isSassNumber && !t1.$isSassColor)
          return this.super$Value$plus(other);
        throw H.wrapException(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " + " + H.S(other) + '".'));
      },
      minus$1: function(other) {
        var t1 = J.getInterceptor(other);
        if (!t1.$isSassNumber && !t1.$isSassColor)
          return this.super$Value$minus(other);
        throw H.wrapException(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " - " + H.S(other) + '".'));
      },
      dividedBy$1: function(other) {
        var t1 = J.getInterceptor(other);
        if (!t1.$isSassNumber && !t1.$isSassColor)
          return this.super$Value$dividedBy(other);
        throw H.wrapException(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " / " + H.S(other) + '".'));
      },
      modulo$1: function(other) {
        return H.throwExpression(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " % " + H.S(other) + '".'));
      },
      $eq: function(_, other) {
        var t1, t2;
        if (other == null)
          return false;
        if (other instanceof K.SassColor) {
          t1 = other.get$red();
          t2 = this.get$red();
          if (t1 == null ? t2 == null : t1 === t2) {
            t1 = other.get$green();
            t2 = this.get$green();
            if (t1 == null ? t2 == null : t1 === t2) {
              t1 = other.get$blue();
              t2 = this.get$blue();
              t1 = (t1 == null ? t2 == null : t1 === t2) && J.$eq$(other.alpha, this.alpha) === true;
            } else
              t1 = false;
          } else
            t1 = false;
        } else
          t1 = false;
        return t1;
      },
      get$hashCode: function(_) {
        return (J.get$hashCode$(this.get$red()) ^ J.get$hashCode$(this.get$green()) ^ J.get$hashCode$(this.get$blue()) ^ J.get$hashCode$(this.alpha)) >>> 0;
      },
      _rgbToHsl$0: function() {
        var t1, scaledRed, scaledGreen, scaledBlue, max, min, delta, t2, t3;
        t1 = this.get$red();
        if (typeof t1 !== "number")
          return t1.$div();
        scaledRed = t1 / 255;
        t1 = this.get$green();
        if (typeof t1 !== "number")
          return t1.$div();
        scaledGreen = t1 / 255;
        t1 = this.get$blue();
        if (typeof t1 !== "number")
          return t1.$div();
        scaledBlue = t1 / 255;
        max = Math.max(Math.max(scaledRed, scaledGreen), scaledBlue);
        min = Math.min(Math.min(scaledRed, scaledGreen), scaledBlue);
        delta = max - min;
        t1 = max === min;
        if (t1)
          this._hue = 0;
        else if (max === scaledRed)
          this._hue = C.JSDouble_methods.$mod(60 * (scaledGreen - scaledBlue) / delta, 360);
        else if (max === scaledGreen)
          this._hue = C.JSNumber_methods.$mod(120 + 60 * (scaledBlue - scaledRed) / delta, 360);
        else if (max === scaledBlue)
          this._hue = C.JSNumber_methods.$mod(240 + 60 * (scaledRed - scaledGreen) / delta, 360);
        t2 = max + min;
        t3 = 50 * t2;
        this._lightness = t3;
        if (t1)
          this._saturation = 0;
        else {
          t1 = 100 * delta;
          if (t3 < 50)
            this._saturation = t1 / t2;
          else
            this._saturation = t1 / (2 - max - min);
        }
      },
      _hslToRgb$0: function() {
        var t1, scaledHue, scaledSaturation, scaledLightness, m2, m1;
        t1 = this.get$hue();
        if (typeof t1 !== "number")
          return t1.$div();
        scaledHue = t1 / 360;
        scaledSaturation = J.$div$n(this.get$saturation(), 100);
        scaledLightness = J.$div$n(this.get$lightness(), 100);
        m2 = scaledLightness <= 0.5 ? scaledLightness * (scaledSaturation + 1) : scaledLightness + scaledSaturation - scaledLightness * scaledSaturation;
        m1 = scaledLightness * 2 - m2;
        this._red = this._hueToRgb$3(m1, m2, scaledHue + 0.3333333333333333);
        this._green = this._hueToRgb$3(m1, m2, scaledHue);
        this._blue = this._hueToRgb$3(m1, m2, scaledHue - 0.3333333333333333);
      },
      _hueToRgb$3: function(m1, m2, hue) {
        var result;
        if (hue < 0)
          ++hue;
        if (hue > 1)
          --hue;
        if (hue < 0.16666666666666666)
          result = m1 + (m2 - m1) * hue * 6;
        else if (hue < 0.5)
          result = m2;
        else
          result = hue < 0.6666666666666666 ? m1 + (m2 - m1) * (0.6666666666666666 - hue) * 6 : m1;
        return T.fuzzyRound(result * 255);
      },
      static: {
        SassColor$rgb: function(_red, _green, _blue, alpha, originalSpan) {
          var t1 = new K.SassColor(_red, _green, _blue, null, null, null, alpha == null ? 1 : T.fuzzyAssertRange(alpha, 0, 1, "alpha"), originalSpan);
          t1.SassColor$rgb$5(_red, _green, _blue, alpha, originalSpan);
          return t1;
        },
        SassColor$hsl: function(hue, saturation, lightness, alpha) {
          var t1, t2, t3;
          t1 = J.$mod$n(hue, 360);
          t2 = T.fuzzyAssertRange(saturation, 0, 100, "saturation");
          t3 = T.fuzzyAssertRange(lightness, 0, 100, "lightness");
          return new K.SassColor(null, null, null, t1, t2, t3, alpha == null ? 1 : T.fuzzyAssertRange(alpha, 0, 1, "alpha"), null);
        }
      }
    }
  }], ["", "package:sass/src/value/function.dart",, F, {
    "^": "",
    SassFunction: {
      "^": "Value;callable",
      accept$1: function(visitor) {
        return visitor.visitFunction$1(this);
      },
      assertFunction$1: function($name) {
        return this;
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        return other instanceof F.SassFunction && J.$eq$(this.callable, other.callable) === true;
      },
      get$hashCode: function(_) {
        return J.get$hashCode$(this.callable);
      }
    }
  }], ["", "package:sass/src/value/list.dart",, D, {
    "^": "",
    SassList: {
      "^": "Value;_list$_contents,separator<,hasBrackets<",
      get$isBlank: function() {
        return C.JSArray_methods.every$1(this._list$_contents, new D.SassList_isBlank_closure());
      },
      get$asList: function() {
        return this._list$_contents;
      },
      get$lengthAsList: function() {
        return this._list$_contents.length;
      },
      SassList$3$brackets: function(contents, separator, brackets) {
        if (this.separator === C.ListSeparator_undecided_null && this._list$_contents.length > 1)
          throw H.wrapException(P.ArgumentError$("A list with more than one element must have an explicit separator."));
      },
      accept$1: function(visitor) {
        return visitor.visitList$1(this);
      },
      assertMap$1: function($name) {
        return this._list$_contents.length === 0 ? C.SassMap_Map_empty : this.super$Value$assertMap($name);
      },
      $eq: function(_, other) {
        var t1, t2, t3;
        if (other == null)
          return false;
        t1 = J.getInterceptor(other);
        if (!!t1.$isSassList) {
          t2 = other.separator;
          t3 = this.separator;
          t2 = (t2 == null ? t3 == null : t2 === t3) && other.hasBrackets === this.hasBrackets && C.ListEquality_DefaultEquality.equals$2(other._list$_contents, this._list$_contents);
        } else
          t2 = false;
        if (!t2)
          t1 = this._list$_contents.length === 0 && !!t1.$isSassMap && other.get$asList().length === 0;
        else
          t1 = true;
        return t1;
      },
      get$hashCode: function(_) {
        return C.ListEquality_DefaultEquality.hash$1(this._list$_contents);
      },
      static: {
        SassList$: function(contents, separator, brackets) {
          var t1 = new D.SassList(P.List_List$unmodifiable(contents, null), separator, brackets);
          t1.SassList$3$brackets(contents, separator, brackets);
          return t1;
        }
      }
    },
    SassList_isBlank_closure: {
      "^": "Closure:0;",
      call$1: function(element) {
        return element.get$isBlank();
      }
    },
    ListSeparator: {
      "^": "Object;_list$_name,separator<",
      toString$0: function(_) {
        return this._list$_name;
      }
    }
  }], ["", "package:sass/src/value/map.dart",, A, {
    "^": "",
    SassMap: {
      "^": "Value;contents>",
      get$separator: function() {
        return C.ListSeparator_kWM;
      },
      get$asList: function() {
        var result = H.setRuntimeTypeInfo([], [F.Value]);
        this.contents.forEach$1(0, new A.SassMap_asList_closure(result));
        return result;
      },
      get$lengthAsList: function() {
        var t1 = this.contents;
        return t1.get$length(t1);
      },
      accept$1: function(visitor) {
        return visitor.visitMap$1(this);
      },
      assertMap$1: function($name) {
        return this;
      },
      $eq: function(_, other) {
        var t1, t2;
        if (other == null)
          return false;
        t1 = J.getInterceptor(other);
        if (!(!!t1.$isSassMap && C.MapEquality_DefaultEquality_DefaultEquality.equals$2(other.contents, this.contents))) {
          t2 = this.contents;
          t1 = t2.get$isEmpty(t2) === true && !!t1.$isSassList && other._list$_contents.length === 0;
        } else
          t1 = true;
        return t1;
      },
      get$hashCode: function(_) {
        var t1 = this.contents;
        return t1.get$isEmpty(t1) === true ? C.ListEquality_DefaultEquality.hash$1(C.List_empty) : C.MapEquality_DefaultEquality_DefaultEquality.hash$1(t1);
      }
    },
    SassMap_asList_closure: {
      "^": "Closure:2;result",
      call$2: function(key, value) {
        this.result.push(D.SassList$([key, value], C.ListSeparator_woc, false));
      }
    }
  }], ["", "package:sass/src/value/null.dart",, O, {
    "^": "",
    SassNull: {
      "^": "Value;",
      get$isTruthy: function() {
        return false;
      },
      get$isBlank: function() {
        return true;
      },
      accept$1: function(visitor) {
        return visitor.visitNull$1(this);
      },
      unaryNot$0: function() {
        return C.SassBoolean_true;
      }
    }
  }], ["", "package:sass/src/value/number.dart",, T, {
    "^": "",
    SassNumber: {
      "^": "Value;value<,numeratorUnits<,denominatorUnits<,asSlash<",
      get$unitString: function() {
        var t1 = this.numeratorUnits;
        return t1.length !== 0 || this.denominatorUnits.length !== 0 ? this._unitString$2(t1, this.denominatorUnits) : "";
      },
      accept$1: function(visitor) {
        return visitor.visitNumber$1(this);
      },
      withoutSlash$0: function() {
        if (this.asSlash == null)
          return this;
        return new T.SassNumber(this.value, this.numeratorUnits, this.denominatorUnits, null);
      },
      assertNumber$1: function($name) {
        return this;
      },
      assertNumber$0: function() {
        return this.assertNumber$1(null);
      },
      assertInt$1: function($name) {
        var t1, integer;
        t1 = this.value;
        integer = T.fuzzyIsInt(t1) ? J.round$0$n(t1) : null;
        if (integer != null)
          return integer;
        throw H.wrapException(this._number0$_exception$2(this.toString$0(0) + " is not an int.", $name));
      },
      assertInt$0: function() {
        return this.assertInt$1(null);
      },
      valueInRange$3: function(min, max, $name) {
        var result = T.fuzzyCheckRange(this.value, min, max);
        if (result != null)
          return result;
        throw H.wrapException(this._number0$_exception$1("Expected " + this.toString$0(0) + " to be within " + min + H.S(this.get$unitString()) + " and " + max + H.S(this.get$unitString()) + "."));
      },
      hasUnit$1: function(unit) {
        var t1 = this.numeratorUnits;
        return t1.length === 1 && this.denominatorUnits.length === 0 && J.$eq$(C.JSArray_methods.get$first(t1), unit) === true;
      },
      assertUnit$2: function(unit, $name) {
        if (this.hasUnit$1(unit))
          return;
        throw H.wrapException(this._number0$_exception$2("Expected " + this.toString$0(0) + ' to have unit "' + unit + '".', $name));
      },
      assertNoUnits$1: function($name) {
        if (!(this.numeratorUnits.length !== 0 || this.denominatorUnits.length !== 0))
          return;
        throw H.wrapException(this._number0$_exception$2("Expected " + this.toString$0(0) + " to have no units.", $name));
      },
      coerce$2: function(newNumerators, newDenominators) {
        return T.SassNumber$withUnits(this.valueInUnits$2(newNumerators, newDenominators), newDenominators, newNumerators);
      },
      valueInUnits$2: function(newNumerators, newDenominators) {
        var _box_0, t1, t2, oldNumerators, _i, oldDenominators, t3;
        _box_0 = {};
        t1 = newNumerators.length;
        if (!(t1 === 0 && newDenominators.length === 0)) {
          t2 = this.numeratorUnits;
          if (!(t2.length === 0 && this.denominatorUnits.length === 0))
            t2 = C.ListEquality_DefaultEquality.equals$2(t2, newNumerators) && C.ListEquality_DefaultEquality.equals$2(this.denominatorUnits, newDenominators);
          else
            t2 = true;
        } else
          t2 = true;
        if (t2)
          return this.value;
        _box_0.value = this.value;
        t2 = this.numeratorUnits;
        oldNumerators = H.setRuntimeTypeInfo(t2.slice(0), [H.getTypeArgumentByIndex(t2, 0)]);
        for (_i = 0; _i < t1; ++_i)
          B.removeFirstWhere(oldNumerators, new T.SassNumber_valueInUnits_closure(_box_0, this, newNumerators[_i]), new T.SassNumber_valueInUnits_closure0(this, newNumerators, newDenominators));
        t1 = this.denominatorUnits;
        oldDenominators = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
        for (t3 = newDenominators.length, _i = 0; _i < t3; ++_i)
          B.removeFirstWhere(oldDenominators, new T.SassNumber_valueInUnits_closure1(_box_0, this, newDenominators[_i]), new T.SassNumber_valueInUnits_closure2(this, newNumerators, newDenominators));
        if (oldNumerators.length !== 0 || oldDenominators.length !== 0)
          throw H.wrapException(E.SassScriptException$("Incompatible units " + H.S(this._unitString$2(t2, t1)) + " and " + H.S(this._unitString$2(newNumerators, newDenominators)) + "."));
        return _box_0.value;
      },
      isComparableTo$1: function(other) {
        var t1, exception;
        if (this.numeratorUnits.length !== 0 || this.denominatorUnits.length !== 0)
          t1 = !(other.numeratorUnits.length !== 0 || other.denominatorUnits.length !== 0);
        else
          t1 = true;
        if (t1)
          return true;
        try {
          this.greaterThan$1(other);
          return true;
        } catch (exception) {
          if (H.unwrapException(exception) instanceof E.SassScriptException)
            return false;
          else
            throw exception;
        }
      },
      greaterThan$1: function(other) {
        if (other instanceof T.SassNumber)
          return this._coerceUnits$2(other, T.number__fuzzyGreaterThan$closure()) === true ? C.SassBoolean_true : C.SassBoolean_false;
        throw H.wrapException(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " > " + H.S(other) + '".'));
      },
      greaterThanOrEquals$1: function(other) {
        if (other instanceof T.SassNumber)
          return this._coerceUnits$2(other, T.number__fuzzyGreaterThanOrEquals$closure()) === true ? C.SassBoolean_true : C.SassBoolean_false;
        throw H.wrapException(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " >= " + H.S(other) + '".'));
      },
      lessThan$1: function(other) {
        if (other instanceof T.SassNumber)
          return this._coerceUnits$2(other, T.number__fuzzyLessThan$closure()) === true ? C.SassBoolean_true : C.SassBoolean_false;
        throw H.wrapException(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " < " + H.S(other) + '".'));
      },
      lessThanOrEquals$1: function(other) {
        if (other instanceof T.SassNumber)
          return this._coerceUnits$2(other, T.number__fuzzyLessThanOrEquals$closure()) === true ? C.SassBoolean_true : C.SassBoolean_false;
        throw H.wrapException(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " <= " + H.S(other) + '".'));
      },
      modulo$1: function(other) {
        if (other instanceof T.SassNumber)
          return this._coerceNumber$2(other, new T.SassNumber_modulo_closure());
        throw H.wrapException(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " % " + H.S(other) + '".'));
      },
      plus$1: function(other) {
        var t1 = J.getInterceptor(other);
        if (!!t1.$isSassNumber)
          return this._coerceNumber$2(other, new T.SassNumber_plus_closure());
        if (!t1.$isSassColor)
          return this.super$Value$plus(other);
        throw H.wrapException(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " + " + other.toString$0(0) + '".'));
      },
      minus$1: function(other) {
        var t1 = J.getInterceptor(other);
        if (!!t1.$isSassNumber)
          return this._coerceNumber$2(other, new T.SassNumber_minus_closure());
        if (!t1.$isSassColor)
          return this.super$Value$minus(other);
        throw H.wrapException(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " - " + other.toString$0(0) + '".'));
      },
      times$1: function(other) {
        if (other instanceof T.SassNumber)
          return this._multiplyUnits$5(J.$mul$ns(this.value, other.value), this.numeratorUnits, this.denominatorUnits, other.numeratorUnits, other.denominatorUnits);
        throw H.wrapException(E.SassScriptException$('Undefined operation "' + this.toString$0(0) + " * " + H.S(other) + '".'));
      },
      dividedBy$1: function(other) {
        if (other instanceof T.SassNumber)
          return this._multiplyUnits$5(J.$div$n(this.value, other.value), this.numeratorUnits, this.denominatorUnits, other.denominatorUnits, other.numeratorUnits);
        return this.super$Value$dividedBy(other);
      },
      unaryPlus$0: function() {
        return this;
      },
      unaryMinus$0: function() {
        return T.SassNumber$withUnits(J.$negate$in(this.value), this.denominatorUnits, this.numeratorUnits);
      },
      _coerceNumber$2: function(other, operation) {
        var result, t1, t2;
        result = this._coerceUnits$2(other, operation);
        t1 = this.numeratorUnits;
        t2 = t1.length === 0;
        t1 = !t2 || this.denominatorUnits.length !== 0 ? t1 : other.numeratorUnits;
        return T.SassNumber$withUnits(result, !t2 || this.denominatorUnits.length !== 0 ? this.denominatorUnits : other.denominatorUnits, t1);
      },
      _coerceUnits$2: function(other, operation) {
        var t1, num1, num2;
        t1 = this.numeratorUnits;
        if (t1.length !== 0 || this.denominatorUnits.length !== 0) {
          num1 = this.value;
          num2 = other.valueInUnits$2(t1, this.denominatorUnits);
        } else {
          num1 = this.valueInUnits$2(other.numeratorUnits, other.denominatorUnits);
          num2 = other.value;
        }
        return operation.call$2(num1, num2);
      },
      _multiplyUnits$5: function(value, numerators1, denominators1, numerators2, denominators2) {
        var _box_0, t1, newNumerators, mutableDenominators2, _i, numerator, mutableDenominators1;
        _box_0 = {};
        _box_0.value = value;
        t1 = numerators1.length;
        if (t1 === 0) {
          if (denominators2.length === 0 && !this._areAnyConvertible$2(denominators1, numerators2))
            return T.SassNumber$withUnits(value, denominators1, numerators2);
          else if (denominators1.length === 0)
            return T.SassNumber$withUnits(value, denominators2, numerators2);
        } else if (numerators2.length === 0)
          if (denominators2.length === 0)
            return T.SassNumber$withUnits(value, denominators2, numerators1);
          else if (denominators1.length === 0 && !this._areAnyConvertible$2(numerators1, denominators2))
            return T.SassNumber$withUnits(value, denominators2, numerators1);
        newNumerators = H.setRuntimeTypeInfo([], [P.String]);
        mutableDenominators2 = H.setRuntimeTypeInfo(denominators2.slice(0), [H.getTypeArgumentByIndex(denominators2, 0)]);
        for (_i = 0; _i < t1; ++_i) {
          numerator = numerators1[_i];
          B.removeFirstWhere(mutableDenominators2, new T.SassNumber__multiplyUnits_closure(_box_0, this, numerator), new T.SassNumber__multiplyUnits_closure0(newNumerators, numerator));
        }
        mutableDenominators1 = H.setRuntimeTypeInfo(denominators1.slice(0), [H.getTypeArgumentByIndex(denominators1, 0)]);
        for (t1 = numerators2.length, _i = 0; _i < t1; ++_i) {
          numerator = numerators2[_i];
          B.removeFirstWhere(mutableDenominators1, new T.SassNumber__multiplyUnits_closure1(_box_0, this, numerator), new T.SassNumber__multiplyUnits_closure2(newNumerators, numerator));
        }
        t1 = _box_0.value;
        C.JSArray_methods.addAll$1(mutableDenominators1, mutableDenominators2);
        return T.SassNumber$withUnits(t1, mutableDenominators1, newNumerators);
      },
      _areAnyConvertible$2: function(units1, units2) {
        return C.JSArray_methods.any$1(units1, new T.SassNumber__areAnyConvertible_closure(this, units2));
      },
      _conversionFactor$2: function(unit1, unit2) {
        var innerMap;
        if (J.$eq$(unit1, unit2) === true)
          return 1;
        innerMap = $.$get$_conversions().$index(0, unit1);
        if (innerMap == null)
          return;
        return innerMap.$index(0, unit2);
      },
      _unitString$2: function(numerators, denominators) {
        var t1;
        if (numerators.length === 0) {
          t1 = denominators.length;
          if (t1 === 0)
            return "no units";
          if (t1 === 1)
            return J.$add$ansx(C.JSArray_methods.get$single(denominators), "^-1");
          return "(" + C.JSArray_methods.join$1(denominators, "*") + ")^-1";
        }
        if (denominators.length === 0)
          return C.JSArray_methods.join$1(numerators, "*");
        return C.JSArray_methods.join$1(numerators, "*") + "/" + C.JSArray_methods.join$1(denominators, "*");
      },
      $eq: function(_, other) {
        var t1, t2, t3, exception;
        if (other == null)
          return false;
        if (other instanceof T.SassNumber) {
          t1 = this.numeratorUnits.length === 0;
          t2 = !t1 || this.denominatorUnits.length !== 0;
          t3 = other;
          if (t2 !== (t3.get$numeratorUnits().length !== 0 || t3.get$denominatorUnits().length !== 0))
            return false;
          if (!(!t1 || this.denominatorUnits.length !== 0))
            return J.$lt$n(J.abs$0$in(J.$sub$n(this.value, other.get$value())), $.$get$epsilon());
          try {
            t1 = this._coerceUnits$2(other, T.number__fuzzyEquals$closure());
            return t1;
          } catch (exception) {
            if (H.unwrapException(exception) instanceof E.SassScriptException)
              return false;
            else
              throw exception;
          }
        } else
          return false;
      },
      get$hashCode: function(_) {
        var t1, t2, remainder, truncated;
        t1 = J.$div$n(J.$mul$ns(this.value, this._canonicalMultiplier$1(this.numeratorUnits)), this._canonicalMultiplier$1(this.denominatorUnits));
        t2 = $.$get$epsilon();
        if (typeof t2 !== "number")
          return H.iae(t2);
        remainder = C.JSNumber_methods.$mod(t1, t2);
        truncated = t1 - remainder;
        t1 = $.$get$_epsilonOver2();
        if (typeof t1 !== "number")
          return H.iae(t1);
        if (remainder >= t1)
          truncated += t2;
        return truncated & 0x1FFFFFFF;
      },
      _canonicalMultiplier$1: function(units) {
        return C.JSArray_methods.fold$2(units, 1, new T.SassNumber__canonicalMultiplier_closure());
      },
      _number0$_exception$2: function(message, $name) {
        return new E.SassScriptException($name == null ? message : "$" + $name + ": " + message);
      },
      _number0$_exception$1: function(message) {
        return this._number0$_exception$2(message, null);
      },
      static: {
        SassNumber$withUnits: function(value, denominatorUnits, numeratorUnits) {
          var t1 = numeratorUnits == null ? C.List_empty : P.List_List$unmodifiable(numeratorUnits, null);
          return new T.SassNumber(value, t1, denominatorUnits == null ? C.List_empty : P.List_List$unmodifiable(denominatorUnits, null), null);
        }
      }
    },
    SassNumber_valueInUnits_closure: {
      "^": "Closure:0;_box_0,$this,newNumerator",
      call$1: function(oldNumerator) {
        var factor, t1;
        factor = this.$this._conversionFactor$2(this.newNumerator, oldNumerator);
        if (factor == null)
          return false;
        t1 = this._box_0;
        t1.value = J.$mul$ns(t1.value, factor);
        return true;
      }
    },
    SassNumber_valueInUnits_closure0: {
      "^": "Closure:1;$this,newNumerators,newDenominators",
      call$0: function() {
        var t1 = this.$this;
        throw H.wrapException(E.SassScriptException$("Incompatible units " + H.S(t1._unitString$2(t1.numeratorUnits, t1.denominatorUnits)) + " and " + H.S(t1._unitString$2(this.newNumerators, this.newDenominators)) + "."));
      }
    },
    SassNumber_valueInUnits_closure1: {
      "^": "Closure:0;_box_0,$this,newDenominator",
      call$1: function(oldDenominator) {
        var factor, t1;
        factor = this.$this._conversionFactor$2(this.newDenominator, oldDenominator);
        if (factor == null)
          return false;
        t1 = this._box_0;
        t1.value = J.$div$n(t1.value, factor);
        return true;
      }
    },
    SassNumber_valueInUnits_closure2: {
      "^": "Closure:1;$this,newNumerators,newDenominators",
      call$0: function() {
        var t1 = this.$this;
        throw H.wrapException(E.SassScriptException$("Incompatible units " + H.S(t1._unitString$2(t1.numeratorUnits, t1.denominatorUnits)) + " and " + H.S(t1._unitString$2(this.newNumerators, this.newDenominators)) + "."));
      }
    },
    SassNumber_modulo_closure: {
      "^": "Closure:2;",
      call$2: function(num1, num2) {
        var t1, result;
        t1 = J.getInterceptor$n(num2);
        if (t1.$gt(num2, 0))
          return J.$mod$n(num1, num2);
        if (t1.$eq(num2, 0) === true)
          return 0 / 0;
        result = J.$mod$n(num1, num2);
        if (result === 0)
          t1 = 0;
        else {
          if (typeof num2 !== "number")
            return H.iae(num2);
          t1 = result + num2;
        }
        return t1;
      }
    },
    SassNumber_plus_closure: {
      "^": "Closure:2;",
      call$2: function(num1, num2) {
        return J.$add$ansx(num1, num2);
      }
    },
    SassNumber_minus_closure: {
      "^": "Closure:2;",
      call$2: function(num1, num2) {
        return J.$sub$n(num1, num2);
      }
    },
    SassNumber__multiplyUnits_closure: {
      "^": "Closure:0;_box_0,$this,numerator",
      call$1: function(denominator) {
        var factor, t1;
        factor = this.$this._conversionFactor$2(this.numerator, denominator);
        if (factor == null)
          return false;
        t1 = this._box_0;
        t1.value = J.$div$n(t1.value, factor);
        return true;
      }
    },
    SassNumber__multiplyUnits_closure0: {
      "^": "Closure:1;newNumerators,numerator",
      call$0: function() {
        this.newNumerators.push(this.numerator);
      }
    },
    SassNumber__multiplyUnits_closure1: {
      "^": "Closure:0;_box_0,$this,numerator",
      call$1: function(denominator) {
        var factor, t1;
        factor = this.$this._conversionFactor$2(this.numerator, denominator);
        if (factor == null)
          return false;
        t1 = this._box_0;
        t1.value = J.$div$n(t1.value, factor);
        return true;
      }
    },
    SassNumber__multiplyUnits_closure2: {
      "^": "Closure:1;newNumerators,numerator",
      call$0: function() {
        this.newNumerators.push(this.numerator);
      }
    },
    SassNumber__areAnyConvertible_closure: {
      "^": "Closure:0;$this,units2",
      call$1: function(unit1) {
        var t1 = $.$get$_conversions();
        if (!t1.containsKey$1(unit1))
          return C.JSArray_methods.contains$1(this.units2, unit1);
        return C.JSArray_methods.any$1(this.units2, t1.$index(0, unit1).get$containsKey());
      }
    },
    SassNumber__canonicalMultiplier_closure: {
      "^": "Closure:2;",
      call$2: function(multiplier, unit) {
        var innerMap, t1;
        innerMap = $.$get$_conversions().$index(0, unit);
        if (innerMap == null)
          t1 = multiplier;
        else {
          t1 = innerMap.get$values();
          t1 = J.$div$n(multiplier, t1.get$first(t1));
        }
        return t1;
      }
    }
  }], ["", "package:sass/src/value/string.dart",, D, {
    "^": "",
    SassString: {
      "^": "Value;text<,hasQuotes<,_sassLength",
      get$sassLength: function() {
        var t1 = this._sassLength;
        if (t1 == null) {
          t1 = J.get$runes$s(this.text);
          t1 = t1.get$length(t1);
          this._sassLength = t1;
        }
        return t1;
      },
      get$isSpecialNumber: function() {
        var t1, t2, t3;
        if (this.hasQuotes)
          return false;
        t1 = this.text;
        t2 = J.getInterceptor$asx(t1);
        if (J.$lt$n(t2.get$length(t1), 7))
          return false;
        t3 = t2.codeUnitAt$1(t1, 0) | 32;
        if (t3 === 99) {
          if ((t2.codeUnitAt$1(t1, 1) | 32) !== 97)
            return false;
          if ((t2.codeUnitAt$1(t1, 2) | 32) !== 108)
            return false;
          if ((t2.codeUnitAt$1(t1, 3) | 32) !== 99)
            return false;
          return t2.codeUnitAt$1(t1, 4) === 40;
        } else if (t3 === 118) {
          if ((t2.codeUnitAt$1(t1, 1) | 32) !== 97)
            return false;
          if ((t2.codeUnitAt$1(t1, 2) | 32) !== 114)
            return false;
          return t2.codeUnitAt$1(t1, 3) === 40;
        } else
          return false;
      },
      get$isVar: function() {
        var t1, t2;
        if (this.hasQuotes)
          return false;
        t1 = this.text;
        t2 = J.getInterceptor$asx(t1);
        if (J.$lt$n(t2.get$length(t1), 8))
          return false;
        return (t2.codeUnitAt$1(t1, 0) | 32) === 118 && (t2.codeUnitAt$1(t1, 1) | 32) === 97 && (t2.codeUnitAt$1(t1, 2) | 32) === 114 && t2.codeUnitAt$1(t1, 3) === 40;
      },
      get$isBlank: function() {
        return !this.hasQuotes && J.get$isEmpty$asx(this.text) === true;
      },
      accept$1: function(visitor) {
        return visitor.visitString$1(this);
      },
      assertString$1: function($name) {
        return this;
      },
      plus$1: function(other) {
        var t1, t2;
        t1 = this.text;
        t2 = this.hasQuotes;
        if (other instanceof D.SassString)
          return new D.SassString(J.$add$ansx(t1, other.text), t2, null);
        else
          return new D.SassString(J.$add$ansx(t1, other.toCssString$0()), t2, null);
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        return other instanceof D.SassString && J.$eq$(this.text, other.text) === true;
      },
      get$hashCode: function(_) {
        return J.get$hashCode$(this.text);
      },
      static: {
        SassString$: function(text, quotes) {
          return new D.SassString(text, quotes, null);
        }
      }
    }
  }], ["", "package:sass/src/visitor/async_evaluate.dart",, E, {
    "^": "",
    evaluateAsync: function(stylesheet, functions, importCache, importer, logger, nodeImporter, sourceMap, variables) {
      return E._EvaluateVisitor$0(functions, importCache, importer, logger, nodeImporter, sourceMap, variables).run$1(0, stylesheet);
    },
    _EvaluateVisitor0: {
      "^": "Object;_async_evaluate$_importCache,_async_evaluate$_nodeImporter,_async_evaluate$_logger,_async_evaluate$_sourceMap,_async_evaluate$_environment,_async_evaluate$_importer,_async_evaluate$_baseUrl,_async_evaluate$_styleRule,_async_evaluate$_mediaQueries,_async_evaluate$_root,_async_evaluate$_parent,_async_evaluate$_declarationName,_async_evaluate$_member,_async_evaluate$_callableSpan,_async_evaluate$_inFunction,_async_evaluate$_inUnknownAtRule,_async_evaluate$_atRootExcludingStyleRule,_async_evaluate$_inKeyframes,_async_evaluate$_endOfImports,_async_evaluate$_outOfOrderImports,_async_evaluate$_includedFiles,_async_evaluate$_activeImports,_async_evaluate$_extender,_async_evaluate$_stack",
      _EvaluateVisitor$7$functions$importCache$importer$logger$nodeImporter$sourceMap$variables0: function(functions, importCache, importer, logger, nodeImporter, sourceMap, variables) {
        var t1, t2, t3, t4, t5, t6, _i, $function, $name;
        t1 = this._async_evaluate$_environment;
        t2 = C.JSString_methods.get$codeUnits("($name)");
        t3 = [P.int];
        t4 = H.setRuntimeTypeInfo([0], t3);
        t4 = new Y.SourceFile(null, t4, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
        t4.SourceFile$decoded$2$url(t2, null);
        t2 = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t4, null, null, "($name)", 0, null, null), C.StderrLogger_false).parseArgumentDeclaration$0();
        t4 = [[S.Tuple2, B.ArgumentDeclaration, {func: 1, ret: F.Value, args: [[P.List, F.Value]]}]];
        t5 = H.setRuntimeTypeInfo([], t4);
        t6 = [null, null];
        t5.push(new S.Tuple2(t2, new E._EvaluateVisitor_closure6(this), t6));
        t1.setFunction$1(new Q.BuiltInCallable("global-variable-exists", t5));
        t5 = this._async_evaluate$_environment;
        t1 = C.JSString_methods.get$codeUnits("($name)");
        t2 = H.setRuntimeTypeInfo([0], t3);
        t2 = new Y.SourceFile(null, t2, new Uint32Array(H._ensureNativeList(t1.toList$0(t1))), null);
        t2.SourceFile$decoded$2$url(t1, null);
        t1 = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t2, null, null, "($name)", 0, null, null), C.StderrLogger_false).parseArgumentDeclaration$0();
        t2 = H.setRuntimeTypeInfo([], t4);
        t2.push(new S.Tuple2(t1, new E._EvaluateVisitor_closure7(this), t6));
        t5.setFunction$1(new Q.BuiltInCallable("variable-exists", t2));
        t2 = this._async_evaluate$_environment;
        t5 = C.JSString_methods.get$codeUnits("($name)");
        t1 = H.setRuntimeTypeInfo([0], t3);
        t1 = new Y.SourceFile(null, t1, new Uint32Array(H._ensureNativeList(t5.toList$0(t5))), null);
        t1.SourceFile$decoded$2$url(t5, null);
        t1 = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t1, null, null, "($name)", 0, null, null), C.StderrLogger_false).parseArgumentDeclaration$0();
        t5 = H.setRuntimeTypeInfo([], t4);
        t5.push(new S.Tuple2(t1, new E._EvaluateVisitor_closure8(this), t6));
        t2.setFunction$1(new Q.BuiltInCallable("function-exists", t5));
        t5 = this._async_evaluate$_environment;
        t2 = C.JSString_methods.get$codeUnits("($name)");
        t1 = H.setRuntimeTypeInfo([0], t3);
        t1 = new Y.SourceFile(null, t1, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
        t1.SourceFile$decoded$2$url(t2, null);
        t1 = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t1, null, null, "($name)", 0, null, null), C.StderrLogger_false).parseArgumentDeclaration$0();
        t2 = H.setRuntimeTypeInfo([], t4);
        t2.push(new S.Tuple2(t1, new E._EvaluateVisitor_closure9(this), t6));
        t5.setFunction$1(new Q.BuiltInCallable("mixin-exists", t2));
        t2 = this._async_evaluate$_environment;
        t5 = C.JSString_methods.get$codeUnits("()");
        t1 = H.setRuntimeTypeInfo([0], t3);
        t1 = new Y.SourceFile(null, t1, new Uint32Array(H._ensureNativeList(t5.toList$0(t5))), null);
        t1.SourceFile$decoded$2$url(t5, null);
        t1 = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t1, null, null, "()", 0, null, null), C.StderrLogger_false).parseArgumentDeclaration$0();
        t5 = H.setRuntimeTypeInfo([], t4);
        t5.push(new S.Tuple2(t1, new E._EvaluateVisitor_closure10(this), t6));
        t2.setFunction$1(new Q.BuiltInCallable("content-exists", t5));
        t5 = this._async_evaluate$_environment;
        t2 = C.JSString_methods.get$codeUnits("($name, $css: false)");
        t1 = H.setRuntimeTypeInfo([0], t3);
        t1 = new Y.SourceFile(null, t1, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
        t1.SourceFile$decoded$2$url(t2, null);
        t1 = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t1, null, null, "($name, $css: false)", 0, null, null), C.StderrLogger_false).parseArgumentDeclaration$0();
        t4 = H.setRuntimeTypeInfo([], t4);
        t4.push(new S.Tuple2(t1, new E._EvaluateVisitor_closure11(this), t6));
        t5.setFunction$1(new Q.BuiltInCallable("get-function", t4));
        t4 = this._async_evaluate$_environment;
        t5 = C.JSString_methods.get$codeUnits("($function, $args...)");
        t3 = H.setRuntimeTypeInfo([0], t3);
        t1 = new Y.SourceFile(null, t3, new Uint32Array(H._ensureNativeList(t5.toList$0(t5))), null);
        t1.SourceFile$decoded$2$url(t5, null);
        t1 = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t1, null, null, "($function, $args...)", 0, null, null), C.StderrLogger_false).parseArgumentDeclaration$0();
        t2 = new S.AsyncBuiltInCallable("call", H.setRuntimeTypeInfo([], [[S.Tuple2, B.ArgumentDeclaration, {func: 1, args: [[P.List, F.Value]]}]]));
        t2.AsyncBuiltInCallable$parsed$3("call", t1, new E._EvaluateVisitor_closure12(this));
        t4.setFunction$1(t2);
        t1 = functions == null ? C.List_empty4 : functions;
        t2 = t1.length;
        _i = 0;
        for (; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          $function = t1[_i];
          this._async_evaluate$_environment.setFunction$1($function);
        }
        _i = 0;
        for (; false; ++_i) {
          if (_i >= 0)
            return H.ioore(C.List_empty0, _i);
          $name = C.List_empty0[_i];
          this._async_evaluate$_environment.setVariable$4$global($name, C.JSNull_methods.$index(variables, $name), null, true);
        }
      },
      run$1: function(_, node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(E.EvaluateResult), $async$returnValue, $async$self = this, t1, t2;
        var $async$run$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = node.get$span();
                t1 = t1 == null ? null : t1.get$sourceUrl();
                $async$self._async_evaluate$_baseUrl = t1;
                if (t1 != null)
                  if ($async$self._async_evaluate$_nodeImporter != null)
                    if (t1.get$scheme() === "file") {
                      t1 = D.p();
                      t2 = $async$self._async_evaluate$_baseUrl;
                      $async$self._async_evaluate$_includedFiles.add$1(0, t1.style.pathFromUri$1(M._parseUri(t2)));
                    } else if (J.$eq$(J.toString$0$($async$self._async_evaluate$_baseUrl), "stdin") !== true)
                      $async$self._async_evaluate$_includedFiles.add$1(0, J.toString$0$($async$self._async_evaluate$_baseUrl));
                $async$goto = 3;
                return P._asyncAwait($async$self.visitStylesheet$1(node), $async$run$1);
              case 3:
                // returning from await.
                $async$returnValue = new E.EvaluateResult($async$self._async_evaluate$_root, $async$self._async_evaluate$_includedFiles);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$run$1, $async$completer);
      },
      visitStylesheet$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, t1;
        var $async$visitStylesheet$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = [];
                t1 = new V.CssStylesheet(node.get$span(), new P.UnmodifiableListView(t1, [B.CssNode]), t1, null, null, false);
                $async$self._async_evaluate$_root = t1;
                $async$self._async_evaluate$_parent = t1;
                t1 = J.get$iterator$ax(node.get$children());
              case 3:
                // for condition
                if (!t1.moveNext$0()) {
                  // goto after for
                  $async$goto = 4;
                  break;
                }
                $async$goto = 5;
                return P._asyncAwait(t1.get$current(t1).accept$1($async$self), $async$visitStylesheet$1);
              case 5:
                // returning from await.
                // goto for condition
                $async$goto = 3;
                break;
              case 4:
                // after for
                if ($async$self._async_evaluate$_outOfOrderImports.length !== 0)
                  new E._EvaluateVisitor_visitStylesheet_closure0($async$self).call$1($async$self._async_evaluate$_root._children);
                $async$self._async_evaluate$_extender.finalize$0();
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitStylesheet$1, $async$completer);
      },
      visitAtRootRule$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, t1, resolved, query, $parent, included, root, innerCopy, outerCopy, copy;
        var $async$visitAtRootRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = node.query;
                $async$goto = t1 != null ? 3 : 5;
                break;
              case 3:
                // then
                $async$goto = 6;
                return P._asyncAwait($async$self._async_evaluate$_performInterpolation$2$warnForColor(t1, true), $async$visitAtRootRule$1);
              case 6:
                // returning from await.
                resolved = $async$result;
                query = $async$self._async_evaluate$_adjustParseError$2(t1.span, new E._EvaluateVisitor_visitAtRootRule_closure2($async$self, resolved));
                // goto join
                $async$goto = 4;
                break;
              case 5:
                // else
                query = C.AtRootQuery_UsS;
              case 4:
                // join
                $parent = $async$self._async_evaluate$_parent;
                included = H.setRuntimeTypeInfo([], [B.CssParentNode]);
                for (; !($parent instanceof V.CssStylesheet);) {
                  if (!query.excludes$1($parent))
                    included.push($parent);
                  $parent = $parent._node0$_parent;
                }
                root = $async$self._async_evaluate$_trimIncluded$1(included);
                t1 = $async$self._async_evaluate$_parent;
                $async$goto = (root == null ? t1 == null : root === t1) ? 7 : 8;
                break;
              case 7:
                // then
                $async$goto = 9;
                return P._asyncAwait($async$self._async_evaluate$_environment.scope$2$when(new E._EvaluateVisitor_visitAtRootRule_closure3($async$self, node), node.hasDeclarations), $async$visitAtRootRule$1);
              case 9:
                // returning from await.
                // goto return
                $async$goto = 1;
                break;
              case 8:
                // join
                innerCopy = included.length === 0 ? null : C.JSArray_methods.get$first(included).copyWithoutChildren$0();
                for (t1 = H.SubListIterable$(included, 1, null, H.getTypeArgumentByIndex(included, 0)), t1 = new H.ListIterator(t1, t1.get$length(t1), 0, null, [H.getTypeArgumentByIndex(t1, 0)]), outerCopy = innerCopy; t1.moveNext$0(); outerCopy = copy) {
                  copy = t1.__internal$_current.copyWithoutChildren$0();
                  copy.addChild$1(outerCopy);
                }
                if (outerCopy != null)
                  root.addChild$1(outerCopy);
                $async$goto = 10;
                return P._asyncAwait($async$self._async_evaluate$_scopeForAtRoot$4(node, innerCopy == null ? root : innerCopy, query, included).call$1(new E._EvaluateVisitor_visitAtRootRule_closure4($async$self, node)), $async$visitAtRootRule$1);
              case 10:
                // returning from await.
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitAtRootRule$1, $async$completer);
      },
      _async_evaluate$_trimIncluded$1: function(nodes) {
        var t1, $parent, innermostContiguous, i, t2, root;
        t1 = nodes.length;
        if (t1 === 0)
          return this._async_evaluate$_root;
        $parent = this._async_evaluate$_parent;
        for (innermostContiguous = null, i = 0; i < t1; ++i) {
          for (; t2 = nodes[i], $parent == null ? t2 != null : $parent !== t2; innermostContiguous = null)
            $parent = $parent._node0$_parent;
          if (innermostContiguous == null)
            innermostContiguous = i;
          $parent = $parent._node0$_parent;
        }
        t2 = this._async_evaluate$_root;
        if ($parent == null ? t2 != null : $parent !== t2)
          return t2;
        if (innermostContiguous >>> 0 !== innermostContiguous || innermostContiguous >= t1)
          return H.ioore(nodes, innermostContiguous);
        root = nodes[innermostContiguous];
        C.JSArray_methods.removeRange$2(nodes, innermostContiguous, t1);
        return root;
      },
      _async_evaluate$_scopeForAtRoot$4: function(node, newParent, query, included) {
        var scope = new E._EvaluateVisitor__scopeForAtRoot_closure5(this, newParent, node);
        if (query.get$excludesStyleRules())
          scope = new E._EvaluateVisitor__scopeForAtRoot_closure6(this, scope);
        if (query.get$excludesMedia())
          scope = new E._EvaluateVisitor__scopeForAtRoot_closure7(this, scope);
        if (this._async_evaluate$_inKeyframes && query.excludesName$1("keyframes"))
          scope = new E._EvaluateVisitor__scopeForAtRoot_closure8(this, scope);
        return this._async_evaluate$_inUnknownAtRule && !C.JSArray_methods.any$1(included, new E._EvaluateVisitor__scopeForAtRoot_closure9()) ? new E._EvaluateVisitor__scopeForAtRoot_closure10(this, scope) : scope;
      },
      visitContentRule$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, block;
        var $async$visitContentRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                block = $async$self._async_evaluate$_environment.get$contentBlock();
                if (block == null) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 3;
                return P._asyncAwait($async$self._async_evaluate$_withStackFrame$3("@content", node.span, new E._EvaluateVisitor_visitContentRule_closure0($async$self, block)), $async$visitContentRule$1);
              case 3:
                // returning from await.
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitContentRule$1, $async$completer);
      },
      visitDebugRule$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, value, t1;
        var $async$visitDebugRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 3;
                return P._asyncAwait(node.expression.accept$1($async$self), $async$visitDebugRule$1);
              case 3:
                // returning from await.
                value = $async$result;
                t1 = J.getInterceptor(value);
                t1 = !!t1.$isSassString ? value.text : t1.toString$0(value);
                $async$self._async_evaluate$_logger.debug$2(t1, node.span);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitDebugRule$1, $async$completer);
      },
      visitDeclaration$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, $name, t1, cssValue, oldDeclarationName, $async$temp1;
        var $async$visitDeclaration$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if (!($async$self._async_evaluate$_styleRule != null && !$async$self._async_evaluate$_atRootExcludingStyleRule) && !$async$self._async_evaluate$_inUnknownAtRule && !$async$self._async_evaluate$_inKeyframes)
                  throw H.wrapException($async$self._async_evaluate$_exception$2("Declarations may only be used within style rules.", node.get$span()));
                $async$goto = 3;
                return P._asyncAwait($async$self._async_evaluate$_interpolationToValue$2$warnForColor(node.get$name(), true), $async$visitDeclaration$1);
              case 3:
                // returning from await.
                $name = $async$result;
                t1 = $async$self._async_evaluate$_declarationName;
                if (t1 != null)
                  $name = new F.CssValue(H.S(t1) + "-" + H.S($name.get$value()), $name.get$span(), [null]);
                $async$goto = node.get$value() == null ? 4 : 6;
                break;
              case 4:
                // then
                $async$result = null;
                // goto join
                $async$goto = 5;
                break;
              case 6:
                // else
                $async$temp1 = F;
                $async$goto = 7;
                return P._asyncAwait(node.get$value().accept$1($async$self), $async$visitDeclaration$1);
              case 7:
                // returning from await.
                $async$result = new $async$temp1.CssValue($async$result, node.get$value().get$span(), [null]);
              case 5:
                // join
                cssValue = $async$result;
                if (cssValue != null)
                  t1 = !cssValue.value.get$isBlank() || cssValue.value.get$asList().length === 0;
                else
                  t1 = false;
                if (t1)
                  $async$self._async_evaluate$_parent.addChild$1(L.CssDeclaration$($name, cssValue, node.get$span(), $async$self._async_evaluate$_expressionSpan$1(node.get$value())));
                else if (J.startsWith$1$s($name.get$value(), "--"))
                  throw H.wrapException($async$self._async_evaluate$_exception$2("Custom property values may not be empty.", node.get$value().get$span()));
                $async$goto = node.get$children() != null ? 8 : 9;
                break;
              case 8:
                // then
                oldDeclarationName = $async$self._async_evaluate$_declarationName;
                $async$self._async_evaluate$_declarationName = $name.get$value();
                $async$goto = 10;
                return P._asyncAwait($async$self._async_evaluate$_environment.scope$2$when(new E._EvaluateVisitor_visitDeclaration_closure0($async$self, node), node.get$hasDeclarations()), $async$visitDeclaration$1);
              case 10:
                // returning from await.
                $async$self._async_evaluate$_declarationName = oldDeclarationName;
              case 9:
                // join
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitDeclaration$1, $async$completer);
      },
      visitEachRule$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, t1, list, span, setVariables;
        var $async$visitEachRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = node.list;
                $async$goto = 3;
                return P._asyncAwait(t1.accept$1($async$self), $async$visitEachRule$1);
              case 3:
                // returning from await.
                list = $async$result;
                span = $async$self._async_evaluate$_expressionSpan$1(t1);
                setVariables = node.variables.length === 1 ? new E._EvaluateVisitor_visitEachRule_closure2($async$self, node, span) : new E._EvaluateVisitor_visitEachRule_closure3($async$self, node, span);
                $async$returnValue = $async$self._async_evaluate$_environment.scope$2$semiGlobal(new E._EvaluateVisitor_visitEachRule_closure4($async$self, list, setVariables, node), true);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitEachRule$1, $async$completer);
      },
      _async_evaluate$_setMultipleVariables$3: function(variables, value, span) {
        var list, t1, minLength, i, t2, t3;
        list = value.get$asList();
        t1 = variables.length;
        minLength = Math.min(t1, list.length);
        for (i = 0; i < minLength; ++i) {
          t2 = this._async_evaluate$_environment;
          if (i >= t1)
            return H.ioore(variables, i);
          t3 = variables[i];
          if (i >= list.length)
            return H.ioore(list, i);
          t2.setLocalVariable$3(t3, list[i].withoutSlash$0(), span);
        }
        for (i = minLength; i < t1; ++i) {
          t2 = this._async_evaluate$_environment;
          if (i >>> 0 !== i || i >= t1)
            return H.ioore(variables, i);
          t2.setLocalVariable$3(variables[i], C.C_SassNull, span);
        }
      },
      visitErrorRule$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$self = this, $async$temp1, $async$temp2;
        var $async$visitErrorRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$temp1 = H;
                $async$temp2 = J;
                $async$goto = 2;
                return P._asyncAwait(node.expression.accept$1($async$self), $async$visitErrorRule$1);
              case 2:
                // returning from await.
                throw $async$temp1.wrapException($async$self._async_evaluate$_exception$2($async$temp2.toString$0$($async$result), node.span));
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitErrorRule$1, $async$completer);
      },
      visitExtendRule$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, targetText, target;
        var $async$visitExtendRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if (!($async$self._async_evaluate$_styleRule != null && !$async$self._async_evaluate$_atRootExcludingStyleRule) || $async$self._async_evaluate$_declarationName != null)
                  throw H.wrapException($async$self._async_evaluate$_exception$2("@extend may only be used within style rules.", node.span));
                $async$goto = 3;
                return P._asyncAwait($async$self._async_evaluate$_interpolationToValue$2$warnForColor(node.selector, true), $async$visitExtendRule$1);
              case 3:
                // returning from await.
                targetText = $async$result;
                target = $async$self._async_evaluate$_adjustParseError$2(targetText.get$span(), new E._EvaluateVisitor_visitExtendRule_closure0($async$self, targetText));
                $async$self._async_evaluate$_extender.addExtension$4($async$self._async_evaluate$_styleRule.selector, target, node, $async$self._async_evaluate$_mediaQueries);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitExtendRule$1, $async$completer);
      },
      visitAtRule$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, value, t1, wasInKeyframes, wasInUnknownAtRule;
        var $async$visitAtRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if ($async$self._async_evaluate$_declarationName != null)
                  throw H.wrapException($async$self._async_evaluate$_exception$2("At-rules may not be used within nested declarations.", node.get$span()));
                $async$goto = node.get$value() == null ? 3 : 5;
                break;
              case 3:
                // then
                $async$result = null;
                // goto join
                $async$goto = 4;
                break;
              case 5:
                // else
                $async$goto = 6;
                return P._asyncAwait($async$self._async_evaluate$_interpolationToValue$3$trim$warnForColor(node.get$value(), true, true), $async$visitAtRule$1);
              case 6:
                // returning from await.
              case 4:
                // join
                value = $async$result;
                if (node.get$children() == null) {
                  t1 = [];
                  $async$self._async_evaluate$_parent.addChild$1(new U.CssAtRule(node.get$name(), value, true, node.get$span(), new P.UnmodifiableListView(t1, [B.CssNode]), t1, null, null, false));
                  // goto return
                  $async$goto = 1;
                  break;
                }
                wasInKeyframes = $async$self._async_evaluate$_inKeyframes;
                wasInUnknownAtRule = $async$self._async_evaluate$_inUnknownAtRule;
                if (node.get$normalizedName() === "keyframes")
                  $async$self._async_evaluate$_inKeyframes = true;
                else
                  $async$self._async_evaluate$_inUnknownAtRule = true;
                t1 = [];
                $async$goto = 7;
                return P._asyncAwait($async$self._async_evaluate$_withParent$4$scopeWhen$through(new U.CssAtRule(node.get$name(), value, false, node.get$span(), new P.UnmodifiableListView(t1, [B.CssNode]), t1, null, null, false), new E._EvaluateVisitor_visitAtRule_closure1($async$self, node), node.get$hasDeclarations(), new E._EvaluateVisitor_visitAtRule_closure2()), $async$visitAtRule$1);
              case 7:
                // returning from await.
                $async$self._async_evaluate$_inUnknownAtRule = wasInUnknownAtRule;
                $async$self._async_evaluate$_inKeyframes = wasInKeyframes;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitAtRule$1, $async$completer);
      },
      visitForRule$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, t1, t2, fromNumber, t3, toNumber, from, to, direction;
        var $async$visitForRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = {};
                t2 = node.from;
                $async$goto = 3;
                return P._asyncAwait($async$self._addExceptionSpanAsync$2(t2.get$span(), new E._EvaluateVisitor_visitForRule_closure4($async$self, node)), $async$visitForRule$1);
              case 3:
                // returning from await.
                fromNumber = $async$result;
                t3 = node.to;
                $async$goto = 4;
                return P._asyncAwait($async$self._addExceptionSpanAsync$2(t3.get$span(), new E._EvaluateVisitor_visitForRule_closure5($async$self, node)), $async$visitForRule$1);
              case 4:
                // returning from await.
                toNumber = $async$result;
                from = $async$self._async_evaluate$_addExceptionSpan$2(t2.get$span(), new E._EvaluateVisitor_visitForRule_closure6(fromNumber, toNumber));
                to = $async$self._async_evaluate$_addExceptionSpan$2(t3.get$span(), new E._EvaluateVisitor_visitForRule_closure7(toNumber));
                t1.to = to;
                t2 = J.getInterceptor$n(from);
                direction = t2.$gt(from, to) ? -1 : 1;
                if (node.isExclusive !== true) {
                  to = J.$add$ansx(to, direction);
                  t1.to = to;
                  t3 = to;
                } else
                  t3 = to;
                if (t2.$eq(from, t3) === true) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$returnValue = $async$self._async_evaluate$_environment.scope$2$semiGlobal(new E._EvaluateVisitor_visitForRule_closure8(t1, $async$self, node, from, direction), true);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitForRule$1, $async$completer);
      },
      visitFunctionRule$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, t1;
        var $async$visitFunctionRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self._async_evaluate$_environment;
                t1.setFunction$1(new E.UserDefinedCallable(node, t1.closure$0(), [null]));
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitFunctionRule$1, $async$completer);
      },
      visitIfRule$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, _box_0, t1, t2, _i, clauseToCheck;
        var $async$visitIfRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                _box_0 = {};
                _box_0.clause = node.lastClause;
                t1 = node.clauses, t2 = t1.length, _i = 0;
              case 3:
                // for condition
                if (!(_i < t2)) {
                  // goto after for
                  $async$goto = 5;
                  break;
                }
                clauseToCheck = t1[_i];
                $async$goto = 6;
                return P._asyncAwait(clauseToCheck.get$expression().accept$1($async$self), $async$visitIfRule$1);
              case 6:
                // returning from await.
                if ($async$result.get$isTruthy()) {
                  _box_0.clause = clauseToCheck;
                  // goto after for
                  $async$goto = 5;
                  break;
                }
              case 4:
                // for update
                ++_i;
                // goto for condition
                $async$goto = 3;
                break;
              case 5:
                // after for
                t1 = _box_0.clause;
                if (t1 == null) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 7;
                return P._asyncAwait($async$self._async_evaluate$_environment.scope$3$semiGlobal$when(new E._EvaluateVisitor_visitIfRule_closure0(_box_0, $async$self), true, t1.get$hasDeclarations()), $async$visitIfRule$1);
              case 7:
                // returning from await.
                $async$returnValue = $async$result;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitIfRule$1, $async$completer);
      },
      visitImportRule$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, t1, t2, _i, $import;
        var $async$visitImportRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = node.imports, t2 = t1.length, _i = 0;
              case 3:
                // for condition
                if (!(_i < t2)) {
                  // goto after for
                  $async$goto = 5;
                  break;
                }
                $import = t1[_i];
                $async$goto = $import instanceof B.DynamicImport ? 6 : 8;
                break;
              case 6:
                // then
                $async$goto = 9;
                return P._asyncAwait($async$self._async_evaluate$_visitDynamicImport$1($import), $async$visitImportRule$1);
              case 9:
                // returning from await.
                // goto join
                $async$goto = 7;
                break;
              case 8:
                // else
                $async$goto = 10;
                return P._asyncAwait($async$self._visitStaticImport$1(H.interceptedTypeCast($import, "$isStaticImport")), $async$visitImportRule$1);
              case 10:
                // returning from await.
              case 7:
                // join
              case 4:
                // for update
                ++_i;
                // goto for condition
                $async$goto = 3;
                break;
              case 5:
                // after for
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitImportRule$1, $async$completer);
      },
      _async_evaluate$_visitDynamicImport$1: function($import) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, result, importer, stylesheet, url, t1;
        var $async$_async_evaluate$_visitDynamicImport$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 2;
                return P._asyncAwait($async$self._async_evaluate$_loadImport$1($import), $async$_async_evaluate$_visitDynamicImport$1);
              case 2:
                // returning from await.
                result = $async$result;
                importer = result.get$item1();
                stylesheet = result.get$item2();
                url = stylesheet.get$span().get$sourceUrl();
                t1 = $async$self._async_evaluate$_activeImports;
                if (t1.contains$1(0, url))
                  throw H.wrapException($async$self._async_evaluate$_exception$2("This file is already being imported.", $import.span));
                t1.add$1(0, url);
                $async$goto = 3;
                return P._asyncAwait($async$self._async_evaluate$_withStackFrame$3("@import", $import.span, new E._EvaluateVisitor__visitDynamicImport_closure0($async$self, importer, url, stylesheet)), $async$_async_evaluate$_visitDynamicImport$1);
              case 3:
                // returning from await.
                t1.remove$1(0, url);
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$_async_evaluate$_visitDynamicImport$1, $async$completer);
      },
      _async_evaluate$_loadImport$1: function($import) {
        return this._loadImport$body$_EvaluateVisitor($import);
      },
      _loadImport$body$_EvaluateVisitor: function($import) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter([S.Tuple2, B.AsyncImporter, V.Stylesheet]), $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, stylesheet, tuple, error, $frames, error0, message, exception, t1, frames0, $async$exception;
        var $async$_async_evaluate$_loadImport$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$handler = 4;
                $async$goto = $async$self._async_evaluate$_nodeImporter != null ? 7 : 9;
                break;
              case 7:
                // then
                $async$goto = 10;
                return P._asyncAwait($async$self._async_evaluate$_importLikeNode$1($import), $async$_async_evaluate$_loadImport$1);
              case 10:
                // returning from await.
                stylesheet = $async$result;
                if (stylesheet != null) {
                  $async$returnValue = new S.Tuple2(null, stylesheet, [null, null]);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                // goto join
                $async$goto = 8;
                break;
              case 9:
                // else
                $async$goto = 11;
                return P._asyncAwait($async$self._async_evaluate$_importCache.import$3(P.Uri_parse($import.url, 0, null), $async$self._async_evaluate$_importer, $async$self._async_evaluate$_baseUrl), $async$_async_evaluate$_loadImport$1);
              case 11:
                // returning from await.
                tuple = $async$result;
                if (tuple != null) {
                  $async$returnValue = tuple;
                  // goto return
                  $async$goto = 1;
                  break;
                }
              case 8:
                // join
                if (J.startsWith$1$s($import.url, "package:"))
                  throw H.wrapException('"package:" URLs aren\'t supported on this platform.');
                else
                  throw H.wrapException("Can't find stylesheet to import.");
                $async$handler = 2;
                // goto after finally
                $async$goto = 6;
                break;
              case 4:
                // catch
                $async$handler = 3;
                $async$exception = $async$currentError;
                t1 = H.unwrapException($async$exception);
                if (t1 instanceof E.SassException) {
                  error = t1;
                  t1 = error.get$trace().frames;
                  frames0 = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
                  frames0.push(B.frameForSpan($import.span, $async$self._async_evaluate$_member));
                  t1 = $async$self._async_evaluate$_stack;
                  t1 = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
                  C.JSArray_methods.addAll$1(frames0, t1);
                  $frames = frames0;
                  throw H.wrapException(E.SassRuntimeException$(J.get$message$x(error), error.get$span(), Y.Trace$($frames, null)));
                } else {
                  error0 = t1;
                  message = null;
                  try {
                    message = H.stringTypeCast(J.get$message$x(error0));
                  } catch (exception) {
                    H.unwrapException($async$exception);
                    message = J.toString$0$(error0);
                  }
                  throw H.wrapException($async$self._async_evaluate$_exception$2(message, $import.span));
                }
                // goto after finally
                $async$goto = 6;
                break;
              case 3:
                // uncaught
                // goto rethrow
                $async$goto = 2;
                break;
              case 6:
                // after finally
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
              case 2:
                // rethrow
                return P._asyncRethrow($async$currentError, $async$completer);
            }
        });
        return P._asyncStartSync($async$_async_evaluate$_loadImport$1, $async$completer);
      },
      _async_evaluate$_importLikeNode$1: function($import) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(V.Stylesheet), $async$returnValue, $async$self = this, result, contents, url, t1, t2, t3, t4, t5;
        var $async$_async_evaluate$_importLikeNode$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 3;
                return P._asyncAwait($async$self._async_evaluate$_nodeImporter.loadAsync$2($import.url, $async$self._async_evaluate$_baseUrl), $async$_async_evaluate$_importLikeNode$1);
              case 3:
                // returning from await.
                result = $async$result;
                if (result == null) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                contents = result.get$item1();
                url = result.get$item2();
                t1 = J.getInterceptor$s(url);
                t2 = $async$self._async_evaluate$_includedFiles;
                if (t1.startsWith$1(url, "file:"))
                  t2.add$1(0, D.p().style.pathFromUri$1(M._parseUri(url)));
                else
                  t2.add$1(0, url);
                t1 = t1.startsWith$1(url, "file") && J.$eq$(X.ParsedPath_ParsedPath$parse(url, $.$get$url().style)._splitExtension$0()[1], ".sass") === true;
                t2 = J.getInterceptor$s(contents);
                t3 = $async$self._async_evaluate$_logger;
                t4 = [P.int];
                if (t1) {
                  t1 = t2.get$codeUnits(contents);
                  t4 = H.setRuntimeTypeInfo([0], t4);
                  t2 = typeof url === "string";
                  t5 = t2 ? P.Uri_parse(url, 0, null) : url;
                  t4 = new Y.SourceFile(t5, t4, new Uint32Array(H._ensureNativeList(t1.toList$0(t1))), null);
                  t4.SourceFile$decoded$2$url(t1, url);
                  t1 = t2 ? P.Uri_parse(url, 0, null) : url;
                  t1 = new U.SassParser(0, null, null, null, false, null, false, false, false, false, false, new S.SpanScanner(t4, null, t1, contents, 0, null, null), t3).parse$0();
                } else {
                  t1 = t2.get$codeUnits(contents);
                  t4 = H.setRuntimeTypeInfo([0], t4);
                  t2 = typeof url === "string";
                  t5 = t2 ? P.Uri_parse(url, 0, null) : url;
                  t4 = new Y.SourceFile(t5, t4, new Uint32Array(H._ensureNativeList(t1.toList$0(t1))), null);
                  t4.SourceFile$decoded$2$url(t1, url);
                  t1 = t2 ? P.Uri_parse(url, 0, null) : url;
                  t1 = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t4, null, t1, contents, 0, null, null), t3).parse$0();
                }
                $async$returnValue = t1;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_async_evaluate$_importLikeNode$1, $async$completer);
      },
      _visitStaticImport$1: function($import) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$self = this, url, supports, resolvedSupports, t1, mediaQuery, node, t2, $async$temp1, $async$temp2;
        var $async$_visitStaticImport$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 3;
                return P._asyncAwait($async$self._async_evaluate$_interpolationToValue$1($import.url), $async$_visitStaticImport$1);
              case 3:
                // returning from await.
                url = $async$result;
                supports = $import.supports;
                $async$goto = supports instanceof L.SupportsDeclaration ? 4 : 6;
                break;
              case 4:
                // then
                $async$temp1 = H;
                $async$goto = 7;
                return P._asyncAwait($async$self._evaluateToCss$1(supports.name), $async$_visitStaticImport$1);
              case 7:
                // returning from await.
                $async$temp1 = $async$temp1.S($async$result) + ": ";
                $async$temp2 = H;
                $async$goto = 8;
                return P._asyncAwait($async$self._evaluateToCss$1(supports.value), $async$_visitStaticImport$1);
              case 8:
                // returning from await.
                resolvedSupports = $async$temp1 + $async$temp2.S($async$result);
                // goto join
                $async$goto = 5;
                break;
              case 6:
                // else
                $async$goto = supports == null ? 9 : 11;
                break;
              case 9:
                // then
                $async$result = null;
                // goto join
                $async$goto = 10;
                break;
              case 11:
                // else
                $async$goto = 12;
                return P._asyncAwait($async$self._async_evaluate$_visitSupportsCondition$1(supports), $async$_visitStaticImport$1);
              case 12:
                // returning from await.
              case 10:
                // join
                resolvedSupports = $async$result;
              case 5:
                // join
                t1 = $import.media;
                $async$goto = t1 == null ? 13 : 15;
                break;
              case 13:
                // then
                $async$result = null;
                // goto join
                $async$goto = 14;
                break;
              case 15:
                // else
                $async$goto = 16;
                return P._asyncAwait($async$self._async_evaluate$_visitMediaQueries$1(t1), $async$_visitStaticImport$1);
              case 16:
                // returning from await.
              case 14:
                // join
                mediaQuery = $async$result;
                t1 = $import.span;
                node = F.CssImport$(url, t1, mediaQuery, resolvedSupports == null ? null : new F.CssValue("supports(" + H.S(resolvedSupports) + ")", supports.get$span(), [null]));
                t1 = $async$self._async_evaluate$_parent;
                t2 = $async$self._async_evaluate$_root;
                if (t1 == null ? t2 != null : t1 !== t2)
                  t1.addChild$1(node);
                else if ($async$self._async_evaluate$_endOfImports === J.get$length$asx(t2.children._collection$_source)) {
                  $async$self._async_evaluate$_root.addChild$1(node);
                  ++$async$self._async_evaluate$_endOfImports;
                } else
                  $async$self._async_evaluate$_outOfOrderImports.push(node);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_visitStaticImport$1, $async$completer);
      },
      visitIncludeRule$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, mixin, t1, environment;
        var $async$visitIncludeRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                mixin = H.subtypeCast($async$self._async_evaluate$_environment.getMixin$1(node.name), "$isUserDefinedCallable", [Q.AsyncEnvironment], "$asUserDefinedCallable");
                if (mixin == null)
                  throw H.wrapException($async$self._async_evaluate$_exception$2("Undefined mixin.", node.span));
                t1 = node.children == null;
                if (!t1 && H.interceptedTypeCast(mixin.declaration, "$isMixinRule").hasContent !== true)
                  throw H.wrapException($async$self._async_evaluate$_exception$2("Mixin doesn't accept a content block.", node.span));
                environment = t1 ? null : $async$self._async_evaluate$_environment.closure$0();
                $async$goto = 3;
                return P._asyncAwait($async$self._async_evaluate$_runUserDefinedCallable$4(node.$arguments, mixin, node.span, new E._EvaluateVisitor_visitIncludeRule_closure0($async$self, node, environment, mixin)), $async$visitIncludeRule$1);
              case 3:
                // returning from await.
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitIncludeRule$1, $async$completer);
      },
      visitMixinRule$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, t1;
        var $async$visitMixinRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self._async_evaluate$_environment;
                t1.setMixin$1(new E.UserDefinedCallable(node, t1.closure$0(), [null]));
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitMixinRule$1, $async$completer);
      },
      visitLoudComment$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, t1, t2, $async$temp1, $async$temp2;
        var $async$visitLoudComment$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if ($async$self._async_evaluate$_inFunction) {
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t1 = $async$self._async_evaluate$_parent;
                t2 = $async$self._async_evaluate$_root;
                if ((t1 == null ? t2 == null : t1 === t2) && $async$self._async_evaluate$_endOfImports === J.get$length$asx(t2.children._collection$_source))
                  ++$async$self._async_evaluate$_endOfImports;
                t1 = node.text;
                $async$temp1 = $async$self._async_evaluate$_parent;
                $async$temp2 = R;
                $async$goto = 3;
                return P._asyncAwait($async$self._async_evaluate$_performInterpolation$1(t1), $async$visitLoudComment$1);
              case 3:
                // returning from await.
                $async$temp1.addChild$1(new $async$temp2.CssComment($async$result, t1.span, null, null, false));
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitLoudComment$1, $async$completer);
      },
      visitMediaRule$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, t1, queries, t2;
        var $async$visitMediaRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = {};
                if ($async$self._async_evaluate$_declarationName != null)
                  throw H.wrapException($async$self._async_evaluate$_exception$2("Media rules may not be used within nested declarations.", node.get$span()));
                $async$goto = 3;
                return P._asyncAwait($async$self._async_evaluate$_visitMediaQueries$1(node.get$query()), $async$visitMediaRule$1);
              case 3:
                // returning from await.
                queries = $async$result;
                t1.queries = queries;
                t2 = $async$self._async_evaluate$_mediaQueries;
                if (t2 != null) {
                  queries = $async$self._async_evaluate$_mergeMediaQueries$2(t2, queries);
                  t1.queries = queries;
                  if (C.JSArray_methods.get$isEmpty(queries)) {
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                  t2 = queries;
                } else
                  t2 = queries;
                $async$goto = 4;
                return P._asyncAwait($async$self._async_evaluate$_withParent$4$scopeWhen$through(G.CssMediaRule$(t2, node.get$span()), new E._EvaluateVisitor_visitMediaRule_closure1(t1, $async$self, node), node.get$hasDeclarations(), new E._EvaluateVisitor_visitMediaRule_closure2()), $async$visitMediaRule$1);
              case 4:
                // returning from await.
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitMediaRule$1, $async$completer);
      },
      _async_evaluate$_visitMediaQueries$1: function(interpolation) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter([P.List, F.CssMediaQuery]), $async$returnValue, $async$self = this, resolved;
        var $async$_async_evaluate$_visitMediaQueries$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 3;
                return P._asyncAwait($async$self._async_evaluate$_performInterpolation$2$warnForColor(interpolation, true), $async$_async_evaluate$_visitMediaQueries$1);
              case 3:
                // returning from await.
                resolved = $async$result;
                $async$returnValue = $async$self._async_evaluate$_adjustParseError$2(interpolation.get$span(), new E._EvaluateVisitor__visitMediaQueries_closure0($async$self, resolved));
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_async_evaluate$_visitMediaQueries$1, $async$completer);
      },
      _async_evaluate$_mergeMediaQueries$2: function(queries1, queries2) {
        return P.List_List$unmodifiable(J.expand$1$ax(queries1, new E._EvaluateVisitor__mergeMediaQueries_closure1(queries2)).where$1(0, new E._EvaluateVisitor__mergeMediaQueries_closure2()), null);
      },
      visitReturnRule$1: function(node) {
        return node.expression.accept$1(this);
      },
      visitSilentComment$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue;
        var $async$visitSilentComment$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitSilentComment$1, $async$completer);
      },
      visitStyleRule$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, t1, selectorText, parsedSelector, rule, oldAtRootExcludingStyleRule;
        var $async$visitStyleRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = {};
                if ($async$self._async_evaluate$_declarationName != null)
                  throw H.wrapException($async$self._async_evaluate$_exception$2("Style rules may not be used within nested declarations.", node.get$span()));
                $async$goto = 3;
                return P._asyncAwait($async$self._async_evaluate$_interpolationToValue$3$trim$warnForColor(node.get$selector(), true, true), $async$visitStyleRule$1);
              case 3:
                // returning from await.
                selectorText = $async$result;
                $async$goto = $async$self._async_evaluate$_inKeyframes ? 4 : 5;
                break;
              case 4:
                // then
                t1 = [];
                $async$goto = 6;
                return P._asyncAwait($async$self._async_evaluate$_withParent$4$scopeWhen$through(new U.CssKeyframeBlock(new F.CssValue(P.List_List$unmodifiable($async$self._async_evaluate$_adjustParseError$2(node.get$selector().get$span(), new E._EvaluateVisitor_visitStyleRule_closure6($async$self, selectorText)), null), node.get$selector().get$span(), [null]), node.get$span(), new P.UnmodifiableListView(t1, [B.CssNode]), t1, null, null, false), new E._EvaluateVisitor_visitStyleRule_closure7($async$self, node), node.get$hasDeclarations(), new E._EvaluateVisitor_visitStyleRule_closure8()), $async$visitStyleRule$1);
              case 6:
                // returning from await.
                // goto return
                $async$goto = 1;
                break;
              case 5:
                // join
                t1.parsedSelector = $async$self._async_evaluate$_adjustParseError$2(node.get$selector().get$span(), new E._EvaluateVisitor_visitStyleRule_closure9($async$self, selectorText));
                parsedSelector = $async$self._async_evaluate$_addExceptionSpan$2(node.get$selector().get$span(), new E._EvaluateVisitor_visitStyleRule_closure10(t1, $async$self));
                t1.parsedSelector = parsedSelector;
                rule = $async$self._async_evaluate$_extender.addSelector$3(new F.CssValue(parsedSelector, node.get$selector().get$span(), [D.SelectorList]), node.get$span(), $async$self._async_evaluate$_mediaQueries);
                oldAtRootExcludingStyleRule = $async$self._async_evaluate$_atRootExcludingStyleRule;
                $async$self._async_evaluate$_atRootExcludingStyleRule = false;
                $async$goto = 7;
                return P._asyncAwait($async$self._async_evaluate$_withParent$4$scopeWhen$through(rule, new E._EvaluateVisitor_visitStyleRule_closure11($async$self, rule, node), node.get$hasDeclarations(), new E._EvaluateVisitor_visitStyleRule_closure12()), $async$visitStyleRule$1);
              case 7:
                // returning from await.
                $async$self._async_evaluate$_atRootExcludingStyleRule = oldAtRootExcludingStyleRule;
                if (!($async$self._async_evaluate$_styleRule != null && !oldAtRootExcludingStyleRule)) {
                  t1 = $async$self._async_evaluate$_parent.children;
                  t1.get$last(t1).set$isGroupEnd(true);
                }
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitStyleRule$1, $async$completer);
      },
      visitSupportsRule$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, t1, $async$temp1, $async$temp2;
        var $async$visitSupportsRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if ($async$self._async_evaluate$_declarationName != null)
                  throw H.wrapException($async$self._async_evaluate$_exception$2("Supports rules may not be used within nested declarations.", node.get$span()));
                t1 = [];
                $async$temp1 = B;
                $async$temp2 = F;
                $async$goto = 4;
                return P._asyncAwait($async$self._async_evaluate$_visitSupportsCondition$1(node.get$condition()), $async$visitSupportsRule$1);
              case 4:
                // returning from await.
                $async$goto = 3;
                return P._asyncAwait($async$self._async_evaluate$_withParent$4$scopeWhen$through(new $async$temp1.CssSupportsRule(new $async$temp2.CssValue($async$result, node.get$condition().get$span(), [null]), node.get$span(), new P.UnmodifiableListView(t1, [B.CssNode]), t1, null, null, false), new E._EvaluateVisitor_visitSupportsRule_closure1($async$self, node), node.get$hasDeclarations(), new E._EvaluateVisitor_visitSupportsRule_closure2()), $async$visitSupportsRule$1);
              case 3:
                // returning from await.
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitSupportsRule$1, $async$completer);
      },
      _async_evaluate$_visitSupportsCondition$1: function(condition) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(P.String), $async$returnValue, $async$self = this, t1, t2, $async$temp1, $async$temp2;
        var $async$_async_evaluate$_visitSupportsCondition$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = J.getInterceptor(condition);
                $async$goto = !!t1.$isSupportsOperation ? 3 : 5;
                break;
              case 3:
                // then
                t1 = condition.left;
                t2 = condition.operator;
                $async$temp1 = H;
                $async$goto = 6;
                return P._asyncAwait($async$self._async_evaluate$_parenthesize$2(t1, t2), $async$_async_evaluate$_visitSupportsCondition$1);
              case 6:
                // returning from await.
                $async$temp1 = $async$temp1.S($async$result) + " " + t2 + " ";
                $async$temp2 = H;
                $async$goto = 7;
                return P._asyncAwait($async$self._async_evaluate$_parenthesize$2(condition.right, t2), $async$_async_evaluate$_visitSupportsCondition$1);
              case 7:
                // returning from await.
                $async$returnValue = $async$temp1 + $async$temp2.S($async$result);
                // goto return
                $async$goto = 1;
                break;
                // goto join
                $async$goto = 4;
                break;
              case 5:
                // else
                $async$goto = !!t1.$isSupportsNegation ? 8 : 10;
                break;
              case 8:
                // then
                $async$temp1 = H;
                $async$goto = 11;
                return P._asyncAwait($async$self._async_evaluate$_parenthesize$1(condition.condition), $async$_async_evaluate$_visitSupportsCondition$1);
              case 11:
                // returning from await.
                $async$returnValue = "not " + $async$temp1.S($async$result);
                // goto return
                $async$goto = 1;
                break;
                // goto join
                $async$goto = 9;
                break;
              case 10:
                // else
                $async$goto = !!t1.$isSupportsInterpolation ? 12 : 14;
                break;
              case 12:
                // then
                $async$goto = 15;
                return P._asyncAwait($async$self._evaluateToCss$2$quote(condition.expression, false), $async$_async_evaluate$_visitSupportsCondition$1);
              case 15:
                // returning from await.
                $async$returnValue = $async$result;
                // goto return
                $async$goto = 1;
                break;
                // goto join
                $async$goto = 13;
                break;
              case 14:
                // else
                $async$goto = !!t1.$isSupportsDeclaration ? 16 : 18;
                break;
              case 16:
                // then
                $async$temp1 = H;
                $async$goto = 19;
                return P._asyncAwait($async$self._evaluateToCss$1(condition.name), $async$_async_evaluate$_visitSupportsCondition$1);
              case 19:
                // returning from await.
                $async$temp1 = "(" + $async$temp1.S($async$result) + ": ";
                $async$temp2 = H;
                $async$goto = 20;
                return P._asyncAwait($async$self._evaluateToCss$1(condition.value), $async$_async_evaluate$_visitSupportsCondition$1);
              case 20:
                // returning from await.
                $async$returnValue = $async$temp1 + $async$temp2.S($async$result) + ")";
                // goto return
                $async$goto = 1;
                break;
                // goto join
                $async$goto = 17;
                break;
              case 18:
                // else
                // goto return
                $async$goto = 1;
                break;
              case 17:
                // join
              case 13:
                // join
              case 9:
                // join
              case 4:
                // join
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_async_evaluate$_visitSupportsCondition$1, $async$completer);
      },
      _async_evaluate$_parenthesize$2: function(condition, operator) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(P.String), $async$returnValue, $async$self = this, t1, $async$temp1;
        var $async$_async_evaluate$_parenthesize$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if (!condition.$isSupportsNegation)
                  if (!!condition.$isSupportsOperation)
                    t1 = operator == null || operator !== condition.operator;
                  else
                    t1 = false;
                else
                  t1 = true;
                $async$goto = t1 ? 3 : 5;
                break;
              case 3:
                // then
                $async$temp1 = H;
                $async$goto = 6;
                return P._asyncAwait($async$self._async_evaluate$_visitSupportsCondition$1(condition), $async$_async_evaluate$_parenthesize$2);
              case 6:
                // returning from await.
                $async$returnValue = "(" + $async$temp1.S($async$result) + ")";
                // goto return
                $async$goto = 1;
                break;
                // goto join
                $async$goto = 4;
                break;
              case 5:
                // else
                $async$goto = 7;
                return P._asyncAwait($async$self._async_evaluate$_visitSupportsCondition$1(condition), $async$_async_evaluate$_parenthesize$2);
              case 7:
                // returning from await.
                $async$returnValue = $async$result;
                // goto return
                $async$goto = 1;
                break;
              case 4:
                // join
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_async_evaluate$_parenthesize$2, $async$completer);
      },
      _async_evaluate$_parenthesize$1: function(condition) {
        return this._async_evaluate$_parenthesize$2(condition, null);
      },
      visitVariableDeclaration$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, value, t1, $async$temp1, $async$temp2;
        var $async$visitVariableDeclaration$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if (node.isGuarded) {
                  value = $async$self._async_evaluate$_environment.getVariable$1(node.name);
                  if (value != null && J.$eq$(value, C.C_SassNull) !== true) {
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                }
                t1 = node.expression;
                $async$temp1 = $async$self._async_evaluate$_environment;
                $async$temp2 = node.name;
                $async$goto = 3;
                return P._asyncAwait(t1.accept$1($async$self), $async$visitVariableDeclaration$1);
              case 3:
                // returning from await.
                $async$temp1.setVariable$4$global($async$temp2, $async$result.withoutSlash$0(), $async$self._async_evaluate$_expressionSpan$1(t1), node.isGlobal);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitVariableDeclaration$1, $async$completer);
      },
      visitWarnRule$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, t1, value, t2;
        var $async$visitWarnRule$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = node.span;
                $async$goto = 3;
                return P._asyncAwait($async$self._addExceptionSpanAsync$2(t1, new E._EvaluateVisitor_visitWarnRule_closure0($async$self, node)), $async$visitWarnRule$1);
              case 3:
                // returning from await.
                value = $async$result;
                t2 = value instanceof D.SassString ? value.text : $async$self._async_evaluate$_serialize$2(value, node.expression.get$span());
                $async$self._async_evaluate$_logger.warn$2$trace(t2, $async$self._async_evaluate$_stackTrace$1(t1));
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitWarnRule$1, $async$completer);
      },
      visitWhileRule$1: function(node) {
        return this._async_evaluate$_environment.scope$3$semiGlobal$when(new E._EvaluateVisitor_visitWhileRule_closure0(this, node), true, node.hasDeclarations);
      },
      visitBinaryOperationExpression$1: function(node) {
        return this._addExceptionSpanAsync$2(B.spanForList([node.left, node.right]), new E._EvaluateVisitor_visitBinaryOperationExpression_closure0(this, node));
      },
      visitValueExpression$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue;
        var $async$visitValueExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$returnValue = node.value;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitValueExpression$1, $async$completer);
      },
      visitVariableExpression$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, result;
        var $async$visitVariableExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                result = $async$self._async_evaluate$_environment.getVariable$1(node.name);
                if (result != null) {
                  $async$returnValue = result;
                  // goto return
                  $async$goto = 1;
                  break;
                }
                throw H.wrapException($async$self._async_evaluate$_exception$2("Undefined variable.", node.span));
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitVariableExpression$1, $async$completer);
      },
      visitUnaryOperationExpression$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, operand, t1;
        var $async$visitUnaryOperationExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            $async$outer:
              switch ($async$goto) {
                case 0:
                  // Function start
                  $async$goto = 3;
                  return P._asyncAwait(node.operand.accept$1($async$self), $async$visitUnaryOperationExpression$1);
                case 3:
                  // returning from await.
                  operand = $async$result;
                  t1 = node.operator;
                  switch (t1) {
                    case C.UnaryOperator_j2w:
                      $async$returnValue = operand.unaryPlus$0();
                      // goto return
                      $async$goto = 1;
                      break $async$outer;
                    case C.UnaryOperator_U4G:
                      $async$returnValue = operand.unaryMinus$0();
                      // goto return
                      $async$goto = 1;
                      break $async$outer;
                    case C.UnaryOperator_zDx:
                      $async$returnValue = operand.unaryDivide$0();
                      // goto return
                      $async$goto = 1;
                      break $async$outer;
                    case C.UnaryOperator_not_not:
                      $async$returnValue = operand.unaryNot$0();
                      // goto return
                      $async$goto = 1;
                      break $async$outer;
                    default:
                      throw H.wrapException(P.StateError$("Unknown unary operator " + H.S(t1) + "."));
                  }
                case 1:
                  // return
                  return P._asyncReturn($async$returnValue, $async$completer);
              }
        });
        return P._asyncStartSync($async$visitUnaryOperationExpression$1, $async$completer);
      },
      visitBooleanExpression$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(Z.SassBoolean), $async$returnValue;
        var $async$visitBooleanExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$returnValue = node.value ? C.SassBoolean_true : C.SassBoolean_false;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitBooleanExpression$1, $async$completer);
      },
      visitIfExpression$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, pair, positional, named, t1, condition, ifTrue, ifFalse;
        var $async$visitIfExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 3;
                return P._asyncAwait($async$self._async_evaluate$_evaluateMacroArguments$1(node), $async$visitIfExpression$1);
              case 3:
                // returning from await.
                pair = $async$result;
                positional = pair.get$item1();
                named = pair.get$item2();
                t1 = J.getInterceptor$asx(positional);
                $async$self._async_evaluate$_verifyArguments$4(t1.get$length(positional), named, $.$get$IfExpression_declaration(), node.span);
                condition = J.$gt$n(t1.get$length(positional), 0) ? t1.$index(positional, 0) : J.$index$asx(named, "condition");
                ifTrue = J.$gt$n(t1.get$length(positional), 1) ? t1.$index(positional, 1) : J.$index$asx(named, "if-true");
                ifFalse = J.$gt$n(t1.get$length(positional), 2) ? t1.$index(positional, 2) : J.$index$asx(named, "if-false");
                $async$goto = 5;
                return P._asyncAwait(condition.accept$1($async$self), $async$visitIfExpression$1);
              case 5:
                // returning from await.
                $async$goto = 4;
                return P._asyncAwait(($async$result.get$isTruthy() ? ifTrue : ifFalse).accept$1($async$self), $async$visitIfExpression$1);
              case 4:
                // returning from await.
                $async$returnValue = $async$result;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitIfExpression$1, $async$completer);
      },
      visitNullExpression$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(O.SassNull), $async$returnValue;
        var $async$visitNullExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$returnValue = C.C_SassNull;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitNullExpression$1, $async$completer);
      },
      visitNumberExpression$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(T.SassNumber), $async$returnValue, t1;
        var $async$visitNumberExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = node.unit;
                t1 = t1 == null ? null : [t1];
                t1 = t1 == null ? C.List_empty : P.List_List$unmodifiable(t1, null);
                $async$returnValue = new T.SassNumber(node.value, t1, C.List_empty, null);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitNumberExpression$1, $async$completer);
      },
      visitColorExpression$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(K.SassColor), $async$returnValue;
        var $async$visitColorExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$returnValue = node.value;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitColorExpression$1, $async$completer);
      },
      visitListExpression$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(D.SassList), $async$returnValue, $async$self = this, $async$temp1;
        var $async$visitListExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$temp1 = D;
                $async$goto = 3;
                return P._asyncAwait(B.mapAsync(node.contents, new E._EvaluateVisitor_visitListExpression_closure0($async$self)), $async$visitListExpression$1);
              case 3:
                // returning from await.
                $async$returnValue = $async$temp1.SassList$($async$result, node.separator, node.hasBrackets);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitListExpression$1, $async$completer);
      },
      visitMapExpression$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(A.SassMap), $async$returnValue, $async$self = this, t1, map, t2, _i, pair, keyValue, valueValue;
        var $async$visitMapExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = F.Value;
                map = P.LinkedHashMap_LinkedHashMap$_empty(t1, t1);
                t1 = node.pairs, t2 = t1.length, _i = 0;
              case 3:
                // for condition
                if (!(_i < t2)) {
                  // goto after for
                  $async$goto = 5;
                  break;
                }
                pair = t1[_i];
                $async$goto = 6;
                return P._asyncAwait(pair.get$item1().accept$1($async$self), $async$visitMapExpression$1);
              case 6:
                // returning from await.
                keyValue = $async$result;
                $async$goto = 7;
                return P._asyncAwait(pair.get$item2().accept$1($async$self), $async$visitMapExpression$1);
              case 7:
                // returning from await.
                valueValue = $async$result;
                if (map.containsKey$1(keyValue))
                  throw H.wrapException($async$self._async_evaluate$_exception$2("Duplicate key.", pair.get$item1().get$span()));
                map.$indexSet(0, keyValue, valueValue);
              case 4:
                // for update
                ++_i;
                // goto for condition
                $async$goto = 3;
                break;
              case 5:
                // after for
                $async$returnValue = new A.SassMap(H.ConstantMap_ConstantMap$from(map, null, null));
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitMapExpression$1, $async$completer);
      },
      visitFunctionExpression$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, t1, plainName, $function, oldInFunction, t2, result, $async$temp1;
        var $async$visitFunctionExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = node.name;
                plainName = t1.get$asPlain();
                $function = plainName == null ? null : $async$self._async_evaluate$_environment.getFunction$1(plainName);
                $async$goto = $function == null ? 3 : 4;
                break;
              case 3:
                // then
                $async$temp1 = L;
                $async$goto = 5;
                return P._asyncAwait($async$self._async_evaluate$_performInterpolation$1(t1), $async$visitFunctionExpression$1);
              case 5:
                // returning from await.
                $function = new $async$temp1.PlainCssCallable($async$result);
              case 4:
                // join
                oldInFunction = $async$self._async_evaluate$_inFunction;
                $async$self._async_evaluate$_inFunction = true;
                t2 = node.$arguments;
                $async$goto = 6;
                return P._asyncAwait($async$self._async_evaluate$_runFunctionCallable$3(t2, $function, B.spanForList([t1, t2])), $async$visitFunctionExpression$1);
              case 6:
                // returning from await.
                result = $async$result;
                $async$self._async_evaluate$_inFunction = oldInFunction;
                $async$returnValue = result;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitFunctionExpression$1, $async$completer);
      },
      _async_evaluate$_runUserDefinedCallable$4: function($arguments, callable, span, run) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, evaluated;
        var $async$_async_evaluate$_runUserDefinedCallable$4 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 3;
                return P._asyncAwait($async$self._async_evaluate$_evaluateArguments$1($arguments), $async$_async_evaluate$_runUserDefinedCallable$4);
              case 3:
                // returning from await.
                evaluated = $async$result;
                $async$goto = 4;
                return P._asyncAwait($async$self._async_evaluate$_withStackFrame$3(callable.declaration.name + "()", span, new E._EvaluateVisitor__runUserDefinedCallable_closure0($async$self, callable, evaluated, span, run)), $async$_async_evaluate$_runUserDefinedCallable$4);
              case 4:
                // returning from await.
                $async$returnValue = $async$result;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_async_evaluate$_runUserDefinedCallable$4, $async$completer);
      },
      _async_evaluate$_runFunctionCallable$3: function($arguments, callable, span) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, t1, t2, t3, first, _i, argument, rest, $async$temp1;
        var $async$_async_evaluate$_runFunctionCallable$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = J.getInterceptor(callable);
                $async$goto = !!t1.$isAsyncBuiltInCallable ? 3 : 5;
                break;
              case 3:
                // then
                $async$goto = 6;
                return P._asyncAwait($async$self._async_evaluate$_runBuiltInCallable$3($arguments, callable, span), $async$_async_evaluate$_runFunctionCallable$3);
              case 6:
                // returning from await.
                $async$returnValue = $async$result.withoutSlash$0();
                // goto return
                $async$goto = 1;
                break;
                // goto join
                $async$goto = 4;
                break;
              case 5:
                // else
                t2 = H.checkSubtypeV1(callable, "$isUserDefinedCallable", [Q.AsyncEnvironment], null);
                $async$goto = t2 ? 7 : 9;
                break;
              case 7:
                // then
                $async$goto = 10;
                return P._asyncAwait($async$self._async_evaluate$_runUserDefinedCallable$4($arguments, callable, span, new E._EvaluateVisitor__runFunctionCallable_closure0($async$self, callable)), $async$_async_evaluate$_runFunctionCallable$3);
              case 10:
                // returning from await.
                $async$returnValue = $async$result.withoutSlash$0();
                // goto return
                $async$goto = 1;
                break;
                // goto join
                $async$goto = 8;
                break;
              case 9:
                // else
                $async$goto = !!t1.$isPlainCssCallable ? 11 : 13;
                break;
              case 11:
                // then
                t1 = $arguments.named;
                if (t1.get$isNotEmpty(t1) || $arguments.keywordRest != null)
                  throw H.wrapException($async$self._async_evaluate$_exception$2("Plain CSS functions don't support keyword arguments.", span));
                t1 = H.S(callable.name) + "(";
                t2 = $arguments.positional, t3 = t2.length, first = true, _i = 0;
              case 14:
                // for condition
                if (!(_i < t3)) {
                  // goto after for
                  $async$goto = 16;
                  break;
                }
                argument = t2[_i];
                if (first)
                  first = false;
                else
                  t1 += ", ";
                $async$temp1 = H;
                $async$goto = 17;
                return P._asyncAwait($async$self._evaluateToCss$1(argument), $async$_async_evaluate$_runFunctionCallable$3);
              case 17:
                // returning from await.
                t1 += $async$temp1.S($async$result);
              case 15:
                // for update
                ++_i;
                // goto for condition
                $async$goto = 14;
                break;
              case 16:
                // after for
                t2 = $arguments.rest;
                $async$goto = 18;
                return P._asyncAwait(t2 == null ? null : t2.accept$1($async$self), $async$_async_evaluate$_runFunctionCallable$3);
              case 18:
                // returning from await.
                rest = $async$result;
                if (rest != null) {
                  if (!first)
                    t1 += ", ";
                  t2 = t1 + H.S($async$self._async_evaluate$_serialize$2(rest, t2.get$span()));
                  t1 = t2;
                }
                t1 += H.Primitives_stringFromCharCode(41);
                $async$returnValue = new D.SassString(t1.charCodeAt(0) == 0 ? t1 : t1, false, null);
                // goto return
                $async$goto = 1;
                break;
                // goto join
                $async$goto = 12;
                break;
              case 13:
                // else
                // goto return
                $async$goto = 1;
                break;
              case 12:
                // join
              case 8:
                // join
              case 4:
                // join
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_async_evaluate$_runFunctionCallable$3, $async$completer);
      },
      _async_evaluate$_runBuiltInCallable$3: function($arguments, callable, span) {
        return this._runBuiltInCallable$body$_EvaluateVisitor($arguments, callable, span);
      },
      _runBuiltInCallable$body$_EvaluateVisitor: function($arguments, callable, span) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, evaluated, callback, result, error, message, oldCallableSpan, namedSet, tuple, overload, declaredArguments, i, t1, t2, argument, t3, rest, argumentList, exception, $async$exception;
        var $async$_async_evaluate$_runBuiltInCallable$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 3;
                return P._asyncAwait($async$self._async_evaluate$_evaluateArguments$2$trackSpans($arguments, false), $async$_async_evaluate$_runBuiltInCallable$3);
              case 3:
                // returning from await.
                evaluated = $async$result;
                oldCallableSpan = $async$self._async_evaluate$_callableSpan;
                $async$self._async_evaluate$_callableSpan = span;
                namedSet = new M.MapKeySet(evaluated.get$named(), [null]);
                tuple = callable.callbackFor$2(J.get$length$asx(evaluated.get$positional()), namedSet);
                overload = tuple.get$item1();
                callback = tuple.get$item2();
                $async$self._async_evaluate$_addExceptionSpan$2(span, new E._EvaluateVisitor__runBuiltInCallable_closure1(overload, evaluated, namedSet));
                declaredArguments = overload.get$$arguments();
                i = J.get$length$asx(evaluated.get$positional());
                t1 = J.getInterceptor$asx(declaredArguments);
              case 4:
                // while condition
                t2 = t1.get$length(declaredArguments);
                if (typeof t2 !== "number") {
                  $async$returnValue = H.iae(t2);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                if (!(i < t2)) {
                  // goto after while
                  $async$goto = 5;
                  break;
                }
                argument = t1.$index(declaredArguments, i);
                t2 = evaluated.get$positional();
                t3 = J.remove$1$ax(evaluated.get$named(), argument.get$name());
                $async$goto = t3 == null ? 6 : 7;
                break;
              case 6:
                // then
                t3 = argument.get$defaultValue();
                $async$goto = 8;
                return P._asyncAwait(t3 == null ? null : t3.accept$1($async$self), $async$_async_evaluate$_runBuiltInCallable$3);
              case 8:
                // returning from await.
                t3 = $async$result;
              case 7:
                // join
                J.add$1$ax(t2, t3);
                ++i;
                // goto while condition
                $async$goto = 4;
                break;
              case 5:
                // after while
                if (overload.get$restArgument() != null) {
                  t2 = J.get$length$asx(evaluated.get$positional());
                  t3 = t1.get$length(declaredArguments);
                  if (typeof t3 !== "number") {
                    $async$returnValue = H.iae(t3);
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                  if (t2 > t3) {
                    rest = J.sublist$1$ax(evaluated.get$positional(), t1.get$length(declaredArguments));
                    J.removeRange$2$ax(evaluated.get$positional(), t1.get$length(declaredArguments), J.get$length$asx(evaluated.get$positional()));
                  } else
                    rest = C.List_empty1;
                  t1 = evaluated.get$named();
                  t2 = evaluated.get$separator() === C.ListSeparator_undecided_null ? C.ListSeparator_kWM : evaluated.get$separator();
                  argumentList = new D.SassArgumentList(new P.UnmodifiableMapView(B.normalizedMap(t1), [null, null]), false, P.List_List$unmodifiable(rest, null), t2, false);
                  argumentList.SassList$3$brackets(rest, t2, false);
                  J.add$1$ax(evaluated.get$positional(), argumentList);
                } else
                  argumentList = null;
                result = null;
                $async$handler = 10;
                $async$goto = 13;
                return P._asyncAwait(callback.call$1(evaluated.get$positional()), $async$_async_evaluate$_runBuiltInCallable$3);
              case 13:
                // returning from await.
                result = $async$result;
                if (result == null)
                  throw H.wrapException("Custom functions may not return Dart's null.");
                $async$handler = 2;
                // goto after finally
                $async$goto = 12;
                break;
              case 10:
                // catch
                $async$handler = 9;
                $async$exception = $async$currentError;
                error = H.unwrapException($async$exception);
                message = null;
                try {
                  message = H.stringTypeCast(J.get$message$x(error));
                } catch (exception) {
                  H.unwrapException($async$exception);
                  message = J.toString$0$(error);
                }
                throw H.wrapException($async$self._async_evaluate$_exception$2(message, span));
                // goto after finally
                $async$goto = 12;
                break;
              case 9:
                // uncaught
                // goto rethrow
                $async$goto = 2;
                break;
              case 12:
                // after finally
                $async$self._async_evaluate$_callableSpan = oldCallableSpan;
                if (argumentList == null) {
                  $async$returnValue = result;
                  // goto return
                  $async$goto = 1;
                  break;
                }
                if (J.get$isEmpty$asx(evaluated.get$named()) === true) {
                  $async$returnValue = result;
                  // goto return
                  $async$goto = 1;
                  break;
                }
                if (argumentList._wereKeywordsAccessed) {
                  $async$returnValue = result;
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t1 = evaluated.get$named().get$keys();
                t1 = "No " + B.pluralize("argument", t1.get$length(t1), null) + " named ";
                t2 = evaluated.get$named().get$keys();
                throw H.wrapException($async$self._async_evaluate$_exception$2(t1 + H.S(B.toSentence(t2.map$1(t2, new E._EvaluateVisitor__runBuiltInCallable_closure2()), "or")) + ".", span));
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
              case 2:
                // rethrow
                return P._asyncRethrow($async$currentError, $async$completer);
            }
        });
        return P._asyncStartSync($async$_async_evaluate$_runBuiltInCallable$3, $async$completer);
      },
      _async_evaluate$_evaluateArguments$2$trackSpans: function($arguments, trackSpans) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(E._ArgumentResults0), $async$returnValue, $async$self = this, t1, positional, t2, named, t3, positionalSpans, namedSpans, rest, restSpan, separator, t4, keywordRest, keywordRestSpan, $async$temp1;
        var $async$_async_evaluate$_evaluateArguments$2$trackSpans = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if (trackSpans == null)
                  trackSpans = $async$self._async_evaluate$_sourceMap;
                t1 = $arguments.positional;
                $async$temp1 = J;
                $async$goto = 3;
                return P._asyncAwait(B.mapAsync(t1, new E._EvaluateVisitor__evaluateArguments_closure7($async$self)), $async$_async_evaluate$_evaluateArguments$2$trackSpans);
              case 3:
                // returning from await.
                positional = $async$temp1.toList$0$ax($async$result);
                t2 = $arguments.named;
                $async$goto = 4;
                return P._asyncAwait(B.normalizedMapMapAsync(t2, null, new E._EvaluateVisitor__evaluateArguments_closure8($async$self)), $async$_async_evaluate$_evaluateArguments$2$trackSpans);
              case 4:
                // returning from await.
                named = $async$result;
                t3 = trackSpans === true;
                positionalSpans = t3 ? new H.MappedListIterable(t1, $async$self.get$_async_evaluate$_expressionSpan(), [H.getTypeArgumentByIndex(t1, 0), null]).toList$0(0) : null;
                namedSpans = t3 ? Y.mapMap(t2, null, new E._EvaluateVisitor__evaluateArguments_closure9($async$self)) : null;
                t1 = $arguments.rest;
                if (t1 == null) {
                  $async$returnValue = E._ArgumentResults$0(positional, named, C.ListSeparator_undecided_null, namedSpans, positionalSpans);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 5;
                return P._asyncAwait(t1.accept$1($async$self), $async$_async_evaluate$_evaluateArguments$2$trackSpans);
              case 5:
                // returning from await.
                rest = $async$result;
                restSpan = t3 ? $async$self._async_evaluate$_expressionSpan$1(t1) : null;
                t2 = J.getInterceptor(rest);
                if (!!t2.$isSassMap) {
                  $async$self._async_evaluate$_addRestMap$3(named, rest, t1.get$span());
                  if (!(namedSpans == null))
                    namedSpans.addAll$1(0, Y.mapMap(rest.contents, new E._EvaluateVisitor__evaluateArguments_closure10(), new E._EvaluateVisitor__evaluateArguments_closure11(restSpan)));
                  separator = C.ListSeparator_undecided_null;
                } else {
                  t1 = J.getInterceptor$ax(positional);
                  if (!!t2.$isSassList) {
                    t4 = rest._list$_contents;
                    t1.addAll$1(positional, t4);
                    if (!(positionalSpans == null))
                      C.JSArray_methods.addAll$1(positionalSpans, P.List_List$filled(t4.length, restSpan, false, null));
                    separator = rest.separator;
                    if (!!t2.$isSassArgumentList) {
                      rest._wereKeywordsAccessed = true;
                      rest._keywords._collection$_map.forEach$1(0, new E._EvaluateVisitor__evaluateArguments_closure12(named, namedSpans, restSpan));
                    }
                  } else {
                    t1.add$1(positional, rest);
                    if (!(positionalSpans == null))
                      C.JSArray_methods.add$1(positionalSpans, restSpan);
                    separator = C.ListSeparator_undecided_null;
                  }
                }
                t1 = $arguments.keywordRest;
                if (t1 == null) {
                  $async$returnValue = E._ArgumentResults$0(positional, named, separator, namedSpans, positionalSpans);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 6;
                return P._asyncAwait(t1.accept$1($async$self), $async$_async_evaluate$_evaluateArguments$2$trackSpans);
              case 6:
                // returning from await.
                keywordRest = $async$result;
                keywordRestSpan = t3 ? $async$self._async_evaluate$_expressionSpan$1(t1) : null;
                if (keywordRest instanceof A.SassMap) {
                  $async$self._async_evaluate$_addRestMap$3(named, keywordRest, t1.get$span());
                  if (!(namedSpans == null))
                    namedSpans.addAll$1(0, Y.mapMap(keywordRest.contents, new E._EvaluateVisitor__evaluateArguments_closure13(), new E._EvaluateVisitor__evaluateArguments_closure14(keywordRestSpan)));
                  $async$returnValue = E._ArgumentResults$0(positional, named, separator, namedSpans, positionalSpans);
                  // goto return
                  $async$goto = 1;
                  break;
                } else
                  throw H.wrapException($async$self._async_evaluate$_exception$2("Variable keyword arguments must be a map (was " + H.S(keywordRest) + ").", t1.get$span()));
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_async_evaluate$_evaluateArguments$2$trackSpans, $async$completer);
      },
      _async_evaluate$_evaluateArguments$1: function($arguments) {
        return this._async_evaluate$_evaluateArguments$2$trackSpans($arguments, null);
      },
      _async_evaluate$_evaluateMacroArguments$1: function(invocation) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter([S.Tuple2, [P.List, T.Expression], [P.Map, P.String, T.Expression]]), $async$returnValue, $async$self = this, t1, t2, t3, positional, named, rest, keywordRest;
        var $async$_async_evaluate$_evaluateMacroArguments$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = invocation.$arguments;
                t2 = t1.rest;
                if (t2 == null) {
                  $async$returnValue = new S.Tuple2(t1.positional, t1.named, [null, null]);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t3 = t1.positional;
                positional = H.setRuntimeTypeInfo(t3.slice(0), [H.getTypeArgumentByIndex(t3, 0)]);
                named = B.normalizedMap(t1.named);
                $async$goto = 3;
                return P._asyncAwait(t2.accept$1($async$self), $async$_async_evaluate$_evaluateMacroArguments$1);
              case 3:
                // returning from await.
                rest = $async$result;
                t2 = J.getInterceptor(rest);
                if (!!t2.$isSassMap)
                  $async$self._async_evaluate$_addRestMap$4(named, rest, invocation.span, new E._EvaluateVisitor__evaluateMacroArguments_closure3());
                else if (!!t2.$isSassList) {
                  t3 = rest._list$_contents;
                  C.JSArray_methods.addAll$1(positional, new H.MappedListIterable(t3, new E._EvaluateVisitor__evaluateMacroArguments_closure4(), [H.getTypeArgumentByIndex(t3, 0), null]));
                  if (!!t2.$isSassArgumentList) {
                    rest._wereKeywordsAccessed = true;
                    rest._keywords._collection$_map.forEach$1(0, new E._EvaluateVisitor__evaluateMacroArguments_closure5(named));
                  }
                } else
                  positional.push(new F.ValueExpression(rest, null));
                t1 = t1.keywordRest;
                if (t1 == null) {
                  $async$returnValue = new S.Tuple2(positional, named, [null, null]);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$goto = 4;
                return P._asyncAwait(t1.accept$1($async$self), $async$_async_evaluate$_evaluateMacroArguments$1);
              case 4:
                // returning from await.
                keywordRest = $async$result;
                t1 = invocation.span;
                if (keywordRest instanceof A.SassMap) {
                  $async$self._async_evaluate$_addRestMap$4(named, keywordRest, t1, new E._EvaluateVisitor__evaluateMacroArguments_closure6());
                  $async$returnValue = new S.Tuple2(positional, named, [null, null]);
                  // goto return
                  $async$goto = 1;
                  break;
                } else
                  throw H.wrapException($async$self._async_evaluate$_exception$2("Variable keyword arguments must be a map (was " + H.S(keywordRest) + ").", t1));
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_async_evaluate$_evaluateMacroArguments$1, $async$completer);
      },
      _async_evaluate$_addRestMap$4: function(values, map, span, convert) {
        var t1 = {};
        t1.convert = convert;
        if (convert == null)
          t1.convert = new E._EvaluateVisitor__addRestMap_closure1();
        map.contents.forEach$1(0, new E._EvaluateVisitor__addRestMap_closure2(t1, this, values, map, span));
      },
      _async_evaluate$_addRestMap$3: function(values, map, span) {
        return this._async_evaluate$_addRestMap$4(values, map, span, null);
      },
      _async_evaluate$_verifyArguments$4: function(positional, named, $arguments, span) {
        return this._async_evaluate$_addExceptionSpan$2(span, new E._EvaluateVisitor__verifyArguments_closure0($arguments, positional, named));
      },
      visitSelectorExpression$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, $async$self = this, t1;
        var $async$visitSelectorExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self._async_evaluate$_styleRule;
                if (t1 == null) {
                  $async$returnValue = C.C_SassNull;
                  // goto return
                  $async$goto = 1;
                  break;
                }
                $async$returnValue = t1.originalSelector.get$asSassList();
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitSelectorExpression$1, $async$completer);
      },
      visitStringExpression$1: function(node) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(D.SassString), $async$returnValue, $async$self = this, $async$temp1, $async$temp2;
        var $async$visitStringExpression$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$temp1 = D;
                $async$temp2 = J;
                $async$goto = 3;
                return P._asyncAwait(B.mapAsync(node.text.contents, new E._EvaluateVisitor_visitStringExpression_closure0($async$self)), $async$visitStringExpression$1);
              case 3:
                // returning from await.
                $async$returnValue = new $async$temp1.SassString($async$temp2.join$0$ax($async$result), node.hasQuotes, null);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$visitStringExpression$1, $async$completer);
      },
      _async_evaluate$_handleReturn$2: function(list, callback) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(F.Value), $async$returnValue, t1, result;
        var $async$_async_evaluate$_handleReturn$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = J.get$iterator$ax(list);
              case 3:
                // for condition
                if (!t1.moveNext$0()) {
                  // goto after for
                  $async$goto = 4;
                  break;
                }
                $async$goto = 5;
                return P._asyncAwait(callback.call$1(t1.get$current(t1)), $async$_async_evaluate$_handleReturn$2);
              case 5:
                // returning from await.
                result = $async$result;
                if (result != null) {
                  $async$returnValue = result;
                  // goto return
                  $async$goto = 1;
                  break;
                }
                // goto for condition
                $async$goto = 3;
                break;
              case 4:
                // after for
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_async_evaluate$_handleReturn$2, $async$completer);
      },
      _async_evaluate$_withEnvironment$2: function(environment, callback) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$self = this, oldEnvironment, result;
        var $async$_async_evaluate$_withEnvironment$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                oldEnvironment = $async$self._async_evaluate$_environment;
                $async$self._async_evaluate$_environment = environment;
                $async$goto = 3;
                return P._asyncAwait(callback.call$0(), $async$_async_evaluate$_withEnvironment$2);
              case 3:
                // returning from await.
                result = $async$result;
                $async$self._async_evaluate$_environment = oldEnvironment;
                $async$returnValue = result;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_async_evaluate$_withEnvironment$2, $async$completer);
      },
      _async_evaluate$_interpolationToValue$3$trim$warnForColor: function(interpolation, trim, warnForColor) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter([F.CssValue, P.String]), $async$returnValue, $async$self = this, result, t1;
        var $async$_async_evaluate$_interpolationToValue$3$trim$warnForColor = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 3;
                return P._asyncAwait($async$self._async_evaluate$_performInterpolation$2$warnForColor(interpolation, warnForColor), $async$_async_evaluate$_interpolationToValue$3$trim$warnForColor);
              case 3:
                // returning from await.
                result = $async$result;
                t1 = trim ? J.trim$0$s(result) : result;
                $async$returnValue = new F.CssValue(t1, interpolation.get$span(), [null]);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_async_evaluate$_interpolationToValue$3$trim$warnForColor, $async$completer);
      },
      _async_evaluate$_interpolationToValue$1: function(interpolation) {
        return this._async_evaluate$_interpolationToValue$3$trim$warnForColor(interpolation, false, false);
      },
      _async_evaluate$_interpolationToValue$2$warnForColor: function(interpolation, warnForColor) {
        return this._async_evaluate$_interpolationToValue$3$trim$warnForColor(interpolation, false, warnForColor);
      },
      _async_evaluate$_performInterpolation$2$warnForColor: function(interpolation, warnForColor) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(P.String), $async$returnValue, $async$self = this, $async$temp1;
        var $async$_async_evaluate$_performInterpolation$2$warnForColor = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$temp1 = J;
                $async$goto = 3;
                return P._asyncAwait(B.mapAsync(J.get$contents$x(interpolation), new E._EvaluateVisitor__performInterpolation_closure0($async$self, warnForColor)), $async$_async_evaluate$_performInterpolation$2$warnForColor);
              case 3:
                // returning from await.
                $async$returnValue = $async$temp1.join$0$ax($async$result);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_async_evaluate$_performInterpolation$2$warnForColor, $async$completer);
      },
      _async_evaluate$_performInterpolation$1: function(interpolation) {
        return this._async_evaluate$_performInterpolation$2$warnForColor(interpolation, false);
      },
      _evaluateToCss$2$quote: function(expression, quote) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(P.String), $async$returnValue, $async$self = this;
        var $async$_evaluateToCss$2$quote = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 3;
                return P._asyncAwait(expression.accept$1($async$self), $async$_evaluateToCss$2$quote);
              case 3:
                // returning from await.
                $async$returnValue = $async$self._async_evaluate$_serialize$3$quote($async$result, expression.get$span(), quote);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_evaluateToCss$2$quote, $async$completer);
      },
      _evaluateToCss$1: function(expression) {
        return this._evaluateToCss$2$quote(expression, true);
      },
      _async_evaluate$_serialize$3$quote: function(value, span, quote) {
        return this._async_evaluate$_addExceptionSpan$2(span, new E._EvaluateVisitor__serialize_closure0(value, quote));
      },
      _async_evaluate$_serialize$2: function(value, span) {
        return this._async_evaluate$_serialize$3$quote(value, span, true);
      },
      _async_evaluate$_expressionSpan$1: [function(expression) {
        if (this._async_evaluate$_sourceMap !== true)
          return;
        if (expression instanceof S.VariableExpression)
          return this._async_evaluate$_environment.getVariableSpan$1(expression.name);
        else
          return expression.get$span();
      }, "call$1", "get$_async_evaluate$_expressionSpan", 4, 0, 29, 18],
      _async_evaluate$_withParent$4$scopeWhen$through: function(node, callback, scopeWhen, through) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$self = this, oldParent, $parent, grandparent, result;
        var $async$_async_evaluate$_withParent$4$scopeWhen$through = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                oldParent = $async$self._async_evaluate$_parent;
                if (through != null) {
                  for ($parent = oldParent; through.call$1($parent) === true;)
                    $parent = $parent._node0$_parent;
                  if ($parent.get$hasFollowingSibling()) {
                    grandparent = $parent._node0$_parent;
                    $parent = $parent.copyWithoutChildren$0();
                    grandparent.addChild$1($parent);
                  }
                } else
                  $parent = oldParent;
                $parent.addChild$1(node);
                $async$self._async_evaluate$_parent = node;
                $async$goto = 3;
                return P._asyncAwait($async$self._async_evaluate$_environment.scope$2$when(callback, scopeWhen), $async$_async_evaluate$_withParent$4$scopeWhen$through);
              case 3:
                // returning from await.
                result = $async$result;
                $async$self._async_evaluate$_parent = oldParent;
                $async$returnValue = result;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_async_evaluate$_withParent$4$scopeWhen$through, $async$completer);
      },
      _async_evaluate$_withParent$2: function(node, callback) {
        return this._async_evaluate$_withParent$4$scopeWhen$through(node, callback, true, null);
      },
      _async_evaluate$_withParent$3$scopeWhen: function(node, callback, scopeWhen) {
        return this._async_evaluate$_withParent$4$scopeWhen$through(node, callback, scopeWhen, null);
      },
      _withStyleRule$2: function(rule, callback) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$self = this, oldRule, result;
        var $async$_withStyleRule$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                oldRule = $async$self._async_evaluate$_styleRule;
                $async$self._async_evaluate$_styleRule = rule;
                $async$goto = 3;
                return P._asyncAwait(callback.call$0(), $async$_withStyleRule$2);
              case 3:
                // returning from await.
                result = $async$result;
                $async$self._async_evaluate$_styleRule = oldRule;
                $async$returnValue = result;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_withStyleRule$2, $async$completer);
      },
      _async_evaluate$_withMediaQueries$2: function(queries, callback) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$self = this, oldMediaQueries, result;
        var $async$_async_evaluate$_withMediaQueries$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                oldMediaQueries = $async$self._async_evaluate$_mediaQueries;
                $async$self._async_evaluate$_mediaQueries = queries;
                $async$goto = 3;
                return P._asyncAwait(callback.call$0(), $async$_async_evaluate$_withMediaQueries$2);
              case 3:
                // returning from await.
                result = $async$result;
                $async$self._async_evaluate$_mediaQueries = oldMediaQueries;
                $async$returnValue = result;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_async_evaluate$_withMediaQueries$2, $async$completer);
      },
      _async_evaluate$_withStackFrame$3: function(member, span, callback) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$self = this, t1, oldMember, result;
        var $async$_async_evaluate$_withStackFrame$3 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self._async_evaluate$_stack;
                t1.push(B.frameForSpan(span, $async$self._async_evaluate$_member));
                oldMember = $async$self._async_evaluate$_member;
                $async$self._async_evaluate$_member = member;
                $async$goto = 3;
                return P._asyncAwait(callback.call$0(), $async$_async_evaluate$_withStackFrame$3);
              case 3:
                // returning from await.
                result = $async$result;
                $async$self._async_evaluate$_member = oldMember;
                if (0 >= t1.length) {
                  $async$returnValue = H.ioore(t1, -1);
                  // goto return
                  $async$goto = 1;
                  break;
                }
                t1.pop();
                $async$returnValue = result;
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$_async_evaluate$_withStackFrame$3, $async$completer);
      },
      _async_evaluate$_stackTrace$1: function(span) {
        var t1, $frames;
        t1 = this._async_evaluate$_stack;
        $frames = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
        $frames.push(B.frameForSpan(span, this._async_evaluate$_member));
        return new Y.Trace(P.List_List$unmodifiable(new H.ReversedListIterable($frames, [H.getTypeArgumentByIndex($frames, 0)]), A.Frame), new P._StringStackTrace(null));
      },
      _async_evaluate$_warn$3$deprecation: function(message, span, deprecation) {
        return this._async_evaluate$_logger.warn$4$deprecation$span$trace(message, deprecation, span, this._async_evaluate$_stackTrace$1(span));
      },
      _async_evaluate$_warn$2: function(message, span) {
        return this._async_evaluate$_warn$3$deprecation(message, span, false);
      },
      _async_evaluate$_exception$2: function(message, span) {
        return new E.SassRuntimeException(this._async_evaluate$_stackTrace$1(span), message, span);
      },
      _async_evaluate$_adjustParseError$2: function(span, callback) {
        var error, errorText, syntheticFile, syntheticSpan, t1, exception, t2, t3, t4, t5;
        try {
          t1 = callback.call$0();
          return t1;
        } catch (exception) {
          t1 = H.unwrapException(exception);
          if (t1 instanceof E.SassFormatException) {
            error = t1;
            t1 = error;
            errorText = P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(H.interceptedTypeCast(G.SourceSpanException.prototype.get$span.call(t1), "$isFileSpan").file._decodedChars, 0, null), 0, null);
            t1 = J.getInterceptor$x(span);
            syntheticFile = C.JSString_methods.replaceRange$3(P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(t1.get$file(span)._decodedChars, 0, null), 0, null), t1.get$start(span).offset, t1.get$end(span).offset, errorText);
            t2 = t1.get$file(span).url;
            t3 = J.get$codeUnits$s(syntheticFile);
            t4 = H.setRuntimeTypeInfo([0], [P.int]);
            t5 = typeof t2 === "string" ? P.Uri_parse(t2, 0, null) : t2;
            t4 = new Y.SourceFile(t5, t4, new Uint32Array(H._ensureNativeList(t3.toList$0(t3))), null);
            t4.SourceFile$decoded$2$url(t3, t2);
            t2 = t1.get$start(span);
            t3 = error;
            t3 = H.interceptedTypeCast(G.SourceSpanException.prototype.get$span.call(t3), "$isFileSpan");
            t3 = J.$add$ansx(t2.offset, Y.FileLocation$_(t3.file, t3._file$_start).offset);
            t1 = t1.get$start(span);
            t2 = error;
            t2 = H.interceptedTypeCast(G.SourceSpanException.prototype.get$span.call(t2), "$isFileSpan");
            syntheticSpan = t4.span$2(t3, J.$add$ansx(t1.offset, Y.FileLocation$_(t2.file, t2._end).offset));
            throw H.wrapException(this._async_evaluate$_exception$2(J.get$message$x(error), syntheticSpan));
          } else
            throw exception;
        }
      },
      _async_evaluate$_addExceptionSpan$2: function(span, callback) {
        var error, t1, exception;
        try {
          t1 = callback.call$0();
          return t1;
        } catch (exception) {
          t1 = H.unwrapException(exception);
          if (t1 instanceof E.SassScriptException) {
            error = t1;
            throw H.wrapException(this._async_evaluate$_exception$2(J.get$message$x(error), span));
          } else
            throw exception;
        }
      },
      _addExceptionSpanAsync$2: function(span, callback) {
        return this._addExceptionSpanAsync$body$_EvaluateVisitor(span, callback);
      },
      _addExceptionSpanAsync$body$_EvaluateVisitor: function(span, callback) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$handler = 2, $async$currentError, $async$next = [], $async$self = this, error, t1, exception, $async$exception;
        var $async$_addExceptionSpanAsync$2 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1) {
            $async$currentError = $async$result;
            $async$goto = $async$handler;
          }
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$handler = 4;
                $async$goto = 7;
                return P._asyncAwait(callback.call$0(), $async$_addExceptionSpanAsync$2);
              case 7:
                // returning from await.
                t1 = $async$result;
                $async$returnValue = t1;
                // goto return
                $async$goto = 1;
                break;
                $async$handler = 2;
                // goto after finally
                $async$goto = 6;
                break;
              case 4:
                // catch
                $async$handler = 3;
                $async$exception = $async$currentError;
                t1 = H.unwrapException($async$exception);
                if (t1 instanceof E.SassScriptException) {
                  error = t1;
                  throw H.wrapException($async$self._async_evaluate$_exception$2(J.get$message$x(error), span));
                } else
                  throw $async$exception;
                // goto after finally
                $async$goto = 6;
                break;
              case 3:
                // uncaught
                // goto rethrow
                $async$goto = 2;
                break;
              case 6:
                // after finally
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
              case 2:
                // rethrow
                return P._asyncRethrow($async$currentError, $async$completer);
            }
        });
        return P._asyncStartSync($async$_addExceptionSpanAsync$2, $async$completer);
      },
      static: {
        _EvaluateVisitor$0: function(functions, importCache, importer, logger, nodeImporter, sourceMap, variables) {
          var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10;
          t1 = H.setRuntimeTypeInfo([], [F.CssImport]);
          t2 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
          t3 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.Uri);
          t4 = M.SimpleSelector;
          t5 = P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6(t4, P.int);
          t6 = H.setRuntimeTypeInfo([], [A.Frame]);
          t7 = importer == null ? $.$get$Importer_noOp() : importer;
          t8 = logger == null ? C.StderrLogger_false : logger;
          t9 = B.normalizedMap(null);
          t10 = sourceMap === true ? [B.normalizedMap(null)] : null;
          t10 = new Q.AsyncEnvironment([t9], t10, B.normalizedMap(null), [B.normalizedMap(null)], B.normalizedMap(null), [B.normalizedMap(null)], B.normalizedMap(null), null, null, false, true, null, null);
          t9 = $.$get$coreFunctions();
          t9.forEach$1(t9, t10.get$setFunction());
          t6 = new E._EvaluateVisitor0(importCache, nodeImporter, t8, sourceMap, t10, t7, null, null, null, null, null, null, "root stylesheet", null, false, false, false, false, 0, t1, t2, t3, new F.Extender(P.LinkedHashMap_LinkedHashMap$_empty(t4, [P.Set, X.CssStyleRule]), P.LinkedHashMap_LinkedHashMap$_empty(t4, [P.Map, S.ComplexSelector, S.Extension]), P.LinkedHashMap_LinkedHashMap$_empty(t4, [P.List, S.Extension]), new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [X.CssStyleRule, [P.List, F.CssMediaQuery]]), t5, new P._LinkedIdentityHashSet(0, null, null, null, null, null, 0, [S.ComplexSelector]), C.ExtendMode_normal), t6);
          t6._EvaluateVisitor$7$functions$importCache$importer$logger$nodeImporter$sourceMap$variables0(functions, importCache, importer, logger, nodeImporter, sourceMap, variables);
          return t6;
        }
      }
    },
    _EvaluateVisitor_closure6: {
      "^": "Closure:0;$this",
      call$1: [function($arguments) {
        var variable = J.$index$asx($arguments, 0).assertString$1("name");
        return this.$this._async_evaluate$_environment.globalVariableExists$1(variable.text) === true ? C.SassBoolean_true : C.SassBoolean_false;
      }, null, null, 4, 0, null, 0, "call"]
    },
    _EvaluateVisitor_closure7: {
      "^": "Closure:0;$this",
      call$1: [function($arguments) {
        var variable = J.$index$asx($arguments, 0).assertString$1("name");
        return this.$this._async_evaluate$_environment.variableExists$1(variable.text) ? C.SassBoolean_true : C.SassBoolean_false;
      }, null, null, 4, 0, null, 0, "call"]
    },
    _EvaluateVisitor_closure8: {
      "^": "Closure:0;$this",
      call$1: [function($arguments) {
        var variable = J.$index$asx($arguments, 0).assertString$1("name");
        return this.$this._async_evaluate$_environment.functionExists$1(variable.text) ? C.SassBoolean_true : C.SassBoolean_false;
      }, null, null, 4, 0, null, 0, "call"]
    },
    _EvaluateVisitor_closure9: {
      "^": "Closure:0;$this",
      call$1: [function($arguments) {
        var variable = J.$index$asx($arguments, 0).assertString$1("name");
        return this.$this._async_evaluate$_environment.mixinExists$1(variable.text) ? C.SassBoolean_true : C.SassBoolean_false;
      }, null, null, 4, 0, null, 0, "call"]
    },
    _EvaluateVisitor_closure10: {
      "^": "Closure:0;$this",
      call$1: [function($arguments) {
        var t1 = this.$this;
        if (!t1._async_evaluate$_environment.get$inMixin())
          throw H.wrapException(E.SassScriptException$("content-exists() may only be called within a mixin."));
        return t1._async_evaluate$_environment.get$contentBlock() != null ? C.SassBoolean_true : C.SassBoolean_false;
      }, null, null, 4, 0, null, 0, "call"]
    },
    _EvaluateVisitor_closure11: {
      "^": "Closure:0;$this",
      call$1: [function($arguments) {
        var t1, $name, t2, callable;
        t1 = J.getInterceptor$asx($arguments);
        $name = t1.$index($arguments, 0).assertString$1("name");
        t2 = $name.text;
        callable = t1.$index($arguments, 1).get$isTruthy() ? new L.PlainCssCallable(t2) : this.$this._async_evaluate$_environment.getFunction$1(t2);
        if (callable != null)
          return new F.SassFunction(callable);
        throw H.wrapException(E.SassScriptException$("Function not found: " + $name.toString$0(0)));
      }, null, null, 4, 0, null, 0, "call"]
    },
    _EvaluateVisitor_closure12: {
      "^": "Closure:6;$this",
      call$1: [function($arguments) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$self = this, t1, $function, args, t2, t3, t4, invocation, callable;
        var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = J.getInterceptor$asx($arguments);
                $function = t1.$index($arguments, 0);
                args = H.interceptedTypeCast(t1.$index($arguments, 1), "$isSassArgumentList");
                t1 = $async$self.$this;
                t2 = t1._async_evaluate$_callableSpan;
                args._wereKeywordsAccessed = true;
                t3 = args._keywords;
                t4 = t3._collection$_map;
                if (t4.get$isEmpty(t4) === true)
                  t3 = null;
                else {
                  args._wereKeywordsAccessed = true;
                  t3 = new F.ValueExpression(new A.SassMap(H.ConstantMap_ConstantMap$from(Y.mapMap(t3, new E._EvaluateVisitor__closure1(), new E._EvaluateVisitor__closure2()), null, null)), t1._async_evaluate$_callableSpan);
                }
                invocation = X.ArgumentInvocation$([], P.LinkedHashMap__makeEmpty(), t2, t3, new F.ValueExpression(args, t2));
                $async$goto = $function instanceof D.SassString ? 3 : 4;
                break;
              case 3:
                // then
                t1._async_evaluate$_warn$3$deprecation("Passing a string to call() is deprecated and will be illegal\nin Sass 4.0. Use call(get-function(" + $function.toString$0(0) + ")) instead.", t1._async_evaluate$_callableSpan, true);
                $async$goto = 5;
                return P._asyncAwait(t1.visitFunctionExpression$1(new F.FunctionExpression(X.Interpolation$([$function.text], t1._async_evaluate$_callableSpan), invocation)), $async$call$1);
              case 5:
                // returning from await.
                $async$returnValue = $async$result;
                // goto return
                $async$goto = 1;
                break;
              case 4:
                // join
                callable = $function.assertFunction$1("function").callable;
                $async$goto = !!J.getInterceptor(callable).$isAsyncCallable ? 6 : 8;
                break;
              case 6:
                // then
                $async$goto = 9;
                return P._asyncAwait(t1._async_evaluate$_runFunctionCallable$3(invocation, callable, t1._async_evaluate$_callableSpan), $async$call$1);
              case 9:
                // returning from await.
                $async$returnValue = $async$result;
                // goto return
                $async$goto = 1;
                break;
                // goto join
                $async$goto = 7;
                break;
              case 8:
                // else
                throw H.wrapException(E.SassScriptException$("The function " + H.S(callable.get$name()) + " is asynchronous.\nThis is probably caused by a bug in a Sass plugin."));
              case 7:
                // join
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$1, $async$completer);
      }, null, null, 4, 0, null, 0, "call"]
    },
    _EvaluateVisitor__closure1: {
      "^": "Closure:10;",
      call$2: function(key, _) {
        return new D.SassString(key, false, null);
      }
    },
    _EvaluateVisitor__closure2: {
      "^": "Closure:10;",
      call$2: function(_, value) {
        return value;
      }
    },
    _EvaluateVisitor_visitStylesheet_closure0: {
      "^": "Closure:0;$this",
      call$1: function(children) {
        var t1 = this.$this;
        C.JSArray_methods.insertAll$2(children, t1._async_evaluate$_endOfImports, t1._async_evaluate$_outOfOrderImports);
      }
    },
    _EvaluateVisitor_visitAtRootRule_closure2: {
      "^": "Closure:1;$this,resolved",
      call$0: function() {
        var t1, t2, t3;
        t1 = this.resolved;
        t2 = J.get$codeUnits$s(t1);
        t3 = H.setRuntimeTypeInfo([0], [P.int]);
        t3 = new Y.SourceFile(null, t3, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
        t3.SourceFile$decoded$2$url(t2, null);
        return new V.AtRootQueryParser(new S.SpanScanner(t3, null, null, t1, 0, null, null), this.$this._async_evaluate$_logger).parse$0();
      }
    },
    _EvaluateVisitor_visitAtRootRule_closure3: {
      "^": "Closure:4;$this,node",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1, t2, t3, _i;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.node.children, t2 = t1.length, t3 = $async$self.$this, _i = 0;
              case 2:
                // for condition
                if (!(_i < t2)) {
                  // goto after for
                  $async$goto = 4;
                  break;
                }
                $async$goto = 5;
                return P._asyncAwait(t1[_i].accept$1(t3), $async$call$0);
              case 5:
                // returning from await.
              case 3:
                // for update
                ++_i;
                // goto for condition
                $async$goto = 2;
                break;
              case 4:
                // after for
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor_visitAtRootRule_closure4: {
      "^": "Closure:4;$this,node",
      call$0: [function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1, t2, t3, _i;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.node.children, t2 = t1.length, t3 = $async$self.$this, _i = 0;
              case 2:
                // for condition
                if (!(_i < t2)) {
                  // goto after for
                  $async$goto = 4;
                  break;
                }
                $async$goto = 5;
                return P._asyncAwait(t1[_i].accept$1(t3), $async$call$0);
              case 5:
                // returning from await.
              case 3:
                // for update
                ++_i;
                // goto for condition
                $async$goto = 2;
                break;
              case 4:
                // after for
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }, null, null, 0, 0, null, "call"]
    },
    _EvaluateVisitor__scopeForAtRoot_closure5: {
      "^": "Closure:77;$this,newParent,node",
      call$1: function(callback) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1, oldParent;
        var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this;
                oldParent = t1._async_evaluate$_parent;
                t1._async_evaluate$_parent = $async$self.newParent;
                $async$goto = 2;
                return P._asyncAwait(t1._async_evaluate$_environment.scope$2$when(callback, $async$self.node.hasDeclarations), $async$call$1);
              case 2:
                // returning from await.
                t1._async_evaluate$_parent = oldParent;
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$1, $async$completer);
      }
    },
    _EvaluateVisitor__scopeForAtRoot_closure6: {
      "^": "Closure:6;$this,innerScope",
      call$1: function(callback) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1, oldAtRootExcludingStyleRule;
        var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this;
                oldAtRootExcludingStyleRule = t1._async_evaluate$_atRootExcludingStyleRule;
                t1._async_evaluate$_atRootExcludingStyleRule = true;
                $async$goto = 2;
                return P._asyncAwait($async$self.innerScope.call$1(callback), $async$call$1);
              case 2:
                // returning from await.
                t1._async_evaluate$_atRootExcludingStyleRule = oldAtRootExcludingStyleRule;
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$1, $async$completer);
      }
    },
    _EvaluateVisitor__scopeForAtRoot_closure7: {
      "^": "Closure:0;$this,innerScope",
      call$1: function(callback) {
        return this.$this._async_evaluate$_withMediaQueries$2(null, new E._EvaluateVisitor__scopeForAtRoot__closure0(this.innerScope, callback));
      }
    },
    _EvaluateVisitor__scopeForAtRoot__closure0: {
      "^": "Closure:1;innerScope,callback",
      call$0: function() {
        return this.innerScope.call$1(this.callback);
      }
    },
    _EvaluateVisitor__scopeForAtRoot_closure8: {
      "^": "Closure:6;$this,innerScope",
      call$1: function(callback) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1, wasInKeyframes;
        var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this;
                wasInKeyframes = t1._async_evaluate$_inKeyframes;
                t1._async_evaluate$_inKeyframes = false;
                $async$goto = 2;
                return P._asyncAwait($async$self.innerScope.call$1(callback), $async$call$1);
              case 2:
                // returning from await.
                t1._async_evaluate$_inKeyframes = wasInKeyframes;
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$1, $async$completer);
      }
    },
    _EvaluateVisitor__scopeForAtRoot_closure9: {
      "^": "Closure:0;",
      call$1: function($parent) {
        return $parent instanceof U.CssAtRule;
      }
    },
    _EvaluateVisitor__scopeForAtRoot_closure10: {
      "^": "Closure:6;$this,innerScope",
      call$1: function(callback) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1, wasInUnknownAtRule;
        var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this;
                wasInUnknownAtRule = t1._async_evaluate$_inUnknownAtRule;
                t1._async_evaluate$_inUnknownAtRule = false;
                $async$goto = 2;
                return P._asyncAwait($async$self.innerScope.call$1(callback), $async$call$1);
              case 2:
                // returning from await.
                t1._async_evaluate$_inUnknownAtRule = wasInUnknownAtRule;
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$1, $async$completer);
      }
    },
    _EvaluateVisitor_visitContentRule_closure0: {
      "^": "Closure:4;$this,block",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this;
                $async$goto = 2;
                return P._asyncAwait(t1._async_evaluate$_withEnvironment$2(t1._async_evaluate$_environment.get$contentEnvironment().closure$0(), new E._EvaluateVisitor_visitContentRule__closure0(t1, $async$self.block)), $async$call$0);
              case 2:
                // returning from await.
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor_visitContentRule__closure0: {
      "^": "Closure:4;$this,block",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1, t2, t3, _i;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.block, t2 = t1.length, t3 = $async$self.$this, _i = 0;
              case 2:
                // for condition
                if (!(_i < t2)) {
                  // goto after for
                  $async$goto = 4;
                  break;
                }
                $async$goto = 5;
                return P._asyncAwait(t1[_i].accept$1(t3), $async$call$0);
              case 5:
                // returning from await.
              case 3:
                // for update
                ++_i;
                // goto for condition
                $async$goto = 2;
                break;
              case 4:
                // after for
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor_visitDeclaration_closure0: {
      "^": "Closure:4;$this,node",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1, t2, t3, _i;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.node.get$children(), t2 = t1.length, t3 = $async$self.$this, _i = 0;
              case 2:
                // for condition
                if (!(_i < t2)) {
                  // goto after for
                  $async$goto = 4;
                  break;
                }
                $async$goto = 5;
                return P._asyncAwait(t1[_i].accept$1(t3), $async$call$0);
              case 5:
                // returning from await.
              case 3:
                // for update
                ++_i;
                // goto for condition
                $async$goto = 2;
                break;
              case 4:
                // after for
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor_visitEachRule_closure2: {
      "^": "Closure:16;$this,node,span",
      call$1: function(value) {
        return this.$this._async_evaluate$_environment.setLocalVariable$3(C.JSArray_methods.get$first(this.node.variables), value.withoutSlash$0(), this.span);
      }
    },
    _EvaluateVisitor_visitEachRule_closure3: {
      "^": "Closure:16;$this,node,span",
      call$1: function(value) {
        return this.$this._async_evaluate$_setMultipleVariables$3(this.node.variables, value, this.span);
      }
    },
    _EvaluateVisitor_visitEachRule_closure4: {
      "^": "Closure:1;$this,list,setVariables,node",
      call$0: function() {
        var t1 = this.$this;
        return t1._async_evaluate$_handleReturn$2(this.list.get$asList(), new E._EvaluateVisitor_visitEachRule__closure0(t1, this.setVariables, this.node));
      }
    },
    _EvaluateVisitor_visitEachRule__closure0: {
      "^": "Closure:0;$this,setVariables,node",
      call$1: function(element) {
        var t1;
        this.setVariables.call$1(element);
        t1 = this.$this;
        return t1._async_evaluate$_handleReturn$2(this.node.children, new E._EvaluateVisitor_visitEachRule___closure0(t1));
      }
    },
    _EvaluateVisitor_visitEachRule___closure0: {
      "^": "Closure:0;$this",
      call$1: function(child) {
        return child.accept$1(this.$this);
      }
    },
    _EvaluateVisitor_visitExtendRule_closure0: {
      "^": "Closure:1;$this,targetText",
      call$0: function() {
        var error, compound, t1, t2, t3, exception;
        try {
          t1 = J.trim$0$s(this.targetText.get$value());
          t2 = C.JSString_methods.get$codeUnits(t1);
          t3 = H.setRuntimeTypeInfo([0], [P.int]);
          t3 = new Y.SourceFile(null, t3, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
          t3.SourceFile$decoded$2$url(t2, null);
          t1 = new T.SelectorParser(false, new S.SpanScanner(t3, null, null, t1, 0, null, null), this.$this._async_evaluate$_logger).parseSimpleSelector$0();
          return t1;
        } catch (exception) {
          t1 = H.unwrapException(exception);
          if (t1 instanceof E.SassFormatException) {
            error = t1;
            compound = null;
            try {
              t1 = J.trim$0$s(this.targetText.get$value());
              t2 = C.JSString_methods.get$codeUnits(t1);
              t3 = H.setRuntimeTypeInfo([0], [P.int]);
              t3 = new Y.SourceFile(null, t3, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
              t3.SourceFile$decoded$2$url(t2, null);
              compound = new T.SelectorParser(false, new S.SpanScanner(t3, null, null, t1, 0, null, null), this.$this._async_evaluate$_logger).parseCompoundSelector$0();
            } catch (exception) {
              if (H.unwrapException(exception) instanceof E.SassFormatException)
                throw H.wrapException(error);
              else
                throw exception;
            }
            throw H.wrapException(E.SassFormatException$("compound selectors may longer be extended.\nConsider `@extend " + C.JSArray_methods.join$1(compound.get$components(), ", ") + "` instead.\nSee http://bit.ly/ExtendCompound for details.\n", error.get$span()));
          } else
            throw exception;
        }
      }
    },
    _EvaluateVisitor_visitAtRule_closure1: {
      "^": "Closure:4;$this,node",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1, t2;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this;
                t2 = t1._async_evaluate$_styleRule;
                $async$goto = !(t2 != null && !t1._async_evaluate$_atRootExcludingStyleRule) ? 2 : 4;
                break;
              case 2:
                // then
                t2 = J.get$iterator$ax($async$self.node.get$children());
              case 5:
                // for condition
                if (!t2.moveNext$0()) {
                  // goto after for
                  $async$goto = 6;
                  break;
                }
                $async$goto = 7;
                return P._asyncAwait(t2.get$current(t2).accept$1(t1), $async$call$0);
              case 7:
                // returning from await.
                // goto for condition
                $async$goto = 5;
                break;
              case 6:
                // after for
                // goto join
                $async$goto = 3;
                break;
              case 4:
                // else
                $async$goto = 8;
                return P._asyncAwait(t1._async_evaluate$_withParent$3$scopeWhen(X.CssStyleRule$(t2.selector, t2.span, t2.originalSelector), new E._EvaluateVisitor_visitAtRule__closure0(t1, $async$self.node), false), $async$call$0);
              case 8:
                // returning from await.
              case 3:
                // join
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor_visitAtRule__closure0: {
      "^": "Closure:4;$this,node",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1, t2;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = J.get$iterator$ax($async$self.node.get$children()), t2 = $async$self.$this;
              case 2:
                // for condition
                if (!t1.moveNext$0()) {
                  // goto after for
                  $async$goto = 3;
                  break;
                }
                $async$goto = 4;
                return P._asyncAwait(t1.get$current(t1).accept$1(t2), $async$call$0);
              case 4:
                // returning from await.
                // goto for condition
                $async$goto = 2;
                break;
              case 3:
                // after for
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor_visitAtRule_closure2: {
      "^": "Closure:0;",
      call$1: function(node) {
        return node instanceof X.CssStyleRule;
      }
    },
    _EvaluateVisitor_visitForRule_closure4: {
      "^": "Closure:4;$this,node",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$self = this;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 3;
                return P._asyncAwait($async$self.node.from.accept$1($async$self.$this), $async$call$0);
              case 3:
                // returning from await.
                $async$returnValue = $async$result.assertNumber$0();
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor_visitForRule_closure5: {
      "^": "Closure:4;$this,node",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$self = this;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                $async$goto = 3;
                return P._asyncAwait($async$self.node.to.accept$1($async$self.$this), $async$call$0);
              case 3:
                // returning from await.
                $async$returnValue = $async$result.assertNumber$0();
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor_visitForRule_closure6: {
      "^": "Closure:1;fromNumber,toNumber",
      call$0: function() {
        var t1 = this.toNumber;
        return this.fromNumber.coerce$2(t1.get$numeratorUnits(), t1.get$denominatorUnits()).assertInt$0();
      }
    },
    _EvaluateVisitor_visitForRule_closure7: {
      "^": "Closure:1;toNumber",
      call$0: function() {
        return this.toNumber.assertInt$0();
      }
    },
    _EvaluateVisitor_visitForRule_closure8: {
      "^": "Closure:4;_box_0,$this,node,from,direction",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$self = this, t1, t2, span, i, t3, t4, t5, t6, t7, result;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this;
                t2 = $async$self.node;
                span = t1._async_evaluate$_expressionSpan$1(t2.from);
                i = $async$self.from, t3 = $async$self._box_0, t4 = $async$self.direction, t5 = t2.children, t2 = t2.variable;
              case 3:
                // for condition
                if (!(t6 = J.getInterceptor(i), t6.$eq(i, t3.to) !== true)) {
                  // goto after for
                  $async$goto = 5;
                  break;
                }
                t7 = t1._async_evaluate$_environment;
                t7.setLocalVariable$3(t2, new T.SassNumber(i, C.List_empty, C.List_empty, null), span);
                $async$goto = 6;
                return P._asyncAwait(t1._async_evaluate$_handleReturn$2(t5, new E._EvaluateVisitor_visitForRule__closure0(t1)), $async$call$0);
              case 6:
                // returning from await.
                result = $async$result;
                if (result != null) {
                  $async$returnValue = result;
                  // goto return
                  $async$goto = 1;
                  break;
                }
              case 4:
                // for update
                i = t6.$add(i, t4);
                // goto for condition
                $async$goto = 3;
                break;
              case 5:
                // after for
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor_visitForRule__closure0: {
      "^": "Closure:0;$this",
      call$1: function(child) {
        return child.accept$1(this.$this);
      }
    },
    _EvaluateVisitor_visitIfRule_closure0: {
      "^": "Closure:1;_box_0,$this",
      call$0: function() {
        var t1 = this.$this;
        return t1._async_evaluate$_handleReturn$2(this._box_0.clause.get$children(), new E._EvaluateVisitor_visitIfRule__closure0(t1));
      }
    },
    _EvaluateVisitor_visitIfRule__closure0: {
      "^": "Closure:0;$this",
      call$1: function(child) {
        return child.accept$1(this.$this);
      }
    },
    _EvaluateVisitor__visitDynamicImport_closure0: {
      "^": "Closure:4;$this,importer,url,stylesheet",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this;
                $async$goto = 2;
                return P._asyncAwait(t1._async_evaluate$_withEnvironment$2(t1._async_evaluate$_environment.global$0(), new E._EvaluateVisitor__visitDynamicImport__closure0(t1, $async$self.importer, $async$self.url, $async$self.stylesheet)), $async$call$0);
              case 2:
                // returning from await.
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor__visitDynamicImport__closure0: {
      "^": "Closure:4;$this,importer,url,stylesheet",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1, oldImporter, oldBaseUrl, t2;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this;
                oldImporter = t1._async_evaluate$_importer;
                oldBaseUrl = t1._async_evaluate$_baseUrl;
                t1._async_evaluate$_importer = $async$self.importer;
                t1._async_evaluate$_baseUrl = $async$self.url;
                t2 = J.get$iterator$ax($async$self.stylesheet.get$children());
              case 2:
                // for condition
                if (!t2.moveNext$0()) {
                  // goto after for
                  $async$goto = 3;
                  break;
                }
                $async$goto = 4;
                return P._asyncAwait(t2.get$current(t2).accept$1(t1), $async$call$0);
              case 4:
                // returning from await.
                // goto for condition
                $async$goto = 2;
                break;
              case 3:
                // after for
                t1._async_evaluate$_importer = oldImporter;
                t1._async_evaluate$_baseUrl = oldBaseUrl;
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor_visitIncludeRule_closure0: {
      "^": "Closure:4;$this,node,environment,mixin",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this;
                $async$goto = 2;
                return P._asyncAwait(t1._async_evaluate$_environment.withContent$3($async$self.node.children, $async$self.environment, new E._EvaluateVisitor_visitIncludeRule__closure0(t1, $async$self.mixin)), $async$call$0);
              case 2:
                // returning from await.
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor_visitIncludeRule__closure0: {
      "^": "Closure:4;$this,mixin",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$self = this, t1;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this;
                $async$goto = 3;
                return P._asyncAwait(t1._async_evaluate$_environment.asMixin$1(new E._EvaluateVisitor_visitIncludeRule___closure0(t1, $async$self.mixin)), $async$call$0);
              case 3:
                // returning from await.
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor_visitIncludeRule___closure0: {
      "^": "Closure:4;$this,mixin",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1, t2, t3, _i;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.mixin.declaration.children, t2 = t1.length, t3 = $async$self.$this, _i = 0;
              case 2:
                // for condition
                if (!(_i < t2)) {
                  // goto after for
                  $async$goto = 4;
                  break;
                }
                $async$goto = 5;
                return P._asyncAwait(t1[_i].accept$1(t3), $async$call$0);
              case 5:
                // returning from await.
              case 3:
                // for update
                ++_i;
                // goto for condition
                $async$goto = 2;
                break;
              case 4:
                // after for
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor_visitMediaRule_closure1: {
      "^": "Closure:4;_box_0,$this,node",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this;
                $async$goto = 2;
                return P._asyncAwait(t1._async_evaluate$_withMediaQueries$2($async$self._box_0.queries, new E._EvaluateVisitor_visitMediaRule__closure0(t1, $async$self.node)), $async$call$0);
              case 2:
                // returning from await.
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor_visitMediaRule__closure0: {
      "^": "Closure:4;$this,node",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1, t2;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this;
                t2 = t1._async_evaluate$_styleRule;
                $async$goto = !(t2 != null && !t1._async_evaluate$_atRootExcludingStyleRule) ? 2 : 4;
                break;
              case 2:
                // then
                t2 = J.get$iterator$ax($async$self.node.get$children());
              case 5:
                // for condition
                if (!t2.moveNext$0()) {
                  // goto after for
                  $async$goto = 6;
                  break;
                }
                $async$goto = 7;
                return P._asyncAwait(t2.get$current(t2).accept$1(t1), $async$call$0);
              case 7:
                // returning from await.
                // goto for condition
                $async$goto = 5;
                break;
              case 6:
                // after for
                // goto join
                $async$goto = 3;
                break;
              case 4:
                // else
                $async$goto = 8;
                return P._asyncAwait(t1._async_evaluate$_withParent$3$scopeWhen(X.CssStyleRule$(t2.selector, t2.span, t2.originalSelector), new E._EvaluateVisitor_visitMediaRule___closure0(t1, $async$self.node), false), $async$call$0);
              case 8:
                // returning from await.
              case 3:
                // join
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor_visitMediaRule___closure0: {
      "^": "Closure:4;$this,node",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1, t2;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = J.get$iterator$ax($async$self.node.get$children()), t2 = $async$self.$this;
              case 2:
                // for condition
                if (!t1.moveNext$0()) {
                  // goto after for
                  $async$goto = 3;
                  break;
                }
                $async$goto = 4;
                return P._asyncAwait(t1.get$current(t1).accept$1(t2), $async$call$0);
              case 4:
                // returning from await.
                // goto for condition
                $async$goto = 2;
                break;
              case 3:
                // after for
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor_visitMediaRule_closure2: {
      "^": "Closure:0;",
      call$1: function(node) {
        var t1 = J.getInterceptor(node);
        return !!t1.$isCssStyleRule || !!t1.$isCssMediaRule;
      }
    },
    _EvaluateVisitor__visitMediaQueries_closure0: {
      "^": "Closure:1;$this,resolved",
      call$0: function() {
        var t1, t2, t3;
        t1 = this.resolved;
        t2 = J.get$codeUnits$s(t1);
        t3 = H.setRuntimeTypeInfo([0], [P.int]);
        t3 = new Y.SourceFile(null, t3, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
        t3.SourceFile$decoded$2$url(t2, null);
        return new F.MediaQueryParser(new S.SpanScanner(t3, null, null, t1, 0, null, null), this.$this._async_evaluate$_logger).parse$0();
      }
    },
    _EvaluateVisitor__mergeMediaQueries_closure1: {
      "^": "Closure:0;queries2",
      call$1: function(query1) {
        return J.map$1$ax(this.queries2, new E._EvaluateVisitor__mergeMediaQueries__closure0(query1));
      }
    },
    _EvaluateVisitor__mergeMediaQueries__closure0: {
      "^": "Closure:0;query1",
      call$1: [function(query2) {
        return this.query1.merge$1(query2);
      }, null, null, 4, 0, null, 42, "call"]
    },
    _EvaluateVisitor__mergeMediaQueries_closure2: {
      "^": "Closure:0;",
      call$1: function(query) {
        return query != null;
      }
    },
    _EvaluateVisitor_visitStyleRule_closure6: {
      "^": "Closure:1;$this,selectorText",
      call$0: function() {
        var t1, t2, t3;
        t1 = this.selectorText.get$value();
        t2 = J.get$codeUnits$s(t1);
        t3 = H.setRuntimeTypeInfo([0], [P.int]);
        t3 = new Y.SourceFile(null, t3, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
        t3.SourceFile$decoded$2$url(t2, null);
        return new E.KeyframeSelectorParser(new S.SpanScanner(t3, null, null, t1, 0, null, null), this.$this._async_evaluate$_logger).parse$0();
      }
    },
    _EvaluateVisitor_visitStyleRule_closure7: {
      "^": "Closure:4;$this,node",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1, t2;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = J.get$iterator$ax($async$self.node.get$children()), t2 = $async$self.$this;
              case 2:
                // for condition
                if (!t1.moveNext$0()) {
                  // goto after for
                  $async$goto = 3;
                  break;
                }
                $async$goto = 4;
                return P._asyncAwait(t1.get$current(t1).accept$1(t2), $async$call$0);
              case 4:
                // returning from await.
                // goto for condition
                $async$goto = 2;
                break;
              case 3:
                // after for
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor_visitStyleRule_closure8: {
      "^": "Closure:0;",
      call$1: function(node) {
        return node instanceof X.CssStyleRule;
      }
    },
    _EvaluateVisitor_visitStyleRule_closure9: {
      "^": "Closure:1;$this,selectorText",
      call$0: function() {
        var t1, t2, t3;
        t1 = this.selectorText.get$value();
        t2 = J.get$codeUnits$s(t1);
        t3 = H.setRuntimeTypeInfo([0], [P.int]);
        t3 = new Y.SourceFile(null, t3, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
        t3.SourceFile$decoded$2$url(t2, null);
        return new T.SelectorParser(true, new S.SpanScanner(t3, null, null, t1, 0, null, null), this.$this._async_evaluate$_logger).parse$0();
      }
    },
    _EvaluateVisitor_visitStyleRule_closure10: {
      "^": "Closure:1;_box_0,$this",
      call$0: function() {
        var t1, t2, t3;
        t1 = this._box_0.parsedSelector;
        t2 = this.$this;
        t3 = t2._async_evaluate$_styleRule;
        t3 = t3 == null ? null : t3.originalSelector;
        return t1.resolveParentSelectors$2$implicitParent(t3, !t2._async_evaluate$_atRootExcludingStyleRule);
      }
    },
    _EvaluateVisitor_visitStyleRule_closure11: {
      "^": "Closure:4;$this,rule,node",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this;
                $async$goto = 2;
                return P._asyncAwait(t1._withStyleRule$2($async$self.rule, new E._EvaluateVisitor_visitStyleRule__closure0(t1, $async$self.node)), $async$call$0);
              case 2:
                // returning from await.
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor_visitStyleRule__closure0: {
      "^": "Closure:4;$this,node",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1, t2;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = J.get$iterator$ax($async$self.node.get$children()), t2 = $async$self.$this;
              case 2:
                // for condition
                if (!t1.moveNext$0()) {
                  // goto after for
                  $async$goto = 3;
                  break;
                }
                $async$goto = 4;
                return P._asyncAwait(t1.get$current(t1).accept$1(t2), $async$call$0);
              case 4:
                // returning from await.
                // goto for condition
                $async$goto = 2;
                break;
              case 3:
                // after for
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor_visitStyleRule_closure12: {
      "^": "Closure:0;",
      call$1: function(node) {
        return node instanceof X.CssStyleRule;
      }
    },
    _EvaluateVisitor_visitSupportsRule_closure1: {
      "^": "Closure:4;$this,node",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1, t2;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.$this;
                t2 = t1._async_evaluate$_styleRule;
                $async$goto = !(t2 != null && !t1._async_evaluate$_atRootExcludingStyleRule) ? 2 : 4;
                break;
              case 2:
                // then
                t2 = J.get$iterator$ax($async$self.node.get$children());
              case 5:
                // for condition
                if (!t2.moveNext$0()) {
                  // goto after for
                  $async$goto = 6;
                  break;
                }
                $async$goto = 7;
                return P._asyncAwait(t2.get$current(t2).accept$1(t1), $async$call$0);
              case 7:
                // returning from await.
                // goto for condition
                $async$goto = 5;
                break;
              case 6:
                // after for
                // goto join
                $async$goto = 3;
                break;
              case 4:
                // else
                $async$goto = 8;
                return P._asyncAwait(t1._async_evaluate$_withParent$2(X.CssStyleRule$(t2.selector, t2.span, t2.originalSelector), new E._EvaluateVisitor_visitSupportsRule__closure0(t1, $async$self.node)), $async$call$0);
              case 8:
                // returning from await.
              case 3:
                // join
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor_visitSupportsRule__closure0: {
      "^": "Closure:4;$this,node",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$self = this, t1, t2;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = J.get$iterator$ax($async$self.node.get$children()), t2 = $async$self.$this;
              case 2:
                // for condition
                if (!t1.moveNext$0()) {
                  // goto after for
                  $async$goto = 3;
                  break;
                }
                $async$goto = 4;
                return P._asyncAwait(t1.get$current(t1).accept$1(t2), $async$call$0);
              case 4:
                // returning from await.
                // goto for condition
                $async$goto = 2;
                break;
              case 3:
                // after for
                // implicit return
                return P._asyncReturn(null, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor_visitSupportsRule_closure2: {
      "^": "Closure:0;",
      call$1: function(node) {
        return node instanceof X.CssStyleRule;
      }
    },
    _EvaluateVisitor_visitWarnRule_closure0: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        return this.node.expression.accept$1(this.$this);
      }
    },
    _EvaluateVisitor_visitWhileRule_closure0: {
      "^": "Closure:4;$this,node",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$self = this, t1, t2, t3, result;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.node, t2 = t1.condition, t3 = $async$self.$this, t1 = t1.children;
              case 3:
                // for condition
                $async$goto = 5;
                return P._asyncAwait(t2.accept$1(t3), $async$call$0);
              case 5:
                // returning from await.
                if (!$async$result.get$isTruthy()) {
                  // goto after for
                  $async$goto = 4;
                  break;
                }
                $async$goto = 6;
                return P._asyncAwait(t3._async_evaluate$_handleReturn$2(t1, new E._EvaluateVisitor_visitWhileRule__closure0(t3)), $async$call$0);
              case 6:
                // returning from await.
                result = $async$result;
                if (result != null) {
                  $async$returnValue = result;
                  // goto return
                  $async$goto = 1;
                  break;
                }
                // goto for condition
                $async$goto = 3;
                break;
              case 4:
                // after for
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor_visitWhileRule__closure0: {
      "^": "Closure:0;$this",
      call$1: function(child) {
        return child.accept$1(this.$this);
      }
    },
    _EvaluateVisitor_visitBinaryOperationExpression_closure0: {
      "^": "Closure:4;$this,node",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$self = this, t1, t2, t3, left, right, result, leftSlash, rightSlash, $async$temp1, $async$temp2;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.node;
                t2 = t1.left;
                t3 = $async$self.$this;
                $async$goto = 3;
                return P._asyncAwait(t2.accept$1(t3), $async$call$0);
              case 3:
                // returning from await.
                left = $async$result;
              case 4:
                // switch
                switch (t1.operator) {
                  case C.BinaryOperator_kjl:
                    // goto case
                    $async$goto = 6;
                    break;
                  case C.BinaryOperator_or_or_1:
                    // goto case
                    $async$goto = 7;
                    break;
                  case C.BinaryOperator_and_and_2:
                    // goto case
                    $async$goto = 8;
                    break;
                  case C.BinaryOperator_YlX:
                    // goto case
                    $async$goto = 9;
                    break;
                  case C.BinaryOperator_i5H:
                    // goto case
                    $async$goto = 10;
                    break;
                  case C.BinaryOperator_AcR0:
                    // goto case
                    $async$goto = 11;
                    break;
                  case C.BinaryOperator_1da:
                    // goto case
                    $async$goto = 12;
                    break;
                  case C.BinaryOperator_8qt:
                    // goto case
                    $async$goto = 13;
                    break;
                  case C.BinaryOperator_33h:
                    // goto case
                    $async$goto = 14;
                    break;
                  case C.BinaryOperator_AcR:
                    // goto case
                    $async$goto = 15;
                    break;
                  case C.BinaryOperator_iyO:
                    // goto case
                    $async$goto = 16;
                    break;
                  case C.BinaryOperator_O1M:
                    // goto case
                    $async$goto = 17;
                    break;
                  case C.BinaryOperator_RTB:
                    // goto case
                    $async$goto = 18;
                    break;
                  case C.BinaryOperator_2ad:
                    // goto case
                    $async$goto = 19;
                    break;
                  default:
                    // goto default
                    $async$goto = 20;
                    break;
                }
                break;
              case 6:
                // case
                $async$temp1 = left;
                $async$goto = 21;
                return P._asyncAwait(t1.right.accept$1(t3), $async$call$0);
              case 21:
                // returning from await.
                $async$returnValue = $async$temp1.singleEquals$1($async$result);
                // goto return
                $async$goto = 1;
                break;
              case 7:
                // case
                $async$goto = left.get$isTruthy() ? 22 : 24;
                break;
              case 22:
                // then
                $async$result = left;
                // goto join
                $async$goto = 23;
                break;
              case 24:
                // else
                $async$goto = 25;
                return P._asyncAwait(t1.right.accept$1(t3), $async$call$0);
              case 25:
                // returning from await.
              case 23:
                // join
                $async$returnValue = $async$result;
                // goto return
                $async$goto = 1;
                break;
              case 8:
                // case
                $async$goto = left.get$isTruthy() ? 26 : 28;
                break;
              case 26:
                // then
                $async$goto = 29;
                return P._asyncAwait(t1.right.accept$1(t3), $async$call$0);
              case 29:
                // returning from await.
                // goto join
                $async$goto = 27;
                break;
              case 28:
                // else
                $async$result = left;
              case 27:
                // join
                $async$returnValue = $async$result;
                // goto return
                $async$goto = 1;
                break;
              case 9:
                // case
                $async$temp1 = J;
                $async$temp2 = left;
                $async$goto = 30;
                return P._asyncAwait(t1.right.accept$1(t3), $async$call$0);
              case 30:
                // returning from await.
                $async$returnValue = $async$temp1.$eq$($async$temp2, $async$result) === true ? C.SassBoolean_true : C.SassBoolean_false;
                // goto return
                $async$goto = 1;
                break;
              case 10:
                // case
                $async$temp1 = J;
                $async$temp2 = left;
                $async$goto = 31;
                return P._asyncAwait(t1.right.accept$1(t3), $async$call$0);
              case 31:
                // returning from await.
                $async$returnValue = $async$temp1.$eq$($async$temp2, $async$result) !== true ? C.SassBoolean_true : C.SassBoolean_false;
                // goto return
                $async$goto = 1;
                break;
              case 11:
                // case
                $async$temp1 = left;
                $async$goto = 32;
                return P._asyncAwait(t1.right.accept$1(t3), $async$call$0);
              case 32:
                // returning from await.
                $async$returnValue = $async$temp1.greaterThan$1($async$result);
                // goto return
                $async$goto = 1;
                break;
              case 12:
                // case
                $async$temp1 = left;
                $async$goto = 33;
                return P._asyncAwait(t1.right.accept$1(t3), $async$call$0);
              case 33:
                // returning from await.
                $async$returnValue = $async$temp1.greaterThanOrEquals$1($async$result);
                // goto return
                $async$goto = 1;
                break;
              case 13:
                // case
                $async$temp1 = left;
                $async$goto = 34;
                return P._asyncAwait(t1.right.accept$1(t3), $async$call$0);
              case 34:
                // returning from await.
                $async$returnValue = $async$temp1.lessThan$1($async$result);
                // goto return
                $async$goto = 1;
                break;
              case 14:
                // case
                $async$temp1 = left;
                $async$goto = 35;
                return P._asyncAwait(t1.right.accept$1(t3), $async$call$0);
              case 35:
                // returning from await.
                $async$returnValue = $async$temp1.lessThanOrEquals$1($async$result);
                // goto return
                $async$goto = 1;
                break;
              case 15:
                // case
                $async$temp1 = left;
                $async$goto = 36;
                return P._asyncAwait(t1.right.accept$1(t3), $async$call$0);
              case 36:
                // returning from await.
                $async$returnValue = $async$temp1.plus$1($async$result);
                // goto return
                $async$goto = 1;
                break;
              case 16:
                // case
                $async$temp1 = left;
                $async$goto = 37;
                return P._asyncAwait(t1.right.accept$1(t3), $async$call$0);
              case 37:
                // returning from await.
                $async$returnValue = $async$temp1.minus$1($async$result);
                // goto return
                $async$goto = 1;
                break;
              case 17:
                // case
                $async$temp1 = left;
                $async$goto = 38;
                return P._asyncAwait(t1.right.accept$1(t3), $async$call$0);
              case 38:
                // returning from await.
                $async$returnValue = $async$temp1.times$1($async$result);
                // goto return
                $async$goto = 1;
                break;
              case 18:
                // case
                $async$goto = 39;
                return P._asyncAwait(t1.right.accept$1(t3), $async$call$0);
              case 39:
                // returning from await.
                right = $async$result;
                result = left.dividedBy$1(right);
                if (t1.allowsSlash && left instanceof T.SassNumber && right instanceof T.SassNumber) {
                  leftSlash = left.get$asSlash();
                  if (leftSlash == null)
                    leftSlash = t3._async_evaluate$_serialize$2(left, t2.get$span());
                  rightSlash = right.asSlash;
                  if (rightSlash == null)
                    rightSlash = t3._async_evaluate$_serialize$2(right, t2.get$span());
                  H.interceptedTypeCast(result, "$isSassNumber");
                  $async$returnValue = new T.SassNumber(result.value, result.numeratorUnits, result.denominatorUnits, H.S(leftSlash) + "/" + H.S(rightSlash));
                  // goto return
                  $async$goto = 1;
                  break;
                } else {
                  $async$returnValue = result;
                  // goto return
                  $async$goto = 1;
                  break;
                }
              case 19:
                // case
                $async$temp1 = left;
                $async$goto = 40;
                return P._asyncAwait(t1.right.accept$1(t3), $async$call$0);
              case 40:
                // returning from await.
                $async$returnValue = $async$temp1.modulo$1($async$result);
                // goto return
                $async$goto = 1;
                break;
              case 20:
                // default
                // goto return
                $async$goto = 1;
                break;
              case 5:
                // after switch
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor_visitListExpression_closure0: {
      "^": "Closure:15;$this",
      call$1: function(expression) {
        return expression.accept$1(this.$this);
      }
    },
    _EvaluateVisitor__runUserDefinedCallable_closure0: {
      "^": "Closure:1;$this,callable,evaluated,span,run",
      call$0: function() {
        var t1, t2;
        t1 = this.$this;
        t2 = this.callable;
        return t1._async_evaluate$_withEnvironment$2(t2.environment.closure$0(), new E._EvaluateVisitor__runUserDefinedCallable__closure0(t1, this.evaluated, t2, this.span, this.run));
      }
    },
    _EvaluateVisitor__runUserDefinedCallable__closure0: {
      "^": "Closure:1;$this,evaluated,callable,span,run",
      call$0: function() {
        var t1 = this.$this;
        return t1._async_evaluate$_environment.scope$1(new E._EvaluateVisitor__runUserDefinedCallable___closure0(t1, this.evaluated, this.callable, this.span, this.run));
      }
    },
    _EvaluateVisitor__runUserDefinedCallable___closure0: {
      "^": "Closure:4;$this,evaluated,callable,span,run",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$self = this, t1, t2, t3, t4, declaredArguments, t5, minLength, t6, i, t7, t8, t9, t10, argument, value, rest, argumentList, result;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            $async$outer:
              switch ($async$goto) {
                case 0:
                  // Function start
                  t1 = $async$self.$this;
                  t2 = $async$self.evaluated;
                  t3 = $async$self.callable.declaration.$arguments;
                  t4 = $async$self.span;
                  t1._async_evaluate$_verifyArguments$4(J.get$length$asx(t2.get$positional()), t2.get$named(), t3, t4);
                  declaredArguments = t3.$arguments;
                  t5 = declaredArguments.length;
                  minLength = Math.min(J.get$length$asx(t2.get$positional()), t5);
                  for (t6 = t1._async_evaluate$_sourceMap === true, i = 0; i < minLength; ++i) {
                    t7 = t1._async_evaluate$_environment;
                    if (i >= t5) {
                      $async$returnValue = H.ioore(declaredArguments, i);
                      // goto return
                      $async$goto = 1;
                      break $async$outer;
                    }
                    t8 = declaredArguments[i].get$name();
                    t9 = J.$index$asx(t2.get$positional(), i).withoutSlash$0();
                    if (t6) {
                      t10 = t2.get$positionalSpans();
                      if (i >= t10.length) {
                        $async$returnValue = H.ioore(t10, i);
                        // goto return
                        $async$goto = 1;
                        break $async$outer;
                      }
                      t10 = t10[i];
                    } else
                      t10 = null;
                    t7.setLocalVariable$3(t8, t9, t10);
                  }
                  i = J.get$length$asx(t2.get$positional());
                case 3:
                  // for condition
                  if (!(i < t5)) {
                    // goto after for
                    $async$goto = 5;
                    break;
                  }
                  argument = declaredArguments[i];
                  value = J.remove$1$ax(t2.get$named(), argument.get$name());
                  $async$goto = value == null ? 6 : 7;
                  break;
                case 6:
                  // then
                  $async$goto = 8;
                  return P._asyncAwait(argument.get$defaultValue().accept$1(t1), $async$call$0);
                case 8:
                  // returning from await.
                  value = $async$result;
                case 7:
                  // join
                  t7 = t1._async_evaluate$_environment;
                  t8 = argument.get$name();
                  t9 = value.withoutSlash$0();
                  if (t6) {
                    t10 = t2.get$namedSpans().$index(0, argument.get$name());
                    if (t10 == null)
                      t10 = t1._async_evaluate$_expressionSpan$1(argument.get$defaultValue());
                  } else
                    t10 = null;
                  t7.setLocalVariable$3(t8, t9, t10);
                case 4:
                  // for update
                  ++i;
                  // goto for condition
                  $async$goto = 3;
                  break;
                case 5:
                  // after for
                  t3 = t3.restArgument;
                  if (t3 != null) {
                    rest = J.get$length$asx(t2.get$positional()) > t5 ? J.sublist$1$ax(t2.get$positional(), t5) : C.List_empty1;
                    t5 = t2.get$named();
                    t6 = t2.get$separator() === C.ListSeparator_undecided_null ? C.ListSeparator_kWM : t2.get$separator();
                    argumentList = new D.SassArgumentList(new P.UnmodifiableMapView(B.normalizedMap(t5), [null, null]), false, P.List_List$unmodifiable(rest, null), t6, false);
                    argumentList.SassList$3$brackets(rest, t6, false);
                    t1._async_evaluate$_environment.setLocalVariable$3(t3, argumentList, t4);
                  } else
                    argumentList = null;
                  $async$goto = 9;
                  return P._asyncAwait($async$self.run.call$0(), $async$call$0);
                case 9:
                  // returning from await.
                  result = $async$result;
                  if (argumentList == null) {
                    $async$returnValue = result;
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                  if (J.get$isEmpty$asx(t2.get$named()) === true) {
                    $async$returnValue = result;
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                  if (argumentList._wereKeywordsAccessed) {
                    $async$returnValue = result;
                    // goto return
                    $async$goto = 1;
                    break;
                  }
                  t3 = t2.get$named().get$keys();
                  t3 = "No " + B.pluralize("argument", t3.get$length(t3), null) + " named ";
                  t2 = t2.get$named().get$keys();
                  throw H.wrapException(t1._async_evaluate$_exception$2(C.JSString_methods.$add(t3, B.toSentence(t2.map$1(t2, new E._EvaluateVisitor__runUserDefinedCallable____closure0()), "or")) + ".", t4));
                case 1:
                  // return
                  return P._asyncReturn($async$returnValue, $async$completer);
              }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor__runUserDefinedCallable____closure0: {
      "^": "Closure:0;",
      call$1: [function($name) {
        return "$" + H.S($name);
      }, null, null, 4, 0, null, 8, "call"]
    },
    _EvaluateVisitor__runFunctionCallable_closure0: {
      "^": "Closure:4;$this,callable",
      call$0: function() {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$self = this, t1, t2, t3, t4, _i, $returnValue;
        var $async$call$0 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                t1 = $async$self.callable.declaration, t2 = t1.children, t3 = t2.length, t4 = $async$self.$this, _i = 0;
              case 3:
                // for condition
                if (!(_i < t3)) {
                  // goto after for
                  $async$goto = 5;
                  break;
                }
                $async$goto = 6;
                return P._asyncAwait(t2[_i].accept$1(t4), $async$call$0);
              case 6:
                // returning from await.
                $returnValue = $async$result;
                if ($returnValue instanceof F.Value) {
                  $async$returnValue = $returnValue;
                  // goto return
                  $async$goto = 1;
                  break;
                }
              case 4:
                // for update
                ++_i;
                // goto for condition
                $async$goto = 3;
                break;
              case 5:
                // after for
                throw H.wrapException(t4._async_evaluate$_exception$2("Function finished without @return.", t1.span));
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$0, $async$completer);
      }
    },
    _EvaluateVisitor__runBuiltInCallable_closure1: {
      "^": "Closure:1;overload,evaluated,namedSet",
      call$0: function() {
        return this.overload.verify$2(J.get$length$asx(this.evaluated.get$positional()), this.namedSet);
      }
    },
    _EvaluateVisitor__runBuiltInCallable_closure2: {
      "^": "Closure:0;",
      call$1: [function($name) {
        return "$" + H.S($name);
      }, null, null, 4, 0, null, 8, "call"]
    },
    _EvaluateVisitor__evaluateArguments_closure7: {
      "^": "Closure:15;$this",
      call$1: function(expression) {
        return expression.accept$1(this.$this);
      }
    },
    _EvaluateVisitor__evaluateArguments_closure8: {
      "^": "Closure:2;$this",
      call$2: function(_, expression) {
        return expression.accept$1(this.$this);
      }
    },
    _EvaluateVisitor__evaluateArguments_closure9: {
      "^": "Closure:2;$this",
      call$2: function(_, expression) {
        return this.$this._async_evaluate$_expressionSpan$1(expression);
      }
    },
    _EvaluateVisitor__evaluateArguments_closure10: {
      "^": "Closure:2;",
      call$2: function(key, _) {
        return H.interceptedTypeCast(key, "$isSassString").text;
      }
    },
    _EvaluateVisitor__evaluateArguments_closure11: {
      "^": "Closure:2;restSpan",
      call$2: function(_, __) {
        return this.restSpan;
      }
    },
    _EvaluateVisitor__evaluateArguments_closure12: {
      "^": "Closure:2;named,namedSpans,restSpan",
      call$2: function(key, value) {
        var t1;
        J.$indexSet$ax(this.named, key, value);
        t1 = this.namedSpans;
        if (t1 != null)
          t1.$indexSet(0, key, this.restSpan);
      }
    },
    _EvaluateVisitor__evaluateArguments_closure13: {
      "^": "Closure:2;",
      call$2: function(key, _) {
        return H.interceptedTypeCast(key, "$isSassString").text;
      }
    },
    _EvaluateVisitor__evaluateArguments_closure14: {
      "^": "Closure:2;keywordRestSpan",
      call$2: function(_, __) {
        return this.keywordRestSpan;
      }
    },
    _EvaluateVisitor__evaluateMacroArguments_closure3: {
      "^": "Closure:0;",
      call$1: function(value) {
        return new F.ValueExpression(value, null);
      }
    },
    _EvaluateVisitor__evaluateMacroArguments_closure4: {
      "^": "Closure:0;",
      call$1: [function(value) {
        return new F.ValueExpression(value, null);
      }, null, null, 4, 0, null, 3, "call"]
    },
    _EvaluateVisitor__evaluateMacroArguments_closure5: {
      "^": "Closure:2;named",
      call$2: function(key, value) {
        this.named.$indexSet(0, key, new F.ValueExpression(value, null));
      }
    },
    _EvaluateVisitor__evaluateMacroArguments_closure6: {
      "^": "Closure:0;",
      call$1: function(value) {
        return new F.ValueExpression(value, null);
      }
    },
    _EvaluateVisitor__addRestMap_closure1: {
      "^": "Closure:0;",
      call$1: function(value) {
        return value;
      }
    },
    _EvaluateVisitor__addRestMap_closure2: {
      "^": "Closure:2;_box_0,$this,values,map,span",
      call$2: function(key, value) {
        if (key instanceof D.SassString)
          J.$indexSet$ax(this.values, key.text, this._box_0.convert.call$1(value));
        else
          throw H.wrapException(this.$this._async_evaluate$_exception$2("Variable keyword argument map must have string keys.\n" + H.S(key) + " is not a string in " + this.map.toString$0(0) + ".", this.span));
      }
    },
    _EvaluateVisitor__verifyArguments_closure0: {
      "^": "Closure:1;$arguments,positional,named",
      call$0: function() {
        return this.$arguments.verify$2(this.positional, new M.MapKeySet(this.named, [null]));
      }
    },
    _EvaluateVisitor_visitStringExpression_closure0: {
      "^": "Closure:6;$this",
      call$1: function(value) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$self = this, t1, result;
        var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if (typeof value === "string") {
                  $async$returnValue = value;
                  // goto return
                  $async$goto = 1;
                  break;
                }
                H.interceptedTypeCast(value, "$isExpression");
                t1 = $async$self.$this;
                $async$goto = 3;
                return P._asyncAwait(value.accept$1(t1), $async$call$1);
              case 3:
                // returning from await.
                result = $async$result;
                $async$returnValue = result instanceof D.SassString ? result.text : t1._async_evaluate$_serialize$3$quote(result, value.get$span(), false);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$1, $async$completer);
      }
    },
    _EvaluateVisitor__performInterpolation_closure0: {
      "^": "Closure:6;$this,warnForColor",
      call$1: function(value) {
        var $async$goto = 0, $async$completer = P._makeAsyncAwaitCompleter(null), $async$returnValue, $async$self = this, t1, result, t2, t3;
        var $async$call$1 = P._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
          if ($async$errorCode === 1)
            return P._asyncRethrow($async$result, $async$completer);
          while (true)
            switch ($async$goto) {
              case 0:
                // Function start
                if (typeof value === "string") {
                  $async$returnValue = value;
                  // goto return
                  $async$goto = 1;
                  break;
                }
                H.interceptedTypeCast(value, "$isExpression");
                t1 = $async$self.$this;
                $async$goto = 3;
                return P._asyncAwait(value.accept$1(t1), $async$call$1);
              case 3:
                // returning from await.
                result = $async$result;
                if ($async$self.warnForColor && result instanceof K.SassColor && $.$get$namesByColor().containsKey$1(result)) {
                  t2 = X.Interpolation$([""], null);
                  t3 = $.$get$namesByColor();
                  t1._async_evaluate$_warn$2("You probably don't mean to use the color value " + H.S(t3.$index(0, result)) + " in interpolation here.\nIt may end up represented as " + H.S(result) + ', which will likely produce invalid CSS.\nAlways quote color names when using them as strings or map keys (for example, "' + H.S(t3.$index(0, result)) + "\").\nIf you really want to use the color value here, use '" + new V.BinaryOperationExpression(C.BinaryOperator_AcR, new D.StringExpression(t2, true), value, false).toString$0(0) + "'.", value.get$span());
                }
                $async$returnValue = t1._async_evaluate$_serialize$3$quote(result, value.get$span(), false);
                // goto return
                $async$goto = 1;
                break;
              case 1:
                // return
                return P._asyncReturn($async$returnValue, $async$completer);
            }
        });
        return P._asyncStartSync($async$call$1, $async$completer);
      }
    },
    _EvaluateVisitor__serialize_closure0: {
      "^": "Closure:1;value,quote",
      call$0: function() {
        return this.value.toCssString$1$quote(this.quote);
      }
    },
    EvaluateResult: {
      "^": "Object;stylesheet<,includedFiles>"
    },
    _ArgumentResults0: {
      "^": "Object;positional<,positionalSpans<,named<,namedSpans<,separator<",
      static: {
        _ArgumentResults$0: function(positional, named, separator, namedSpans, positionalSpans) {
          return new E._ArgumentResults0(positional, positionalSpans, named, namedSpans, separator);
        }
      }
    }
  }], ["", "package:sass/src/visitor/evaluate.dart",, R, {
    "^": "",
    evaluate: function(stylesheet, functions, importCache, importer, logger, nodeImporter, sourceMap, variables) {
      return R._EvaluateVisitor$(functions, importCache, importer, logger, nodeImporter, sourceMap, variables).run$1(0, stylesheet);
    },
    _EvaluateVisitor: {
      "^": "Object;_importCache,_nodeImporter,_logger,_sourceMap,_environment,_importer,_baseUrl,_styleRule,_mediaQueries,_root,_parent,_declarationName,_member,_callableSpan,_inFunction,_evaluate$_inUnknownAtRule,_atRootExcludingStyleRule,_inKeyframes,_endOfImports,_outOfOrderImports,_includedFiles,_activeImports,_extender,_stack",
      _EvaluateVisitor$7$functions$importCache$importer$logger$nodeImporter$sourceMap$variables: function(functions, importCache, importer, logger, nodeImporter, sourceMap, variables) {
        var t1, t2, t3, t4, t5, t6, $function, $name;
        t1 = this._environment;
        t2 = C.JSString_methods.get$codeUnits("($name)");
        t3 = [P.int];
        t4 = H.setRuntimeTypeInfo([0], t3);
        t4 = new Y.SourceFile(null, t4, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
        t4.SourceFile$decoded$2$url(t2, null);
        t2 = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t4, null, null, "($name)", 0, null, null), C.StderrLogger_false).parseArgumentDeclaration$0();
        t4 = [[S.Tuple2, B.ArgumentDeclaration, {func: 1, ret: F.Value, args: [[P.List, F.Value]]}]];
        t5 = H.setRuntimeTypeInfo([], t4);
        t6 = [null, null];
        t5.push(new S.Tuple2(t2, new R._EvaluateVisitor_closure(this), t6));
        t1.setFunction$1(new Q.BuiltInCallable("global-variable-exists", t5));
        t5 = this._environment;
        t1 = C.JSString_methods.get$codeUnits("($name)");
        t2 = H.setRuntimeTypeInfo([0], t3);
        t2 = new Y.SourceFile(null, t2, new Uint32Array(H._ensureNativeList(t1.toList$0(t1))), null);
        t2.SourceFile$decoded$2$url(t1, null);
        t1 = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t2, null, null, "($name)", 0, null, null), C.StderrLogger_false).parseArgumentDeclaration$0();
        t2 = H.setRuntimeTypeInfo([], t4);
        t2.push(new S.Tuple2(t1, new R._EvaluateVisitor_closure0(this), t6));
        t5.setFunction$1(new Q.BuiltInCallable("variable-exists", t2));
        t2 = this._environment;
        t5 = C.JSString_methods.get$codeUnits("($name)");
        t1 = H.setRuntimeTypeInfo([0], t3);
        t1 = new Y.SourceFile(null, t1, new Uint32Array(H._ensureNativeList(t5.toList$0(t5))), null);
        t1.SourceFile$decoded$2$url(t5, null);
        t1 = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t1, null, null, "($name)", 0, null, null), C.StderrLogger_false).parseArgumentDeclaration$0();
        t5 = H.setRuntimeTypeInfo([], t4);
        t5.push(new S.Tuple2(t1, new R._EvaluateVisitor_closure1(this), t6));
        t2.setFunction$1(new Q.BuiltInCallable("function-exists", t5));
        t5 = this._environment;
        t2 = C.JSString_methods.get$codeUnits("($name)");
        t1 = H.setRuntimeTypeInfo([0], t3);
        t1 = new Y.SourceFile(null, t1, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
        t1.SourceFile$decoded$2$url(t2, null);
        t1 = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t1, null, null, "($name)", 0, null, null), C.StderrLogger_false).parseArgumentDeclaration$0();
        t2 = H.setRuntimeTypeInfo([], t4);
        t2.push(new S.Tuple2(t1, new R._EvaluateVisitor_closure2(this), t6));
        t5.setFunction$1(new Q.BuiltInCallable("mixin-exists", t2));
        t2 = this._environment;
        t5 = C.JSString_methods.get$codeUnits("()");
        t1 = H.setRuntimeTypeInfo([0], t3);
        t1 = new Y.SourceFile(null, t1, new Uint32Array(H._ensureNativeList(t5.toList$0(t5))), null);
        t1.SourceFile$decoded$2$url(t5, null);
        t1 = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t1, null, null, "()", 0, null, null), C.StderrLogger_false).parseArgumentDeclaration$0();
        t5 = H.setRuntimeTypeInfo([], t4);
        t5.push(new S.Tuple2(t1, new R._EvaluateVisitor_closure3(this), t6));
        t2.setFunction$1(new Q.BuiltInCallable("content-exists", t5));
        t5 = this._environment;
        t2 = C.JSString_methods.get$codeUnits("($name, $css: false)");
        t1 = H.setRuntimeTypeInfo([0], t3);
        t1 = new Y.SourceFile(null, t1, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
        t1.SourceFile$decoded$2$url(t2, null);
        t1 = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t1, null, null, "($name, $css: false)", 0, null, null), C.StderrLogger_false).parseArgumentDeclaration$0();
        t2 = H.setRuntimeTypeInfo([], t4);
        t2.push(new S.Tuple2(t1, new R._EvaluateVisitor_closure4(this), t6));
        t5.setFunction$1(new Q.BuiltInCallable("get-function", t2));
        t2 = this._environment;
        t5 = C.JSString_methods.get$codeUnits("($function, $args...)");
        t3 = H.setRuntimeTypeInfo([0], t3);
        t1 = new Y.SourceFile(null, t3, new Uint32Array(H._ensureNativeList(t5.toList$0(t5))), null);
        t1.SourceFile$decoded$2$url(t5, null);
        t1 = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t1, null, null, "($function, $args...)", 0, null, null), C.StderrLogger_false).parseArgumentDeclaration$0();
        t4 = H.setRuntimeTypeInfo([], t4);
        t4.push(new S.Tuple2(t1, new R._EvaluateVisitor_closure5(this), t6));
        t2.setFunction$1(new Q.BuiltInCallable("call", t4));
        t1 = J.get$iterator$ax(functions == null ? C.List_empty2 : functions);
        for (; t1.moveNext$0();) {
          $function = t1.get$current(t1);
          this._environment.setFunction$1($function);
        }
        t1 = variables == null ? null : variables.get$keys();
        t1 = J.get$iterator$ax(t1 == null ? C.List_empty0 : t1);
        for (; t1.moveNext$0();) {
          $name = t1.get$current(t1);
          this._environment.setVariable$4$global($name, variables.$index(0, $name), null, true);
        }
      },
      run$1: function(_, node) {
        var t1, t2;
        t1 = node.get$span();
        t1 = t1 == null ? null : t1.get$sourceUrl();
        this._baseUrl = t1;
        if (t1 != null)
          if (this._nodeImporter != null)
            if (t1.get$scheme() === "file") {
              t1 = D.p();
              t2 = this._baseUrl;
              this._includedFiles.add$1(0, t1.style.pathFromUri$1(M._parseUri(t2)));
            } else if (J.$eq$(J.toString$0$(this._baseUrl), "stdin") !== true)
              this._includedFiles.add$1(0, J.toString$0$(this._baseUrl));
        this.visitStylesheet$1(node);
        return new E.EvaluateResult(this._root, this._includedFiles);
      },
      visitStylesheet$1: function(node) {
        var t1 = [];
        t1 = new V.CssStylesheet(node.get$span(), new P.UnmodifiableListView(t1, [B.CssNode]), t1, null, null, false);
        this._root = t1;
        this._parent = t1;
        for (t1 = J.get$iterator$ax(node.get$children()); t1.moveNext$0();)
          t1.get$current(t1).accept$1(this);
        if (this._outOfOrderImports.length !== 0)
          new R._EvaluateVisitor_visitStylesheet_closure(this).call$1(this._root._children);
        this._extender.finalize$0();
        return;
      },
      visitAtRootRule$1: function(node) {
        var t1, resolved, query, $parent, included, root, innerCopy, outerCopy, copy;
        t1 = node.query;
        if (t1 != null) {
          resolved = this._performInterpolation$2$warnForColor(t1, true);
          query = this._adjustParseError$2(t1.span, new R._EvaluateVisitor_visitAtRootRule_closure(this, resolved));
        } else
          query = C.AtRootQuery_UsS;
        $parent = this._parent;
        included = H.setRuntimeTypeInfo([], [B.CssParentNode]);
        for (; !($parent instanceof V.CssStylesheet);) {
          if (!query.excludes$1($parent))
            included.push($parent);
          $parent = $parent._node0$_parent;
        }
        root = this._trimIncluded$1(included);
        t1 = this._parent;
        if (root == null ? t1 == null : root === t1) {
          this._environment.scope$2$when(new R._EvaluateVisitor_visitAtRootRule_closure0(this, node), node.hasDeclarations);
          return;
        }
        innerCopy = included.length === 0 ? null : C.JSArray_methods.get$first(included).copyWithoutChildren$0();
        for (t1 = H.SubListIterable$(included, 1, null, H.getTypeArgumentByIndex(included, 0)), t1 = new H.ListIterator(t1, t1.get$length(t1), 0, null, [H.getTypeArgumentByIndex(t1, 0)]), outerCopy = innerCopy; t1.moveNext$0(); outerCopy = copy) {
          copy = t1.__internal$_current.copyWithoutChildren$0();
          copy.addChild$1(outerCopy);
        }
        if (outerCopy != null)
          root.addChild$1(outerCopy);
        this._scopeForAtRoot$4(node, innerCopy == null ? root : innerCopy, query, included).call$1(new R._EvaluateVisitor_visitAtRootRule_closure1(this, node));
        return;
      },
      _trimIncluded$1: function(nodes) {
        var t1, $parent, innermostContiguous, i, t2, root;
        t1 = nodes.length;
        if (t1 === 0)
          return this._root;
        $parent = this._parent;
        for (innermostContiguous = null, i = 0; i < t1; ++i) {
          for (; t2 = nodes[i], $parent == null ? t2 != null : $parent !== t2; innermostContiguous = null)
            $parent = $parent._node0$_parent;
          if (innermostContiguous == null)
            innermostContiguous = i;
          $parent = $parent._node0$_parent;
        }
        t2 = this._root;
        if ($parent == null ? t2 != null : $parent !== t2)
          return t2;
        if (innermostContiguous >>> 0 !== innermostContiguous || innermostContiguous >= t1)
          return H.ioore(nodes, innermostContiguous);
        root = nodes[innermostContiguous];
        C.JSArray_methods.removeRange$2(nodes, innermostContiguous, t1);
        return root;
      },
      _scopeForAtRoot$4: function(node, newParent, query, included) {
        var scope = new R._EvaluateVisitor__scopeForAtRoot_closure(this, newParent, node);
        if (query.get$excludesStyleRules())
          scope = new R._EvaluateVisitor__scopeForAtRoot_closure0(this, scope);
        if (query.get$excludesMedia())
          scope = new R._EvaluateVisitor__scopeForAtRoot_closure1(this, scope);
        if (this._inKeyframes && query.excludesName$1("keyframes"))
          scope = new R._EvaluateVisitor__scopeForAtRoot_closure2(this, scope);
        return this._evaluate$_inUnknownAtRule && !C.JSArray_methods.any$1(included, new R._EvaluateVisitor__scopeForAtRoot_closure3()) ? new R._EvaluateVisitor__scopeForAtRoot_closure4(this, scope) : scope;
      },
      visitContentRule$1: function(node) {
        var block = this._environment.get$contentBlock();
        if (block == null)
          return;
        this._withStackFrame$3("@content", node.span, new R._EvaluateVisitor_visitContentRule_closure(this, block));
        return;
      },
      visitDebugRule$1: function(node) {
        var value, t1;
        value = node.expression.accept$1(this);
        t1 = J.getInterceptor(value);
        t1 = !!t1.$isSassString ? value.text : t1.toString$0(value);
        this._logger.debug$2(t1, node.span);
        return;
      },
      visitDeclaration$1: function(node) {
        var $name, t1, cssValue, oldDeclarationName;
        if (!(this._styleRule != null && !this._atRootExcludingStyleRule) && !this._evaluate$_inUnknownAtRule && !this._inKeyframes)
          throw H.wrapException(this._exception$2("Declarations may only be used within style rules.", node.get$span()));
        $name = this._interpolationToValue$2$warnForColor(node.get$name(), true);
        t1 = this._declarationName;
        if (t1 != null)
          $name = new F.CssValue(H.S(t1) + "-" + H.S($name.value), $name.span, [null]);
        cssValue = node.get$value() == null ? null : new F.CssValue(node.get$value().accept$1(this), node.get$value().get$span(), [null]);
        if (cssValue != null)
          t1 = !cssValue.value.get$isBlank() || cssValue.value.get$asList().length === 0;
        else
          t1 = false;
        if (t1)
          this._parent.addChild$1(L.CssDeclaration$($name, cssValue, node.get$span(), this._expressionSpan$1(node.get$value())));
        else if (J.startsWith$1$s($name.value, "--"))
          throw H.wrapException(this._exception$2("Custom property values may not be empty.", node.get$value().get$span()));
        if (node.get$children() != null) {
          oldDeclarationName = this._declarationName;
          this._declarationName = $name.value;
          this._environment.scope$2$when(new R._EvaluateVisitor_visitDeclaration_closure(this, node), node.get$hasDeclarations());
          this._declarationName = oldDeclarationName;
        }
        return;
      },
      visitEachRule$1: function(node) {
        var t1, list, span, setVariables;
        t1 = node.list;
        list = t1.accept$1(this);
        span = this._expressionSpan$1(t1);
        setVariables = node.variables.length === 1 ? new R._EvaluateVisitor_visitEachRule_closure(this, node, span) : new R._EvaluateVisitor_visitEachRule_closure0(this, node, span);
        return this._environment.scope$2$semiGlobal(new R._EvaluateVisitor_visitEachRule_closure1(this, list, setVariables, node), true);
      },
      _setMultipleVariables$3: function(variables, value, span) {
        var list, t1, minLength, i, t2, t3;
        list = value.get$asList();
        t1 = variables.length;
        minLength = Math.min(t1, list.length);
        for (i = 0; i < minLength; ++i) {
          t2 = this._environment;
          if (i >= t1)
            return H.ioore(variables, i);
          t3 = variables[i];
          if (i >= list.length)
            return H.ioore(list, i);
          t2.setLocalVariable$3(t3, list[i].withoutSlash$0(), span);
        }
        for (i = minLength; i < t1; ++i) {
          t2 = this._environment;
          if (i >>> 0 !== i || i >= t1)
            return H.ioore(variables, i);
          t2.setLocalVariable$3(variables[i], C.C_SassNull, span);
        }
      },
      visitErrorRule$1: function(node) {
        throw H.wrapException(this._exception$2(J.toString$0$(node.expression.accept$1(this)), node.span));
      },
      visitExtendRule$1: function(node) {
        var targetText, target;
        if (!(this._styleRule != null && !this._atRootExcludingStyleRule) || this._declarationName != null)
          throw H.wrapException(this._exception$2("@extend may only be used within style rules.", node.span));
        targetText = this._interpolationToValue$2$warnForColor(node.selector, true);
        target = this._adjustParseError$2(targetText.span, new R._EvaluateVisitor_visitExtendRule_closure(this, targetText));
        this._extender.addExtension$4(this._styleRule.selector, target, node, this._mediaQueries);
        return;
      },
      visitAtRule$1: function(node) {
        var value, t1, wasInKeyframes, wasInUnknownAtRule;
        if (this._declarationName != null)
          throw H.wrapException(this._exception$2("At-rules may not be used within nested declarations.", node.get$span()));
        value = node.get$value() == null ? null : this._interpolationToValue$3$trim$warnForColor(node.get$value(), true, true);
        if (node.get$children() == null) {
          t1 = [];
          this._parent.addChild$1(new U.CssAtRule(node.get$name(), value, true, node.get$span(), new P.UnmodifiableListView(t1, [B.CssNode]), t1, null, null, false));
          return;
        }
        wasInKeyframes = this._inKeyframes;
        wasInUnknownAtRule = this._evaluate$_inUnknownAtRule;
        if (node.get$normalizedName() === "keyframes")
          this._inKeyframes = true;
        else
          this._evaluate$_inUnknownAtRule = true;
        t1 = [];
        this._withParent$4$scopeWhen$through(new U.CssAtRule(node.get$name(), value, false, node.get$span(), new P.UnmodifiableListView(t1, [B.CssNode]), t1, null, null, false), new R._EvaluateVisitor_visitAtRule_closure(this, node), node.get$hasDeclarations(), new R._EvaluateVisitor_visitAtRule_closure0());
        this._evaluate$_inUnknownAtRule = wasInUnknownAtRule;
        this._inKeyframes = wasInKeyframes;
        return;
      },
      visitForRule$1: function(node) {
        var t1, t2, fromNumber, t3, toNumber, from, to, direction;
        t1 = {};
        t2 = node.from;
        fromNumber = this._addExceptionSpan$2(t2.get$span(), new R._EvaluateVisitor_visitForRule_closure(this, node));
        t3 = node.to;
        toNumber = this._addExceptionSpan$2(t3.get$span(), new R._EvaluateVisitor_visitForRule_closure0(this, node));
        from = this._addExceptionSpan$2(t2.get$span(), new R._EvaluateVisitor_visitForRule_closure1(fromNumber, toNumber));
        to = this._addExceptionSpan$2(t3.get$span(), new R._EvaluateVisitor_visitForRule_closure2(toNumber));
        t1.to = to;
        t2 = J.getInterceptor$n(from);
        direction = t2.$gt(from, to) ? -1 : 1;
        if (node.isExclusive !== true) {
          to = J.$add$ansx(to, direction);
          t1.to = to;
          t3 = to;
        } else
          t3 = to;
        if (t2.$eq(from, t3) === true)
          return;
        return this._environment.scope$2$semiGlobal(new R._EvaluateVisitor_visitForRule_closure3(t1, this, node, from, direction), true);
      },
      visitFunctionRule$1: function(node) {
        var t1 = this._environment;
        t1.setFunction$1(new E.UserDefinedCallable(node, t1.closure$0(), [null]));
        return;
      },
      visitIfRule$1: function(node) {
        var _box_0, t1, t2, _i, clauseToCheck;
        _box_0 = {};
        _box_0.clause = node.lastClause;
        for (t1 = node.clauses, t2 = t1.length, _i = 0; _i < t2; ++_i) {
          clauseToCheck = t1[_i];
          if (clauseToCheck.get$expression().accept$1(this).get$isTruthy()) {
            _box_0.clause = clauseToCheck;
            break;
          }
        }
        t1 = _box_0.clause;
        if (t1 == null)
          return;
        return this._environment.scope$3$semiGlobal$when(new R._EvaluateVisitor_visitIfRule_closure(_box_0, this), true, t1.get$hasDeclarations());
      },
      visitImportRule$1: function(node) {
        var t1, t2, t3, t4, _i, $import, t5, result, supports, t6, t7, resolvedSupports, mediaQuery, t8, result0;
        for (t1 = node.imports, t2 = t1.length, t3 = this._outOfOrderImports, t4 = [null], _i = 0; _i < t2; ++_i) {
          $import = t1[_i];
          if ($import instanceof B.DynamicImport)
            this._visitDynamicImport$1($import);
          else {
            H.interceptedTypeCast($import, "$isStaticImport");
            t5 = $import.url;
            result = this._performInterpolation$2$warnForColor(t5, false);
            supports = $import.supports;
            if (supports instanceof L.SupportsDeclaration) {
              t6 = supports.name;
              t6 = H.S(this._evaluate$_serialize$3$quote(t6.accept$1(this), t6.get$span(), true)) + ": ";
              t7 = supports.value;
              resolvedSupports = t6 + H.S(this._evaluate$_serialize$3$quote(t7.accept$1(this), t7.get$span(), true));
            } else
              resolvedSupports = supports == null ? null : this._visitSupportsCondition$1(supports);
            t6 = $import.media;
            mediaQuery = t6 == null ? null : this._visitMediaQueries$1(t6);
            t6 = $import.span;
            t7 = resolvedSupports == null ? null : new F.CssValue("supports(" + H.S(resolvedSupports) + ")", supports.get$span(), t4);
            if (mediaQuery == null)
              t8 = null;
            else {
              result0 = P.List_List$from(mediaQuery, false, null);
              result0.fixed$length = Array;
              result0.immutable$list = Array;
              t8 = result0;
            }
            node = new F.CssImport(new F.CssValue(result, t5.span, t4), t7, t8, t6, null, null, false);
            t5 = this._parent;
            t6 = this._root;
            if (t5 == null ? t6 != null : t5 !== t6)
              t5.addChild$1(node);
            else if (this._endOfImports === J.get$length$asx(t6.children._collection$_source)) {
              t5 = this._root;
              t5.toString;
              node._node0$_parent = t5;
              t5 = t5._children;
              node._indexInParent = t5.length;
              t5.push(node);
              ++this._endOfImports;
            } else
              t3.push(node);
          }
        }
        return;
      },
      _visitDynamicImport$1: function($import) {
        var result, importer, stylesheet, url, t1;
        result = this._loadImport$1($import);
        importer = result.item1;
        stylesheet = result.item2;
        url = stylesheet.get$span().get$sourceUrl();
        t1 = this._activeImports;
        if (t1.contains$1(0, url))
          throw H.wrapException(this._exception$2("This file is already being imported.", $import.span));
        t1.add$1(0, url);
        this._withStackFrame$3("@import", $import.span, new R._EvaluateVisitor__visitDynamicImport_closure(this, importer, url, stylesheet));
        t1.remove$1(0, url);
      },
      _loadImport$1: function($import) {
        var stylesheet, tuple, error, $frames, error0, message, exception, t1, frames0;
        try {
          if (this._nodeImporter != null) {
            stylesheet = this._importLikeNode$1($import);
            if (stylesheet != null)
              return new S.Tuple2(null, stylesheet, [null, null]);
          } else {
            tuple = this._importCache.import$3(P.Uri_parse($import.url, 0, null), this._importer, this._baseUrl);
            if (tuple != null)
              return tuple;
          }
          if (J.startsWith$1$s($import.url, "package:"))
            throw H.wrapException('"package:" URLs aren\'t supported on this platform.');
          else
            throw H.wrapException("Can't find stylesheet to import.");
        } catch (exception) {
          t1 = H.unwrapException(exception);
          if (t1 instanceof E.SassException) {
            error = t1;
            t1 = error.get$trace().frames;
            frames0 = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
            frames0.push(B.frameForSpan($import.span, this._member));
            t1 = this._stack;
            t1 = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
            C.JSArray_methods.addAll$1(frames0, t1);
            $frames = frames0;
            throw H.wrapException(E.SassRuntimeException$(J.get$message$x(error), error.get$span(), Y.Trace$($frames, null)));
          } else {
            error0 = t1;
            message = null;
            try {
              message = H.stringTypeCast(J.get$message$x(error0));
            } catch (exception) {
              H.unwrapException(exception);
              message = J.toString$0$(error0);
            }
            throw H.wrapException(this._exception$2(message, $import.span));
          }
        }
      },
      _importLikeNode$1: function($import) {
        var result, contents, url, t1, t2, t3, t4, t5;
        result = this._nodeImporter.load$2($import.url, this._baseUrl);
        if (result == null)
          return;
        contents = result.item1;
        url = result.item2;
        t1 = J.getInterceptor$s(url);
        t2 = this._includedFiles;
        if (t1.startsWith$1(url, "file:"))
          t2.add$1(0, D.p().style.pathFromUri$1(M._parseUri(url)));
        else
          t2.add$1(0, url);
        t1 = t1.startsWith$1(url, "file") && J.$eq$(X.ParsedPath_ParsedPath$parse(url, $.$get$url().style)._splitExtension$0()[1], ".sass") === true;
        t2 = J.getInterceptor$s(contents);
        t3 = this._logger;
        t4 = [P.int];
        if (t1) {
          t1 = t2.get$codeUnits(contents);
          t4 = H.setRuntimeTypeInfo([0], t4);
          t2 = typeof url === "string";
          t5 = t2 ? P.Uri_parse(url, 0, null) : url;
          t4 = new Y.SourceFile(t5, t4, new Uint32Array(H._ensureNativeList(t1.toList$0(t1))), null);
          t4.SourceFile$decoded$2$url(t1, url);
          t1 = t2 ? P.Uri_parse(url, 0, null) : url;
          t1 = new U.SassParser(0, null, null, null, false, null, false, false, false, false, false, new S.SpanScanner(t4, null, t1, contents, 0, null, null), t3).parse$0();
        } else {
          t1 = t2.get$codeUnits(contents);
          t4 = H.setRuntimeTypeInfo([0], t4);
          t2 = typeof url === "string";
          t5 = t2 ? P.Uri_parse(url, 0, null) : url;
          t4 = new Y.SourceFile(t5, t4, new Uint32Array(H._ensureNativeList(t1.toList$0(t1))), null);
          t4.SourceFile$decoded$2$url(t1, url);
          t1 = t2 ? P.Uri_parse(url, 0, null) : url;
          t1 = new L.ScssParser(false, null, false, false, false, false, false, new S.SpanScanner(t4, null, t1, contents, 0, null, null), t3).parse$0();
        }
        return t1;
      },
      visitIncludeRule$1: function(node) {
        var mixin, t1, environment;
        mixin = H.subtypeCast(this._environment.getMixin$1(node.name), "$isUserDefinedCallable", [O.Environment], "$asUserDefinedCallable");
        if (mixin == null)
          throw H.wrapException(this._exception$2("Undefined mixin.", node.span));
        t1 = node.children == null;
        if (!t1 && H.interceptedTypeCast(mixin.declaration, "$isMixinRule").hasContent !== true)
          throw H.wrapException(this._exception$2("Mixin doesn't accept a content block.", node.span));
        environment = t1 ? null : this._environment.closure$0();
        this._runUserDefinedCallable$4(node.$arguments, mixin, node.span, new R._EvaluateVisitor_visitIncludeRule_closure(this, node, environment, mixin));
        return;
      },
      visitMixinRule$1: function(node) {
        var t1 = this._environment;
        t1.setMixin$1(new E.UserDefinedCallable(node, t1.closure$0(), [null]));
        return;
      },
      visitLoudComment$1: function(node) {
        var t1, t2;
        if (this._inFunction)
          return;
        t1 = this._parent;
        t2 = this._root;
        if ((t1 == null ? t2 == null : t1 === t2) && this._endOfImports === J.get$length$asx(t2.children._collection$_source))
          ++this._endOfImports;
        t1 = node.text;
        this._parent.addChild$1(new R.CssComment(this._performInterpolation$1(t1), t1.span, null, null, false));
        return;
      },
      visitMediaRule$1: function(node) {
        var t1, queries, t2;
        t1 = {};
        if (this._declarationName != null)
          throw H.wrapException(this._exception$2("Media rules may not be used within nested declarations.", node.get$span()));
        queries = this._visitMediaQueries$1(node.get$query());
        t1.queries = queries;
        t2 = this._mediaQueries;
        if (t2 != null) {
          queries = this._mergeMediaQueries$2(t2, queries);
          t1.queries = queries;
          if (C.JSArray_methods.get$isEmpty(queries))
            return;
          t2 = queries;
        } else
          t2 = queries;
        this._withParent$4$scopeWhen$through(G.CssMediaRule$(t2, node.get$span()), new R._EvaluateVisitor_visitMediaRule_closure(t1, this, node), node.get$hasDeclarations(), new R._EvaluateVisitor_visitMediaRule_closure0());
        return;
      },
      _visitMediaQueries$1: function(interpolation) {
        var resolved = this._performInterpolation$2$warnForColor(interpolation, true);
        return this._adjustParseError$2(interpolation.get$span(), new R._EvaluateVisitor__visitMediaQueries_closure(this, resolved));
      },
      _mergeMediaQueries$2: function(queries1, queries2) {
        return P.List_List$unmodifiable(J.expand$1$ax(queries1, new R._EvaluateVisitor__mergeMediaQueries_closure(queries2)).where$1(0, new R._EvaluateVisitor__mergeMediaQueries_closure0()), null);
      },
      visitReturnRule$1: function(node) {
        return node.expression.accept$1(this);
      },
      visitSilentComment$1: function(node) {
        return;
      },
      visitStyleRule$1: function(node) {
        var t1, selectorText, parsedSelector, rule, oldAtRootExcludingStyleRule;
        t1 = {};
        if (this._declarationName != null)
          throw H.wrapException(this._exception$2("Style rules may not be used within nested declarations.", node.get$span()));
        selectorText = this._interpolationToValue$3$trim$warnForColor(node.get$selector(), true, true);
        if (this._inKeyframes) {
          t1 = [];
          this._withParent$4$scopeWhen$through(new U.CssKeyframeBlock(new F.CssValue(P.List_List$unmodifiable(this._adjustParseError$2(node.get$selector().get$span(), new R._EvaluateVisitor_visitStyleRule_closure(this, selectorText)), null), node.get$selector().get$span(), [null]), node.get$span(), new P.UnmodifiableListView(t1, [B.CssNode]), t1, null, null, false), new R._EvaluateVisitor_visitStyleRule_closure0(this, node), node.get$hasDeclarations(), new R._EvaluateVisitor_visitStyleRule_closure1());
          return;
        }
        t1.parsedSelector = this._adjustParseError$2(node.get$selector().get$span(), new R._EvaluateVisitor_visitStyleRule_closure2(this, selectorText));
        parsedSelector = this._addExceptionSpan$2(node.get$selector().get$span(), new R._EvaluateVisitor_visitStyleRule_closure3(t1, this));
        t1.parsedSelector = parsedSelector;
        rule = this._extender.addSelector$3(new F.CssValue(parsedSelector, node.get$selector().get$span(), [D.SelectorList]), node.get$span(), this._mediaQueries);
        oldAtRootExcludingStyleRule = this._atRootExcludingStyleRule;
        this._atRootExcludingStyleRule = false;
        this._withParent$4$scopeWhen$through(rule, new R._EvaluateVisitor_visitStyleRule_closure4(this, rule, node), node.get$hasDeclarations(), new R._EvaluateVisitor_visitStyleRule_closure5());
        this._atRootExcludingStyleRule = oldAtRootExcludingStyleRule;
        if (!(this._styleRule != null && !oldAtRootExcludingStyleRule)) {
          t1 = this._parent.children;
          t1.get$last(t1).set$isGroupEnd(true);
        }
        return;
      },
      visitSupportsRule$1: function(node) {
        var t1;
        if (this._declarationName != null)
          throw H.wrapException(this._exception$2("Supports rules may not be used within nested declarations.", node.get$span()));
        t1 = [];
        this._withParent$4$scopeWhen$through(new B.CssSupportsRule(new F.CssValue(this._visitSupportsCondition$1(node.get$condition()), node.get$condition().get$span(), [null]), node.get$span(), new P.UnmodifiableListView(t1, [B.CssNode]), t1, null, null, false), new R._EvaluateVisitor_visitSupportsRule_closure(this, node), node.get$hasDeclarations(), new R._EvaluateVisitor_visitSupportsRule_closure0());
        return;
      },
      _visitSupportsCondition$1: function(condition) {
        var t1, t2;
        t1 = J.getInterceptor(condition);
        if (!!t1.$isSupportsOperation) {
          t1 = condition.left;
          t2 = condition.operator;
          return H.S(this._parenthesize$2(t1, t2)) + " " + t2 + " " + H.S(this._parenthesize$2(condition.right, t2));
        } else if (!!t1.$isSupportsNegation)
          return "not " + H.S(this._parenthesize$1(condition.condition));
        else if (!!t1.$isSupportsInterpolation) {
          t1 = condition.expression;
          return this._evaluate$_serialize$3$quote(t1.accept$1(this), t1.get$span(), false);
        } else if (!!t1.$isSupportsDeclaration) {
          t1 = condition.name;
          t1 = "(" + H.S(this._evaluate$_serialize$3$quote(t1.accept$1(this), t1.get$span(), true)) + ": ";
          t2 = condition.value;
          return t1 + H.S(this._evaluate$_serialize$3$quote(t2.accept$1(this), t2.get$span(), true)) + ")";
        } else
          return;
      },
      _parenthesize$2: function(condition, operator) {
        var t1;
        if (!condition.$isSupportsNegation)
          if (!!condition.$isSupportsOperation)
            t1 = operator == null || operator !== condition.operator;
          else
            t1 = false;
        else
          t1 = true;
        if (t1)
          return "(" + H.S(this._visitSupportsCondition$1(condition)) + ")";
        else
          return this._visitSupportsCondition$1(condition);
      },
      _parenthesize$1: function(condition) {
        return this._parenthesize$2(condition, null);
      },
      visitVariableDeclaration$1: function(node) {
        var value, t1;
        if (node.isGuarded) {
          value = this._environment.getVariable$1(node.name);
          if (value != null && J.$eq$(value, C.C_SassNull) !== true)
            return;
        }
        t1 = node.expression;
        this._environment.setVariable$4$global(node.name, t1.accept$1(this).withoutSlash$0(), this._expressionSpan$1(t1), node.isGlobal);
        return;
      },
      visitWarnRule$1: function(node) {
        var t1, value, t2;
        t1 = node.span;
        value = this._addExceptionSpan$2(t1, new R._EvaluateVisitor_visitWarnRule_closure(this, node));
        t2 = value instanceof D.SassString ? value.text : this._evaluate$_serialize$2(value, node.expression.get$span());
        this._logger.warn$2$trace(t2, this._evaluate$_stackTrace$1(t1));
        return;
      },
      visitWhileRule$1: function(node) {
        return this._environment.scope$3$semiGlobal$when(new R._EvaluateVisitor_visitWhileRule_closure(this, node), true, node.hasDeclarations);
      },
      visitBinaryOperationExpression$1: function(node) {
        return this._addExceptionSpan$2(B.spanForList([node.left, node.right]), new R._EvaluateVisitor_visitBinaryOperationExpression_closure(this, node));
      },
      visitValueExpression$1: function(node) {
        return node.value;
      },
      visitVariableExpression$1: function(node) {
        var result = this._environment.getVariable$1(node.name);
        if (result != null)
          return result;
        throw H.wrapException(this._exception$2("Undefined variable.", node.span));
      },
      visitUnaryOperationExpression$1: function(node) {
        var operand, t1;
        operand = node.operand.accept$1(this);
        t1 = node.operator;
        switch (t1) {
          case C.UnaryOperator_j2w:
            return operand.unaryPlus$0();
          case C.UnaryOperator_U4G:
            return operand.unaryMinus$0();
          case C.UnaryOperator_zDx:
            return operand.unaryDivide$0();
          case C.UnaryOperator_not_not:
            return operand.unaryNot$0();
          default:
            throw H.wrapException(P.StateError$("Unknown unary operator " + H.S(t1) + "."));
        }
      },
      visitBooleanExpression$1: function(node) {
        return node.value ? C.SassBoolean_true : C.SassBoolean_false;
      },
      visitIfExpression$1: function(node) {
        var pair, positional, named, t1, condition, ifTrue, ifFalse;
        pair = this._evaluateMacroArguments$1(node);
        positional = pair.item1;
        named = pair.item2;
        t1 = J.getInterceptor$asx(positional);
        this._verifyArguments$4(t1.get$length(positional), named, $.$get$IfExpression_declaration(), node.span);
        condition = J.$gt$n(t1.get$length(positional), 0) ? t1.$index(positional, 0) : J.$index$asx(named, "condition");
        ifTrue = J.$gt$n(t1.get$length(positional), 1) ? t1.$index(positional, 1) : J.$index$asx(named, "if-true");
        ifFalse = J.$gt$n(t1.get$length(positional), 2) ? t1.$index(positional, 2) : J.$index$asx(named, "if-false");
        return (condition.accept$1(this).get$isTruthy() ? ifTrue : ifFalse).accept$1(this);
      },
      visitNullExpression$1: function(node) {
        return C.C_SassNull;
      },
      visitNumberExpression$1: function(node) {
        var t1 = node.unit;
        t1 = t1 == null ? null : [t1];
        t1 = t1 == null ? C.List_empty : P.List_List$unmodifiable(t1, null);
        return new T.SassNumber(node.value, t1, C.List_empty, null);
      },
      visitColorExpression$1: function(node) {
        return node.value;
      },
      visitListExpression$1: function(node) {
        var t1 = node.contents;
        return D.SassList$(new H.MappedListIterable(t1, new R._EvaluateVisitor_visitListExpression_closure(this), [H.getTypeArgumentByIndex(t1, 0), null]), node.separator, node.hasBrackets);
      },
      visitMapExpression$1: function(node) {
        var t1, map, t2, _i, pair, keyValue, valueValue;
        t1 = F.Value;
        map = P.LinkedHashMap_LinkedHashMap$_empty(t1, t1);
        for (t1 = node.pairs, t2 = t1.length, _i = 0; _i < t2; ++_i) {
          pair = t1[_i];
          keyValue = pair.get$item1().accept$1(this);
          valueValue = pair.get$item2().accept$1(this);
          if (map.containsKey$1(keyValue))
            throw H.wrapException(this._exception$2("Duplicate key.", pair.get$item1().get$span()));
          map.$indexSet(0, keyValue, valueValue);
        }
        return new A.SassMap(H.ConstantMap_ConstantMap$from(map, null, null));
      },
      visitFunctionExpression$1: function(node) {
        var t1, plainName, $function, oldInFunction, t2, result;
        t1 = node.name;
        plainName = t1.get$asPlain();
        $function = plainName == null ? null : this._environment.getFunction$1(plainName);
        if ($function == null)
          $function = new L.PlainCssCallable(this._performInterpolation$1(t1));
        oldInFunction = this._inFunction;
        this._inFunction = true;
        t2 = node.$arguments;
        result = this._runFunctionCallable$3(t2, $function, B.spanForList([t1, t2]));
        this._inFunction = oldInFunction;
        return result;
      },
      _runUserDefinedCallable$4: function($arguments, callable, span, run) {
        var evaluated = this._evaluateArguments$1($arguments);
        return this._withStackFrame$3(callable.declaration.name + "()", span, new R._EvaluateVisitor__runUserDefinedCallable_closure(this, callable, evaluated, span, run));
      },
      _runFunctionCallable$3: function($arguments, callable, span) {
        var t1, t2, t3, first, _i, argument, rest;
        t1 = J.getInterceptor(callable);
        if (!!t1.$isBuiltInCallable)
          return this._runBuiltInCallable$3($arguments, callable, span).withoutSlash$0();
        else {
          t2 = H.checkSubtypeV1(callable, "$isUserDefinedCallable", [O.Environment], null);
          if (t2)
            return this._runUserDefinedCallable$4($arguments, callable, span, new R._EvaluateVisitor__runFunctionCallable_closure(this, callable)).withoutSlash$0();
          else if (!!t1.$isPlainCssCallable) {
            t1 = $arguments.named;
            if (t1.get$isNotEmpty(t1) || $arguments.keywordRest != null)
              throw H.wrapException(this._exception$2("Plain CSS functions don't support keyword arguments.", span));
            t1 = H.S(callable.name) + "(";
            for (t2 = $arguments.positional, t3 = t2.length, first = true, _i = 0; _i < t3; ++_i) {
              argument = t2[_i];
              if (first)
                first = false;
              else
                t1 += ", ";
              t1 += H.S(this._evaluate$_serialize$3$quote(argument.accept$1(this), argument.get$span(), true));
            }
            t2 = $arguments.rest;
            rest = t2 == null ? null : t2.accept$1(this);
            if (rest != null) {
              if (!first)
                t1 += ", ";
              t2 = t1 + H.S(this._evaluate$_serialize$2(rest, t2.get$span()));
              t1 = t2;
            }
            t1 += H.Primitives_stringFromCharCode(41);
            return new D.SassString(t1.charCodeAt(0) == 0 ? t1 : t1, false, null);
          } else
            return;
        }
      },
      _runBuiltInCallable$3: function($arguments, callable, span) {
        var evaluated, callback, result, error, message, oldCallableSpan, namedSet, tuple, overload, declaredArguments, i, t1, t2, argument, t3, rest, argumentList, exception;
        evaluated = this._evaluateArguments$2$trackSpans($arguments, false);
        oldCallableSpan = this._callableSpan;
        this._callableSpan = span;
        namedSet = new M.MapKeySet(evaluated.get$named(), [null]);
        tuple = callable.callbackFor$2(evaluated.get$positional().length, namedSet);
        overload = tuple.get$item1();
        callback = tuple.get$item2();
        this._addExceptionSpan$2(span, new R._EvaluateVisitor__runBuiltInCallable_closure(overload, evaluated, namedSet));
        declaredArguments = overload.get$$arguments();
        i = evaluated.get$positional().length;
        t1 = J.getInterceptor$asx(declaredArguments);
        while (true) {
          t2 = t1.get$length(declaredArguments);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          argument = t1.$index(declaredArguments, i);
          t2 = evaluated.get$positional();
          t3 = J.remove$1$ax(evaluated.get$named(), argument.get$name());
          if (t3 == null) {
            t3 = argument.get$defaultValue();
            t3 = t3 == null ? null : t3.accept$1(this);
          }
          J.add$1$ax(t2, t3);
          ++i;
        }
        if (overload.get$restArgument() != null) {
          t2 = evaluated.get$positional().length;
          t3 = t1.get$length(declaredArguments);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (t2 > t3) {
            rest = J.sublist$1$ax(evaluated.get$positional(), t1.get$length(declaredArguments));
            J.removeRange$2$ax(evaluated.get$positional(), t1.get$length(declaredArguments), evaluated.get$positional().length);
          } else
            rest = C.List_empty1;
          t1 = evaluated.get$named();
          t2 = evaluated.get$separator() === C.ListSeparator_undecided_null ? C.ListSeparator_kWM : evaluated.get$separator();
          argumentList = new D.SassArgumentList(new P.UnmodifiableMapView(B.normalizedMap(t1), [null, null]), false, P.List_List$unmodifiable(rest, null), t2, false);
          argumentList.SassList$3$brackets(rest, t2, false);
          J.add$1$ax(evaluated.get$positional(), argumentList);
        } else
          argumentList = null;
        result = null;
        try {
          result = callback.call$1(evaluated.get$positional());
          if (result == null)
            throw H.wrapException("Custom functions may not return Dart's null.");
        } catch (exception) {
          error = H.unwrapException(exception);
          message = null;
          try {
            message = H.stringTypeCast(J.get$message$x(error));
          } catch (exception) {
            H.unwrapException(exception);
            message = J.toString$0$(error);
          }
          throw H.wrapException(this._exception$2(message, span));
        }
        this._callableSpan = oldCallableSpan;
        if (argumentList == null)
          return result;
        if (J.get$isEmpty$asx(evaluated.get$named()))
          return result;
        if (argumentList._wereKeywordsAccessed)
          return result;
        t1 = evaluated.get$named().get$keys();
        t1 = "No " + B.pluralize("argument", t1.get$length(t1), null) + " named ";
        t2 = evaluated.get$named().get$keys();
        throw H.wrapException(this._exception$2(t1 + H.S(B.toSentence(t2.map$1(t2, new R._EvaluateVisitor__runBuiltInCallable_closure0()), "or")) + ".", span));
      },
      _evaluateArguments$2$trackSpans: function($arguments, trackSpans) {
        var t1, t2, positional, t3, named, t4, positionalSpans, namedSpans, rest, restSpan, separator, keywordRest, keywordRestSpan;
        if (trackSpans == null)
          trackSpans = this._sourceMap;
        t1 = $arguments.positional;
        t2 = [H.getTypeArgumentByIndex(t1, 0), null];
        positional = new H.MappedListIterable(t1, new R._EvaluateVisitor__evaluateArguments_closure(this), t2).toList$0(0);
        t3 = $arguments.named;
        named = B.normalizedMapMap(t3, null, new R._EvaluateVisitor__evaluateArguments_closure0(this));
        t4 = trackSpans === true;
        positionalSpans = t4 ? new H.MappedListIterable(t1, this.get$_expressionSpan(), t2).toList$0(0) : null;
        namedSpans = t4 ? Y.mapMap(t3, null, new R._EvaluateVisitor__evaluateArguments_closure1(this)) : null;
        t1 = $arguments.rest;
        if (t1 == null)
          return R._ArgumentResults$(positional, named, C.ListSeparator_undecided_null, namedSpans, positionalSpans);
        rest = t1.accept$1(this);
        restSpan = t4 ? this._expressionSpan$1(t1) : null;
        t2 = J.getInterceptor(rest);
        if (!!t2.$isSassMap) {
          this._addRestMap$3(named, rest, t1.get$span());
          if (!(namedSpans == null))
            namedSpans.addAll$1(0, Y.mapMap(rest.contents, new R._EvaluateVisitor__evaluateArguments_closure2(), new R._EvaluateVisitor__evaluateArguments_closure3(restSpan)));
          separator = C.ListSeparator_undecided_null;
        } else if (!!t2.$isSassList) {
          t1 = rest._list$_contents;
          C.JSArray_methods.addAll$1(positional, t1);
          if (!(positionalSpans == null))
            C.JSArray_methods.addAll$1(positionalSpans, P.List_List$filled(t1.length, restSpan, false, null));
          separator = rest.separator;
          if (!!t2.$isSassArgumentList) {
            rest._wereKeywordsAccessed = true;
            rest._keywords._collection$_map.forEach$1(0, new R._EvaluateVisitor__evaluateArguments_closure4(named, namedSpans, restSpan));
          }
        } else {
          C.JSArray_methods.add$1(positional, rest);
          if (!(positionalSpans == null))
            C.JSArray_methods.add$1(positionalSpans, restSpan);
          separator = C.ListSeparator_undecided_null;
        }
        t1 = $arguments.keywordRest;
        if (t1 == null)
          return R._ArgumentResults$(positional, named, separator, namedSpans, positionalSpans);
        keywordRest = t1.accept$1(this);
        keywordRestSpan = t4 ? this._expressionSpan$1(t1) : null;
        if (keywordRest instanceof A.SassMap) {
          this._addRestMap$3(named, keywordRest, t1.get$span());
          if (!(namedSpans == null))
            namedSpans.addAll$1(0, Y.mapMap(keywordRest.contents, new R._EvaluateVisitor__evaluateArguments_closure5(), new R._EvaluateVisitor__evaluateArguments_closure6(keywordRestSpan)));
          return R._ArgumentResults$(positional, named, separator, namedSpans, positionalSpans);
        } else
          throw H.wrapException(this._exception$2("Variable keyword arguments must be a map (was " + H.S(keywordRest) + ").", t1.get$span()));
      },
      _evaluateArguments$1: function($arguments) {
        return this._evaluateArguments$2$trackSpans($arguments, null);
      },
      _evaluateMacroArguments$1: function(invocation) {
        var t1, t2, t3, positional, named, rest, keywordRest;
        t1 = invocation.$arguments;
        t2 = t1.rest;
        if (t2 == null)
          return new S.Tuple2(t1.positional, t1.named, [null, null]);
        t3 = t1.positional;
        positional = H.setRuntimeTypeInfo(t3.slice(0), [H.getTypeArgumentByIndex(t3, 0)]);
        named = B.normalizedMap(t1.named);
        rest = t2.accept$1(this);
        t2 = J.getInterceptor(rest);
        if (!!t2.$isSassMap)
          this._addRestMap$4(named, rest, invocation.span, new R._EvaluateVisitor__evaluateMacroArguments_closure());
        else if (!!t2.$isSassList) {
          t3 = rest._list$_contents;
          C.JSArray_methods.addAll$1(positional, new H.MappedListIterable(t3, new R._EvaluateVisitor__evaluateMacroArguments_closure0(), [H.getTypeArgumentByIndex(t3, 0), null]));
          if (!!t2.$isSassArgumentList) {
            rest._wereKeywordsAccessed = true;
            rest._keywords._collection$_map.forEach$1(0, new R._EvaluateVisitor__evaluateMacroArguments_closure1(named));
          }
        } else
          positional.push(new F.ValueExpression(rest, null));
        t1 = t1.keywordRest;
        if (t1 == null)
          return new S.Tuple2(positional, named, [null, null]);
        keywordRest = t1.accept$1(this);
        t1 = invocation.span;
        if (keywordRest instanceof A.SassMap) {
          this._addRestMap$4(named, keywordRest, t1, new R._EvaluateVisitor__evaluateMacroArguments_closure2());
          return new S.Tuple2(positional, named, [null, null]);
        } else
          throw H.wrapException(this._exception$2("Variable keyword arguments must be a map (was " + H.S(keywordRest) + ").", t1));
      },
      _addRestMap$4: function(values, map, span, convert) {
        var t1 = {};
        t1.convert = convert;
        if (convert == null)
          t1.convert = new R._EvaluateVisitor__addRestMap_closure();
        map.contents.forEach$1(0, new R._EvaluateVisitor__addRestMap_closure0(t1, this, values, map, span));
      },
      _addRestMap$3: function(values, map, span) {
        return this._addRestMap$4(values, map, span, null);
      },
      _verifyArguments$4: function(positional, named, $arguments, span) {
        return this._addExceptionSpan$2(span, new R._EvaluateVisitor__verifyArguments_closure($arguments, positional, named));
      },
      visitSelectorExpression$1: function(node) {
        var t1 = this._styleRule;
        if (t1 == null)
          return C.C_SassNull;
        return t1.originalSelector.get$asSassList();
      },
      visitStringExpression$1: function(node) {
        var t1 = node.text.contents;
        return new D.SassString(new H.MappedListIterable(t1, new R._EvaluateVisitor_visitStringExpression_closure(this), [H.getTypeArgumentByIndex(t1, 0), null]).join$0(0), node.hasQuotes, null);
      },
      _handleReturn$2: function(list, callback) {
        var t1, result;
        for (t1 = J.get$iterator$ax(list); t1.moveNext$0();) {
          result = callback.call$1(t1.get$current(t1));
          if (result != null)
            return result;
        }
        return;
      },
      _withEnvironment$2: function(environment, callback) {
        var oldEnvironment, result;
        oldEnvironment = this._environment;
        this._environment = environment;
        result = callback.call$0();
        this._environment = oldEnvironment;
        return result;
      },
      _interpolationToValue$3$trim$warnForColor: function(interpolation, trim, warnForColor) {
        var result, t1;
        result = this._performInterpolation$2$warnForColor(interpolation, warnForColor);
        t1 = trim ? J.trim$0$s(result) : result;
        return new F.CssValue(t1, interpolation.get$span(), [null]);
      },
      _interpolationToValue$2$warnForColor: function(interpolation, warnForColor) {
        return this._interpolationToValue$3$trim$warnForColor(interpolation, false, warnForColor);
      },
      _performInterpolation$2$warnForColor: function(interpolation, warnForColor) {
        return J.join$0$ax(J.map$1$ax(J.get$contents$x(interpolation), new R._EvaluateVisitor__performInterpolation_closure(this, warnForColor)));
      },
      _performInterpolation$1: function(interpolation) {
        return this._performInterpolation$2$warnForColor(interpolation, false);
      },
      _evaluate$_serialize$3$quote: function(value, span, quote) {
        return this._addExceptionSpan$2(span, new R._EvaluateVisitor__serialize_closure(value, quote));
      },
      _evaluate$_serialize$2: function(value, span) {
        return this._evaluate$_serialize$3$quote(value, span, true);
      },
      _expressionSpan$1: [function(expression) {
        if (this._sourceMap !== true)
          return;
        if (expression instanceof S.VariableExpression)
          return this._environment.getVariableSpan$1(expression.name);
        else
          return expression.get$span();
      }, "call$1", "get$_expressionSpan", 4, 0, 29, 18],
      _withParent$4$scopeWhen$through: function(node, callback, scopeWhen, through) {
        var oldParent, $parent, grandparent, result;
        oldParent = this._parent;
        if (through != null) {
          for ($parent = oldParent; through.call$1($parent) === true;)
            $parent = $parent._node0$_parent;
          if ($parent.get$hasFollowingSibling()) {
            grandparent = $parent._node0$_parent;
            $parent = $parent.copyWithoutChildren$0();
            grandparent.addChild$1($parent);
          }
        } else
          $parent = oldParent;
        $parent.addChild$1(node);
        this._parent = node;
        result = this._environment.scope$2$when(callback, scopeWhen);
        this._parent = oldParent;
        return result;
      },
      _withParent$3$scopeWhen: function(node, callback, scopeWhen) {
        return this._withParent$4$scopeWhen$through(node, callback, scopeWhen, null);
      },
      _withParent$2: function(node, callback) {
        return this._withParent$4$scopeWhen$through(node, callback, true, null);
      },
      _withMediaQueries$2: function(queries, callback) {
        var oldMediaQueries, result;
        oldMediaQueries = this._mediaQueries;
        this._mediaQueries = queries;
        result = callback.call$0();
        this._mediaQueries = oldMediaQueries;
        return result;
      },
      _withStackFrame$3: function(member, span, callback) {
        var t1, oldMember, result;
        t1 = this._stack;
        t1.push(B.frameForSpan(span, this._member));
        oldMember = this._member;
        this._member = member;
        result = callback.call$0();
        this._member = oldMember;
        if (0 >= t1.length)
          return H.ioore(t1, -1);
        t1.pop();
        return result;
      },
      _evaluate$_stackTrace$1: function(span) {
        var t1, $frames;
        t1 = this._stack;
        $frames = H.setRuntimeTypeInfo(t1.slice(0), [H.getTypeArgumentByIndex(t1, 0)]);
        $frames.push(B.frameForSpan(span, this._member));
        return new Y.Trace(P.List_List$unmodifiable(new H.ReversedListIterable($frames, [H.getTypeArgumentByIndex($frames, 0)]), A.Frame), new P._StringStackTrace(null));
      },
      _warn$3$deprecation: function(message, span, deprecation) {
        return this._logger.warn$4$deprecation$span$trace(message, deprecation, span, this._evaluate$_stackTrace$1(span));
      },
      _warn$2: function(message, span) {
        return this._warn$3$deprecation(message, span, false);
      },
      _exception$2: function(message, span) {
        return new E.SassRuntimeException(this._evaluate$_stackTrace$1(span), message, span);
      },
      _adjustParseError$2: function(span, callback) {
        var error, errorText, syntheticFile, syntheticSpan, t1, exception, t2, t3, t4, t5;
        try {
          t1 = callback.call$0();
          return t1;
        } catch (exception) {
          t1 = H.unwrapException(exception);
          if (t1 instanceof E.SassFormatException) {
            error = t1;
            t1 = error;
            errorText = P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(H.interceptedTypeCast(G.SourceSpanException.prototype.get$span.call(t1), "$isFileSpan").file._decodedChars, 0, null), 0, null);
            t1 = J.getInterceptor$x(span);
            syntheticFile = C.JSString_methods.replaceRange$3(P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(t1.get$file(span)._decodedChars, 0, null), 0, null), t1.get$start(span).offset, t1.get$end(span).offset, errorText);
            t2 = t1.get$file(span).url;
            t3 = J.get$codeUnits$s(syntheticFile);
            t4 = H.setRuntimeTypeInfo([0], [P.int]);
            t5 = typeof t2 === "string" ? P.Uri_parse(t2, 0, null) : t2;
            t4 = new Y.SourceFile(t5, t4, new Uint32Array(H._ensureNativeList(t3.toList$0(t3))), null);
            t4.SourceFile$decoded$2$url(t3, t2);
            t2 = t1.get$start(span);
            t3 = error;
            t3 = H.interceptedTypeCast(G.SourceSpanException.prototype.get$span.call(t3), "$isFileSpan");
            t3 = J.$add$ansx(t2.offset, Y.FileLocation$_(t3.file, t3._file$_start).offset);
            t1 = t1.get$start(span);
            t2 = error;
            t2 = H.interceptedTypeCast(G.SourceSpanException.prototype.get$span.call(t2), "$isFileSpan");
            syntheticSpan = t4.span$2(t3, J.$add$ansx(t1.offset, Y.FileLocation$_(t2.file, t2._end).offset));
            throw H.wrapException(this._exception$2(J.get$message$x(error), syntheticSpan));
          } else
            throw exception;
        }
      },
      _addExceptionSpan$2: function(span, callback) {
        var error, t1, exception;
        try {
          t1 = callback.call$0();
          return t1;
        } catch (exception) {
          t1 = H.unwrapException(exception);
          if (t1 instanceof E.SassScriptException) {
            error = t1;
            throw H.wrapException(this._exception$2(J.get$message$x(error), span));
          } else
            throw exception;
        }
      },
      static: {
        _EvaluateVisitor$: function(functions, importCache, importer, logger, nodeImporter, sourceMap, variables) {
          var t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11;
          t1 = H.setRuntimeTypeInfo([], [F.CssImport]);
          t2 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.String);
          t3 = P.LinkedHashSet_LinkedHashSet(null, null, null, P.Uri);
          t4 = M.SimpleSelector;
          t5 = P._LinkedIdentityHashMap__LinkedIdentityHashMap$es6(t4, P.int);
          t6 = H.setRuntimeTypeInfo([], [A.Frame]);
          t7 = importCache == null ? C.ImportCache_89P : importCache;
          t8 = importer == null ? $.$get$Importer_noOp() : importer;
          t9 = logger == null ? C.StderrLogger_false : logger;
          t10 = B.normalizedMap(null);
          t11 = sourceMap === true ? [B.normalizedMap(null)] : null;
          t11 = new O.Environment([t10], t11, B.normalizedMap(null), [B.normalizedMap(null)], B.normalizedMap(null), [B.normalizedMap(null)], B.normalizedMap(null), null, null, false, true, null, null);
          t10 = $.$get$coreFunctions();
          t10.forEach$1(t10, t11.get$setFunction());
          t6 = new R._EvaluateVisitor(t7, nodeImporter, t9, sourceMap, t11, t8, null, null, null, null, null, null, "root stylesheet", null, false, false, false, false, 0, t1, t2, t3, new F.Extender(P.LinkedHashMap_LinkedHashMap$_empty(t4, [P.Set, X.CssStyleRule]), P.LinkedHashMap_LinkedHashMap$_empty(t4, [P.Map, S.ComplexSelector, S.Extension]), P.LinkedHashMap_LinkedHashMap$_empty(t4, [P.List, S.Extension]), new H.JsLinkedHashMap(0, null, null, null, null, null, 0, [X.CssStyleRule, [P.List, F.CssMediaQuery]]), t5, new P._LinkedIdentityHashSet(0, null, null, null, null, null, 0, [S.ComplexSelector]), C.ExtendMode_normal), t6);
          t6._EvaluateVisitor$7$functions$importCache$importer$logger$nodeImporter$sourceMap$variables(functions, importCache, importer, logger, nodeImporter, sourceMap, variables);
          return t6;
        }
      }
    },
    _EvaluateVisitor_closure: {
      "^": "Closure:0;$this",
      call$1: [function($arguments) {
        var variable = J.$index$asx($arguments, 0).assertString$1("name");
        return this.$this._environment.globalVariableExists$1(variable.text) === true ? C.SassBoolean_true : C.SassBoolean_false;
      }, null, null, 4, 0, null, 0, "call"]
    },
    _EvaluateVisitor_closure0: {
      "^": "Closure:0;$this",
      call$1: [function($arguments) {
        var variable = J.$index$asx($arguments, 0).assertString$1("name");
        return this.$this._environment.variableExists$1(variable.text) ? C.SassBoolean_true : C.SassBoolean_false;
      }, null, null, 4, 0, null, 0, "call"]
    },
    _EvaluateVisitor_closure1: {
      "^": "Closure:0;$this",
      call$1: [function($arguments) {
        var variable = J.$index$asx($arguments, 0).assertString$1("name");
        return this.$this._environment.functionExists$1(variable.text) ? C.SassBoolean_true : C.SassBoolean_false;
      }, null, null, 4, 0, null, 0, "call"]
    },
    _EvaluateVisitor_closure2: {
      "^": "Closure:0;$this",
      call$1: [function($arguments) {
        var variable = J.$index$asx($arguments, 0).assertString$1("name");
        return this.$this._environment.mixinExists$1(variable.text) ? C.SassBoolean_true : C.SassBoolean_false;
      }, null, null, 4, 0, null, 0, "call"]
    },
    _EvaluateVisitor_closure3: {
      "^": "Closure:0;$this",
      call$1: [function($arguments) {
        var t1 = this.$this;
        if (!t1._environment.get$inMixin())
          throw H.wrapException(E.SassScriptException$("content-exists() may only be called within a mixin."));
        return t1._environment.get$contentBlock() != null ? C.SassBoolean_true : C.SassBoolean_false;
      }, null, null, 4, 0, null, 0, "call"]
    },
    _EvaluateVisitor_closure4: {
      "^": "Closure:0;$this",
      call$1: [function($arguments) {
        var t1, $name, t2, callable;
        t1 = J.getInterceptor$asx($arguments);
        $name = t1.$index($arguments, 0).assertString$1("name");
        t2 = $name.text;
        callable = t1.$index($arguments, 1).get$isTruthy() ? new L.PlainCssCallable(t2) : this.$this._environment.getFunction$1(t2);
        if (callable != null)
          return new F.SassFunction(callable);
        throw H.wrapException(E.SassScriptException$("Function not found: " + $name.toString$0(0)));
      }, null, null, 4, 0, null, 0, "call"]
    },
    _EvaluateVisitor_closure5: {
      "^": "Closure:0;$this",
      call$1: [function($arguments) {
        var t1, $function, args, t2, t3, t4, invocation, callable;
        t1 = J.getInterceptor$asx($arguments);
        $function = t1.$index($arguments, 0);
        args = H.interceptedTypeCast(t1.$index($arguments, 1), "$isSassArgumentList");
        t1 = this.$this;
        t2 = t1._callableSpan;
        args._wereKeywordsAccessed = true;
        t3 = args._keywords;
        t4 = t3._collection$_map;
        if (t4.get$isEmpty(t4) === true)
          t3 = null;
        else {
          args._wereKeywordsAccessed = true;
          t3 = new F.ValueExpression(new A.SassMap(H.ConstantMap_ConstantMap$from(Y.mapMap(t3, new R._EvaluateVisitor__closure(), new R._EvaluateVisitor__closure0()), null, null)), t1._callableSpan);
        }
        invocation = X.ArgumentInvocation$([], P.LinkedHashMap__makeEmpty(), t2, t3, new F.ValueExpression(args, t2));
        if ($function instanceof D.SassString) {
          t1._warn$3$deprecation("Passing a string to call() is deprecated and will be illegal\nin Sass 4.0. Use call(get-function(" + $function.toString$0(0) + ")) instead.", t1._callableSpan, true);
          return t1.visitFunctionExpression$1(new F.FunctionExpression(X.Interpolation$([$function.text], t1._callableSpan), invocation));
        }
        callable = $function.assertFunction$1("function").callable;
        if (!!J.getInterceptor(callable).$isCallable)
          return t1._runFunctionCallable$3(invocation, callable, t1._callableSpan);
        else
          throw H.wrapException(E.SassScriptException$("The function " + H.S(callable.get$name()) + " is asynchronous.\nThis is probably caused by a bug in a Sass plugin."));
      }, null, null, 4, 0, null, 0, "call"]
    },
    _EvaluateVisitor__closure: {
      "^": "Closure:10;",
      call$2: function(key, _) {
        return new D.SassString(key, false, null);
      }
    },
    _EvaluateVisitor__closure0: {
      "^": "Closure:10;",
      call$2: function(_, value) {
        return value;
      }
    },
    _EvaluateVisitor_visitStylesheet_closure: {
      "^": "Closure:0;$this",
      call$1: function(children) {
        var t1 = this.$this;
        C.JSArray_methods.insertAll$2(children, t1._endOfImports, t1._outOfOrderImports);
      }
    },
    _EvaluateVisitor_visitAtRootRule_closure: {
      "^": "Closure:1;$this,resolved",
      call$0: function() {
        var t1, t2, t3;
        t1 = this.resolved;
        t2 = J.get$codeUnits$s(t1);
        t3 = H.setRuntimeTypeInfo([0], [P.int]);
        t3 = new Y.SourceFile(null, t3, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
        t3.SourceFile$decoded$2$url(t2, null);
        return new V.AtRootQueryParser(new S.SpanScanner(t3, null, null, t1, 0, null, null), this.$this._logger).parse$0();
      }
    },
    _EvaluateVisitor_visitAtRootRule_closure0: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        var t1, t2, t3, _i;
        for (t1 = this.node.children, t2 = t1.length, t3 = this.$this, _i = 0; _i < t2; ++_i)
          t1[_i].accept$1(t3);
      }
    },
    _EvaluateVisitor_visitAtRootRule_closure1: {
      "^": "Closure:1;$this,node",
      call$0: [function() {
        var t1, t2, t3, _i;
        for (t1 = this.node.children, t2 = t1.length, t3 = this.$this, _i = 0; _i < t2; ++_i)
          t1[_i].accept$1(t3);
      }, null, null, 0, 0, null, "call"]
    },
    _EvaluateVisitor__scopeForAtRoot_closure: {
      "^": "Closure:35;$this,newParent,node",
      call$1: function(callback) {
        var t1, oldParent;
        t1 = this.$this;
        oldParent = t1._parent;
        t1._parent = this.newParent;
        t1._environment.scope$2$when(callback, this.node.hasDeclarations);
        t1._parent = oldParent;
      }
    },
    _EvaluateVisitor__scopeForAtRoot_closure0: {
      "^": "Closure:0;$this,innerScope",
      call$1: function(callback) {
        var t1, oldAtRootExcludingStyleRule;
        t1 = this.$this;
        oldAtRootExcludingStyleRule = t1._atRootExcludingStyleRule;
        t1._atRootExcludingStyleRule = true;
        this.innerScope.call$1(callback);
        t1._atRootExcludingStyleRule = oldAtRootExcludingStyleRule;
      }
    },
    _EvaluateVisitor__scopeForAtRoot_closure1: {
      "^": "Closure:0;$this,innerScope",
      call$1: function(callback) {
        return this.$this._withMediaQueries$2(null, new R._EvaluateVisitor__scopeForAtRoot__closure(this.innerScope, callback));
      }
    },
    _EvaluateVisitor__scopeForAtRoot__closure: {
      "^": "Closure:1;innerScope,callback",
      call$0: function() {
        return this.innerScope.call$1(this.callback);
      }
    },
    _EvaluateVisitor__scopeForAtRoot_closure2: {
      "^": "Closure:0;$this,innerScope",
      call$1: function(callback) {
        var t1, wasInKeyframes;
        t1 = this.$this;
        wasInKeyframes = t1._inKeyframes;
        t1._inKeyframes = false;
        this.innerScope.call$1(callback);
        t1._inKeyframes = wasInKeyframes;
      }
    },
    _EvaluateVisitor__scopeForAtRoot_closure3: {
      "^": "Closure:0;",
      call$1: function($parent) {
        return $parent instanceof U.CssAtRule;
      }
    },
    _EvaluateVisitor__scopeForAtRoot_closure4: {
      "^": "Closure:0;$this,innerScope",
      call$1: function(callback) {
        var t1, wasInUnknownAtRule;
        t1 = this.$this;
        wasInUnknownAtRule = t1._evaluate$_inUnknownAtRule;
        t1._evaluate$_inUnknownAtRule = false;
        this.innerScope.call$1(callback);
        t1._evaluate$_inUnknownAtRule = wasInUnknownAtRule;
      }
    },
    _EvaluateVisitor_visitContentRule_closure: {
      "^": "Closure:1;$this,block",
      call$0: function() {
        var t1 = this.$this;
        t1._withEnvironment$2(t1._environment.get$contentEnvironment().closure$0(), new R._EvaluateVisitor_visitContentRule__closure(t1, this.block));
      }
    },
    _EvaluateVisitor_visitContentRule__closure: {
      "^": "Closure:1;$this,block",
      call$0: function() {
        var t1, t2, t3, _i;
        for (t1 = this.block, t2 = t1.length, t3 = this.$this, _i = 0; _i < t2; ++_i)
          t1[_i].accept$1(t3);
      }
    },
    _EvaluateVisitor_visitDeclaration_closure: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        var t1, t2, t3, _i;
        for (t1 = this.node.get$children(), t2 = t1.length, t3 = this.$this, _i = 0; _i < t2; ++_i)
          t1[_i].accept$1(t3);
      }
    },
    _EvaluateVisitor_visitEachRule_closure: {
      "^": "Closure:16;$this,node,span",
      call$1: function(value) {
        return this.$this._environment.setLocalVariable$3(C.JSArray_methods.get$first(this.node.variables), value.withoutSlash$0(), this.span);
      }
    },
    _EvaluateVisitor_visitEachRule_closure0: {
      "^": "Closure:16;$this,node,span",
      call$1: function(value) {
        return this.$this._setMultipleVariables$3(this.node.variables, value, this.span);
      }
    },
    _EvaluateVisitor_visitEachRule_closure1: {
      "^": "Closure:1;$this,list,setVariables,node",
      call$0: function() {
        var t1 = this.$this;
        return t1._handleReturn$2(this.list.get$asList(), new R._EvaluateVisitor_visitEachRule__closure(t1, this.setVariables, this.node));
      }
    },
    _EvaluateVisitor_visitEachRule__closure: {
      "^": "Closure:0;$this,setVariables,node",
      call$1: function(element) {
        var t1;
        this.setVariables.call$1(element);
        t1 = this.$this;
        return t1._handleReturn$2(this.node.children, new R._EvaluateVisitor_visitEachRule___closure(t1));
      }
    },
    _EvaluateVisitor_visitEachRule___closure: {
      "^": "Closure:0;$this",
      call$1: function(child) {
        return child.accept$1(this.$this);
      }
    },
    _EvaluateVisitor_visitExtendRule_closure: {
      "^": "Closure:1;$this,targetText",
      call$0: function() {
        var error, compound, t1, t2, t3, exception;
        try {
          t1 = J.trim$0$s(this.targetText.value);
          t2 = C.JSString_methods.get$codeUnits(t1);
          t3 = H.setRuntimeTypeInfo([0], [P.int]);
          t3 = new Y.SourceFile(null, t3, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
          t3.SourceFile$decoded$2$url(t2, null);
          t1 = new T.SelectorParser(false, new S.SpanScanner(t3, null, null, t1, 0, null, null), this.$this._logger).parseSimpleSelector$0();
          return t1;
        } catch (exception) {
          t1 = H.unwrapException(exception);
          if (t1 instanceof E.SassFormatException) {
            error = t1;
            compound = null;
            try {
              t1 = J.trim$0$s(this.targetText.value);
              t2 = C.JSString_methods.get$codeUnits(t1);
              t3 = H.setRuntimeTypeInfo([0], [P.int]);
              t3 = new Y.SourceFile(null, t3, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
              t3.SourceFile$decoded$2$url(t2, null);
              compound = new T.SelectorParser(false, new S.SpanScanner(t3, null, null, t1, 0, null, null), this.$this._logger).parseCompoundSelector$0();
            } catch (exception) {
              if (H.unwrapException(exception) instanceof E.SassFormatException)
                throw H.wrapException(error);
              else
                throw exception;
            }
            throw H.wrapException(E.SassFormatException$("compound selectors may longer be extended.\nConsider `@extend " + C.JSArray_methods.join$1(compound.get$components(), ", ") + "` instead.\nSee http://bit.ly/ExtendCompound for details.\n", error.get$span()));
          } else
            throw exception;
        }
      }
    },
    _EvaluateVisitor_visitAtRule_closure: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        var t1, t2;
        t1 = this.$this;
        t2 = t1._styleRule;
        if (!(t2 != null && !t1._atRootExcludingStyleRule))
          for (t2 = J.get$iterator$ax(this.node.get$children()); t2.moveNext$0();)
            t2.get$current(t2).accept$1(t1);
        else
          t1._withParent$3$scopeWhen(X.CssStyleRule$(t2.selector, t2.span, t2.originalSelector), new R._EvaluateVisitor_visitAtRule__closure(t1, this.node), false);
      }
    },
    _EvaluateVisitor_visitAtRule__closure: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        var t1, t2;
        for (t1 = J.get$iterator$ax(this.node.get$children()), t2 = this.$this; t1.moveNext$0();)
          t1.get$current(t1).accept$1(t2);
      }
    },
    _EvaluateVisitor_visitAtRule_closure0: {
      "^": "Closure:0;",
      call$1: function(node) {
        return node instanceof X.CssStyleRule;
      }
    },
    _EvaluateVisitor_visitForRule_closure: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        return this.node.from.accept$1(this.$this).assertNumber$0();
      }
    },
    _EvaluateVisitor_visitForRule_closure0: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        return this.node.to.accept$1(this.$this).assertNumber$0();
      }
    },
    _EvaluateVisitor_visitForRule_closure1: {
      "^": "Closure:1;fromNumber,toNumber",
      call$0: function() {
        var t1 = this.toNumber;
        return this.fromNumber.coerce$2(t1.get$numeratorUnits(), t1.get$denominatorUnits()).assertInt$0();
      }
    },
    _EvaluateVisitor_visitForRule_closure2: {
      "^": "Closure:1;toNumber",
      call$0: function() {
        return this.toNumber.assertInt$0();
      }
    },
    _EvaluateVisitor_visitForRule_closure3: {
      "^": "Closure:1;_box_0,$this,node,from,direction",
      call$0: function() {
        var t1, t2, span, i, t3, t4, t5, t6, t7, result;
        t1 = this.$this;
        t2 = this.node;
        span = t1._expressionSpan$1(t2.from);
        for (i = this.from, t3 = this._box_0, t4 = this.direction, t5 = t2.children, t2 = t2.variable; t6 = J.getInterceptor(i), t6.$eq(i, t3.to) !== true; i = t6.$add(i, t4)) {
          t7 = t1._environment;
          t7.setLocalVariable$3(t2, new T.SassNumber(i, C.List_empty, C.List_empty, null), span);
          result = t1._handleReturn$2(t5, new R._EvaluateVisitor_visitForRule__closure(t1));
          if (result != null)
            return result;
        }
        return;
      }
    },
    _EvaluateVisitor_visitForRule__closure: {
      "^": "Closure:0;$this",
      call$1: function(child) {
        return child.accept$1(this.$this);
      }
    },
    _EvaluateVisitor_visitIfRule_closure: {
      "^": "Closure:1;_box_0,$this",
      call$0: function() {
        var t1 = this.$this;
        return t1._handleReturn$2(this._box_0.clause.get$children(), new R._EvaluateVisitor_visitIfRule__closure(t1));
      }
    },
    _EvaluateVisitor_visitIfRule__closure: {
      "^": "Closure:0;$this",
      call$1: function(child) {
        return child.accept$1(this.$this);
      }
    },
    _EvaluateVisitor__visitDynamicImport_closure: {
      "^": "Closure:1;$this,importer,url,stylesheet",
      call$0: function() {
        var t1 = this.$this;
        t1._withEnvironment$2(t1._environment.global$0(), new R._EvaluateVisitor__visitDynamicImport__closure(t1, this.importer, this.url, this.stylesheet));
      }
    },
    _EvaluateVisitor__visitDynamicImport__closure: {
      "^": "Closure:1;$this,importer,url,stylesheet",
      call$0: function() {
        var t1, oldImporter, oldBaseUrl, t2;
        t1 = this.$this;
        oldImporter = t1._importer;
        oldBaseUrl = t1._baseUrl;
        t1._importer = this.importer;
        t1._baseUrl = this.url;
        for (t2 = J.get$iterator$ax(this.stylesheet.get$children()); t2.moveNext$0();)
          t2.get$current(t2).accept$1(t1);
        t1._importer = oldImporter;
        t1._baseUrl = oldBaseUrl;
      }
    },
    _EvaluateVisitor_visitIncludeRule_closure: {
      "^": "Closure:1;$this,node,environment,mixin",
      call$0: function() {
        var t1 = this.$this;
        t1._environment.withContent$3(this.node.children, this.environment, new R._EvaluateVisitor_visitIncludeRule__closure(t1, this.mixin));
      }
    },
    _EvaluateVisitor_visitIncludeRule__closure: {
      "^": "Closure:1;$this,mixin",
      call$0: function() {
        var t1 = this.$this;
        t1._environment.asMixin$1(new R._EvaluateVisitor_visitIncludeRule___closure(t1, this.mixin));
        return;
      }
    },
    _EvaluateVisitor_visitIncludeRule___closure: {
      "^": "Closure:1;$this,mixin",
      call$0: function() {
        var t1, t2, t3, _i;
        for (t1 = this.mixin.declaration.children, t2 = t1.length, t3 = this.$this, _i = 0; _i < t2; ++_i)
          t1[_i].accept$1(t3);
      }
    },
    _EvaluateVisitor_visitMediaRule_closure: {
      "^": "Closure:1;_box_0,$this,node",
      call$0: function() {
        var t1 = this.$this;
        t1._withMediaQueries$2(this._box_0.queries, new R._EvaluateVisitor_visitMediaRule__closure(t1, this.node));
      }
    },
    _EvaluateVisitor_visitMediaRule__closure: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        var t1, t2;
        t1 = this.$this;
        t2 = t1._styleRule;
        if (!(t2 != null && !t1._atRootExcludingStyleRule))
          for (t2 = J.get$iterator$ax(this.node.get$children()); t2.moveNext$0();)
            t2.get$current(t2).accept$1(t1);
        else
          t1._withParent$3$scopeWhen(X.CssStyleRule$(t2.selector, t2.span, t2.originalSelector), new R._EvaluateVisitor_visitMediaRule___closure(t1, this.node), false);
      }
    },
    _EvaluateVisitor_visitMediaRule___closure: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        var t1, t2;
        for (t1 = J.get$iterator$ax(this.node.get$children()), t2 = this.$this; t1.moveNext$0();)
          t1.get$current(t1).accept$1(t2);
      }
    },
    _EvaluateVisitor_visitMediaRule_closure0: {
      "^": "Closure:0;",
      call$1: function(node) {
        var t1 = J.getInterceptor(node);
        return !!t1.$isCssStyleRule || !!t1.$isCssMediaRule;
      }
    },
    _EvaluateVisitor__visitMediaQueries_closure: {
      "^": "Closure:1;$this,resolved",
      call$0: function() {
        var t1, t2, t3;
        t1 = this.resolved;
        t2 = J.get$codeUnits$s(t1);
        t3 = H.setRuntimeTypeInfo([0], [P.int]);
        t3 = new Y.SourceFile(null, t3, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
        t3.SourceFile$decoded$2$url(t2, null);
        return new F.MediaQueryParser(new S.SpanScanner(t3, null, null, t1, 0, null, null), this.$this._logger).parse$0();
      }
    },
    _EvaluateVisitor__mergeMediaQueries_closure: {
      "^": "Closure:0;queries2",
      call$1: function(query1) {
        return J.map$1$ax(this.queries2, new R._EvaluateVisitor__mergeMediaQueries__closure(query1));
      }
    },
    _EvaluateVisitor__mergeMediaQueries__closure: {
      "^": "Closure:0;query1",
      call$1: [function(query2) {
        return this.query1.merge$1(query2);
      }, null, null, 4, 0, null, 42, "call"]
    },
    _EvaluateVisitor__mergeMediaQueries_closure0: {
      "^": "Closure:0;",
      call$1: function(query) {
        return query != null;
      }
    },
    _EvaluateVisitor_visitStyleRule_closure: {
      "^": "Closure:1;$this,selectorText",
      call$0: function() {
        var t1, t2, t3;
        t1 = this.selectorText.value;
        t2 = J.get$codeUnits$s(t1);
        t3 = H.setRuntimeTypeInfo([0], [P.int]);
        t3 = new Y.SourceFile(null, t3, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
        t3.SourceFile$decoded$2$url(t2, null);
        return new E.KeyframeSelectorParser(new S.SpanScanner(t3, null, null, t1, 0, null, null), this.$this._logger).parse$0();
      }
    },
    _EvaluateVisitor_visitStyleRule_closure0: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        var t1, t2;
        for (t1 = J.get$iterator$ax(this.node.get$children()), t2 = this.$this; t1.moveNext$0();)
          t1.get$current(t1).accept$1(t2);
      }
    },
    _EvaluateVisitor_visitStyleRule_closure1: {
      "^": "Closure:0;",
      call$1: function(node) {
        return node instanceof X.CssStyleRule;
      }
    },
    _EvaluateVisitor_visitStyleRule_closure2: {
      "^": "Closure:1;$this,selectorText",
      call$0: function() {
        var t1, t2, t3;
        t1 = this.selectorText.value;
        t2 = J.get$codeUnits$s(t1);
        t3 = H.setRuntimeTypeInfo([0], [P.int]);
        t3 = new Y.SourceFile(null, t3, new Uint32Array(H._ensureNativeList(t2.toList$0(t2))), null);
        t3.SourceFile$decoded$2$url(t2, null);
        return new T.SelectorParser(true, new S.SpanScanner(t3, null, null, t1, 0, null, null), this.$this._logger).parse$0();
      }
    },
    _EvaluateVisitor_visitStyleRule_closure3: {
      "^": "Closure:1;_box_0,$this",
      call$0: function() {
        var t1, t2, t3;
        t1 = this._box_0.parsedSelector;
        t2 = this.$this;
        t3 = t2._styleRule;
        t3 = t3 == null ? null : t3.originalSelector;
        return t1.resolveParentSelectors$2$implicitParent(t3, !t2._atRootExcludingStyleRule);
      }
    },
    _EvaluateVisitor_visitStyleRule_closure4: {
      "^": "Closure:1;$this,rule,node",
      call$0: function() {
        var t1, oldRule;
        t1 = this.$this;
        oldRule = t1._styleRule;
        t1._styleRule = this.rule;
        new R._EvaluateVisitor_visitStyleRule__closure(t1, this.node).call$0();
        t1._styleRule = oldRule;
      }
    },
    _EvaluateVisitor_visitStyleRule__closure: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        var t1, t2;
        for (t1 = J.get$iterator$ax(this.node.get$children()), t2 = this.$this; t1.moveNext$0();)
          t1.get$current(t1).accept$1(t2);
      }
    },
    _EvaluateVisitor_visitStyleRule_closure5: {
      "^": "Closure:0;",
      call$1: function(node) {
        return node instanceof X.CssStyleRule;
      }
    },
    _EvaluateVisitor_visitSupportsRule_closure: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        var t1, t2;
        t1 = this.$this;
        t2 = t1._styleRule;
        if (!(t2 != null && !t1._atRootExcludingStyleRule))
          for (t2 = J.get$iterator$ax(this.node.get$children()); t2.moveNext$0();)
            t2.get$current(t2).accept$1(t1);
        else
          t1._withParent$2(X.CssStyleRule$(t2.selector, t2.span, t2.originalSelector), new R._EvaluateVisitor_visitSupportsRule__closure(t1, this.node));
      }
    },
    _EvaluateVisitor_visitSupportsRule__closure: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        var t1, t2;
        for (t1 = J.get$iterator$ax(this.node.get$children()), t2 = this.$this; t1.moveNext$0();)
          t1.get$current(t1).accept$1(t2);
      }
    },
    _EvaluateVisitor_visitSupportsRule_closure0: {
      "^": "Closure:0;",
      call$1: function(node) {
        return node instanceof X.CssStyleRule;
      }
    },
    _EvaluateVisitor_visitWarnRule_closure: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        return this.node.expression.accept$1(this.$this);
      }
    },
    _EvaluateVisitor_visitWhileRule_closure: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        var t1, t2, t3, result;
        for (t1 = this.node, t2 = t1.condition, t3 = this.$this, t1 = t1.children; t2.accept$1(t3).get$isTruthy();) {
          result = t3._handleReturn$2(t1, new R._EvaluateVisitor_visitWhileRule__closure(t3));
          if (result != null)
            return result;
        }
        return;
      }
    },
    _EvaluateVisitor_visitWhileRule__closure: {
      "^": "Closure:0;$this",
      call$1: function(child) {
        return child.accept$1(this.$this);
      }
    },
    _EvaluateVisitor_visitBinaryOperationExpression_closure: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        var t1, t2, t3, left, right, result, leftSlash, rightSlash;
        t1 = this.node;
        t2 = t1.left;
        t3 = this.$this;
        left = t2.accept$1(t3);
        switch (t1.operator) {
          case C.BinaryOperator_kjl:
            return left.singleEquals$1(t1.right.accept$1(t3));
          case C.BinaryOperator_or_or_1:
            return left.get$isTruthy() ? left : t1.right.accept$1(t3);
          case C.BinaryOperator_and_and_2:
            return left.get$isTruthy() ? t1.right.accept$1(t3) : left;
          case C.BinaryOperator_YlX:
            return J.$eq$(left, t1.right.accept$1(t3)) === true ? C.SassBoolean_true : C.SassBoolean_false;
          case C.BinaryOperator_i5H:
            return J.$eq$(left, t1.right.accept$1(t3)) !== true ? C.SassBoolean_true : C.SassBoolean_false;
          case C.BinaryOperator_AcR0:
            return left.greaterThan$1(t1.right.accept$1(t3));
          case C.BinaryOperator_1da:
            return left.greaterThanOrEquals$1(t1.right.accept$1(t3));
          case C.BinaryOperator_8qt:
            return left.lessThan$1(t1.right.accept$1(t3));
          case C.BinaryOperator_33h:
            return left.lessThanOrEquals$1(t1.right.accept$1(t3));
          case C.BinaryOperator_AcR:
            return left.plus$1(t1.right.accept$1(t3));
          case C.BinaryOperator_iyO:
            return left.minus$1(t1.right.accept$1(t3));
          case C.BinaryOperator_O1M:
            return left.times$1(t1.right.accept$1(t3));
          case C.BinaryOperator_RTB:
            right = t1.right.accept$1(t3);
            result = left.dividedBy$1(right);
            if (t1.allowsSlash && left instanceof T.SassNumber && right instanceof T.SassNumber) {
              leftSlash = left.get$asSlash();
              if (leftSlash == null)
                leftSlash = t3._evaluate$_serialize$2(left, t2.get$span());
              rightSlash = right.asSlash;
              if (rightSlash == null)
                rightSlash = t3._evaluate$_serialize$2(right, t2.get$span());
              H.interceptedTypeCast(result, "$isSassNumber");
              return new T.SassNumber(result.value, result.numeratorUnits, result.denominatorUnits, H.S(leftSlash) + "/" + H.S(rightSlash));
            } else
              return result;
          case C.BinaryOperator_2ad:
            return left.modulo$1(t1.right.accept$1(t3));
          default:
            return;
        }
      }
    },
    _EvaluateVisitor_visitListExpression_closure: {
      "^": "Closure:15;$this",
      call$1: [function(expression) {
        return expression.accept$1(this.$this);
      }, null, null, 4, 0, null, 18, "call"]
    },
    _EvaluateVisitor__runUserDefinedCallable_closure: {
      "^": "Closure:1;$this,callable,evaluated,span,run",
      call$0: function() {
        var t1, t2;
        t1 = this.$this;
        t2 = this.callable;
        return t1._withEnvironment$2(t2.environment.closure$0(), new R._EvaluateVisitor__runUserDefinedCallable__closure(t1, this.evaluated, t2, this.span, this.run));
      }
    },
    _EvaluateVisitor__runUserDefinedCallable__closure: {
      "^": "Closure:1;$this,evaluated,callable,span,run",
      call$0: function() {
        var t1 = this.$this;
        return t1._environment.scope$1(new R._EvaluateVisitor__runUserDefinedCallable___closure(t1, this.evaluated, this.callable, this.span, this.run));
      }
    },
    _EvaluateVisitor__runUserDefinedCallable___closure: {
      "^": "Closure:1;$this,evaluated,callable,span,run",
      call$0: function() {
        var t1, t2, t3, t4, t5, t6, declaredArguments, t7, minLength, t8, t9, i, t10, t11, t12, t13, argument, value, rest, argumentList, result;
        t1 = this.$this;
        t2 = this.evaluated;
        t3 = t2.positional;
        t4 = t2.named;
        t5 = this.callable.declaration.$arguments;
        t6 = this.span;
        t1._verifyArguments$4(t3.length, t4, t5, t6);
        declaredArguments = t5.$arguments;
        t7 = declaredArguments.length;
        minLength = Math.min(t3.length, t7);
        for (t8 = t1._sourceMap === true, t9 = t2.positionalSpans, i = 0; i < minLength; ++i) {
          t10 = t1._environment;
          if (i >= t7)
            return H.ioore(declaredArguments, i);
          t11 = declaredArguments[i].get$name();
          if (i >= t3.length)
            return H.ioore(t3, i);
          t12 = t3[i].withoutSlash$0();
          if (t8) {
            if (i >= t9.length)
              return H.ioore(t9, i);
            t13 = t9[i];
          } else
            t13 = null;
          t10.setLocalVariable$3(t11, t12, t13);
        }
        for (i = t3.length, t9 = t2.namedSpans; i < t7; ++i) {
          argument = declaredArguments[i];
          value = t4.remove$1(0, argument.get$name());
          if (value == null)
            value = argument.get$defaultValue().accept$1(t1);
          t10 = t1._environment;
          t11 = argument.get$name();
          t12 = value.withoutSlash$0();
          if (t8) {
            t13 = t9.$index(0, argument.get$name());
            if (t13 == null)
              t13 = t1._expressionSpan$1(argument.get$defaultValue());
          } else
            t13 = null;
          t10.setLocalVariable$3(t11, t12, t13);
        }
        t5 = t5.restArgument;
        if (t5 != null) {
          rest = t3.length > t7 ? C.JSArray_methods.sublist$1(t3, t7) : C.List_empty1;
          t2 = t2.separator;
          if (t2 === C.ListSeparator_undecided_null)
            t2 = C.ListSeparator_kWM;
          argumentList = new D.SassArgumentList(new P.UnmodifiableMapView(B.normalizedMap(t4), [null, null]), false, P.List_List$unmodifiable(rest, null), t2, false);
          argumentList.SassList$3$brackets(rest, t2, false);
          t1._environment.setLocalVariable$3(t5, argumentList, t6);
        } else
          argumentList = null;
        result = this.run.call$0();
        if (argumentList == null)
          return result;
        if (t4.get$isEmpty(t4))
          return result;
        if (argumentList._wereKeywordsAccessed)
          return result;
        t2 = t4.get$keys();
        throw H.wrapException(t1._exception$2(C.JSString_methods.$add("No " + B.pluralize("argument", t2.get$length(t2), null) + " named ", B.toSentence(t4.get$keys().map$1(0, new R._EvaluateVisitor__runUserDefinedCallable____closure()), "or")) + ".", t6));
      }
    },
    _EvaluateVisitor__runUserDefinedCallable____closure: {
      "^": "Closure:0;",
      call$1: [function($name) {
        return "$" + H.S($name);
      }, null, null, 4, 0, null, 8, "call"]
    },
    _EvaluateVisitor__runFunctionCallable_closure: {
      "^": "Closure:1;$this,callable",
      call$0: function() {
        var t1, t2, t3, t4, _i, $returnValue;
        for (t1 = this.callable.declaration, t2 = t1.children, t3 = t2.length, t4 = this.$this, _i = 0; _i < t3; ++_i) {
          $returnValue = t2[_i].accept$1(t4);
          if ($returnValue instanceof F.Value)
            return $returnValue;
        }
        throw H.wrapException(t4._exception$2("Function finished without @return.", t1.span));
      }
    },
    _EvaluateVisitor__runBuiltInCallable_closure: {
      "^": "Closure:1;overload,evaluated,namedSet",
      call$0: function() {
        return this.overload.verify$2(this.evaluated.positional.length, this.namedSet);
      }
    },
    _EvaluateVisitor__runBuiltInCallable_closure0: {
      "^": "Closure:0;",
      call$1: [function($name) {
        return "$" + H.S($name);
      }, null, null, 4, 0, null, 8, "call"]
    },
    _EvaluateVisitor__evaluateArguments_closure: {
      "^": "Closure:15;$this",
      call$1: [function(expression) {
        return expression.accept$1(this.$this);
      }, null, null, 4, 0, null, 18, "call"]
    },
    _EvaluateVisitor__evaluateArguments_closure0: {
      "^": "Closure:2;$this",
      call$2: function(_, expression) {
        return expression.accept$1(this.$this);
      }
    },
    _EvaluateVisitor__evaluateArguments_closure1: {
      "^": "Closure:2;$this",
      call$2: function(_, expression) {
        return this.$this._expressionSpan$1(expression);
      }
    },
    _EvaluateVisitor__evaluateArguments_closure2: {
      "^": "Closure:2;",
      call$2: function(key, _) {
        return H.interceptedTypeCast(key, "$isSassString").text;
      }
    },
    _EvaluateVisitor__evaluateArguments_closure3: {
      "^": "Closure:2;restSpan",
      call$2: function(_, __) {
        return this.restSpan;
      }
    },
    _EvaluateVisitor__evaluateArguments_closure4: {
      "^": "Closure:2;named,namedSpans,restSpan",
      call$2: function(key, value) {
        var t1;
        this.named.$indexSet(0, key, value);
        t1 = this.namedSpans;
        if (t1 != null)
          t1.$indexSet(0, key, this.restSpan);
      }
    },
    _EvaluateVisitor__evaluateArguments_closure5: {
      "^": "Closure:2;",
      call$2: function(key, _) {
        return H.interceptedTypeCast(key, "$isSassString").text;
      }
    },
    _EvaluateVisitor__evaluateArguments_closure6: {
      "^": "Closure:2;keywordRestSpan",
      call$2: function(_, __) {
        return this.keywordRestSpan;
      }
    },
    _EvaluateVisitor__evaluateMacroArguments_closure: {
      "^": "Closure:0;",
      call$1: function(value) {
        return new F.ValueExpression(value, null);
      }
    },
    _EvaluateVisitor__evaluateMacroArguments_closure0: {
      "^": "Closure:0;",
      call$1: [function(value) {
        return new F.ValueExpression(value, null);
      }, null, null, 4, 0, null, 3, "call"]
    },
    _EvaluateVisitor__evaluateMacroArguments_closure1: {
      "^": "Closure:2;named",
      call$2: function(key, value) {
        this.named.$indexSet(0, key, new F.ValueExpression(value, null));
      }
    },
    _EvaluateVisitor__evaluateMacroArguments_closure2: {
      "^": "Closure:0;",
      call$1: function(value) {
        return new F.ValueExpression(value, null);
      }
    },
    _EvaluateVisitor__addRestMap_closure: {
      "^": "Closure:0;",
      call$1: function(value) {
        return value;
      }
    },
    _EvaluateVisitor__addRestMap_closure0: {
      "^": "Closure:2;_box_0,$this,values,map,span",
      call$2: function(key, value) {
        if (key instanceof D.SassString)
          this.values.$indexSet(0, key.text, this._box_0.convert.call$1(value));
        else
          throw H.wrapException(this.$this._exception$2("Variable keyword argument map must have string keys.\n" + H.S(key) + " is not a string in " + this.map.toString$0(0) + ".", this.span));
      }
    },
    _EvaluateVisitor__verifyArguments_closure: {
      "^": "Closure:1;$arguments,positional,named",
      call$0: function() {
        return this.$arguments.verify$2(this.positional, new M.MapKeySet(this.named, [null]));
      }
    },
    _EvaluateVisitor_visitStringExpression_closure: {
      "^": "Closure:0;$this",
      call$1: [function(value) {
        var t1, result;
        if (typeof value === "string")
          return value;
        H.interceptedTypeCast(value, "$isExpression");
        t1 = this.$this;
        result = value.accept$1(t1);
        return result instanceof D.SassString ? result.text : t1._evaluate$_serialize$3$quote(result, value.get$span(), false);
      }, null, null, 4, 0, null, 3, "call"]
    },
    _EvaluateVisitor__performInterpolation_closure: {
      "^": "Closure:0;$this,warnForColor",
      call$1: [function(value) {
        var t1, result, t2, t3;
        if (typeof value === "string")
          return value;
        H.interceptedTypeCast(value, "$isExpression");
        t1 = this.$this;
        result = value.accept$1(t1);
        if (this.warnForColor && result instanceof K.SassColor && $.$get$namesByColor().containsKey$1(result)) {
          t2 = X.Interpolation$([""], null);
          t3 = $.$get$namesByColor();
          t1._warn$2("You probably don't mean to use the color value " + H.S(t3.$index(0, result)) + " in interpolation here.\nIt may end up represented as " + H.S(result) + ', which will likely produce invalid CSS.\nAlways quote color names when using them as strings or map keys (for example, "' + H.S(t3.$index(0, result)) + "\").\nIf you really want to use the color value here, use '" + new V.BinaryOperationExpression(C.BinaryOperator_AcR, new D.StringExpression(t2, true), value, false).toString$0(0) + "'.", value.get$span());
        }
        return t1._evaluate$_serialize$3$quote(result, value.get$span(), false);
      }, null, null, 4, 0, null, 3, "call"]
    },
    _EvaluateVisitor__serialize_closure: {
      "^": "Closure:1;value,quote",
      call$0: function() {
        return this.value.toCssString$1$quote(this.quote);
      }
    },
    _ArgumentResults: {
      "^": "Object;positional<,positionalSpans<,named<,namedSpans<,separator<",
      static: {
        _ArgumentResults$: function(positional, named, separator, namedSpans, positionalSpans) {
          return new R._ArgumentResults(positional, positionalSpans, named, namedSpans, separator);
        }
      }
    }
  }], ["", "package:sass/src/visitor/find_imports.dart",, L, {
    "^": "",
    _FindImportsVisitor: {
      "^": "RecursiveStatementVisitor;_imports",
      run$1: function(_, stylesheet) {
        this.visitChildren$1(stylesheet);
        return this._imports;
      },
      visitEachRule$1: function(node) {
      },
      visitForRule$1: function(node) {
      },
      visitIfRule$1: function(node) {
      },
      visitWhileRule$1: function(node) {
      },
      visitImportRule$1: function(node) {
        var t1, t2, t3, _i, $import;
        for (t1 = node.imports, t2 = t1.length, t3 = this._imports, _i = 0; _i < t2; ++_i) {
          $import = t1[_i];
          if ($import instanceof B.DynamicImport)
            t3.push($import);
        }
      },
      $asRecursiveStatementVisitor: Isolate.functionThatReturnsNull
    }
  }], ["", "package:sass/src/visitor/recursive_statement.dart",, D, {
    "^": "",
    RecursiveStatementVisitor: {
      "^": "Object;$ti",
      visitAtRootRule$1: function(node) {
        return this.visitChildren$1(node);
      },
      visitAtRule$1: function(node) {
        node.get$value();
        return node.get$children() == null ? null : this.visitChildren$1(node);
      },
      visitContentRule$1: function(node) {
        return;
      },
      visitDebugRule$1: function(node) {
        return;
      },
      visitDeclaration$1: function(node) {
        node.get$name();
        node.get$value();
        return node.get$children() == null ? null : this.visitChildren$1(node);
      },
      visitErrorRule$1: function(node) {
        return;
      },
      visitExtendRule$1: function(node) {
        return;
      },
      visitFunctionRule$1: function(node) {
        return;
      },
      visitIncludeRule$1: function(node) {
        var t1, t2, _i;
        for (t1 = node.$arguments, t2 = t1.positional.length, _i = 0; _i < t2; ++_i)
          ;
        for (t1 = t1.named.get$values(), t1 = t1.get$iterator(t1); t1.moveNext$0();)
          t1.get$current(t1);
        return node.children == null ? null : this.visitChildren$1(node);
      },
      visitLoudComment$1: function(node) {
        return;
      },
      visitMediaRule$1: function(node) {
        node.get$query();
        return this.visitChildren$1(node);
      },
      visitMixinRule$1: function(node) {
        return;
      },
      visitReturnRule$1: function(node) {
        return;
      },
      visitSilentComment$1: function(node) {
        return;
      },
      visitStyleRule$1: function(node) {
        node.get$selector();
        return this.visitChildren$1(node);
      },
      visitStylesheet$1: function(node) {
        return this.visitChildren$1(node);
      },
      visitSupportsRule$1: function(node) {
        node.get$condition();
        return this.visitChildren$1(node);
      },
      visitVariableDeclaration$1: function(node) {
        return;
      },
      visitWarnRule$1: function(node) {
        return;
      },
      visitChildren$1: function(node) {
        var t1;
        for (t1 = J.get$iterator$ax(node.get$children()); t1.moveNext$0();)
          t1.get$current(t1).accept$1(this);
        return;
      }
    }
  }], ["", "package:sass/src/visitor/serialize.dart",, N, {
    "^": "",
    serialize: function(node, indentWidth, inspect, lineFeed, sourceMap, style, useSpaces) {
      var visitor, t1, css, t2, t3;
      visitor = N._SerializeVisitor$(indentWidth == null ? 2 : indentWidth, inspect, lineFeed, true, sourceMap, style, useSpaces);
      node.accept$1(visitor);
      t1 = visitor._buffer;
      css = t1.toString$0(0);
      t2 = new H.CodeUnits(css);
      if (t2.any$1(t2, new N.serialize_closure()))
        css = style === C.OutputStyle_compressed ? "\ufeff" + css : '@charset "UTF-8";\n' + css;
      t2 = sourceMap === true;
      t3 = t2 ? t1.buildSourceMap$0() : null;
      return new N.SerializeResult(css, t3, t2 ? t1.get$sourceFiles() : null);
    },
    serializeValue: function(value, inspect, quote) {
      var visitor = N._SerializeVisitor$(null, inspect, null, quote, false, null, true);
      value.accept$1(visitor);
      return visitor._buffer.toString$0(0);
    },
    serialize_closure: {
      "^": "Closure:0;",
      call$1: function(codeUnit) {
        return J.$gt$n(codeUnit, 127);
      }
    },
    _SerializeVisitor: {
      "^": "Object;_buffer,_indentation,_style,_inspect,_quote,_indentCharacter,_indentWidth,_lineFeed",
      _SerializeVisitor$7$indentWidth$inspect$lineFeed$quote$sourceMap$style$useSpaces: function(indentWidth, inspect, lineFeed, quote, sourceMap, style, useSpaces) {
        P.RangeError_checkValueInInterval(this._indentWidth, 0, 10, "indentWidth", null);
      },
      visitStylesheet$1: function(node) {
        var t1, t2, t3, previous, i, t4, child;
        t1 = this._style !== C.OutputStyle_compressed;
        t2 = this._buffer;
        t3 = this._lineFeed.text;
        previous = null;
        i = 0;
        while (true) {
          t4 = J.get$length$asx(node.get$children());
          if (typeof t4 !== "number")
            return H.iae(t4);
          if (!(i < t4))
            break;
          c$0: {
            child = J.$index$asx(node.get$children(), i);
            if (this._isInvisible$1(child))
              break c$0;
            if (previous != null) {
              t4 = J.getInterceptor(previous);
              if (!!t4.$isCssParentNode ? previous.get$isChildless() : !t4.$isCssComment)
                t2.writeCharCode$1(59);
              if (t1)
                t2.write$1(0, t3);
              if (previous.get$isGroupEnd())
                if (t1)
                  t2.write$1(0, t3);
            }
            child.accept$1(this);
            previous = child;
          }
          ++i;
        }
        if (previous != null) {
          t3 = J.getInterceptor(previous);
          t1 = (!!t3.$isCssParentNode ? previous.get$isChildless() : !t3.$isCssComment) && t1;
        } else
          t1 = false;
        if (t1)
          t2.writeCharCode$1(59);
      },
      visitComment$1: function(node) {
        this._buffer.forSpan$2(node.span, new N._SerializeVisitor_visitComment_closure(this, node));
      },
      visitAtRule$1: function(node) {
        var t1;
        this._writeIndentation$0();
        t1 = this._buffer;
        t1.forSpan$2(node.get$span(), new N._SerializeVisitor_visitAtRule_closure(this, node));
        if (!node.get$isChildless()) {
          if (this._style !== C.OutputStyle_compressed)
            t1.writeCharCode$1(32);
          this._visitChildren$1(node.get$children());
        }
      },
      visitMediaRule$1: function(node) {
        var t1;
        this._writeIndentation$0();
        t1 = this._buffer;
        t1.forSpan$2(node.get$span(), new N._SerializeVisitor_visitMediaRule_closure(this, node));
        if (this._style !== C.OutputStyle_compressed)
          t1.writeCharCode$1(32);
        this._visitChildren$1(node.get$children());
      },
      visitImport$1: function(node) {
        this._writeIndentation$0();
        this._buffer.forSpan$2(node.span, new N._SerializeVisitor_visitImport_closure(this, node));
      },
      _writeImportUrl$1: function(url) {
        var t1, urlContents, maybeQuote;
        if (this._style !== C.OutputStyle_compressed || J.codeUnitAt$1$s(url, 0) !== 117) {
          this._buffer.write$1(0, url);
          return;
        }
        t1 = J.getInterceptor$asx(url);
        urlContents = t1.substring$2(url, 4, J.$sub$n(t1.get$length(url), 1));
        maybeQuote = C.JSString_methods._codeUnitAt$1(urlContents, 0);
        if (maybeQuote === 39 || maybeQuote === 34)
          this._buffer.write$1(0, urlContents);
        else
          this._visitQuotedString$1(urlContents);
      },
      visitKeyframeBlock$1: function(node) {
        var t1;
        this._writeIndentation$0();
        t1 = this._buffer;
        t1.forSpan$2(node.selector.span, new N._SerializeVisitor_visitKeyframeBlock_closure(this, node));
        if (this._style !== C.OutputStyle_compressed)
          t1.writeCharCode$1(32);
        this._visitChildren$1(node.children);
      },
      _visitMediaQuery$1: [function(query) {
        var t1, t2, t3;
        if (query.get$modifier() != null) {
          t1 = this._buffer;
          t1.write$1(0, query.get$modifier());
          t1.writeCharCode$1(32);
        }
        if (query.get$type() != null) {
          t1 = this._buffer;
          t1.write$1(0, query.get$type());
          if (query.get$features().length !== 0)
            t1.write$1(0, " and ");
        }
        t1 = query.get$features();
        t2 = this._style === C.OutputStyle_compressed ? "and " : " and ";
        t3 = this._buffer;
        this._writeBetween$3(t1, t2, t3.get$write(t3));
      }, "call$1", "get$_visitMediaQuery", 4, 0, 80],
      visitStyleRule$1: function(node) {
        var t1;
        this._writeIndentation$0();
        t1 = this._buffer;
        t1.forSpan$2(node.get$selector().get$span(), new N._SerializeVisitor_visitStyleRule_closure(this, node));
        if (this._style !== C.OutputStyle_compressed)
          t1.writeCharCode$1(32);
        this._visitChildren$1(node.get$children());
      },
      visitSupportsRule$1: function(node) {
        var t1;
        this._writeIndentation$0();
        t1 = this._buffer;
        t1.forSpan$2(node.get$span(), new N._SerializeVisitor_visitSupportsRule_closure(this, node));
        if (this._style !== C.OutputStyle_compressed)
          t1.writeCharCode$1(32);
        this._visitChildren$1(node.get$children());
      },
      visitDeclaration$1: function(node) {
        var error, t1, exception;
        this._writeIndentation$0();
        this._write$1(node.get$name());
        t1 = this._buffer;
        t1.writeCharCode$1(58);
        if (this._isParsedCustomProperty$1(node))
          t1.forSpan$2(node.get$value().get$span(), new N._SerializeVisitor_visitDeclaration_closure(this, node));
        else {
          if (this._style !== C.OutputStyle_compressed)
            t1.writeCharCode$1(32);
          try {
            t1.forSpan$2(node.get$valueSpanForMap(), new N._SerializeVisitor_visitDeclaration_closure0(this, node));
          } catch (exception) {
            t1 = H.unwrapException(exception);
            if (t1 instanceof E.SassScriptException) {
              error = t1;
              throw H.wrapException(E.SassException$(J.get$message$x(error), node.get$value().get$span()));
            } else
              throw exception;
          }
        }
      },
      _isParsedCustomProperty$1: function(node) {
        var value;
        if (!J.startsWith$1$s(node.get$name().get$value(), "--"))
          return false;
        value = node.get$value().get$value();
        return value instanceof D.SassString && !value.hasQuotes;
      },
      _writeFoldedValue$1: function(node) {
        var scanner, t1, t2, t3, next, t4;
        scanner = X.StringScanner$(H.interceptedTypeCast(node.get$value().get$value(), "$isSassString").text, null, null);
        for (t1 = scanner.string, t2 = J.getInterceptor$asx(t1), t3 = this._buffer; !J.$eq$(scanner._position, t2.get$length(t1));) {
          next = scanner.readChar$0();
          if (next !== 10) {
            t3.writeCharCode$1(next);
            continue;
          }
          t3.writeCharCode$1(32);
          while (true) {
            t4 = scanner.peekChar$0();
            if (!(t4 === 32 || t4 === 9 || t4 === 10 || t4 === 13 || t4 === 12))
              break;
            scanner.readChar$0();
          }
        }
      },
      _writeReindentedValue$1: function(node) {
        var value, minimumIndentation, t1;
        value = H.interceptedTypeCast(node.get$value().get$value(), "$isSassString").text;
        minimumIndentation = this._minimumIndentation$1(value);
        if (minimumIndentation == null) {
          this._buffer.write$1(0, value);
          return;
        } else if (minimumIndentation === -1) {
          t1 = this._buffer;
          t1.write$1(0, J.trimRight$0$s(value));
          t1.writeCharCode$1(32);
          return;
        }
        if (node.get$value().get$span() != null) {
          t1 = J.get$start$x(node.get$name().get$span());
          minimumIndentation = Math.min(minimumIndentation, H.checkNum(t1.file.getColumn$1(t1.offset)));
        }
        this._writeWithIndent$2(value, minimumIndentation);
      },
      _minimumIndentation$1: function(text) {
        var scanner, t1, character, t2, min, next, min0;
        scanner = new Z.LineScanner(0, 0, null, text, 0, null, null);
        t1 = J.getInterceptor$asx(text);
        while (true) {
          if (!J.$eq$(scanner._position, t1.get$length(text))) {
            character = scanner.super$StringScanner$readChar();
            scanner._adjustLineAndColumn$1(character);
            t2 = character !== 10;
          } else
            t2 = false;
          if (!t2)
            break;
        }
        if (J.$eq$(scanner._position, t1.get$length(text)))
          return scanner.peekChar$1(-1) === 10 ? -1 : null;
        for (min = null; !J.$eq$(scanner._position, t1.get$length(text));) {
          for (; !J.$eq$(scanner._position, t1.get$length(text));) {
            next = scanner.peekChar$0();
            if (next !== 32 && next !== 9)
              break;
            scanner._adjustLineAndColumn$1(scanner.super$StringScanner$readChar());
          }
          if (J.$eq$(scanner._position, t1.get$length(text)) || scanner.scanChar$1(10))
            continue;
          min0 = scanner._line_scanner$_column;
          min = min == null ? min0 : Math.min(min, min0);
          while (true) {
            if (!J.$eq$(scanner._position, t1.get$length(text))) {
              character = scanner.super$StringScanner$readChar();
              scanner._adjustLineAndColumn$1(character);
              t2 = character !== 10;
            } else
              t2 = false;
            if (!t2)
              break;
          }
        }
        return min == null ? -1 : min;
      },
      _writeWithIndent$2: function(text, minimumIndentation) {
        var scanner, t1, t2, character, lineStart, newlines, t3, end;
        scanner = new Z.LineScanner(0, 0, null, text, 0, null, null);
        for (t1 = J.getInterceptor$asx(text), t2 = this._buffer; !J.$eq$(scanner._position, t1.get$length(text));) {
          character = scanner.super$StringScanner$readChar();
          scanner._adjustLineAndColumn$1(character);
          if (character === 10)
            break;
          t2.writeCharCode$1(character);
        }
        for (; true;) {
          lineStart = scanner._position;
          for (newlines = 1; true;) {
            if (J.$eq$(scanner._position, t1.get$length(text))) {
              t2.writeCharCode$1(32);
              return;
            }
            character = scanner.super$StringScanner$readChar();
            scanner._adjustLineAndColumn$1(character);
            if (character === 32 || character === 9)
              continue;
            if (character !== 10)
              break;
            lineStart = scanner._position;
            ++newlines;
          }
          this._writeTimes$2(10, newlines);
          this._writeIndentation$0();
          t3 = J.$add$ansx(lineStart, minimumIndentation);
          end = scanner._position;
          t2.write$1(0, t1.substring$2(text, t3, end));
          for (; true;) {
            if (J.$eq$(scanner._position, t1.get$length(text)))
              return;
            character = scanner.super$StringScanner$readChar();
            scanner._adjustLineAndColumn$1(character);
            if (character === 10)
              break;
            t2.writeCharCode$1(character);
          }
        }
      },
      visitBoolean$1: function(value) {
        return this._buffer.write$1(0, String(value.value));
      },
      visitColor$1: function(value) {
        var t1, $name, hexLength, t2, t3;
        t1 = this._style === C.OutputStyle_compressed;
        if (t1 && J.$lt$n(J.abs$0$in(J.$sub$n(value.alpha, 1)), $.$get$epsilon())) {
          $name = $.$get$namesByColor().$index(0, value);
          hexLength = this._canUseShortHex$1(value) ? 4 : 7;
          if ($name != null && J.$le$n(J.get$length$asx($name), hexLength))
            this._buffer.write$1(0, $name);
          else {
            t1 = this._buffer;
            if (this._canUseShortHex$1(value)) {
              t1.writeCharCode$1(35);
              t2 = value.get$red();
              if (typeof t2 !== "number")
                return t2.$and();
              t1.writeCharCode$1(T.hexCharFor(t2 & 15));
              t2 = value.get$green();
              if (typeof t2 !== "number")
                return t2.$and();
              t1.writeCharCode$1(T.hexCharFor(t2 & 15));
              t2 = value.get$blue();
              if (typeof t2 !== "number")
                return t2.$and();
              t1.writeCharCode$1(T.hexCharFor(t2 & 15));
            } else {
              t1.writeCharCode$1(35);
              this._writeHexComponent$1(value.get$red());
              this._writeHexComponent$1(value.get$green());
              this._writeHexComponent$1(value.get$blue());
            }
          }
          return;
        }
        if (value.get$original() != null)
          this._buffer.write$1(0, value.get$original());
        else {
          t2 = $.$get$namesByColor();
          if (t2.containsKey$1(value) && !J.$lt$n(J.abs$0$in(J.$sub$n(value.alpha, 0)), $.$get$epsilon()))
            this._buffer.write$1(0, t2.$index(0, value));
          else {
            t2 = value.alpha;
            t3 = this._buffer;
            if (J.$lt$n(J.abs$0$in(J.$sub$n(t2, 1)), $.$get$epsilon())) {
              t3.writeCharCode$1(35);
              this._writeHexComponent$1(value.get$red());
              this._writeHexComponent$1(value.get$green());
              this._writeHexComponent$1(value.get$blue());
            } else {
              t3.write$1(0, "rgba(" + H.S(value.get$red()));
              t3.write$1(0, t1 ? "," : ", ");
              t3.write$1(0, value.get$green());
              t3.write$1(0, t1 ? "," : ", ");
              t3.write$1(0, value.get$blue());
              t3.write$1(0, t1 ? "," : ", ");
              this._writeNumber$1(t2);
              t3.writeCharCode$1(41);
            }
          }
        }
      },
      _canUseShortHex$1: function(color) {
        var t1 = color.get$red();
        if (typeof t1 !== "number")
          return t1.$and();
        if ((t1 & 15) === C.JSInt_methods._shrOtherPositive$1(t1, 4)) {
          t1 = color.get$green();
          if (typeof t1 !== "number")
            return t1.$and();
          if ((t1 & 15) === C.JSInt_methods._shrOtherPositive$1(t1, 4)) {
            t1 = color.get$blue();
            if (typeof t1 !== "number")
              return t1.$and();
            t1 = (t1 & 15) === C.JSInt_methods._shrOtherPositive$1(t1, 4);
          } else
            t1 = false;
        } else
          t1 = false;
        return t1;
      },
      _writeHexComponent$1: function(color) {
        var t1 = this._buffer;
        if (typeof color !== "number")
          return color.$shr();
        t1.writeCharCode$1(T.hexCharFor(C.JSInt_methods._shrOtherPositive$1(color, 4)));
        t1.writeCharCode$1(T.hexCharFor(color & 15));
      },
      visitFunction$1: function($function) {
        var t1;
        if (!this._inspect)
          throw H.wrapException(E.SassScriptException$($function.toString$0(0) + " isn't a valid CSS value."));
        t1 = this._buffer;
        t1.write$1(0, "get-function(");
        this._visitQuotedString$1($function.callable.get$name());
        t1.writeCharCode$1(41);
      },
      visitList$1: function(value) {
        var t1, t2, singleton, t3, t4;
        t1 = value.hasBrackets;
        if (t1)
          this._buffer.writeCharCode$1(91);
        else if (value._list$_contents.length === 0) {
          if (!this._inspect)
            throw H.wrapException(E.SassScriptException$("() isn't a valid CSS value"));
          this._buffer.write$1(0, "()");
          return;
        }
        t2 = this._inspect;
        singleton = t2 && value._list$_contents.length === 1 && value.separator === C.ListSeparator_kWM;
        if (singleton && !t1)
          this._buffer.writeCharCode$1(40);
        t3 = value._list$_contents;
        t3 = t2 ? t3 : new H.WhereIterable(t3, new N._SerializeVisitor_visitList_closure(), [H.getTypeArgumentByIndex(t3, 0)]);
        if (value.separator === C.ListSeparator_woc)
          t4 = " ";
        else
          t4 = this._style === C.OutputStyle_compressed ? "," : ", ";
        this._writeBetween$3(t3, t4, t2 ? new N._SerializeVisitor_visitList_closure0(this, value) : new N._SerializeVisitor_visitList_closure1(this));
        if (singleton) {
          t2 = this._buffer;
          t2.writeCharCode$1(44);
          if (!t1)
            t2.writeCharCode$1(41);
        }
        if (t1)
          this._buffer.writeCharCode$1(93);
      },
      _elementNeedsParens$2: function(separator, value) {
        var t1;
        if (value instanceof D.SassList) {
          if (value._list$_contents.length < 2)
            return false;
          if (value.hasBrackets)
            return false;
          t1 = value.separator;
          return separator === C.ListSeparator_kWM ? t1 === C.ListSeparator_kWM : t1 !== C.ListSeparator_undecided_null;
        }
        return false;
      },
      visitMap$1: function(map) {
        var t1;
        if (!this._inspect)
          throw H.wrapException(E.SassScriptException$(map.toString$0(0) + " isn't a valid CSS value."));
        t1 = this._buffer;
        t1.writeCharCode$1(40);
        this._writeBetween$3(map.contents.get$keys(), ", ", new N._SerializeVisitor_visitMap_closure(this, map));
        t1.writeCharCode$1(41);
      },
      _writeMapElement$1: function(value) {
        var needsParens = value instanceof D.SassList && value.separator === C.ListSeparator_kWM && !value.hasBrackets;
        if (needsParens)
          this._buffer.writeCharCode$1(40);
        value.accept$1(this);
        if (needsParens)
          this._buffer.writeCharCode$1(41);
      },
      visitNull$1: function(value) {
        if (this._inspect)
          this._buffer.write$1(0, "null");
      },
      visitNumber$1: function(value) {
        var t1, t2;
        t1 = value.asSlash;
        if (t1 != null) {
          this._buffer.write$1(0, t1);
          return;
        }
        if (this._style === C.OutputStyle_compressed)
          if (J.$lt$n(J.abs$0$in(J.$sub$n(value.value, 0)), $.$get$epsilon()))
            if (value.denominatorUnits.length === 0) {
              t1 = value.numeratorUnits;
              t1 = t1.length === 1 && $.$get$_compressibleUnits().contains$1(0, C.JSArray_methods.get$first(t1));
            } else
              t1 = false;
          else
            t1 = false;
        else
          t1 = false;
        if (t1) {
          this._buffer.writeCharCode$1(48);
          return;
        }
        this._writeNumber$1(value.value);
        if (!this._inspect) {
          t1 = value.numeratorUnits;
          t2 = t1.length;
          if (t2 > 1 || value.denominatorUnits.length !== 0)
            throw H.wrapException(E.SassScriptException$(value.toString$0(0) + " isn't a valid CSS value."));
          if (t2 !== 0)
            this._buffer.write$1(0, C.JSArray_methods.get$first(t1));
        } else
          this._buffer.write$1(0, value.get$unitString());
      },
      _writeNumber$1: function(number) {
        var integer, text;
        integer = T.fuzzyIsInt(number) ? J.round$0$n(number) : null;
        if (integer != null) {
          this._buffer.write$1(0, integer);
          return;
        }
        text = J.toString$0$(number);
        if (J.contains$1$asx(text, "e") === true)
          text = this._removeExponent$1(text);
        if (this._style === C.OutputStyle_compressed && J.codeUnitAt$1$s(text, 0) === 48)
          text = J.substring$1$s(text, 1);
        if (J.$lt$n(J.get$length$asx(text), 12)) {
          this._buffer.write$1(0, text);
          return;
        }
        this._writeDecimal$1(text);
      },
      _removeExponent$1: function(text) {
        var buffer, exponent, t1, i, t2, codeUnit, negative;
        buffer = new P.StringBuffer("");
        t1 = J.getInterceptor$asx(text);
        i = 0;
        while (true) {
          t2 = t1.get$length(text);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2)) {
            exponent = null;
            break;
          }
          codeUnit = t1.codeUnitAt$1(text, i);
          if (codeUnit === 101) {
            exponent = P.int_parse(t1.substring$2(text, i + 1, t1.get$length(text)), null, null);
            break;
          } else if (codeUnit !== 46)
            buffer._contents += H.Primitives_stringFromCharCode(codeUnit);
          ++i;
        }
        if (J.$gt$n(exponent, 0)) {
          if (typeof exponent !== "number")
            return H.iae(exponent);
          i = 0;
          for (; i < exponent; ++i)
            buffer._contents += H.Primitives_stringFromCharCode(48);
          t1 = buffer._contents;
          return t1.charCodeAt(0) == 0 ? t1 : t1;
        } else {
          negative = t1.codeUnitAt$1(text, 0) === 45;
          t1 = (negative ? H.Primitives_stringFromCharCode(45) : "") + "0.";
          if (typeof exponent !== "number")
            return H.iae(exponent);
          i = -1;
          for (; i > exponent; --i)
            t1 += H.Primitives_stringFromCharCode(48);
          if (negative) {
            t2 = buffer._contents;
            t2 = C.JSString_methods.substring$1(t2.charCodeAt(0) == 0 ? t2 : t2, 1);
          } else
            t2 = buffer;
          t2 = t1 + H.S(t2);
          return t2.charCodeAt(0) == 0 ? t2 : t2;
        }
      },
      _writeDecimal$1: function(text) {
        var t1, t2, textIndex, t3, codeUnit, digits, digitsIndex, t4, digitsIndex0, textIndex0, newDigit, i;
        t1 = J.getInterceptor$asx(text);
        t2 = this._buffer;
        textIndex = 0;
        while (true) {
          t3 = t1.get$length(text);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(textIndex < t3))
            break;
          codeUnit = t1.codeUnitAt$1(text, textIndex);
          t2.writeCharCode$1(codeUnit);
          if (codeUnit === 46) {
            ++textIndex;
            break;
          }
          ++textIndex;
        }
        if (textIndex === t1.get$length(text))
          return;
        digits = new Uint8Array(10);
        t3 = digits.length;
        digitsIndex = 0;
        while (true) {
          t4 = t1.get$length(text);
          if (typeof t4 !== "number")
            return H.iae(t4);
          if (!(textIndex < t4 && digitsIndex < t3))
            break;
          digitsIndex0 = digitsIndex + 1;
          textIndex0 = textIndex + 1;
          t4 = t1.codeUnitAt$1(text, textIndex);
          if (digitsIndex >= t3)
            return H.ioore(digits, digitsIndex);
          digits[digitsIndex] = t4 - 48;
          digitsIndex = digitsIndex0;
          textIndex = textIndex0;
        }
        if (textIndex !== t1.get$length(text) && t1.codeUnitAt$1(text, textIndex) - 48 >= 5)
          for (; digitsIndex >= 0; digitsIndex = digitsIndex0) {
            digitsIndex0 = digitsIndex - 1;
            if (digitsIndex0 < 0 || digitsIndex0 >= t3)
              return H.ioore(digits, digitsIndex0);
            newDigit = digits[digitsIndex0] + 1;
            digits[digitsIndex0] = newDigit;
            if (newDigit !== 10)
              break;
          }
        while (true) {
          if (digitsIndex >= 0) {
            t1 = digitsIndex - 1;
            if (t1 < 0 || t1 >= t3)
              return H.ioore(digits, t1);
            t1 = digits[t1] === 0;
          } else
            t1 = false;
          if (!t1)
            break;
          --digitsIndex;
        }
        for (i = 0; i < digitsIndex; ++i) {
          if (i >= t3)
            return H.ioore(digits, i);
          t2.writeCharCode$1(48 + digits[i]);
        }
      },
      visitString$1: function(string) {
        var t1, t2;
        t1 = this._quote && string.hasQuotes;
        t2 = string.text;
        if (t1)
          this._visitQuotedString$1(t2);
        else
          this._visitUnquotedString$1(t2);
      },
      _visitQuotedString$2$forceDoubleQuote: function(string, forceDoubleQuote) {
        var buffer, t1, includesSingleQuote, includesDoubleQuote, i, t2, char, next, quote;
        buffer = forceDoubleQuote ? this._buffer : new P.StringBuffer("");
        if (forceDoubleQuote)
          buffer.writeCharCode$1(34);
        t1 = J.getInterceptor$asx(string);
        includesSingleQuote = false;
        includesDoubleQuote = false;
        i = 0;
        while (true) {
          t2 = t1.get$length(string);
          if (typeof t2 !== "number")
            return H.iae(t2);
          if (!(i < t2))
            break;
          char = t1.codeUnitAt$1(string, i);
          switch (char) {
            case 39:
              if (forceDoubleQuote)
                buffer.writeCharCode$1(39);
              else {
                if (includesDoubleQuote) {
                  this._visitQuotedString$2$forceDoubleQuote(string, true);
                  return;
                } else
                  buffer.writeCharCode$1(39);
                includesSingleQuote = true;
              }
              break;
            case 34:
              if (forceDoubleQuote) {
                buffer.writeCharCode$1(92);
                buffer.writeCharCode$1(34);
              } else {
                if (includesSingleQuote) {
                  this._visitQuotedString$2$forceDoubleQuote(string, true);
                  return;
                } else
                  buffer.writeCharCode$1(34);
                includesDoubleQuote = true;
              }
              break;
            case 0:
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
            case 6:
            case 7:
            case 8:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
            case 17:
            case 18:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 30:
            case 31:
              buffer.writeCharCode$1(92);
              if (char > 15) {
                t2 = char >>> 4;
                buffer.writeCharCode$1(t2 < 10 ? 48 + t2 : 87 + t2);
              }
              t2 = char & 15;
              buffer.writeCharCode$1(t2 < 10 ? 48 + t2 : 87 + t2);
              t2 = i + 1;
              if (J.$eq$(t1.get$length(string), t2) === true)
                break;
              next = t1.codeUnitAt$1(string, t2);
              t2 = next >= 48 && next <= 57;
              if (!t2)
                if (!(next >= 97 && next <= 102))
                  t2 = next >= 65 && next <= 70;
                else
                  t2 = true;
              else
                t2 = true;
              if (t2 || next === 32 || next === 9)
                buffer.writeCharCode$1(32);
              break;
            case 92:
              buffer.writeCharCode$1(92);
              buffer.writeCharCode$1(92);
              break;
            default:
              buffer.writeCharCode$1(char);
              break;
          }
          ++i;
        }
        if (forceDoubleQuote)
          buffer.writeCharCode$1(34);
        else {
          quote = includesDoubleQuote ? 39 : 34;
          t1 = this._buffer;
          t1.writeCharCode$1(quote);
          t1.write$1(0, buffer);
          t1.writeCharCode$1(quote);
        }
      },
      _visitQuotedString$1: function(string) {
        return this._visitQuotedString$2$forceDoubleQuote(string, false);
      },
      _visitUnquotedString$1: function(string) {
        var t1, t2, afterNewline, i, t3, char;
        t1 = J.getInterceptor$asx(string);
        t2 = this._buffer;
        afterNewline = false;
        i = 0;
        while (true) {
          t3 = t1.get$length(string);
          if (typeof t3 !== "number")
            return H.iae(t3);
          if (!(i < t3))
            break;
          char = t1.codeUnitAt$1(string, i);
          switch (char) {
            case 10:
              t2.writeCharCode$1(32);
              afterNewline = true;
              break;
            case 32:
              if (!afterNewline)
                t2.writeCharCode$1(32);
              break;
            default:
              t2.writeCharCode$1(char);
              afterNewline = false;
              break;
          }
          ++i;
        }
      },
      visitAttributeSelector$1: function(attribute) {
        var t1, t2;
        t1 = this._buffer;
        t1.writeCharCode$1(91);
        t1.write$1(0, attribute.name);
        t2 = attribute.op;
        if (t2 != null) {
          t1.write$1(0, t2);
          t2 = attribute.value;
          if (this._isIdentifier$1(t2) === true)
            t1.write$1(0, t2);
          else
            this._visitQuotedString$1(t2);
        }
        t1.writeCharCode$1(93);
      },
      visitClassSelector$1: function(klass) {
        var t1 = this._buffer;
        t1.writeCharCode$1(46);
        t1.write$1(0, klass.name);
      },
      visitComplexSelector$1: function(complex) {
        this._writeBetween$3(complex.get$components(), " ", new N._SerializeVisitor_visitComplexSelector_closure(this));
      },
      visitCompoundSelector$1: function(compound) {
        var t1, start, t2, t3, _i;
        t1 = this._buffer;
        start = t1.get$length(t1);
        for (t2 = compound.components, t3 = t2.length, _i = 0; _i < t3; ++_i)
          t2[_i].accept$1(this);
        if (t1.get$length(t1) === start)
          t1.writeCharCode$1(42);
      },
      visitIDSelector$1: function(id) {
        var t1 = this._buffer;
        t1.writeCharCode$1(35);
        t1.write$1(0, id.name);
      },
      visitSelectorList$1: function(list) {
        var complexes, t1, t2, t3, t4, first, complex;
        if (this._inspect)
          complexes = list.components;
        else {
          t1 = list.components;
          complexes = new H.WhereIterable(t1, new N._SerializeVisitor_visitSelectorList_closure(), [H.getTypeArgumentByIndex(t1, 0)]);
        }
        for (t1 = J.get$iterator$ax(complexes), t2 = this._style !== C.OutputStyle_compressed, t3 = this._buffer, t4 = this._lineFeed.text, first = true; t1.moveNext$0();) {
          complex = t1.get$current(t1);
          if (first)
            first = false;
          else {
            t3.writeCharCode$1(44);
            if (complex.get$lineBreak()) {
              if (t2)
                t3.write$1(0, t4);
            } else if (t2)
              t3.writeCharCode$1(32);
          }
          this.visitComplexSelector$1(complex);
        }
      },
      visitParentSelector$1: function($parent) {
        var t1, t2;
        t1 = this._buffer;
        t1.writeCharCode$1(38);
        t2 = $parent.suffix;
        if (t2 != null)
          t1.write$1(0, t2);
      },
      visitPlaceholderSelector$1: function(placeholder) {
        var t1 = this._buffer;
        t1.writeCharCode$1(37);
        t1.write$1(0, placeholder.name);
      },
      visitPseudoSelector$1: function(pseudo) {
        var t1, t2, t3, t4, t5, t6;
        t1 = pseudo.selector;
        t2 = t1 == null;
        t3 = !t2;
        if (t3 && pseudo.name === "not" && t1.get$isInvisible())
          return;
        t4 = this._buffer;
        t4.writeCharCode$1(58);
        if (!pseudo.isClass)
          t4.writeCharCode$1(58);
        t4.write$1(0, pseudo.name);
        t5 = pseudo.argument;
        t6 = t5 == null;
        if (t6 && t2)
          return;
        t4.writeCharCode$1(40);
        if (!t6) {
          t4.write$1(0, t5);
          if (t3)
            t4.writeCharCode$1(32);
        }
        if (t3)
          this.visitSelectorList$1(t1);
        t4.writeCharCode$1(41);
      },
      visitTypeSelector$1: function(type) {
        this._buffer.write$1(0, type.name);
      },
      visitUniversalSelector$1: function(universal) {
        var t1, t2;
        t1 = universal.namespace;
        if (t1 != null) {
          t2 = this._buffer;
          t2.write$1(0, t1);
          t2.writeCharCode$1(124);
        }
        this._buffer.writeCharCode$1(42);
      },
      _write$1: function(value) {
        return this._buffer.forSpan$2(value.get$span(), new N._SerializeVisitor__write_closure(this, value));
      },
      _visitChildren$1: function(children) {
        var t1, t2, t3;
        t1 = {};
        t2 = this._buffer;
        t2.writeCharCode$1(123);
        if (J.every$1$ax(children, this.get$_isInvisible())) {
          t2.writeCharCode$1(125);
          return;
        }
        this._writeLineFeed$0();
        t1.previous = null;
        ++this._indentation;
        new N._SerializeVisitor__visitChildren_closure(t1, this, children).call$0();
        --this._indentation;
        t1 = t1.previous;
        t3 = J.getInterceptor(t1);
        if ((!!t3.$isCssParentNode ? t1.get$isChildless() : !t3.$isCssComment) && this._style !== C.OutputStyle_compressed)
          t2.writeCharCode$1(59);
        this._writeLineFeed$0();
        this._writeIndentation$0();
        t2.writeCharCode$1(125);
      },
      _writeLineFeed$0: function() {
        if (this._style !== C.OutputStyle_compressed)
          this._buffer.write$1(0, this._lineFeed.text);
      },
      _writeIndentation$0: function() {
        var t1, t2;
        if (this._style === C.OutputStyle_compressed)
          return;
        t1 = this._indentation;
        t2 = this._indentWidth;
        if (typeof t2 !== "number")
          return H.iae(t2);
        this._writeTimes$2(this._indentCharacter, t1 * t2);
      },
      _writeTimes$2: function(char, times) {
        var t1, i;
        for (t1 = this._buffer, i = 0; i < times; ++i)
          t1.writeCharCode$1(char);
      },
      _writeBetween$3: function(iterable, text, callback) {
        var t1, t2, first, value;
        for (t1 = J.get$iterator$ax(iterable), t2 = this._buffer, first = true; t1.moveNext$0();) {
          value = t1.get$current(t1);
          if (first)
            first = false;
          else
            t2.write$1(0, text);
          callback.call$1(value);
        }
      },
      _isInvisible$1: [function(node) {
        var t1;
        if (this._inspect)
          return false;
        if (this._style === C.OutputStyle_compressed && node instanceof R.CssComment && J.codeUnitAt$1$s(node.text, 2) !== 33)
          return true;
        t1 = J.getInterceptor(node);
        if (!!t1.$isCssParentNode) {
          if (!!t1.$isCssAtRule)
            return false;
          if (!!t1.$isCssStyleRule && node.selector.value.get$isInvisible() === true)
            return true;
          t1 = node.children;
          return t1.every$1(t1, this.get$_isInvisible());
        } else
          return false;
      }, "call$1", "get$_isInvisible", 4, 0, 34],
      _isIdentifier$1: function(text) {
        var scanner, t1, t2, first, next;
        scanner = X.StringScanner$(text, null, null);
        for (; scanner.scanChar$1(45);)
          ;
        t1 = scanner.string;
        t2 = J.getInterceptor$asx(t1);
        if (J.$eq$(scanner._position, t2.get$length(t1)))
          return false;
        first = scanner.readChar$0();
        if (first === 95 || T.isAlphabetic0(first) || first >= 128) {
          if (J.$eq$(scanner._position, t2.get$length(t1)))
            return true;
          scanner.readChar$0();
        } else if (first === 92) {
          if (!this._consumeEscape$1(scanner))
            return false;
        } else
          return false;
        for (; true;) {
          next = scanner.peekChar$0();
          if (next == null)
            return true;
          if (next !== 95) {
            if (!(next >= 97 && next <= 122))
              t1 = next >= 65 && next <= 90;
            else
              t1 = true;
            t1 = t1 || next >= 128;
          } else
            t1 = true;
          if (!t1) {
            t1 = next >= 48 && next <= 57;
            t1 = t1 || next === 45;
          } else
            t1 = true;
          if (t1)
            scanner.readChar$0();
          else if (next === 92) {
            if (!this._consumeEscape$1(scanner))
              return false;
          } else
            return false;
        }
      },
      _consumeEscape$1: function(scanner) {
        var first, i, next, t1;
        scanner.expectChar$1(92);
        first = scanner.peekChar$0();
        if (first == null || T.isNewline(first))
          return false;
        if (T.isHex(first)) {
          for (i = 0; i < 6; ++i) {
            next = scanner.peekChar$0();
            if (next != null) {
              t1 = next >= 48 && next <= 57;
              if (!t1)
                if (!(next >= 97 && next <= 102))
                  t1 = next >= 65 && next <= 70;
                else
                  t1 = true;
              else
                t1 = true;
              t1 = !t1;
            } else
              t1 = true;
            if (t1)
              break;
            scanner.readChar$0();
          }
          t1 = scanner.peekChar$0();
          if (t1 === 32 || t1 === 9 || T.isNewline(t1))
            scanner.readChar$0();
        } else {
          if (J.$eq$(scanner._position, J.get$length$asx(scanner.string)))
            return false;
          scanner.readChar$0();
        }
        return true;
      },
      static: {
        _SerializeVisitor$: function(indentWidth, inspect, lineFeed, quote, sourceMap, style, useSpaces) {
          var t1, t2, t3, t4;
          t1 = sourceMap === true ? new D.SourceMapBuffer(new P.StringBuffer(""), H.setRuntimeTypeInfo([], [L.Entry]), P.LinkedHashMap_LinkedHashMap$_empty(P.Uri, Y.SourceFile), 0, 0, false) : new N.NoSourceMapBuffer(new P.StringBuffer(""));
          t2 = style == null ? C.OutputStyle_expanded : style;
          t3 = useSpaces ? 32 : 9;
          t4 = indentWidth == null ? 2 : indentWidth;
          t1 = new N._SerializeVisitor(t1, 0, t2, inspect, quote, t3, t4, lineFeed == null ? C.LineFeed_D6m : lineFeed);
          t1._SerializeVisitor$7$indentWidth$inspect$lineFeed$quote$sourceMap$style$useSpaces(indentWidth, inspect, lineFeed, quote, sourceMap, style, useSpaces);
          return t1;
        }
      }
    },
    _SerializeVisitor_visitComment_closure: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        var t1, t2, t3, minimumIndentation;
        t1 = this.$this;
        if (t1._style === C.OutputStyle_compressed && J.codeUnitAt$1$s(this.node.text, 2) !== 33)
          return;
        t2 = this.node;
        t3 = t2.text;
        minimumIndentation = t1._minimumIndentation$1(t3);
        if (minimumIndentation == null) {
          t1._writeIndentation$0();
          t1._buffer.write$1(0, t3);
          return;
        }
        t2 = t2.span;
        if (t2 != null) {
          t2 = Y.FileLocation$_(t2.file, t2._file$_start);
          minimumIndentation = Math.min(minimumIndentation, H.checkNum(t2.file.getColumn$1(t2.offset)));
        }
        t1._writeIndentation$0();
        t1._writeWithIndent$2(t3, minimumIndentation);
      }
    },
    _SerializeVisitor_visitAtRule_closure: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        var t1, t2, t3;
        t1 = this.$this;
        t2 = t1._buffer;
        t2.writeCharCode$1(64);
        t3 = this.node;
        t2.write$1(0, t3.get$name());
        if (t3.get$value() != null) {
          t2.writeCharCode$1(32);
          t1._write$1(t3.get$value());
        }
      }
    },
    _SerializeVisitor_visitMediaRule_closure: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        var t1, t2, t3;
        t1 = this.$this;
        t2 = t1._buffer;
        t2.write$1(0, "@media");
        t3 = t1._style === C.OutputStyle_compressed;
        if (!t3 || !C.JSArray_methods.get$first(this.node.get$queries()).get$isCondition())
          t2.writeCharCode$1(32);
        t2 = this.node.get$queries();
        t3 = t3 ? "," : ", ";
        t1._writeBetween$3(t2, t3, t1.get$_visitMediaQuery());
      }
    },
    _SerializeVisitor_visitImport_closure: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        var t1, t2, t3, t4, t5, t6;
        t1 = this.$this;
        t2 = t1._buffer;
        t2.write$1(0, "@import");
        t3 = t1._style === C.OutputStyle_compressed;
        t4 = !t3;
        if (t4)
          t2.writeCharCode$1(32);
        t5 = this.node;
        t2.forSpan$2(t5.url.get$span(), new N._SerializeVisitor_visitImport__closure(t1, t5));
        t6 = t5.supports;
        if (t6 != null) {
          if (t4)
            t2.writeCharCode$1(32);
          t1._write$1(t6);
        }
        t5 = t5.media;
        if (t5 != null) {
          if (t4)
            t2.writeCharCode$1(32);
          t2 = t3 ? "," : ", ";
          t1._writeBetween$3(t5, t2, t1.get$_visitMediaQuery());
        }
      }
    },
    _SerializeVisitor_visitImport__closure: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        return this.$this._writeImportUrl$1(this.node.url.get$value());
      }
    },
    _SerializeVisitor_visitKeyframeBlock_closure: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        var t1, t2, t3, t4;
        t1 = this.$this;
        t2 = this.node.selector.value;
        t3 = t1._style === C.OutputStyle_compressed ? "," : ", ";
        t4 = t1._buffer;
        return t1._writeBetween$3(t2, t3, t4.get$write(t4));
      }
    },
    _SerializeVisitor_visitStyleRule_closure: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        return this.node.get$selector().get$value().accept$1(this.$this);
      }
    },
    _SerializeVisitor_visitSupportsRule_closure: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        var t1, t2;
        t1 = this.$this;
        t2 = t1._buffer;
        t2.write$1(0, "@supports");
        if (!(t1._style === C.OutputStyle_compressed && J.codeUnitAt$1$s(this.node.get$condition().get$value(), 0) === 40))
          t2.writeCharCode$1(32);
        t1._write$1(this.node.get$condition());
      }
    },
    _SerializeVisitor_visitDeclaration_closure: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        var t1, t2;
        t1 = this.$this;
        t2 = this.node;
        if (t1._style === C.OutputStyle_compressed)
          t1._writeFoldedValue$1(t2);
        else
          t1._writeReindentedValue$1(t2);
      }
    },
    _SerializeVisitor_visitDeclaration_closure0: {
      "^": "Closure:1;$this,node",
      call$0: function() {
        return this.node.get$value().get$value().accept$1(this.$this);
      }
    },
    _SerializeVisitor_visitList_closure: {
      "^": "Closure:0;",
      call$1: function(element) {
        return !element.get$isBlank();
      }
    },
    _SerializeVisitor_visitList_closure0: {
      "^": "Closure:0;$this,value",
      call$1: function(element) {
        var t1, needsParens;
        t1 = this.$this;
        needsParens = t1._elementNeedsParens$2(this.value.separator, element);
        if (needsParens)
          t1._buffer.writeCharCode$1(40);
        element.accept$1(t1);
        if (needsParens)
          t1._buffer.writeCharCode$1(41);
      }
    },
    _SerializeVisitor_visitList_closure1: {
      "^": "Closure:0;$this",
      call$1: function(element) {
        element.accept$1(this.$this);
      }
    },
    _SerializeVisitor_visitMap_closure: {
      "^": "Closure:0;$this,map",
      call$1: function(key) {
        var t1 = this.$this;
        t1._writeMapElement$1(key);
        t1._buffer.write$1(0, ": ");
        t1._writeMapElement$1(this.map.contents.$index(0, key));
      }
    },
    _SerializeVisitor_visitComplexSelector_closure: {
      "^": "Closure:0;$this",
      call$1: function(component) {
        var t1 = this.$this;
        if (component instanceof X.CompoundSelector)
          t1.visitCompoundSelector$1(component);
        else
          t1._buffer.write$1(0, component);
      }
    },
    _SerializeVisitor_visitSelectorList_closure: {
      "^": "Closure:0;",
      call$1: function(complex) {
        return complex.get$isInvisible() !== true;
      }
    },
    _SerializeVisitor__write_closure: {
      "^": "Closure:1;$this,value",
      call$0: function() {
        return this.$this._buffer.write$1(0, this.value.get$value());
      }
    },
    _SerializeVisitor__visitChildren_closure: {
      "^": "Closure:1;_box_0,$this,children",
      call$0: function() {
        var t1, t2, t3, t4, t5, t6, i, t7, child, t8;
        t1 = this.children;
        t2 = J.getInterceptor$asx(t1);
        t3 = this._box_0;
        t4 = this.$this;
        t5 = t4._buffer;
        t6 = t4._lineFeed.text;
        i = 0;
        while (true) {
          t7 = t2.get$length(t1);
          if (typeof t7 !== "number")
            return H.iae(t7);
          if (!(i < t7))
            break;
          c$0: {
            child = t2.$index(t1, i);
            if (t4._isInvisible$1(child))
              break c$0;
            t7 = t3.previous;
            if (t7 != null) {
              t8 = J.getInterceptor(t7);
              if (!!t8.$isCssParentNode ? t7.get$isChildless() : !t8.$isCssComment)
                t5.writeCharCode$1(59);
              t7 = t4._style !== C.OutputStyle_compressed;
              if (t7)
                t5.write$1(0, t6);
              if (t3.previous.get$isGroupEnd())
                if (t7)
                  t5.write$1(0, t6);
            }
            t3.previous = child;
            child.accept$1(t4);
          }
          ++i;
        }
      }
    },
    OutputStyle: {
      "^": "Object;_name",
      toString$0: function(_) {
        return this._name;
      }
    },
    LineFeed: {
      "^": "Object;name<,text<",
      toString$0: function(_) {
        return this.name;
      }
    },
    SerializeResult: {
      "^": "Object;css>,sourceMap>,sourceFiles"
    }
  }], ["source_maps.builder", "package:source_maps/builder.dart",, L, {
    "^": "",
    Entry: {
      "^": "Object;source<,target<,identifierName<",
      compareTo$1: function(_, other) {
        var res, t1;
        res = this.target.compareTo$1(0, other.get$target());
        if (res !== 0)
          return res;
        t1 = this.source;
        res = J.compareTo$1$ns(J.toString$0$(t1.get$sourceUrl()), J.toString$0$(other.get$source().get$sourceUrl()));
        if (!J.$eq$(res, 0))
          return res;
        return J.compareTo$1$ns(t1, other.get$source());
      }
    }
  }], ["source_maps.parser", "package:source_maps/parser.dart",, T, {
    "^": "",
    Mapping: {
      "^": "Object;"
    },
    SingleMapping: {
      "^": "Mapping;urls<,names,files,lines,targetUrl?,sourceRoot?,_mapUrl",
      toJson$1$includeSourceContents: function(includeSourceContents) {
        var buff, t1, t2, line, column, srcLine, srcColumn, srcUrlId, srcNameId, first, _i, entry, nextLine, i, t3, segment, column0, t4, newUrlId, srcLine0, srcColumn0, srcNameId0, result;
        buff = new P.StringBuffer("");
        for (t1 = this.lines, t2 = t1.length, line = 0, column = 0, srcLine = 0, srcColumn = 0, srcUrlId = 0, srcNameId = 0, first = true, _i = 0; _i < t1.length; t1.length === t2 || (0, H.throwConcurrentModificationError)(t1), ++_i) {
          entry = t1[_i];
          nextLine = entry.line;
          if (J.$gt$n(nextLine, line)) {
            for (i = line; t3 = J.getInterceptor$n(i), t3.$lt(i, nextLine); i = t3.$add(i, 1))
              buff._contents += ";";
            line = nextLine;
            column = 0;
            first = true;
          }
          for (t3 = C.JSArray_methods.get$iterator(entry.entries); t3.moveNext$0(); column = column0, first = false) {
            segment = t3.get$current(t3);
            if (!first)
              buff._contents += ",";
            column0 = segment.get$column();
            t4 = L.encodeVlq(J.$sub$n(column0, column));
            t4 = P.StringBuffer__writeAll(buff._contents, t4, "");
            buff._contents = t4;
            newUrlId = segment.get$sourceUrlId();
            if (newUrlId == null)
              continue;
            t4 = P.StringBuffer__writeAll(t4, L.encodeVlq(J.$sub$n(newUrlId, srcUrlId)), "");
            buff._contents = t4;
            srcLine0 = segment.get$sourceLine();
            t4 = P.StringBuffer__writeAll(t4, L.encodeVlq(J.$sub$n(srcLine0, srcLine)), "");
            buff._contents = t4;
            srcColumn0 = segment.get$sourceColumn();
            t4 = P.StringBuffer__writeAll(t4, L.encodeVlq(J.$sub$n(srcColumn0, srcColumn)), "");
            buff._contents = t4;
            if (segment.get$sourceNameId() == null) {
              srcUrlId = newUrlId;
              srcColumn = srcColumn0;
              srcLine = srcLine0;
              continue;
            }
            srcNameId0 = segment.get$sourceNameId();
            buff._contents = P.StringBuffer__writeAll(t4, L.encodeVlq(J.$sub$n(srcNameId0, srcNameId)), "");
            srcNameId = srcNameId0;
            srcUrlId = newUrlId;
            srcColumn = srcColumn0;
            srcLine = srcLine0;
          }
        }
        t1 = this.sourceRoot;
        if (t1 == null)
          t1 = "";
        t2 = buff._contents;
        result = P.LinkedHashMap__makeLiteral(["version", 3, "sourceRoot", t1, "sources", this.urls, "names", this.names, "mappings", t2.charCodeAt(0) == 0 ? t2 : t2]);
        t1 = this.targetUrl;
        if (t1 != null)
          result.$indexSet(0, "file", t1);
        if (includeSourceContents === true) {
          t1 = this.files;
          result.$indexSet(0, "sourcesContent", new H.MappedListIterable(t1, new T.SingleMapping_toJson_closure(), [H.getTypeArgumentByIndex(t1, 0), null]).toList$0(0));
        }
        return result;
      },
      toJson$0: function() {
        return this.toJson$1$includeSourceContents(false);
      },
      toString$0: function(_) {
        var t1 = H.S(new H.TypeImpl(H.getRuntimeTypeString(this), null));
        t1 + " : [";
        t1 = t1 + " : [targetUrl: " + H.S(this.targetUrl) + ", sourceRoot: " + H.S(this.sourceRoot) + ", urls: " + H.S(this.urls) + ", names: " + H.S(this.names) + ", lines: " + H.S(this.lines) + "]";
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      },
      static: {
        SingleMapping_SingleMapping$fromEntries: function(entries, fileUrl) {
          var sourceEntries, lines, t1, t2, urls, files, t3, t4, lineNum, targetEntries, _i, sourceEntry, sourceUrl, t5, urlId;
          sourceEntries = P.List_List$from(entries, true, null);
          C.JSArray_methods.sort$0(sourceEntries);
          lines = H.setRuntimeTypeInfo([], [T.TargetLineEntry]);
          t1 = P.String;
          t2 = P.int;
          urls = P.LinkedHashMap_LinkedHashMap$_empty(t1, t2);
          files = P.LinkedHashMap_LinkedHashMap$_empty(t2, Y.SourceFile);
          for (t3 = sourceEntries.length, t4 = [T.TargetEntry], lineNum = null, targetEntries = null, _i = 0; _i < sourceEntries.length; sourceEntries.length === t3 || (0, H.throwConcurrentModificationError)(sourceEntries), ++_i) {
            sourceEntry = sourceEntries[_i];
            if (lineNum == null || J.$gt$n(sourceEntry.get$target().get$line(), lineNum)) {
              lineNum = sourceEntry.get$target().get$line();
              targetEntries = H.setRuntimeTypeInfo([], t4);
              lines.push(new T.TargetLineEntry(lineNum, targetEntries));
            }
            if (sourceEntry.get$source() == null)
              targetEntries.push(new T.TargetEntry(sourceEntry.get$target().get$column(), null, null, null, null));
            else {
              sourceUrl = sourceEntry.get$source().get$sourceUrl();
              t5 = sourceUrl == null ? "" : J.toString$0$(sourceUrl);
              urlId = urls.putIfAbsent$2(t5, new T.SingleMapping_SingleMapping$fromEntries_closure(urls));
              if (sourceEntry.get$source() instanceof Y.FileLocation)
                files.putIfAbsent$2(urlId, new T.SingleMapping_SingleMapping$fromEntries_closure0(sourceEntry));
              sourceEntry.get$identifierName();
              targetEntries.push(new T.TargetEntry(sourceEntry.get$target().get$column(), urlId, sourceEntry.get$source().get$line(), sourceEntry.get$source().get$column(), null));
            }
          }
          t3 = urls.get$values();
          t3 = H.MappedIterable_MappedIterable(t3, new T.SingleMapping_SingleMapping$fromEntries_closure1(files), H.getRuntimeTypeArgument(t3, "Iterable", 0), null);
          t3 = P.List_List$from(t3, true, H.getRuntimeTypeArgument(t3, "Iterable", 0));
          t4 = urls.get$keys();
          t4 = P.List_List$from(t4, true, H.getRuntimeTypeArgument(t4, "Iterable", 0));
          t2 = P.LinkedHashMap_LinkedHashMap$_empty(t1, t2).get$keys();
          return new T.SingleMapping(t4, P.List_List$from(t2, true, H.getRuntimeTypeArgument(t2, "Iterable", 0)), t3, lines, fileUrl, null, null);
        }
      }
    },
    SingleMapping_SingleMapping$fromEntries_closure: {
      "^": "Closure:1;urls",
      call$0: function() {
        var t1 = this.urls;
        return t1.get$length(t1);
      }
    },
    SingleMapping_SingleMapping$fromEntries_closure0: {
      "^": "Closure:1;sourceEntry",
      call$0: function() {
        return H.interceptedTypeCast(this.sourceEntry.get$source(), "$isFileLocation").file;
      }
    },
    SingleMapping_SingleMapping$fromEntries_closure1: {
      "^": "Closure:0;files",
      call$1: [function(i) {
        return this.files.$index(0, i);
      }, null, null, 4, 0, null, 40, "call"]
    },
    SingleMapping_toJson_closure: {
      "^": "Closure:0;",
      call$1: [function(file) {
        return file == null ? null : file.getText$1(0);
      }, null, null, 4, 0, null, 75, "call"]
    },
    TargetLineEntry: {
      "^": "Object;line<,entries",
      toString$0: function(_) {
        return H.S(new H.TypeImpl(H.getRuntimeTypeString(this), null)) + ": " + H.S(this.line) + " " + H.S(this.entries);
      }
    },
    TargetEntry: {
      "^": "Object;column<,sourceUrlId<,sourceLine<,sourceColumn<,sourceNameId<",
      toString$0: function(_) {
        return H.S(new H.TypeImpl(H.getRuntimeTypeString(this), null)) + ": (" + H.S(this.column) + ", " + H.S(this.sourceUrlId) + ", " + H.S(this.sourceLine) + ", " + H.S(this.sourceColumn) + ", " + H.S(this.sourceNameId) + ")";
      }
    }
  }], ["source_maps.src.vlq", "package:source_maps/src/vlq.dart",, L, {
    "^": "",
    encodeVlq: function(value) {
      var t1, res, signBit, digit;
      t1 = J.getInterceptor$in(value);
      if (t1.$lt(value, $.$get$MIN_INT32()) || t1.$gt(value, $.$get$MAX_INT32()))
        throw H.wrapException(P.ArgumentError$("expected 32 bit int, got: " + H.S(value)));
      res = H.setRuntimeTypeInfo([], [P.String]);
      if (t1.$lt(value, 0)) {
        value = t1.$negate(value);
        signBit = 1;
      } else
        signBit = 0;
      value = J.$shl$n(value, 1) | signBit;
      do {
        digit = value & 31;
        value = value >>> 5;
        t1 = value > 0;
        if (t1)
          digit |= 32;
        if (digit >= 64)
          return H.ioore("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", digit);
        res.push("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[digit]);
      } while (t1);
      return res;
    }
  }], ["", "package:source_span/src/file.dart",, Y, {
    "^": "",
    SourceFile: {
      "^": "Object;url<,_lineStarts,_decodedChars,_cachedLine",
      get$length: function(_) {
        return this._decodedChars.length;
      },
      get$lines: function() {
        return this._lineStarts.length;
      },
      SourceFile$decoded$2$url: function(decodedChars, url) {
        var t1, t2, t3, i, c, j, t4;
        for (t1 = this._decodedChars, t2 = t1.length, t3 = this._lineStarts, i = 0; i < t2; ++i) {
          c = t1[i];
          if (c === 13) {
            j = i + 1;
            if (j < t2) {
              if (j >= t2)
                return H.ioore(t1, j);
              t4 = t1[j] !== 10;
            } else
              t4 = true;
            if (t4)
              c = 10;
          }
          if (c === 10)
            t3.push(i + 1);
        }
      },
      span$2: [function(start, end) {
        return Y._FileSpan$(this, start, end == null ? this._decodedChars.length - 1 : end);
      }, function(start) {
        return this.span$2(start, null);
      }, "span$1", "call$2", "call$1", "get$span", 4, 2, 81, 2, 76, 77],
      location$1: [function(offset) {
        return Y.FileLocation$_(this, offset);
      }, "call$1", "get$location", 4, 0, 82],
      getLine$1: function(offset) {
        var t1, t2;
        t1 = J.getInterceptor$n(offset);
        if (t1.$lt(offset, 0))
          throw H.wrapException(P.RangeError$("Offset may not be negative, was " + H.S(offset) + "."));
        else if (t1.$gt(offset, this._decodedChars.length))
          throw H.wrapException(P.RangeError$("Offset " + H.S(offset) + " must not be greater than the number of characters in the file, " + this.get$length(this) + "."));
        t2 = this._lineStarts;
        if (t1.$lt(offset, C.JSArray_methods.get$first(t2)))
          return -1;
        if (t1.$ge(offset, C.JSArray_methods.get$last(t2)))
          return t2.length - 1;
        if (this._isNearCachedLine$1(offset))
          return this._cachedLine;
        t1 = this._binarySearch$1(offset) - 1;
        this._cachedLine = t1;
        return t1;
      },
      _isNearCachedLine$1: function(offset) {
        var t1, t2, t3, t4;
        t1 = this._cachedLine;
        if (t1 == null)
          return false;
        t2 = this._lineStarts;
        if (t1 >>> 0 !== t1 || t1 >= t2.length)
          return H.ioore(t2, t1);
        t3 = J.getInterceptor$n(offset);
        if (t3.$lt(offset, t2[t1]))
          return false;
        t1 = this._cachedLine;
        t4 = t2.length;
        if (typeof t1 !== "number")
          return t1.$ge();
        if (t1 < t4 - 1) {
          ++t1;
          if (t1 < 0 || t1 >= t4)
            return H.ioore(t2, t1);
          t1 = t3.$lt(offset, t2[t1]);
        } else
          t1 = true;
        if (t1)
          return true;
        t1 = this._cachedLine;
        t4 = t2.length;
        if (typeof t1 !== "number")
          return t1.$ge();
        if (t1 < t4 - 2) {
          t1 += 2;
          if (t1 < 0 || t1 >= t4)
            return H.ioore(t2, t1);
          t1 = t3.$lt(offset, t2[t1]);
        } else
          t1 = true;
        if (t1) {
          t1 = this._cachedLine;
          if (typeof t1 !== "number")
            return t1.$add();
          this._cachedLine = t1 + 1;
          return true;
        }
        return false;
      },
      _binarySearch$1: function(offset) {
        var t1, t2, max, min, half, t3;
        t1 = this._lineStarts;
        t2 = t1.length;
        max = t2 - 1;
        for (min = 0; min < max;) {
          half = min + C.JSInt_methods._tdivFast$1(max - min, 2);
          if (half < 0 || half >= t2)
            return H.ioore(t1, half);
          t3 = t1[half];
          if (typeof offset !== "number")
            return H.iae(offset);
          if (t3 > offset)
            max = half;
          else
            min = half + 1;
        }
        return max;
      },
      getColumn$2$line: function(offset, line) {
        var t1, lineStart;
        t1 = J.getInterceptor$n(offset);
        if (t1.$lt(offset, 0))
          throw H.wrapException(P.RangeError$("Offset may not be negative, was " + H.S(offset) + "."));
        else if (t1.$gt(offset, this._decodedChars.length))
          throw H.wrapException(P.RangeError$("Offset " + H.S(offset) + " must be not be greater than the number of characters in the file, " + this.get$length(this) + "."));
        line = this.getLine$1(offset);
        t1 = this._lineStarts;
        if (line >>> 0 !== line || line >= t1.length)
          return H.ioore(t1, line);
        lineStart = t1[line];
        if (typeof offset !== "number")
          return H.iae(offset);
        if (lineStart > offset)
          throw H.wrapException(P.RangeError$("Line " + line + " comes after offset " + H.S(offset) + "."));
        return offset - lineStart;
      },
      getColumn$1: function(offset) {
        return this.getColumn$2$line(offset, null);
      },
      getOffset$2: function(line, column) {
        var t1, t2, result, t3;
        if (typeof line !== "number")
          return line.$lt();
        if (line < 0)
          throw H.wrapException(P.RangeError$("Line may not be negative, was " + line + "."));
        else {
          t1 = this._lineStarts;
          t2 = t1.length;
          if (line >= t2)
            throw H.wrapException(P.RangeError$("Line " + line + " must be less than the number of lines in the file, " + this.get$lines() + "."));
        }
        result = t1[line];
        if (result <= this._decodedChars.length) {
          t3 = line + 1;
          t1 = t3 < t2 && result >= t1[t3];
        } else
          t1 = true;
        if (t1)
          throw H.wrapException(P.RangeError$("Line " + line + " doesn't have 0 columns."));
        return result;
      },
      getOffset$1: function(line) {
        return this.getOffset$2(line, null);
      },
      getText$2: function(start, end) {
        return P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(this._decodedChars, start, end), 0, null);
      },
      getText$1: function(start) {
        return this.getText$2(start, null);
      }
    },
    FileLocation: {
      "^": "SourceLocationMixin;file>,offset<",
      get$sourceUrl: function() {
        return this.file.url;
      },
      get$line: function() {
        return this.file.getLine$1(this.offset);
      },
      get$column: function() {
        return this.file.getColumn$1(this.offset);
      },
      FileLocation$_$2: function(file, offset) {
        var t1, t2, t3;
        t1 = this.offset;
        t2 = J.getInterceptor$n(t1);
        if (t2.$lt(t1, 0))
          throw H.wrapException(P.RangeError$("Offset may not be negative, was " + H.S(t1) + "."));
        else {
          t3 = this.file;
          if (t2.$gt(t1, t3._decodedChars.length))
            throw H.wrapException(P.RangeError$("Offset " + H.S(t1) + " must not be greater than the number of characters in the file, " + t3.get$length(t3) + "."));
        }
      },
      pointSpan$0: function() {
        var t1 = this.offset;
        return Y._FileSpan$(this.file, t1, t1);
      },
      static: {
        FileLocation$_: function(file, offset) {
          var t1 = new Y.FileLocation(file, offset);
          t1.FileLocation$_$2(file, offset);
          return t1;
        }
      }
    },
    FileSpan: {
      "^": "Object;",
      $isSourceSpan: 1,
      $isSourceSpanWithContext: 1
    },
    _FileSpan: {
      "^": "SourceSpanMixin;file>,_file$_start<,_end<",
      get$sourceUrl: function() {
        return this.file.url;
      },
      get$length: function(_) {
        return J.$sub$n(this._end, this._file$_start);
      },
      get$start: function(_) {
        return Y.FileLocation$_(this.file, this._file$_start);
      },
      get$end: function(_) {
        return Y.FileLocation$_(this.file, this._end);
      },
      get$text: function() {
        return P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(this.file._decodedChars, this._file$_start, this._end), 0, null);
      },
      _FileSpan$3: function(file, _start, _end) {
        var t1, t2, t3, t4;
        t1 = this._end;
        t2 = this._file$_start;
        t3 = J.getInterceptor$n(t1);
        if (t3.$lt(t1, t2))
          throw H.wrapException(P.ArgumentError$("End " + H.S(t1) + " must come after start " + H.S(t2) + "."));
        else {
          t4 = this.file;
          if (t3.$gt(t1, t4._decodedChars.length))
            throw H.wrapException(P.RangeError$("End " + H.S(t1) + " must not be greater than the number of characters in the file, " + t4.get$length(t4) + "."));
          else if (J.$lt$n(t2, 0))
            throw H.wrapException(P.RangeError$("Start may not be negative, was " + H.S(t2) + "."));
        }
      },
      compareTo$1: function(_, other) {
        var result;
        if (!(other instanceof Y._FileSpan))
          return this.super$SourceSpanMixin$compareTo(0, other);
        result = J.compareTo$1$ns(this._file$_start, other._file$_start);
        return J.$eq$(result, 0) ? J.compareTo$1$ns(this._end, other._end) : result;
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        if (!J.getInterceptor(other).$isFileSpan)
          return this.super$SourceSpanMixin$$eq(0, other);
        return J.$eq$(this._file$_start, other._file$_start) === true && J.$eq$(this._end, other._end) === true && J.$eq$(this.file.url, other.file.url) === true;
      },
      get$hashCode: function(_) {
        return Y.SourceSpanMixin.prototype.get$hashCode.call(this, this);
      },
      expand$1: function(_, other) {
        var t1, t2, t3, t4, start, t5;
        t1 = this.file;
        if (J.$eq$(t1.url, other.get$sourceUrl()) !== true)
          throw H.wrapException(P.ArgumentError$('Source URLs "' + H.S(this.get$sourceUrl()) + '" and  "' + H.S(other.get$sourceUrl()) + "\" don't match."));
        t2 = J.getInterceptor(other);
        t3 = this._file$_start;
        t4 = this._end;
        if (!!t2.$is_FileSpan) {
          t2 = other._file$_start;
          start = Math.min(H.checkNum(t3), H.checkNum(t2));
          t2 = other._end;
          return Y._FileSpan$(t1, start, Math.max(H.checkNum(t4), H.checkNum(t2)));
        } else {
          t5 = t2.get$start(other);
          start = Math.min(H.checkNum(t3), H.checkNum(t5.offset));
          t2 = t2.get$end(other);
          return Y._FileSpan$(t1, start, Math.max(H.checkNum(t4), H.checkNum(t2.offset)));
        }
      },
      $isFileSpan: 1,
      $isSourceSpanWithContext: 1,
      static: {
        _FileSpan$: function(file, _start, _end) {
          var t1 = new Y._FileSpan(file, _start, _end);
          t1._FileSpan$3(file, _start, _end);
          return t1;
        }
      }
    }
  }], ["", "package:source_span/src/location.dart",, V, {
    "^": "",
    SourceLocation: {
      "^": "Object;sourceUrl<,offset<,line<,column<",
      compareTo$1: function(_, other) {
        var t1 = this.sourceUrl;
        if (J.$eq$(t1, other.get$sourceUrl()) !== true)
          throw H.wrapException(P.ArgumentError$('Source URLs "' + H.S(t1) + '" and "' + H.S(other.get$sourceUrl()) + "\" don't match."));
        t1 = other.get$offset();
        if (typeof t1 !== "number")
          return H.iae(t1);
        return this.offset - t1;
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        return !!J.getInterceptor(other).$isSourceLocation && J.$eq$(this.sourceUrl, other.get$sourceUrl()) === true && this.offset === other.get$offset();
      },
      get$hashCode: function(_) {
        return J.get$hashCode$(this.sourceUrl) + this.offset;
      },
      toString$0: function(_) {
        var t1, source;
        t1 = "<" + H.S(new H.TypeImpl(H.getRuntimeTypeString(this), null)) + ": " + this.offset + " ";
        source = this.sourceUrl;
        return t1 + (H.S(source == null ? "unknown source" : source) + ":" + (this.line + 1) + ":" + (this.column + 1)) + ">";
      }
    }
  }], ["", "package:source_span/src/location_mixin.dart",, D, {
    "^": "",
    SourceLocationMixin: {
      "^": "Object;",
      compareTo$1: function(_, other) {
        if (J.$eq$(this.file.url, other.get$sourceUrl()) !== true)
          throw H.wrapException(P.ArgumentError$('Source URLs "' + H.S(this.get$sourceUrl()) + '" and "' + H.S(other.get$sourceUrl()) + "\" don't match."));
        return J.$sub$n(this.offset, other.get$offset());
      },
      $eq: function(_, other) {
        if (other == null)
          return false;
        return !!J.getInterceptor(other).$isSourceLocation && J.$eq$(this.file.url, other.get$sourceUrl()) === true && J.$eq$(this.offset, other.get$offset()) === true;
      },
      get$hashCode: function(_) {
        var t1, t2;
        t1 = J.get$hashCode$(this.file.url);
        t2 = this.offset;
        if (typeof t2 !== "number")
          return H.iae(t2);
        return t1 + t2;
      },
      toString$0: function(_) {
        var t1, t2, t3, source, t4, t5;
        t1 = this.offset;
        t2 = "<" + H.S(new H.TypeImpl(H.getRuntimeTypeString(this), null)) + ": " + H.S(t1) + " ";
        t3 = this.file;
        source = t3.url;
        t4 = H.S(source == null ? "unknown source" : source) + ":";
        t5 = t3.getLine$1(t1);
        if (typeof t5 !== "number")
          return t5.$add();
        return t2 + (t4 + (t5 + 1) + ":" + H.S(J.$add$ansx(t3.getColumn$1(t1), 1))) + ">";
      },
      $isSourceLocation: 1
    }
  }], ["", "package:source_span/src/span_exception.dart",, G, {
    "^": "",
    SourceSpanException: {
      "^": "Object;_span_exception$_message<,_span<",
      get$message: function(_) {
        return this._span_exception$_message;
      },
      get$span: function() {
        return this._span;
      },
      toString$1$color: function(_, color) {
        if (this.get$span() == null)
          return this._span_exception$_message;
        return "Error on " + J.message$2$color$x(this.get$span(), this._span_exception$_message, color);
      },
      toString$0: function($receiver) {
        return this.toString$1$color($receiver, null);
      }
    },
    SourceSpanFormatException: {
      "^": "SourceSpanException;_span_exception$_source,_span_exception$_message,_span",
      get$source: function() {
        return this._span_exception$_source;
      },
      get$offset: function() {
        var t1 = this._span;
        return t1 == null ? null : J.get$start$x(t1).offset;
      },
      $isFormatException: 1
    }
  }], ["", "package:source_span/src/span_mixin.dart",, Y, {
    "^": "",
    SourceSpanMixin: {
      "^": "Object;",
      get$sourceUrl: function() {
        return this.get$start(this).get$sourceUrl();
      },
      get$length: function(_) {
        return J.$sub$n(this.get$end(this).get$offset(), this.get$start(this).get$offset());
      },
      compareTo$1: ["super$SourceSpanMixin$compareTo", function(_, other) {
        var t1, result;
        t1 = J.getInterceptor$x(other);
        result = this.get$start(this).compareTo$1(0, t1.get$start(other));
        return J.$eq$(result, 0) ? this.get$end(this).compareTo$1(0, t1.get$end(other)) : result;
      }],
      message$2$color: [function(_, message, color) {
        var t1, t2, highlight;
        t1 = this.get$start(this).get$line();
        if (typeof t1 !== "number")
          return t1.$add();
        t1 = "line " + (t1 + 1) + ", column " + H.S(J.$add$ansx(this.get$start(this).get$column(), 1));
        if (this.get$sourceUrl() != null) {
          t2 = this.get$sourceUrl();
          t2 = t1 + (" of " + H.S($.$get$context().prettyUri$1(t2)));
          t1 = t2;
        }
        t1 += ": " + H.S(message);
        highlight = this.highlight$1$color(color);
        if (highlight.length !== 0)
          t1 = t1 + "\n" + highlight;
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      }, function($receiver, message) {
        return this.message$2$color($receiver, message, null);
      }, "message$1", "call$2$color", "call$1", "get$message", 5, 3, 83, 2, 25, 79],
      highlight$1$color: function(color) {
        var column, t1, t2, t3, t4, context, lineStart, endIndex, textLine, toColumn, i;
        if (J.$eq$(color, true) === true)
          color = "\x1b[31m";
        if (J.$eq$(color, false) === true)
          color = null;
        column = this.get$start(this).get$column();
        if (!!this.$isSourceSpanWithContext) {
          t1 = this.file;
          t2 = Y.FileLocation$_(t1, this._file$_start);
          t2 = t1.getOffset$1(t2.file.getLine$1(t2.offset));
          t3 = this._end;
          t4 = Y.FileLocation$_(t1, t3);
          if (t4.file.getLine$1(t4.offset) === t1._lineStarts.length - 1)
            t3 = null;
          else {
            t3 = Y.FileLocation$_(t1, t3);
            t3 = t3.file.getLine$1(t3.offset);
            if (typeof t3 !== "number")
              return t3.$add();
            t3 = t1.getOffset$1(t3 + 1);
          }
          context = P.String_String$fromCharCodes(C.NativeUint32List_methods.sublist$2(t1._decodedChars, t2, t3), 0, null);
          lineStart = B.findLineStart(context, this.get$text(), column);
          if (lineStart != null && lineStart > 0) {
            t1 = C.JSString_methods.substring$2(context, 0, lineStart);
            context = C.JSString_methods.substring$1(context, lineStart);
          } else
            t1 = "";
          endIndex = C.JSString_methods.indexOf$1(context, "\n");
          textLine = endIndex === -1 ? context : C.JSString_methods.substring$2(context, 0, endIndex + 1);
          column = Math.min(H.checkNum(column), textLine.length);
        } else {
          if (J.$eq$(this.get$length(this), 0))
            return "";
          else
            textLine = C.JSArray_methods.get$first(this.get$text().split("\n"));
          column = 0;
          t1 = "";
        }
        t2 = this.get$end(this).get$offset();
        if (typeof t2 !== "number")
          return H.iae(t2);
        t3 = this.get$start(this).get$offset();
        if (typeof t3 !== "number")
          return H.iae(t3);
        t4 = J.getInterceptor$asx(textLine);
        toColumn = Math.min(column + t2 - t3, H.checkNum(t4.get$length(textLine)));
        t2 = color != null;
        t1 = t2 ? t1 + t4.substring$2(textLine, 0, column) + H.S(color) + t4.substring$2(textLine, column, toColumn) + "\x1b[0m" + t4.substring$1(textLine, toColumn) : t1 + H.S(textLine);
        if (!t4.endsWith$1(textLine, "\n"))
          t1 += "\n";
        for (i = 0; i < column; ++i)
          t1 = t4.codeUnitAt$1(textLine, i) === 9 ? t1 + H.Primitives_stringFromCharCode(9) : t1 + H.Primitives_stringFromCharCode(32);
        if (t2)
          t1 += H.S(color);
        t1 += C.JSString_methods.$mul("^", Math.max(toColumn - column, 1));
        if (t2)
          t1 += "\x1b[0m";
        return t1.charCodeAt(0) == 0 ? t1 : t1;
      },
      highlight$0: function() {
        return this.highlight$1$color(null);
      },
      $eq: ["super$SourceSpanMixin$$eq", function(_, other) {
        var t1;
        if (other == null)
          return false;
        t1 = J.getInterceptor(other);
        return !!t1.$isSourceSpan && this.get$start(this).$eq(0, t1.get$start(other)) && this.get$end(this).$eq(0, t1.get$end(other));
      }],
      get$hashCode: function(_) {
        var t1, t2;
        t1 = this.get$start(this);
        t1 = t1.get$hashCode(t1);
        t2 = this.get$end(this);
        return t1 + 31 * t2.get$hashCode(t2);
      },
      toString$0: function(_) {
        return "<" + H.S(new H.TypeImpl(H.getRuntimeTypeString(this), null)) + ": from " + this.get$start(this).toString$0(0) + " to " + this.get$end(this).toString$0(0) + ' "' + this.get$text() + '">';
      },
      $isSourceSpan: 1
    }
  }], ["", "package:source_span/src/utils.dart",, B, {
    "^": "",
    findLineStart: function(context, text, column) {
      var isEmpty, index, t1, lineStart, textColumn, t2;
      isEmpty = text === "";
      index = C.JSString_methods.indexOf$1(context, text);
      for (t1 = J.getInterceptor(column); index !== -1;) {
        lineStart = C.JSString_methods.lastIndexOf$2(context, "\n", index) + 1;
        textColumn = index - lineStart;
        if (!t1.$eq(column, textColumn))
          t2 = isEmpty && t1.$eq(column, textColumn + 1);
        else
          t2 = true;
        if (t2)
          return lineStart;
        index = C.JSString_methods.indexOf$2(context, text, index + 1);
      }
      return;
    }
  }], ["", "package:stack_trace/src/chain.dart",, U, {
    "^": "",
    Chain: {
      "^": "Object;traces",
      get$terse: function() {
        return this.foldFrames$2$terse(new U.Chain_terse_closure(), true);
      },
      foldFrames$2$terse: function(predicate, terse) {
        var t1, foldedTraces, nonEmptyTraces;
        t1 = this.traces;
        foldedTraces = new H.MappedListIterable(t1, new U.Chain_foldFrames_closure(predicate, true), [H.getTypeArgumentByIndex(t1, 0), null]);
        nonEmptyTraces = foldedTraces.super$Iterable$where(0, new U.Chain_foldFrames_closure0(true));
        if (!nonEmptyTraces.get$iterator(nonEmptyTraces).moveNext$0() && foldedTraces.get$isEmpty(foldedTraces) !== true)
          return new U.Chain(P.List_List$unmodifiable([foldedTraces.get$last(foldedTraces)], Y.Trace));
        return new U.Chain(P.List_List$unmodifiable(nonEmptyTraces, Y.Trace));
      },
      toTrace$0: function() {
        var t1 = this.traces;
        return new Y.Trace(P.List_List$unmodifiable(new H.ExpandIterable(t1, new U.Chain_toTrace_closure(), [H.getTypeArgumentByIndex(t1, 0), null]), A.Frame), new P._StringStackTrace(null));
      },
      toString$0: function(_) {
        var t1, t2;
        t1 = this.traces;
        t2 = [H.getTypeArgumentByIndex(t1, 0), null];
        return new H.MappedListIterable(t1, new U.Chain_toString_closure(new H.MappedListIterable(t1, new U.Chain_toString_closure0(), t2).fold$2(0, 0, P.math__max$closure())), t2).join$1(0, "===== asynchronous gap ===========================\n");
      },
      $isStackTrace: 1,
      static: {
        Chain_Chain$parse: function(chain) {
          var t1 = J.getInterceptor$asx(chain);
          if (t1.get$isEmpty(chain) === true)
            return new U.Chain(P.List_List$unmodifiable([], Y.Trace));
          if (t1.contains$1(chain, "<asynchronous suspension>\n") === true) {
            t1 = t1.split$1(chain, "<asynchronous suspension>\n");
            return new U.Chain(P.List_List$unmodifiable(new H.MappedListIterable(t1, new U.Chain_Chain$parse_closure(), [H.getTypeArgumentByIndex(t1, 0), null]), Y.Trace));
          }
          if (t1.contains$1(chain, "===== asynchronous gap ===========================\n") !== true)
            return new U.Chain(P.List_List$unmodifiable([Y.Trace_Trace$parse(chain)], Y.Trace));
          t1 = t1.split$1(chain, "===== asynchronous gap ===========================\n");
          return new U.Chain(P.List_List$unmodifiable(new H.MappedListIterable(t1, new U.Chain_Chain$parse_closure0(), [H.getTypeArgumentByIndex(t1, 0), null]), Y.Trace));
        }
      }
    },
    Chain_Chain$parse_closure: {
      "^": "Closure:0;",
      call$1: [function(trace) {
        return new Y.Trace(P.List_List$unmodifiable(Y.Trace__parseVM(trace), A.Frame), new P._StringStackTrace(trace));
      }, null, null, 4, 0, null, 14, "call"]
    },
    Chain_Chain$parse_closure0: {
      "^": "Closure:0;",
      call$1: [function(trace) {
        return Y.Trace$parseFriendly(trace);
      }, null, null, 4, 0, null, 14, "call"]
    },
    Chain_terse_closure: {
      "^": "Closure:0;",
      call$1: function(_) {
        return false;
      }
    },
    Chain_foldFrames_closure: {
      "^": "Closure:0;predicate,terse",
      call$1: [function(trace) {
        return trace.foldFrames$2$terse(this.predicate, this.terse);
      }, null, null, 4, 0, null, 14, "call"]
    },
    Chain_foldFrames_closure0: {
      "^": "Closure:0;terse",
      call$1: function(trace) {
        if (trace.get$frames().length > 1)
          return true;
        if (trace.get$frames().length === 0)
          return false;
        if (!this.terse)
          return false;
        return C.JSArray_methods.get$single(trace.get$frames()).get$line() != null;
      }
    },
    Chain_toTrace_closure: {
      "^": "Closure:0;",
      call$1: function(trace) {
        return trace.get$frames();
      }
    },
    Chain_toString_closure0: {
      "^": "Closure:0;",
      call$1: [function(trace) {
        var t1 = trace.get$frames();
        return new H.MappedListIterable(t1, new U.Chain_toString__closure0(), [H.getTypeArgumentByIndex(t1, 0), null]).fold$2(0, 0, P.math__max$closure());
      }, null, null, 4, 0, null, 14, "call"]
    },
    Chain_toString__closure0: {
      "^": "Closure:0;",
      call$1: [function(frame) {
        return J.get$length$asx(frame.get$location());
      }, null, null, 4, 0, null, 12, "call"]
    },
    Chain_toString_closure: {
      "^": "Closure:0;longest",
      call$1: [function(trace) {
        var t1 = trace.get$frames();
        return new H.MappedListIterable(t1, new U.Chain_toString__closure(this.longest), [H.getTypeArgumentByIndex(t1, 0), null]).join$0(0);
      }, null, null, 4, 0, null, 14, "call"]
    },
    Chain_toString__closure: {
      "^": "Closure:0;longest",
      call$1: [function(frame) {
        return J.padRight$1$s(frame.get$location(), this.longest) + "  " + H.S(frame.get$member()) + "\n";
      }, null, null, 4, 0, null, 12, "call"]
    }
  }], ["", "package:stack_trace/src/frame.dart",, A, {
    "^": "",
    Frame: {
      "^": "Object;uri<,line<,column<,member<",
      get$isCore: function() {
        return this.uri.get$scheme() === "dart";
      },
      get$library: function() {
        var t1 = this.uri;
        if (t1.get$scheme() === "data")
          return "data:...";
        return $.$get$context().prettyUri$1(t1);
      },
      get$$package: function() {
        var t1 = this.uri;
        if (t1.get$scheme() !== "package")
          return;
        return C.JSArray_methods.get$first(J.split$1$s(J.get$path$x(t1), "/"));
      },
      get$location: function() {
        var t1, t2;
        t1 = this.line;
        if (t1 == null)
          return this.get$library();
        t2 = this.column;
        if (t2 == null)
          return H.S(this.get$library()) + " " + H.S(t1);
        return H.S(this.get$library()) + " " + H.S(t1) + ":" + H.S(t2);
      },
      toString$0: function(_) {
        return H.S(this.get$location()) + " in " + H.S(this.member);
      },
      static: {
        Frame_Frame$parseVM: function(frame) {
          return A.Frame__catchFormatException(frame, new A.Frame_Frame$parseVM_closure(frame));
        },
        Frame_Frame$parseV8: function(frame) {
          return A.Frame__catchFormatException(frame, new A.Frame_Frame$parseV8_closure(frame));
        },
        Frame_Frame$parseFirefox: function(frame) {
          return A.Frame__catchFormatException(frame, new A.Frame_Frame$parseFirefox_closure(frame));
        },
        Frame_Frame$parseFriendly: function(frame) {
          return A.Frame__catchFormatException(frame, new A.Frame_Frame$parseFriendly_closure(frame));
        },
        Frame__uriOrPathToUri: function(uriOrPath) {
          if (J.getInterceptor$asx(uriOrPath).contains$1(uriOrPath, $.$get$Frame__uriRegExp()))
            return P.Uri_parse(uriOrPath, 0, null);
          else if (C.JSString_methods.contains$1(uriOrPath, $.$get$Frame__windowsRegExp()))
            return P._Uri__Uri$file(uriOrPath, true);
          else if (C.JSString_methods.startsWith$1(uriOrPath, "/"))
            return P._Uri__Uri$file(uriOrPath, false);
          if (C.JSString_methods.contains$1(uriOrPath, "\\"))
            return $.$get$windows().toUri$1(uriOrPath);
          return P.Uri_parse(uriOrPath, 0, null);
        },
        Frame__catchFormatException: function(text, body) {
          var t1, exception;
          try {
            t1 = body.call$0();
            return t1;
          } catch (exception) {
            if (!!J.getInterceptor(H.unwrapException(exception)).$isFormatException)
              return new N.UnparsedFrame(P._Uri__Uri(null, null, "unparsed", null, null, null, null, null, null), null, null, false, "unparsed", null, "unparsed", text);
            else
              throw exception;
          }
        }
      }
    },
    Frame_Frame$parseVM_closure: {
      "^": "Closure:1;frame",
      call$0: function() {
        var t1, match, t2, t3, member, uri, lineAndColumn, line;
        t1 = this.frame;
        if (J.$eq$(t1, "...") === true)
          return new A.Frame(P._Uri__Uri(null, null, null, null, null, null, null, null, null), null, null, "...");
        match = $.$get$_vmFrame().firstMatch$1(t1);
        if (match == null)
          return new N.UnparsedFrame(P._Uri__Uri(null, null, "unparsed", null, null, null, null, null, null), null, null, false, "unparsed", null, "unparsed", t1);
        t1 = match._match;
        if (1 >= t1.length)
          return H.ioore(t1, 1);
        t2 = t1[1];
        t3 = $.$get$_asyncBody();
        t2.toString;
        t2 = H.stringReplaceAllUnchecked(t2, t3, "<async>");
        member = H.stringReplaceAllUnchecked(t2, "<anonymous closure>", "<fn>");
        if (2 >= t1.length)
          return H.ioore(t1, 2);
        uri = P.Uri_parse(t1[2], 0, null);
        if (3 >= t1.length)
          return H.ioore(t1, 3);
        lineAndColumn = t1[3].split(":");
        t1 = lineAndColumn.length;
        line = t1 > 1 ? P.int_parse(lineAndColumn[1], null, null) : null;
        return new A.Frame(uri, line, t1 > 2 ? P.int_parse(lineAndColumn[2], null, null) : null, member);
      }
    },
    Frame_Frame$parseV8_closure: {
      "^": "Closure:1;frame",
      call$0: function() {
        var t1, match, t2, t3, t4;
        t1 = this.frame;
        match = $.$get$_v8Frame().firstMatch$1(t1);
        if (match == null)
          return new N.UnparsedFrame(P._Uri__Uri(null, null, "unparsed", null, null, null, null, null, null), null, null, false, "unparsed", null, "unparsed", t1);
        t1 = new A.Frame_Frame$parseV8_closure_parseLocation(t1);
        t2 = match._match;
        t3 = t2.length;
        if (2 >= t3)
          return H.ioore(t2, 2);
        t4 = t2[2];
        if (t4 != null) {
          t2 = t2[1];
          t2.toString;
          t2 = H.stringReplaceAllUnchecked(t2, "<anonymous>", "<fn>");
          t2 = H.stringReplaceAllUnchecked(t2, "Anonymous function", "<fn>");
          return t1.call$2(t4, H.stringReplaceAllUnchecked(t2, "(anonymous function)", "<fn>"));
        } else {
          if (3 >= t3)
            return H.ioore(t2, 3);
          return t1.call$2(t2[3], "<fn>");
        }
      }
    },
    Frame_Frame$parseV8_closure_parseLocation: {
      "^": "Closure:2;frame",
      call$2: function($location, member) {
        var t1, evalMatch, t2, urlMatch, t3;
        t1 = $.$get$_v8EvalLocation();
        evalMatch = t1.firstMatch$1($location);
        for (; evalMatch != null;) {
          t2 = evalMatch._match;
          if (1 >= t2.length)
            return H.ioore(t2, 1);
          $location = t2[1];
          evalMatch = t1.firstMatch$1($location);
        }
        if ($location === "native")
          return new A.Frame(P.Uri_parse("native", 0, null), null, null, member);
        urlMatch = $.$get$_v8UrlLocation().firstMatch$1($location);
        if (urlMatch == null)
          return new N.UnparsedFrame(P._Uri__Uri(null, null, "unparsed", null, null, null, null, null, null), null, null, false, "unparsed", null, "unparsed", this.frame);
        t1 = urlMatch._match;
        if (1 >= t1.length)
          return H.ioore(t1, 1);
        t2 = A.Frame__uriOrPathToUri(t1[1]);
        if (2 >= t1.length)
          return H.ioore(t1, 2);
        t3 = P.int_parse(t1[2], null, null);
        if (3 >= t1.length)
          return H.ioore(t1, 3);
        return new A.Frame(t2, t3, P.int_parse(t1[3], null, null), member);
      }
    },
    Frame_Frame$parseFirefox_closure: {
      "^": "Closure:1;frame",
      call$0: function() {
        var t1, match, uri, t2, t3, member, line;
        t1 = this.frame;
        match = $.$get$_firefoxSafariFrame().firstMatch$1(t1);
        if (match == null)
          return new N.UnparsedFrame(P._Uri__Uri(null, null, "unparsed", null, null, null, null, null, null), null, null, false, "unparsed", null, "unparsed", t1);
        t1 = match._match;
        if (3 >= t1.length)
          return H.ioore(t1, 3);
        uri = A.Frame__uriOrPathToUri(t1[3]);
        t2 = t1.length;
        if (1 >= t2)
          return H.ioore(t1, 1);
        t3 = t1[1];
        if (t3 != null) {
          if (2 >= t2)
            return H.ioore(t1, 2);
          t2 = C.JSString_methods.allMatches$1("/", t1[2]);
          member = J.$add$ansx(t3, C.JSArray_methods.join$0(P.List_List$filled(t2.get$length(t2), ".<fn>", false, null)));
          if (member === "")
            member = "<fn>";
          member = C.JSString_methods.replaceFirst$2(member, $.$get$_initialDot(), "");
        } else
          member = "<fn>";
        if (4 >= t1.length)
          return H.ioore(t1, 4);
        t2 = t1[4];
        line = t2 === "" ? null : P.int_parse(t2, null, null);
        if (5 >= t1.length)
          return H.ioore(t1, 5);
        t1 = t1[5];
        return new A.Frame(uri, line, t1 == null || t1 === "" ? null : P.int_parse(t1, null, null), member);
      }
    },
    Frame_Frame$parseFriendly_closure: {
      "^": "Closure:1;frame",
      call$0: function() {
        var t1, match, t2, uri, line, column;
        t1 = this.frame;
        match = $.$get$_friendlyFrame().firstMatch$1(t1);
        if (match == null)
          throw H.wrapException(P.FormatException$("Couldn't parse package:stack_trace stack trace line '" + H.S(t1) + "'.", null, null));
        t1 = match._match;
        if (1 >= t1.length)
          return H.ioore(t1, 1);
        t2 = t1[1];
        uri = t2 === "data:..." ? P.Uri_Uri$dataFromString("", false, null, null, null) : P.Uri_parse(t2, 0, null);
        if (uri.get$scheme() === "") {
          t2 = $.$get$context();
          uri = t2.toUri$1(t2.absolute$7(t2.style.pathFromUri$1(M._parseUri(uri)), null, null, null, null, null, null));
        }
        if (2 >= t1.length)
          return H.ioore(t1, 2);
        t2 = t1[2];
        line = t2 == null ? null : P.int_parse(t2, null, null);
        if (3 >= t1.length)
          return H.ioore(t1, 3);
        t2 = t1[3];
        column = t2 == null ? null : P.int_parse(t2, null, null);
        if (4 >= t1.length)
          return H.ioore(t1, 4);
        return new A.Frame(uri, line, column, t1[4]);
      }
    }
  }], ["", "package:stack_trace/src/lazy_trace.dart",, T, {
    "^": "",
    LazyTrace: {
      "^": "Object;_thunk,_inner",
      get$_lazy_trace$_trace: function() {
        var t1 = this._inner;
        if (t1 == null) {
          t1 = this._thunk.call$0();
          this._inner = t1;
        }
        return t1;
      },
      get$frames: function() {
        return this.get$_lazy_trace$_trace().get$frames();
      },
      get$terse: function() {
        return new T.LazyTrace(new T.LazyTrace_terse_closure(this), null);
      },
      foldFrames$2$terse: function(predicate, terse) {
        return new T.LazyTrace(new T.LazyTrace_foldFrames_closure(this, predicate, true), null);
      },
      toString$0: function(_) {
        return J.toString$0$(this.get$_lazy_trace$_trace());
      },
      $isStackTrace: 1,
      $isTrace: 1
    },
    LazyTrace_terse_closure: {
      "^": "Closure:1;$this",
      call$0: function() {
        return this.$this.get$_lazy_trace$_trace().get$terse();
      }
    },
    LazyTrace_foldFrames_closure: {
      "^": "Closure:1;$this,predicate,terse",
      call$0: function() {
        return this.$this.get$_lazy_trace$_trace().foldFrames$2$terse(this.predicate, this.terse);
      }
    }
  }], ["", "package:stack_trace/src/trace.dart",, Y, {
    "^": "",
    Trace: {
      "^": "Object;frames<,original",
      get$terse: function() {
        return this.foldFrames$2$terse(new Y.Trace_terse_closure(), true);
      },
      foldFrames$2$terse: function(predicate, terse) {
        var _box_0, t1, newFrames, t2, t3, frame;
        _box_0 = {};
        _box_0.predicate = predicate;
        _box_0.predicate = new Y.Trace_foldFrames_closure(predicate);
        t1 = A.Frame;
        newFrames = H.setRuntimeTypeInfo([], [t1]);
        for (t2 = this.frames, t3 = H.getTypeArgumentByIndex(t2, 0), t2 = new H.ReversedListIterable(t2, [t3]), t3 = new H.ListIterator(t2, t2.get$length(t2), 0, null, [t3]); t3.moveNext$0();) {
          frame = t3.__internal$_current;
          if (frame instanceof N.UnparsedFrame || _box_0.predicate.call$1(frame) !== true)
            newFrames.push(frame);
          else if (newFrames.length === 0 || _box_0.predicate.call$1(C.JSArray_methods.get$last(newFrames)) !== true)
            newFrames.push(new A.Frame(frame.get$uri(), frame.get$line(), frame.get$column(), frame.get$member()));
        }
        newFrames = new H.MappedListIterable(newFrames, new Y.Trace_foldFrames_closure0(_box_0), [H.getTypeArgumentByIndex(newFrames, 0), null]).toList$0(0);
        if (newFrames.length > 1 && _box_0.predicate.call$1(C.JSArray_methods.get$first(newFrames)) === true)
          C.JSArray_methods.removeAt$1(newFrames, 0);
        return new Y.Trace(P.List_List$unmodifiable(new H.ReversedListIterable(newFrames, [H.getTypeArgumentByIndex(newFrames, 0)]), t1), new P._StringStackTrace(this.original._stackTrace));
      },
      toString$0: function(_) {
        var t1, t2;
        t1 = this.frames;
        t2 = [H.getTypeArgumentByIndex(t1, 0), null];
        return new H.MappedListIterable(t1, new Y.Trace_toString_closure(new H.MappedListIterable(t1, new Y.Trace_toString_closure0(), t2).fold$2(0, 0, P.math__max$closure())), t2).join$0(0);
      },
      $isStackTrace: 1,
      static: {
        Trace_Trace$from: function(trace) {
          var t1;
          if (trace == null)
            throw H.wrapException(P.ArgumentError$("Cannot create a Trace from null."));
          t1 = J.getInterceptor(trace);
          if (!!t1.$isTrace)
            return trace;
          if (!!t1.$isChain)
            return trace.toTrace$0();
          return new T.LazyTrace(new Y.Trace_Trace$from_closure(trace), null);
        },
        Trace_Trace$parse: function(trace) {
          var error, t1, exception;
          try {
            t1 = J.getInterceptor$asx(trace);
            if (t1.get$isEmpty(trace) === true) {
              t1 = A.Frame;
              t1 = P.List_List$unmodifiable(H.setRuntimeTypeInfo([], [t1]), t1);
              return new Y.Trace(t1, new P._StringStackTrace(null));
            }
            if (t1.contains$1(trace, $.$get$_v8Trace()) === true) {
              t1 = Y.Trace$parseV8(trace);
              return t1;
            }
            if (t1.contains$1(trace, "\tat ") === true) {
              t1 = Y.Trace$parseJSCore(trace);
              return t1;
            }
            if (t1.contains$1(trace, $.$get$_firefoxSafariTrace()) === true) {
              t1 = Y.Trace$parseFirefox(trace);
              return t1;
            }
            if (t1.contains$1(trace, "===== asynchronous gap ===========================\n") === true) {
              t1 = U.Chain_Chain$parse(trace).toTrace$0();
              return t1;
            }
            if (t1.contains$1(trace, $.$get$_friendlyTrace()) === true) {
              t1 = Y.Trace$parseFriendly(trace);
              return t1;
            }
            t1 = P.List_List$unmodifiable(Y.Trace__parseVM(trace), A.Frame);
            return new Y.Trace(t1, new P._StringStackTrace(trace));
          } catch (exception) {
            t1 = H.unwrapException(exception);
            if (!!J.getInterceptor(t1).$isFormatException) {
              error = t1;
              throw H.wrapException(P.FormatException$(H.S(J.get$message$x(error)) + "\nStack trace:\n" + H.S(trace), null, null));
            } else
              throw exception;
          }
        },
        Trace__parseVM: function(trace) {
          var t1, lines, $frames;
          t1 = J.trim$0$s(trace);
          lines = H.setRuntimeTypeInfo(H.stringReplaceAllUnchecked(t1, "<asynchronous suspension>\n", "").split("\n"), [P.String]);
          t1 = H.SubListIterable$(lines, 0, lines.length - 1, H.getTypeArgumentByIndex(lines, 0));
          $frames = new H.MappedListIterable(t1, new Y.Trace__parseVM_closure(), [H.getTypeArgumentByIndex(t1, 0), null]).toList$0(0);
          if (!J.endsWith$1$s(C.JSArray_methods.get$last(lines), ".da"))
            C.JSArray_methods.add$1($frames, A.Frame_Frame$parseVM(C.JSArray_methods.get$last(lines)));
          return $frames;
        },
        Trace$parseV8: function(trace) {
          var t1 = J.split$1$s(trace, "\n");
          t1 = H.SubListIterable$(t1, 1, null, H.getTypeArgumentByIndex(t1, 0)).super$Iterable$skipWhile(0, new Y.Trace$parseV8_closure());
          return new Y.Trace(P.List_List$unmodifiable(H.MappedIterable_MappedIterable(t1, new Y.Trace$parseV8_closure0(), H.getTypeArgumentByIndex(t1, 0), null), A.Frame), new P._StringStackTrace(trace));
        },
        Trace$parseJSCore: function(trace) {
          var t1, t2;
          t1 = J.split$1$s(trace, "\n");
          t2 = H.getTypeArgumentByIndex(t1, 0);
          return new Y.Trace(P.List_List$unmodifiable(new H.MappedIterable(new H.WhereIterable(t1, new Y.Trace$parseJSCore_closure(), [t2]), new Y.Trace$parseJSCore_closure0(), [t2, null]), A.Frame), new P._StringStackTrace(trace));
        },
        Trace$parseFirefox: function(trace) {
          var t1, t2;
          t1 = H.setRuntimeTypeInfo(J.trim$0$s(trace).split("\n"), [P.String]);
          t2 = H.getTypeArgumentByIndex(t1, 0);
          return new Y.Trace(P.List_List$unmodifiable(new H.MappedIterable(new H.WhereIterable(t1, new Y.Trace$parseFirefox_closure(), [t2]), new Y.Trace$parseFirefox_closure0(), [t2, null]), A.Frame), new P._StringStackTrace(trace));
        },
        Trace$parseFriendly: function(trace) {
          var t1, t2;
          t1 = J.getInterceptor$asx(trace);
          if (t1.get$isEmpty(trace) === true)
            t1 = [];
          else {
            t1 = H.setRuntimeTypeInfo(t1.trim$0(trace).split("\n"), [P.String]);
            t2 = H.getTypeArgumentByIndex(t1, 0);
            t2 = new H.MappedIterable(new H.WhereIterable(t1, new Y.Trace$parseFriendly_closure(), [t2]), new Y.Trace$parseFriendly_closure0(), [t2, null]);
            t1 = t2;
          }
          return new Y.Trace(P.List_List$unmodifiable(t1, A.Frame), new P._StringStackTrace(trace));
        },
        Trace$: function($frames, original) {
          return new Y.Trace(P.List_List$unmodifiable($frames, A.Frame), new P._StringStackTrace(original));
        }
      }
    },
    Trace_Trace$from_closure: {
      "^": "Closure:1;trace",
      call$0: function() {
        return Y.Trace_Trace$parse(J.toString$0$(this.trace));
      }
    },
    Trace__parseVM_closure: {
      "^": "Closure:0;",
      call$1: [function(line) {
        return A.Frame_Frame$parseVM(line);
      }, null, null, 4, 0, null, 13, "call"]
    },
    Trace$parseV8_closure: {
      "^": "Closure:0;",
      call$1: function(line) {
        return !J.startsWith$1$s(line, $.$get$_v8TraceLine());
      }
    },
    Trace$parseV8_closure0: {
      "^": "Closure:0;",
      call$1: [function(line) {
        return A.Frame_Frame$parseV8(line);
      }, null, null, 4, 0, null, 13, "call"]
    },
    Trace$parseJSCore_closure: {
      "^": "Closure:0;",
      call$1: function(line) {
        return J.$eq$(line, "\tat ") !== true;
      }
    },
    Trace$parseJSCore_closure0: {
      "^": "Closure:0;",
      call$1: [function(line) {
        return A.Frame_Frame$parseV8(line);
      }, null, null, 4, 0, null, 13, "call"]
    },
    Trace$parseFirefox_closure: {
      "^": "Closure:0;",
      call$1: function(line) {
        var t1 = J.getInterceptor$asx(line);
        return t1.get$isNotEmpty(line) && t1.$eq(line, "[native code]") !== true;
      }
    },
    Trace$parseFirefox_closure0: {
      "^": "Closure:0;",
      call$1: [function(line) {
        return A.Frame_Frame$parseFirefox(line);
      }, null, null, 4, 0, null, 13, "call"]
    },
    Trace$parseFriendly_closure: {
      "^": "Closure:0;",
      call$1: function(line) {
        return !J.startsWith$1$s(line, "=====");
      }
    },
    Trace$parseFriendly_closure0: {
      "^": "Closure:0;",
      call$1: [function(line) {
        return A.Frame_Frame$parseFriendly(line);
      }, null, null, 4, 0, null, 13, "call"]
    },
    Trace_terse_closure: {
      "^": "Closure:0;",
      call$1: function(_) {
        return false;
      }
    },
    Trace_foldFrames_closure: {
      "^": "Closure:0;oldPredicate",
      call$1: function(frame) {
        if (this.oldPredicate.call$1(frame) === true)
          return true;
        if (frame.get$isCore())
          return true;
        if (J.$eq$(frame.get$$package(), "stack_trace") === true)
          return true;
        if (J.contains$1$asx(frame.get$member(), "<async>") !== true)
          return false;
        return frame.get$line() == null;
      }
    },
    Trace_foldFrames_closure0: {
      "^": "Closure:0;_box_0",
      call$1: [function(frame) {
        if (frame instanceof N.UnparsedFrame || this._box_0.predicate.call$1(frame) !== true)
          return frame;
        return new A.Frame(P.Uri_parse(J.replaceAll$2$s(frame.get$library(), $.$get$_terseRegExp(), ""), 0, null), null, null, frame.get$member());
      }, null, null, 4, 0, null, 12, "call"]
    },
    Trace_toString_closure0: {
      "^": "Closure:0;",
      call$1: [function(frame) {
        return J.get$length$asx(frame.get$location());
      }, null, null, 4, 0, null, 12, "call"]
    },
    Trace_toString_closure: {
      "^": "Closure:0;longest",
      call$1: [function(frame) {
        if (frame instanceof N.UnparsedFrame)
          return H.S(frame) + "\n";
        return J.padRight$1$s(frame.get$location(), this.longest) + "  " + H.S(frame.get$member()) + "\n";
      }, null, null, 4, 0, null, 12, "call"]
    }
  }], ["", "package:stack_trace/src/unparsed_frame.dart",, N, {
    "^": "",
    UnparsedFrame: {
      "^": "Object;uri<,line<,column<,isCore<,library<,$package<,location<,member<",
      toString$0: function(_) {
        return this.member;
      }
    }
  }], ["", "package:stream_transform/src/debounce.dart",, T, {
    "^": "",
    _collectToList: [function(element, soFar) {
      if (soFar == null)
        soFar = [];
      J.add$1$ax(soFar, element);
      return soFar;
    }, "call$2", "debounce___collectToList$closure", 8, 0, function() {
      return {func: 1, ret: P.List, args: [, P.List]};
    }],
    _debounceAggregate: function(duration, collect) {
      var t1 = {};
      t1.timer = null;
      t1.soFar = null;
      t1.shouldClose = false;
      return new L._StreamTransformer(new T._debounceAggregate_closure(t1, duration, collect), new T._debounceAggregate_closure0(t1), L.from_handlers__StreamTransformer__defaultHandleError$closure(), [null, null]);
    },
    _debounceAggregate_closure: {
      "^": "Closure;_box_0,duration,collect",
      call$2: [function(value, sink) {
        var t1, t2;
        t1 = this._box_0;
        t2 = t1.timer;
        if (!(t2 == null))
          t2.cancel$0();
        t1.timer = P.Timer_Timer(this.duration, new T._debounceAggregate__closure(t1, sink));
        t1.soFar = this.collect.call$2(value, t1.soFar);
      }, null, null, 8, 0, null, 3, 81, "call"],
      $signature: function() {
        return {func: 1, args: [, P.EventSink]};
      }
    },
    _debounceAggregate__closure: {
      "^": "Closure:1;_box_0,sink",
      call$0: function() {
        var t1, t2, t3;
        t1 = this.sink;
        t2 = this._box_0;
        t3 = J.getInterceptor$ax(t1);
        t3.add$1(t1, t2.soFar);
        if (t2.shouldClose)
          t3.close$0(t1);
        t2.soFar = null;
        t2.timer = null;
      }
    },
    _debounceAggregate_closure0: {
      "^": "Closure;_box_0",
      call$1: function(sink) {
        var t1 = this._box_0;
        if (t1.soFar != null)
          t1.shouldClose = true;
        else
          sink.close$0(0);
      },
      $signature: function() {
        return {func: 1, args: [P.EventSink]};
      }
    }
  }], ["", "package:stream_transform/src/from_handlers.dart",, L, {
    "^": "",
    _StreamTransformer: {
      "^": "StreamTransformerBase;_from_handlers$_handleData,_from_handlers$_handleDone,_from_handlers$_handleError,$ti",
      bind$1: function(values) {
        var t1, t2, controller;
        t1 = {};
        t2 = H.getTypeArgumentByIndex(this, 1);
        if (values.get$isBroadcast())
          controller = new P._SyncBroadcastStreamController(null, null, 0, null, null, null, null, [t2]);
        else
          controller = P.StreamController_StreamController(null, null, null, null, true, t2);
        t1.subscription = null;
        controller.set$onListen(new L._StreamTransformer_bind_closure(t1, this, values, controller));
        return controller.get$stream();
      },
      static: {
        _StreamTransformer__defaultHandleError: [function(error, stackTrace, sink) {
          sink.addError$2(error, stackTrace);
        }, "call$3", "from_handlers__StreamTransformer__defaultHandleError$closure", 12, 0, function() {
          return {func: 1, v: true, args: [P.Object, P.StackTrace, P.EventSink]};
        }]
      }
    },
    _StreamTransformer_bind_closure: {
      "^": "Closure:1;_box_1,$this,values,controller",
      call$0: function() {
        var t1, t2, t3, t4, t5;
        t1 = {};
        t2 = this._box_1;
        if (t2.subscription != null)
          return;
        t1.valuesDone = false;
        t3 = this.values;
        t4 = this.$this;
        t5 = this.controller;
        t2.subscription = t3.listen$3$onDone$onError(new L._StreamTransformer_bind__closure(t4, t5), new L._StreamTransformer_bind__closure0(t1, t4, t5), new L._StreamTransformer_bind__closure1(t4, t5));
        if (!t3.get$isBroadcast()) {
          t3 = t2.subscription;
          t5.set$onPause(t3.get$pause(t3));
          t5.set$onResume(t2.subscription.get$resume());
        }
        t5.set$onCancel(new L._StreamTransformer_bind__closure2(t2, t1));
      }
    },
    _StreamTransformer_bind__closure: {
      "^": "Closure:0;$this,controller",
      call$1: [function(value) {
        return this.$this._from_handlers$_handleData.call$2(value, this.controller);
      }, null, null, 4, 0, null, 3, "call"]
    },
    _StreamTransformer_bind__closure1: {
      "^": "Closure:7;$this,controller",
      call$2: [function(error, stackTrace) {
        this.$this._from_handlers$_handleError.call$3(error, stackTrace, this.controller);
      }, null, null, 8, 0, null, 4, 5, "call"]
    },
    _StreamTransformer_bind__closure0: {
      "^": "Closure:1;_box_0,$this,controller",
      call$0: [function() {
        this._box_0.valuesDone = true;
        this.$this._from_handlers$_handleDone.call$1(this.controller);
      }, null, null, 0, 0, null, "call"]
    },
    _StreamTransformer_bind__closure2: {
      "^": "Closure:1;_box_1,_box_0",
      call$0: function() {
        var t1, toCancel;
        t1 = this._box_1;
        toCancel = t1.subscription;
        t1.subscription = null;
        if (!this._box_0.valuesDone)
          return toCancel.cancel$0();
        return;
      }
    }
  }], ["", "package:string_scanner/src/exception.dart",, E, {
    "^": "",
    StringScannerException: {
      "^": "SourceSpanFormatException;_span_exception$_source,_span_exception$_message,_span",
      get$source: function() {
        return G.SourceSpanFormatException.prototype.get$source.call(this);
      },
      get$sourceUrl: function() {
        return this._span.get$sourceUrl();
      },
      static: {
        StringScannerException$: function(message, span, source) {
          return new E.StringScannerException(source, message, span);
        }
      }
    }
  }], ["", "package:string_scanner/src/line_scanner.dart",, Z, {
    "^": "",
    LineScanner: {
      "^": "StringScanner;_line_scanner$_line,_line_scanner$_column,sourceUrl,string,_position,_lastMatch,_lastMatchPosition",
      get$line: function() {
        return this._line_scanner$_line;
      },
      get$column: function() {
        return this._line_scanner$_column;
      },
      get$_betweenCRLF: function() {
        return this.peekChar$1(-1) === 13 && this.peekChar$0() === 10;
      },
      scanChar$1: function(character) {
        if (!this.super$StringScanner$scanChar(character))
          return false;
        this._adjustLineAndColumn$1(character);
        return true;
      },
      _adjustLineAndColumn$1: function(character) {
        var t1;
        if (character !== 10)
          t1 = character === 13 && this.peekChar$0() !== 10;
        else
          t1 = true;
        if (t1) {
          ++this._line_scanner$_line;
          this._line_scanner$_column = 0;
        } else
          ++this._line_scanner$_column;
      },
      scan$1: function(pattern) {
        var t1, newlines, t2;
        if (!this.super$StringScanner$scan(pattern))
          return false;
        t1 = this.get$lastMatch();
        newlines = this._newlinesIn$1(t1.pattern);
        t1 = this._line_scanner$_line;
        t2 = newlines.length;
        this._line_scanner$_line = t1 + t2;
        if (t2 === 0) {
          t1 = this._line_scanner$_column;
          t2 = this.get$lastMatch();
          this._line_scanner$_column = t1 + t2.pattern.length;
        } else {
          t1 = this.get$lastMatch();
          t1 = t1.pattern;
          t2 = J.get$end$x(C.JSArray_methods.get$last(newlines));
          if (typeof t2 !== "number")
            return H.iae(t2);
          this._line_scanner$_column = t1.length - t2;
        }
        return true;
      },
      _newlinesIn$1: function(text) {
        var t1, newlines;
        t1 = $.$get$_newlineRegExp().allMatches$1(0, text);
        newlines = P.List_List$from(t1, true, H.getRuntimeTypeArgument(t1, "Iterable", 0));
        if (this.get$_betweenCRLF())
          C.JSArray_methods.removeLast$0(newlines);
        return newlines;
      }
    }
  }], ["", "package:string_scanner/src/span_scanner.dart",, S, {
    "^": "",
    SpanScanner: {
      "^": "StringScanner;_sourceFile,_lastSpan,sourceUrl,string,_position,_lastMatch,_lastMatchPosition",
      get$line: function() {
        return this._sourceFile.getLine$1(this._position);
      },
      get$column: function() {
        return this._sourceFile.getColumn$1(this._position);
      },
      set$state: function(state) {
        if (!(state instanceof S._SpanScannerState) || state._scanner !== this)
          throw H.wrapException(P.ArgumentError$("The given LineScannerState was not returned by this LineScanner."));
        this.set$position(state.position);
      },
      get$location: function() {
        return Y.FileLocation$_(this._sourceFile, this._position);
      },
      spanFrom$2: function(startState, endState) {
        var endPosition = endState == null ? this._position : endState.position;
        return this._sourceFile.span$2(startState.position, endPosition);
      },
      spanFrom$1: function(startState) {
        return this.spanFrom$2(startState, null);
      },
      matches$1: function(pattern) {
        var t1, t2;
        if (!this.super$StringScanner$matches(pattern)) {
          this._lastSpan = null;
          return false;
        }
        t1 = this._position;
        t2 = this.get$lastMatch();
        this._lastSpan = this._sourceFile.span$2(t1, J.$add$ansx(t2.start, t2.pattern.length));
        return true;
      },
      error$4$length$match$position: [function(message, $length, match, position) {
        var t1, t2;
        t1 = this.string;
        B.validateErrorArgs(t1, match, position, $length);
        if (match == null && position == null && $length == null)
          match = this.get$lastMatch();
        if (position == null)
          position = match == null ? this._position : J.get$start$x(match);
        if ($length == null)
          if (match == null)
            $length = 0;
          else {
            t2 = J.getInterceptor$x(match);
            $length = J.$sub$n(t2.get$end(match), t2.get$start(match));
          }
        throw H.wrapException(E.StringScannerException$(message, this._sourceFile.span$2(position, J.$add$ansx(position, $length)), t1));
      }, function(message) {
        return this.error$4$length$match$position(message, null, null, null);
      }, "error$1", function(message, $length, position) {
        return this.error$4$length$match$position(message, $length, null, position);
      }, "error$3$length$position", function(message, position) {
        return this.error$4$length$match$position(message, null, null, position);
      }, "error$2$position", "call$4$length$match$position", "call$1", "call$3$length$position", "call$2$position", "get$error", 4, 7, 40, 2, 2, 2, 25, 19, 43, 26]
    },
    _SpanScannerState: {
      "^": "Object;_scanner,position",
      get$line: function() {
        return this._scanner._sourceFile.getLine$1(this.position);
      },
      get$column: function() {
        return this._scanner._sourceFile.getColumn$1(this.position);
      }
    }
  }], ["", "package:string_scanner/src/string_scanner.dart",, X, {
    "^": "",
    StringScanner: {
      "^": "Object;sourceUrl<,string,_position,_lastMatch,_lastMatchPosition",
      set$position: function(position) {
        var t1 = J.getInterceptor$n(position);
        if (t1.$lt(position, 0) || t1.$gt(position, J.get$length$asx(this.string)))
          throw H.wrapException(P.ArgumentError$("Invalid position " + H.S(position)));
        this._position = position;
        this._lastMatch = null;
      },
      get$lastMatch: function() {
        if (!J.$eq$(this._position, this._lastMatchPosition))
          this._lastMatch = null;
        return this._lastMatch;
      },
      readChar$0: ["super$StringScanner$readChar", function() {
        var t1, t2, t3;
        t1 = this.string;
        t2 = J.getInterceptor$asx(t1);
        if (J.$eq$(this._position, t2.get$length(t1)))
          this.error$3$length$position("expected more input.", 0, this._position);
        t3 = this._position;
        this._position = J.$add$ansx(t3, 1);
        return t2.codeUnitAt$1(t1, t3);
      }],
      peekChar$1: function(offset) {
        var index, t1;
        if (offset == null)
          offset = 0;
        index = J.$add$ansx(this._position, offset);
        t1 = J.getInterceptor$n(index);
        if (t1.$lt(index, 0) || t1.$ge(index, J.get$length$asx(this.string)))
          return;
        return J.codeUnitAt$1$s(this.string, index);
      },
      peekChar$0: function() {
        return this.peekChar$1(null);
      },
      scanChar$1: ["super$StringScanner$scanChar", function(character) {
        var t1, t2;
        t1 = this.string;
        t2 = J.getInterceptor$asx(t1);
        if (J.$eq$(this._position, t2.get$length(t1)))
          return false;
        if (t2.codeUnitAt$1(t1, this._position) !== character)
          return false;
        this._position = J.$add$ansx(this._position, 1);
        return true;
      }],
      expectChar$2$name: function(character, $name) {
        if (this.scanChar$1(character))
          return;
        if (character === 92)
          $name = '"\\"';
        else
          $name = character === 34 ? '"\\""' : '"' + H.Primitives_stringFromCharCode(character) + '"';
        this.error$3$length$position("expected " + $name + ".", 0, this._position);
      },
      expectChar$1: function(character) {
        return this.expectChar$2$name(character, null);
      },
      scan$1: ["super$StringScanner$scan", function(pattern) {
        var success, t1;
        success = this.matches$1(pattern);
        if (success) {
          t1 = this._lastMatch;
          t1 = J.$add$ansx(t1.start, t1.pattern.length);
          this._position = t1;
          this._lastMatchPosition = t1;
        }
        return success;
      }],
      expect$2$name: function(pattern, $name) {
        var t1;
        if (this.scan$1(pattern))
          return;
        t1 = H.stringReplaceAllUnchecked(pattern, "\\", "\\\\");
        $name = '"' + H.stringReplaceAllUnchecked(t1, '"', '\\"') + '"';
        this.error$3$length$position("expected " + $name + ".", 0, this._position);
      },
      expect$1: function(pattern) {
        return this.expect$2$name(pattern, null);
      },
      expectDone$0: function() {
        if (J.$eq$(this._position, J.get$length$asx(this.string)))
          return;
        this.error$3$length$position("expected no more input.", 0, this._position);
      },
      matches$1: ["super$StringScanner$matches", function(pattern) {
        var t1 = C.JSString_methods.matchAsPrefix$2(pattern, this.string, this._position);
        this._lastMatch = t1;
        this._lastMatchPosition = this._position;
        return t1 != null;
      }],
      substring$2: function(_, start, end) {
        if (end == null)
          end = this._position;
        return J.substring$2$s(this.string, start, end);
      },
      substring$1: function($receiver, start) {
        return this.substring$2($receiver, start, null);
      },
      error$4$length$match$position: [function(message, $length, match, position) {
        var t1, t2, t3, t4, t5, sourceFile;
        t1 = this.string;
        B.validateErrorArgs(t1, match, position, $length);
        if (match == null && position == null && $length == null)
          match = this.get$lastMatch();
        if (position == null)
          position = match == null ? this._position : J.get$start$x(match);
        if ($length == null)
          if (match == null)
            $length = 0;
          else {
            t2 = J.getInterceptor$x(match);
            $length = J.$sub$n(t2.get$end(match), t2.get$start(match));
          }
        t2 = this.sourceUrl;
        t3 = J.get$codeUnits$s(t1);
        t4 = H.setRuntimeTypeInfo([0], [P.int]);
        t5 = typeof t2 === "string" ? P.Uri_parse(t2, 0, null) : t2;
        sourceFile = new Y.SourceFile(t5, t4, new Uint32Array(H._ensureNativeList(t3.toList$0(t3))), null);
        sourceFile.SourceFile$decoded$2$url(t3, t2);
        throw H.wrapException(E.StringScannerException$(message, sourceFile.span$2(position, J.$add$ansx(position, $length)), t1));
      }, function(message) {
        return this.error$4$length$match$position(message, null, null, null);
      }, "error$1", function(message, $length, position) {
        return this.error$4$length$match$position(message, $length, null, position);
      }, "error$3$length$position", function(message, position) {
        return this.error$4$length$match$position(message, null, null, position);
      }, "error$2$position", "call$4$length$match$position", "call$1", "call$3$length$position", "call$2$position", "get$error", 4, 7, 40, 2, 2, 2, 25, 19, 43, 26],
      static: {
        StringScanner$: function(string, position, sourceUrl) {
          var t1 = typeof sourceUrl === "string" ? P.Uri_parse(sourceUrl, 0, null) : sourceUrl;
          return new X.StringScanner(t1, string, 0, null, null);
        }
      }
    }
  }], ["", "package:string_scanner/src/utils.dart",, B, {
    "^": "",
    validateErrorArgs: function(string, match, position, $length) {
      var t1, t2;
      if (match != null)
        t1 = position != null || $length != null;
      else
        t1 = false;
      if (t1)
        throw H.wrapException(P.ArgumentError$("Can't pass both match and position/length."));
      t1 = position != null;
      if (t1) {
        t2 = J.getInterceptor$n(position);
        if (t2.$lt(position, 0))
          throw H.wrapException(P.RangeError$("position must be greater than or equal to 0."));
        else if (t2.$gt(position, J.get$length$asx(string)))
          throw H.wrapException(P.RangeError$("position must be less than or equal to the string length."));
      }
      t2 = $length != null;
      if (t2 && J.$lt$n($length, 0))
        throw H.wrapException(P.RangeError$("length must be greater than or equal to 0."));
      if (t1 && t2 && J.$gt$n(J.$add$ansx(position, $length), J.get$length$asx(string)))
        throw H.wrapException(P.RangeError$("position plus length must not go beyond the end of the string."));
    }
  }], ["tuple", "package:tuple/tuple.dart",, S, {
    "^": "",
    Tuple2: {
      "^": "Object;item1<,item2<,$ti",
      toList$1$growable: function(_, growable) {
        return P.List_List$from([this.item1, this.item2], false, null);
      },
      toList$0: function($receiver) {
        return this.toList$1$growable($receiver, false);
      },
      toString$0: function(_) {
        return "[" + H.S(this.item1) + ", " + H.S(this.item2) + "]";
      },
      $eq: function(_, o) {
        if (o == null)
          return false;
        return o instanceof S.Tuple2 && J.$eq$(o.item1, this.item1) === true && J.$eq$(o.item2, this.item2) === true;
      },
      get$hashCode: function(_) {
        var t1, t2, hash;
        t1 = J.get$hashCode$(this.item1);
        t2 = J.get$hashCode$(this.item2);
        t2 = L._combine(L._combine(0, t1 & 0x1FFFFFFF), t2 & 0x1FFFFFFF);
        hash = 536870911 & t2 + ((67108863 & t2) << 3);
        hash ^= hash >>> 11;
        return 536870911 & hash + ((16383 & hash) << 15);
      }
    }
  }], ["", "package:watcher/src/watch_event.dart",, E, {
    "^": "",
    WatchEvent: {
      "^": "Object;type<,path>",
      toString$0: function(_) {
        return H.S(this.type) + " " + H.S(this.path);
      }
    },
    ChangeType: {
      "^": "Object;_watch_event$_name",
      toString$0: function(_) {
        return this._watch_event$_name;
      }
    }
  }]];
  setupProgram(dart, 0, 0);
  // getInterceptor methods
  J.getInterceptor = function(receiver) {
    if (typeof receiver == "number") {
      if (Math.floor(receiver) == receiver)
        return J.JSInt.prototype;
      return J.JSDouble.prototype;
    }
    if (typeof receiver == "string")
      return J.JSString.prototype;
    if (receiver == null)
      return J.JSNull.prototype;
    if (typeof receiver == "boolean")
      return J.JSBool.prototype;
    if (receiver.constructor == Array)
      return J.JSArray.prototype;
    if (typeof receiver != "object") {
      if (typeof receiver == "function")
        return J.JavaScriptFunction.prototype;
      return receiver;
    }
    if (receiver instanceof P.Object)
      return receiver;
    return J.getNativeInterceptor(receiver);
  };
  J.getInterceptor$ansx = function(receiver) {
    if (typeof receiver == "number")
      return J.JSNumber.prototype;
    if (typeof receiver == "string")
      return J.JSString.prototype;
    if (receiver == null)
      return receiver;
    if (receiver.constructor == Array)
      return J.JSArray.prototype;
    if (typeof receiver != "object") {
      if (typeof receiver == "function")
        return J.JavaScriptFunction.prototype;
      return receiver;
    }
    if (receiver instanceof P.Object)
      return receiver;
    return J.getNativeInterceptor(receiver);
  };
  J.getInterceptor$asx = function(receiver) {
    if (typeof receiver == "string")
      return J.JSString.prototype;
    if (receiver == null)
      return receiver;
    if (receiver.constructor == Array)
      return J.JSArray.prototype;
    if (typeof receiver != "object") {
      if (typeof receiver == "function")
        return J.JavaScriptFunction.prototype;
      return receiver;
    }
    if (receiver instanceof P.Object)
      return receiver;
    return J.getNativeInterceptor(receiver);
  };
  J.getInterceptor$ax = function(receiver) {
    if (receiver == null)
      return receiver;
    if (receiver.constructor == Array)
      return J.JSArray.prototype;
    if (typeof receiver != "object") {
      if (typeof receiver == "function")
        return J.JavaScriptFunction.prototype;
      return receiver;
    }
    if (receiver instanceof P.Object)
      return receiver;
    return J.getNativeInterceptor(receiver);
  };
  J.getInterceptor$in = function(receiver) {
    if (typeof receiver == "number") {
      if (Math.floor(receiver) == receiver)
        return J.JSInt.prototype;
      return J.JSNumber.prototype;
    }
    if (receiver == null)
      return receiver;
    if (!(receiver instanceof P.Object))
      return J.UnknownJavaScriptObject.prototype;
    return receiver;
  };
  J.getInterceptor$n = function(receiver) {
    if (typeof receiver == "number")
      return J.JSNumber.prototype;
    if (receiver == null)
      return receiver;
    if (!(receiver instanceof P.Object))
      return J.UnknownJavaScriptObject.prototype;
    return receiver;
  };
  J.getInterceptor$ns = function(receiver) {
    if (typeof receiver == "number")
      return J.JSNumber.prototype;
    if (typeof receiver == "string")
      return J.JSString.prototype;
    if (receiver == null)
      return receiver;
    if (!(receiver instanceof P.Object))
      return J.UnknownJavaScriptObject.prototype;
    return receiver;
  };
  J.getInterceptor$s = function(receiver) {
    if (typeof receiver == "string")
      return J.JSString.prototype;
    if (receiver == null)
      return receiver;
    if (!(receiver instanceof P.Object))
      return J.UnknownJavaScriptObject.prototype;
    return receiver;
  };
  J.getInterceptor$x = function(receiver) {
    if (receiver == null)
      return receiver;
    if (typeof receiver != "object") {
      if (typeof receiver == "function")
        return J.JavaScriptFunction.prototype;
      return receiver;
    }
    if (receiver instanceof P.Object)
      return receiver;
    return J.getNativeInterceptor(receiver);
  };
  J.set$context$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$context(receiver, value);
  };
  J.set$dartValue$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$dartValue(receiver, value);
  };
  J.set$info$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$info(receiver, value);
  };
  J.set$length$asx = function(receiver, value) {
    return J.getInterceptor$asx(receiver).set$length(receiver, value);
  };
  J.set$render$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$render(receiver, value);
  };
  J.set$renderSync$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$renderSync(receiver, value);
  };
  J.set$run_$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$run_(receiver, value);
  };
  J.set$types$x = function(receiver, value) {
    return J.getInterceptor$x(receiver).set$types(receiver, value);
  };
  J.get$code$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$code(receiver);
  };
  J.get$codeUnits$s = function(receiver) {
    return J.getInterceptor$s(receiver).get$codeUnits(receiver);
  };
  J.get$contents$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$contents(receiver);
  };
  J.get$current$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$current(receiver);
  };
  J.get$dartValue$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$dartValue(receiver);
  };
  J.get$end$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$end(receiver);
  };
  J.get$fiber$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$fiber(receiver);
  };
  J.get$file$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$file(receiver);
  };
  J.get$first$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).get$first(receiver);
  };
  J.get$importer$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$importer(receiver);
  };
  J.get$includedFiles$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$includedFiles(receiver);
  };
  J.get$isEmpty$asx = function(receiver) {
    return J.getInterceptor$asx(receiver).get$isEmpty(receiver);
  };
  J.get$isNotEmpty$asx = function(receiver) {
    return J.getInterceptor$asx(receiver).get$isNotEmpty(receiver);
  };
  J.get$isTTY$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$isTTY(receiver);
  };
  J.get$iterator$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).get$iterator(receiver);
  };
  J.get$last$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).get$last(receiver);
  };
  J.get$length$asx = function(receiver) {
    return J.getInterceptor$asx(receiver).get$length(receiver);
  };
  J.get$message$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$message(receiver);
  };
  J.get$mtime$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$mtime(receiver);
  };
  J.get$options$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$options(receiver);
  };
  J.get$path$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$path(receiver);
  };
  J.get$platform$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$platform(receiver);
  };
  J.get$result$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$result(receiver);
  };
  J.get$reversed$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).get$reversed(receiver);
  };
  J.get$runes$s = function(receiver) {
    return J.getInterceptor$s(receiver).get$runes(receiver);
  };
  J.get$single$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).get$single(receiver);
  };
  J.get$start$x = function(receiver) {
    return J.getInterceptor$x(receiver).get$start(receiver);
  };
  J.$add$ansx = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver + a0;
    return J.getInterceptor$ansx(receiver).$add(receiver, a0);
  };
  J.$and$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return (receiver & a0) >>> 0;
    return J.getInterceptor$n(receiver).$and(receiver, a0);
  };
  J.$div$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver / a0;
    return J.getInterceptor$n(receiver).$div(receiver, a0);
  };
  J.$ge$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver >= a0;
    return J.getInterceptor$n(receiver).$ge(receiver, a0);
  };
  J.$gt$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver > a0;
    return J.getInterceptor$n(receiver).$gt(receiver, a0);
  };
  J.$index$asx = function(receiver, a0) {
    if (typeof a0 === "number")
      if (receiver.constructor == Array || typeof receiver == "string" || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName]))
        if (a0 >>> 0 === a0 && a0 < receiver.length)
          return receiver[a0];
    return J.getInterceptor$asx(receiver).$index(receiver, a0);
  };
  J.$indexSet$ax = function(receiver, a0, a1) {
    if (typeof a0 === "number")
      if ((receiver.constructor == Array || H.isJsIndexable(receiver, receiver[init.dispatchPropertyName])) && !receiver.immutable$list && a0 >>> 0 === a0 && a0 < receiver.length)
        return receiver[a0] = a1;
    return J.getInterceptor$ax(receiver).$indexSet(receiver, a0, a1);
  };
  J.$le$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver <= a0;
    return J.getInterceptor$n(receiver).$le(receiver, a0);
  };
  J.$lt$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver < a0;
    return J.getInterceptor$n(receiver).$lt(receiver, a0);
  };
  J.$mod$n = function(receiver, a0) {
    return J.getInterceptor$n(receiver).$mod(receiver, a0);
  };
  J.$mul$ns = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver * a0;
    return J.getInterceptor$ns(receiver).$mul(receiver, a0);
  };
  J.$negate$in = function(receiver) {
    if (typeof receiver == "number")
      return -receiver;
    return J.getInterceptor$in(receiver).$negate(receiver);
  };
  J.$shl$n = function(receiver, a0) {
    return J.getInterceptor$n(receiver).$shl(receiver, a0);
  };
  J.$sub$n = function(receiver, a0) {
    if (typeof receiver == "number" && typeof a0 == "number")
      return receiver - a0;
    return J.getInterceptor$n(receiver).$sub(receiver, a0);
  };
  J.$tdiv$n = function(receiver, a0) {
    return J.getInterceptor$n(receiver).$tdiv(receiver, a0);
  };
  J.abs$0$in = function(receiver) {
    if (typeof receiver === "number")
      return Math.abs(receiver);
    return J.getInterceptor$in(receiver).abs$0(receiver);
  };
  J.add$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).add$1(receiver, a0);
  };
  J.any$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).any$1(receiver, a0);
  };
  J.apply$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).apply$2(receiver, a0, a1);
  };
  J.cast$0$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).cast$0(receiver);
  };
  J.ceil$0$n = function(receiver) {
    return J.getInterceptor$n(receiver).ceil$0(receiver);
  };
  J.clamp$2$n = function(receiver, a0, a1) {
    return J.getInterceptor$n(receiver).clamp$2(receiver, a0, a1);
  };
  J.close$0$x = function(receiver) {
    return J.getInterceptor$x(receiver).close$0(receiver);
  };
  J.codeUnitAt$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).codeUnitAt$1(receiver, a0);
  };
  J.compareTo$1$ns = function(receiver, a0) {
    return J.getInterceptor$ns(receiver).compareTo$1(receiver, a0);
  };
  J.contains$1$asx = function(receiver, a0) {
    return J.getInterceptor$asx(receiver).contains$1(receiver, a0);
  };
  J.createInterface$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).createInterface$1(receiver, a0);
  };
  J.cwd$0$x = function(receiver) {
    return J.getInterceptor$x(receiver).cwd$0(receiver);
  };
  J.elementAt$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).elementAt$1(receiver, a0);
  };
  J.endsWith$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).endsWith$1(receiver, a0);
  };
  J.every$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).every$1(receiver, a0);
  };
  J.expand$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).expand$1(receiver, a0);
  };
  J.fillRange$3$ax = function(receiver, a0, a1, a2) {
    return J.getInterceptor$ax(receiver).fillRange$3(receiver, a0, a1, a2);
  };
  J.floor$0$n = function(receiver) {
    return J.getInterceptor$n(receiver).floor$0(receiver);
  };
  J.fold$2$ax = function(receiver, a0, a1) {
    return J.getInterceptor$ax(receiver).fold$2(receiver, a0, a1);
  };
  J.forEach$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).forEach$1(receiver, a0);
  };
  J.getTime$0$x = function(receiver) {
    return J.getInterceptor$x(receiver).getTime$0(receiver);
  };
  J.indexOf$1$asx = function(receiver, a0) {
    return J.getInterceptor$asx(receiver).indexOf$1(receiver, a0);
  };
  J.isDirectory$0$x = function(receiver) {
    return J.getInterceptor$x(receiver).isDirectory$0(receiver);
  };
  J.isFile$0$x = function(receiver) {
    return J.getInterceptor$x(receiver).isFile$0(receiver);
  };
  J.join$0$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).join$0(receiver);
  };
  J.join$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).join$1(receiver, a0);
  };
  J.map$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).map$1(receiver, a0);
  };
  J.matchAsPrefix$2$s = function(receiver, a0, a1) {
    return J.getInterceptor$s(receiver).matchAsPrefix$2(receiver, a0, a1);
  };
  J.message$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).message$1(receiver, a0);
  };
  J.message$2$color$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).message$2$color(receiver, a0, a1);
  };
  J.mkdirSync$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).mkdirSync$1(receiver, a0);
  };
  J.on$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).on$2(receiver, a0, a1);
  };
  J.padRight$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).padRight$1(receiver, a0);
  };
  J.pause$0$x = function(receiver) {
    return J.getInterceptor$x(receiver).pause$0(receiver);
  };
  J.readFileSync$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).readFileSync$2(receiver, a0, a1);
  };
  J.readdirSync$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).readdirSync$1(receiver, a0);
  };
  J.remove$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).remove$1(receiver, a0);
  };
  J.removeRange$2$ax = function(receiver, a0, a1) {
    return J.getInterceptor$ax(receiver).removeRange$2(receiver, a0, a1);
  };
  J.replaceAll$2$s = function(receiver, a0, a1) {
    return J.getInterceptor$s(receiver).replaceAll$2(receiver, a0, a1);
  };
  J.replaceRange$3$asx = function(receiver, a0, a1, a2) {
    return J.getInterceptor$asx(receiver).replaceRange$3(receiver, a0, a1, a2);
  };
  J.round$0$n = function(receiver) {
    return J.getInterceptor$n(receiver).round$0(receiver);
  };
  J.run$0$x = function(receiver) {
    return J.getInterceptor$x(receiver).run$0(receiver);
  };
  J.run$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).run$1(receiver, a0);
  };
  J.setPrompt$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).setPrompt$1(receiver, a0);
  };
  J.setRange$4$ax = function(receiver, a0, a1, a2, a3) {
    return J.getInterceptor$ax(receiver).setRange$4(receiver, a0, a1, a2, a3);
  };
  J.skip$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).skip$1(receiver, a0);
  };
  J.split$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).split$1(receiver, a0);
  };
  J.startsWith$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).startsWith$1(receiver, a0);
  };
  J.startsWith$2$s = function(receiver, a0, a1) {
    return J.getInterceptor$s(receiver).startsWith$2(receiver, a0, a1);
  };
  J.statSync$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).statSync$1(receiver, a0);
  };
  J.sublist$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).sublist$1(receiver, a0);
  };
  J.substring$1$s = function(receiver, a0) {
    return J.getInterceptor$s(receiver).substring$1(receiver, a0);
  };
  J.substring$2$s = function(receiver, a0, a1) {
    return J.getInterceptor$s(receiver).substring$2(receiver, a0, a1);
  };
  J.take$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).take$1(receiver, a0);
  };
  J.toList$0$ax = function(receiver) {
    return J.getInterceptor$ax(receiver).toList$0(receiver);
  };
  J.toList$1$growable$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).toList$1$growable(receiver, a0);
  };
  J.toLowerCase$0$s = function(receiver) {
    return J.getInterceptor$s(receiver).toLowerCase$0(receiver);
  };
  J.toRadixString$1$n = function(receiver, a0) {
    return J.getInterceptor$n(receiver).toRadixString$1(receiver, a0);
  };
  J.trim$0$s = function(receiver) {
    return J.getInterceptor$s(receiver).trim$0(receiver);
  };
  J.trimRight$0$s = function(receiver) {
    return J.getInterceptor$s(receiver).trimRight$0(receiver);
  };
  J.unlinkSync$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).unlinkSync$1(receiver, a0);
  };
  J.watch$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).watch$2(receiver, a0, a1);
  };
  J.where$1$ax = function(receiver, a0) {
    return J.getInterceptor$ax(receiver).where$1(receiver, a0);
  };
  J.write$1$x = function(receiver, a0) {
    return J.getInterceptor$x(receiver).write$1(receiver, a0);
  };
  J.writeFileSync$2$x = function(receiver, a0, a1) {
    return J.getInterceptor$x(receiver).writeFileSync$2(receiver, a0, a1);
  };
  J.yield$0$x = function(receiver) {
    return J.getInterceptor$x(receiver).yield$0(receiver);
  };
  J.get$hashCode$ = function(receiver) {
    return J.getInterceptor(receiver).get$hashCode(receiver);
  };
  J.$eq$ = function(receiver, a0) {
    if (receiver == null)
      return a0 == null;
    if (typeof receiver != "object")
      return a0 != null && receiver === a0;
    return J.getInterceptor(receiver).$eq(receiver, a0);
  };
  J.noSuchMethod$1$ = function(receiver, a0) {
    return J.getInterceptor(receiver).noSuchMethod$1(receiver, a0);
  };
  J.toString$0$ = function(receiver) {
    return J.getInterceptor(receiver).toString$0(receiver);
  };
  J.toString$1$color$ = function(receiver, a0) {
    return J.getInterceptor(receiver).toString$1$color(receiver, a0);
  };
  Isolate.makeConstantList = function(list) {
    list.immutable$list = Array;
    list.fixed$length = Array;
    return list;
  };
  var $ = Isolate.$isolateProperties;
  C.Interceptor_methods = J.Interceptor.prototype;
  C.JSArray_methods = J.JSArray.prototype;
  C.JSBool_methods = J.JSBool.prototype;
  C.JSDouble_methods = J.JSDouble.prototype;
  C.JSInt_methods = J.JSInt.prototype;
  C.JSNull_methods = J.JSNull.prototype;
  C.JSNumber_methods = J.JSNumber.prototype;
  C.JSString_methods = J.JSString.prototype;
  C.JavaScriptFunction_methods = J.JavaScriptFunction.prototype;
  C.NativeUint32List_methods = H.NativeUint32List.prototype;
  C.NativeUint8List_methods = H.NativeUint8List.prototype;
  C.PlainJavaScriptObject_methods = J.PlainJavaScriptObject.prototype;
  C.UnknownJavaScriptObject_methods = J.UnknownJavaScriptObject.prototype;
  C.AsciiCodec_false = new P.AsciiCodec(false);
  C.AsciiEncoder_127 = new P.AsciiEncoder(127);
  C.C_EmptyUnmodifiableSet = new O.EmptyUnmodifiableSet([null]);
  C.AtRootQuery_UsS = new V.AtRootQuery(false, C.C_EmptyUnmodifiableSet, false, true);
  C.AttributeOperator_4L5 = new N.AttributeOperator("^=");
  C.AttributeOperator_AuK = new N.AttributeOperator("|=");
  C.AttributeOperator_fz1 = new N.AttributeOperator("~=");
  C.AttributeOperator_gqZ = new N.AttributeOperator("*=");
  C.AttributeOperator_mOX = new N.AttributeOperator("$=");
  C.AttributeOperator_sEs = new N.AttributeOperator("=");
  C.Base64Encoder_false = new P.Base64Encoder(false);
  C.Base64Codec_Base64Encoder_false = new P.Base64Codec(C.Base64Encoder_false);
  C.BinaryOperator_1da = new V.BinaryOperator("greater than or equals", ">=", 4);
  C.BinaryOperator_2ad = new V.BinaryOperator("modulo", "%", 6);
  C.BinaryOperator_33h = new V.BinaryOperator("less than or equals", "<=", 4);
  C.BinaryOperator_8qt = new V.BinaryOperator("less than", "<", 4);
  C.BinaryOperator_AcR0 = new V.BinaryOperator("greater than", ">", 4);
  C.BinaryOperator_AcR = new V.BinaryOperator("plus", "+", 5);
  C.BinaryOperator_O1M = new V.BinaryOperator("times", "*", 6);
  C.BinaryOperator_RTB = new V.BinaryOperator("divided by", "/", 6);
  C.BinaryOperator_YlX = new V.BinaryOperator("equals", "==", 3);
  C.BinaryOperator_and_and_2 = new V.BinaryOperator("and", "and", 2);
  C.BinaryOperator_i5H = new V.BinaryOperator("not equals", "!=", 3);
  C.BinaryOperator_iyO = new V.BinaryOperator("minus", "-", 5);
  C.BinaryOperator_kjl = new V.BinaryOperator("single equals", "=", 0);
  C.BinaryOperator_or_or_1 = new V.BinaryOperator("or", "or", 1);
  C.C_EmptyIterator = new H.EmptyIterator([null]);
  C.C_OutOfMemoryError = new P.OutOfMemoryError();
  C.C_SassNull = new O.SassNull();
  C.C_Utf8Encoder = new P.Utf8Encoder();
  C.C__DelayedDone = new P._DelayedDone();
  C.C__JSRandom = new P._JSRandom();
  C.C__RootZone = new P._RootZone();
  C.ChangeType_add = new E.ChangeType("add");
  C.ChangeType_modify = new E.ChangeType("modify");
  C.ChangeType_remove = new E.ChangeType("remove");
  C.Combinator_CzM = new S.Combinator("~");
  C.Combinator_sgq = new S.Combinator(">");
  C.Combinator_uzg = new S.Combinator("+");
  C.Duration_0 = new P.Duration(0);
  C.ExtendMode_allTargets = new L.ExtendMode("allTargets");
  C.ExtendMode_normal = new L.ExtendMode("normal");
  C.ExtendMode_replace = new L.ExtendMode("replace");
  C.List_empty = Isolate.makeConstantList([]);
  C.StderrLogger_false = new S.StderrLogger(false);
  C.Map_empty0 = new H.ConstantStringMap(0, {}, C.List_empty, [null, null]);
  C.ImportCache_89P = new R.ImportCache(C.List_empty, C.StderrLogger_false, C.Map_empty0, C.Map_empty0);
  C.JS_CONST_0 = function(hooks) {
  if (typeof dartExperimentalFixupGetTag != "function") return hooks;
  hooks.getTag = dartExperimentalFixupGetTag(hooks.getTag);
};
  C.JS_CONST_4hp = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Firefox") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "GeoGeolocation": "Geolocation",
    "Location": "!Location",
    "WorkerMessageEvent": "MessageEvent",
    "XMLDocument": "!Document"};
  function getTagFirefox(o) {
    var tag = getTag(o);
    return quickMap[tag] || tag;
  }
  hooks.getTag = getTagFirefox;
};
  C.JS_CONST_Fs4 = function(hooks) { return hooks; }
;
  C.JS_CONST_QJm = function(getTagFallback) {
  return function(hooks) {
    if (typeof navigator != "object") return hooks;
    var ua = navigator.userAgent;
    if (ua.indexOf("DumpRenderTree") >= 0) return hooks;
    if (ua.indexOf("Chrome") >= 0) {
      function confirm(p) {
        return typeof window == "object" && window[p] && window[p].name == p;
      }
      if (confirm("Window") && confirm("HTMLElement")) return hooks;
    }
    hooks.getTag = getTagFallback;
  };
};
  C.JS_CONST_bDt = function() {
  var toStringFunction = Object.prototype.toString;
  function getTag(o) {
    var s = toStringFunction.call(o);
    return s.substring(8, s.length - 1);
  }
  function getUnknownTag(object, tag) {
    if (/^HTML[A-Z].*Element$/.test(tag)) {
      var name = toStringFunction.call(object);
      if (name == "[object Object]") return null;
      return "HTMLElement";
    }
  }
  function getUnknownTagGenericBrowser(object, tag) {
    if (self.HTMLElement && object instanceof HTMLElement) return "HTMLElement";
    return getUnknownTag(object, tag);
  }
  function prototypeForTag(tag) {
    if (typeof window == "undefined") return null;
    if (typeof window[tag] == "undefined") return null;
    var constructor = window[tag];
    if (typeof constructor != "function") return null;
    return constructor.prototype;
  }
  function discriminator(tag) { return null; }
  var isBrowser = typeof navigator == "object";
  return {
    getTag: getTag,
    getUnknownTag: isBrowser ? getUnknownTagGenericBrowser : getUnknownTag,
    prototypeForTag: prototypeForTag,
    discriminator: discriminator };
};
  C.JS_CONST_gkc = function(hooks) {
  var userAgent = typeof navigator == "object" ? navigator.userAgent : "";
  if (userAgent.indexOf("Trident/") == -1) return hooks;
  var getTag = hooks.getTag;
  var quickMap = {
    "BeforeUnloadEvent": "Event",
    "DataTransfer": "Clipboard",
    "HTMLDDElement": "HTMLElement",
    "HTMLDTElement": "HTMLElement",
    "HTMLPhraseElement": "HTMLElement",
    "Position": "Geoposition"
  };
  function getTagIE(o) {
    var tag = getTag(o);
    var newTag = quickMap[tag];
    if (newTag) return newTag;
    if (tag == "Object") {
      if (window.DataView && (o instanceof window.DataView)) return "DataView";
    }
    return tag;
  }
  function prototypeForTagIE(tag) {
    var constructor = window[tag];
    if (constructor == null) return null;
    return constructor.prototype;
  }
  hooks.getTag = getTagIE;
  hooks.prototypeForTag = prototypeForTagIE;
};
  C.JS_CONST_rr7 = function(hooks) {
  var getTag = hooks.getTag;
  var prototypeForTag = hooks.prototypeForTag;
  function getTagFixed(o) {
    var tag = getTag(o);
    if (tag == "Document") {
      if (!!o.xmlVersion) return "!Document";
      return "!HTMLDocument";
    }
    return tag;
  }
  function prototypeForTagFixed(tag) {
    if (tag == "Document") return null;
    return prototypeForTag(tag);
  }
  hooks.getTag = getTagFixed;
  hooks.prototypeForTag = prototypeForTagFixed;
};
  C.JS_CONST_u2C = function getTagFallback(o) {
  var s = Object.prototype.toString.call(o);
  return s.substring(8, s.length - 1);
};
  C.JsonCodec_null_null = new P.JsonCodec(null, null);
  C.JsonEncoder_null_null = new P.JsonEncoder(null, null);
  C.LineFeed_D6m = new N.LineFeed("lf", "\n");
  C.LineFeed_Mss = new N.LineFeed("crlf", "\r\n");
  C.LineFeed_a1Y = new N.LineFeed("lfcr", "\n\r");
  C.LineFeed_kMT = new N.LineFeed("cr", "\r");
  C.C_DefaultEquality = new U.DefaultEquality([null]);
  C.ListEquality_DefaultEquality = new U.ListEquality(C.C_DefaultEquality, [null]);
  C.ListSeparator_kWM = new D.ListSeparator("comma", ",");
  C.ListSeparator_undecided_null = new D.ListSeparator("undecided", null);
  C.ListSeparator_woc = new D.ListSeparator("space", " ");
  C.List_127_2047_65535_1114111 = H.setRuntimeTypeInfo(Isolate.makeConstantList([127, 2047, 65535, 1114111]), [P.int]);
  C.List_2Vk = H.setRuntimeTypeInfo(Isolate.makeConstantList([0, 0, 32776, 33792, 1, 10240, 0, 0]), [P.int]);
  C.List_CVk = Isolate.makeConstantList([0, 0, 65490, 45055, 65535, 34815, 65534, 18431]);
  C.List_JYB = H.setRuntimeTypeInfo(Isolate.makeConstantList([0, 0, 26624, 1023, 65534, 2047, 65534, 2047]), [P.int]);
  C.List_WnV = Isolate.makeConstantList(["/", "\\"]);
  C.List_cSk = Isolate.makeConstantList(["/"]);
  C.List_empty4 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [B.AsyncCallable]);
  C.List_empty2 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [D.Callable]);
  C.List_empty3 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [S.ComplexSelector]);
  C.List_empty0 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [P.String]);
  C.List_empty1 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [F.Value]);
  C.List_gRj = H.setRuntimeTypeInfo(Isolate.makeConstantList([0, 0, 32722, 12287, 65534, 34815, 65534, 18431]), [P.int]);
  C.List_nxB = H.setRuntimeTypeInfo(Isolate.makeConstantList([0, 0, 24576, 1023, 65534, 34815, 65534, 18431]), [P.int]);
  C.List_qFt = Isolate.makeConstantList([0, 0, 27858, 1023, 65534, 51199, 65535, 32767]);
  C.List_qNA = H.setRuntimeTypeInfo(Isolate.makeConstantList([0, 0, 32754, 11263, 65534, 34815, 65534, 18431]), [P.int]);
  C.List_qg40 = H.setRuntimeTypeInfo(Isolate.makeConstantList([0, 0, 32722, 12287, 65535, 34815, 65534, 18431]), [P.int]);
  C.List_qg4 = Isolate.makeConstantList([0, 0, 65490, 12287, 65535, 34815, 65534, 18431]);
  C.MapEquality_DefaultEquality_DefaultEquality = new U.MapEquality(C.C_DefaultEquality, C.C_DefaultEquality, [null, null]);
  C.List_empty5 = H.setRuntimeTypeInfo(Isolate.makeConstantList([]), [P.Symbol0]);
  C.Map_empty = new H.ConstantStringMap(0, {}, C.List_empty5, [P.Symbol0, null]);
  C.OptionType_YwU = new G.OptionType("OptionType.single");
  C.OptionType_nMZ = new G.OptionType("OptionType.flag");
  C.OptionType_qyr = new G.OptionType("OptionType.multiple");
  C.OutputStyle_compressed = new N.OutputStyle("compressed");
  C.OutputStyle_expanded = new N.OutputStyle("expanded");
  C.SassBoolean_false = new Z.SassBoolean(false);
  C.SassBoolean_true = new Z.SassBoolean(true);
  C.SassMap_Map_empty = new A.SassMap(C.Map_empty0);
  C.Symbol_call = new H.Symbol("call");
  C.UnaryOperator_U4G = new X.UnaryOperator("minus", "-");
  C.UnaryOperator_j2w = new X.UnaryOperator("plus", "+");
  C.UnaryOperator_not_not = new X.UnaryOperator("not", "not");
  C.UnaryOperator_zDx = new X.UnaryOperator("divide", "/");
  C.Utf8Codec_false = new P.Utf8Codec(false);
  C._IterationMarker_null_2 = new P._IterationMarker(null, 2);
  C._PathDirection_8Gl = new M._PathDirection("at root");
  C._PathDirection_988 = new M._PathDirection("below root");
  C._PathDirection_FIw = new M._PathDirection("reaches root");
  C._PathDirection_ZGD = new M._PathDirection("above root");
  C._PathRelation_different = new M._PathRelation("different");
  C._PathRelation_equal = new M._PathRelation("equal");
  C._PathRelation_inconclusive = new M._PathRelation("inconclusive");
  C._PathRelation_within = new M._PathRelation("within");
  C._StreamGroupState_canceled = new L._StreamGroupState("canceled");
  C._StreamGroupState_dormant = new L._StreamGroupState("dormant");
  C._StreamGroupState_listening = new L._StreamGroupState("listening");
  C._StreamGroupState_paused = new L._StreamGroupState("paused");
  $.Closure_functionCounter = 0;
  $.BoundClosure_selfFieldNameCache = null;
  $.BoundClosure_receiverFieldNameCache = null;
  $.getTagFunction = null;
  $.alternateTagFunction = null;
  $.prototypeForTagFunction = null;
  $.dispatchRecordsForInstanceTags = null;
  $.interceptorsForUncacheableTags = null;
  $.initNativeDispatchFlag = null;
  $._nextCallback = null;
  $._lastCallback = null;
  $._lastPriorityCallback = null;
  $._isInCallbackLoop = false;
  $.Zone__current = C.C__RootZone;
  $._currentUriBase = null;
  $._current = null;
  $._p = null;
  $ = null;
  init.isHunkLoaded = function(hunkHash) {
    return !!$dart_deferred_initializers$[hunkHash];
  };
  init.deferredInitialized = new Object(null);
  init.isHunkInitialized = function(hunkHash) {
    return init.deferredInitialized[hunkHash];
  };
  init.initializeLoadedHunk = function(hunkHash) {
    var hunk = $dart_deferred_initializers$[hunkHash];
    if (hunk == null)
      throw "DeferredLoading state error: code with hash '" + hunkHash + "' was not loaded";
    hunk($globals$, $);
    init.deferredInitialized[hunkHash] = true;
  };
  init.deferredLibraryParts = {};
  init.deferredPartUris = [];
  init.deferredPartHashes = [];
  // Empty type-to-interceptor map.
  (function(lazies) {
    for (var i = 0; i < lazies.length;) {
      var fieldName = lazies[i++];
      var getterName = lazies[i++];
      var lazyValue = lazies[i++];
      var staticName = lazies[i++];
      Isolate.$lazy(fieldName, getterName, lazyValue, staticName);
    }
  })(["DART_CLOSURE_PROPERTY_NAME", "$get$DART_CLOSURE_PROPERTY_NAME", function() {
    return H.getIsolateAffinityTag("_$dart_dartClosure");
  }, "DART_CLOSURE_PROPERTY_NAME", "JS_INTEROP_INTERCEPTOR_TAG", "$get$JS_INTEROP_INTERCEPTOR_TAG", function() {
    return H.getIsolateAffinityTag("_$dart_js");
  }, "JS_INTEROP_INTERCEPTOR_TAG", "TypeErrorDecoder_noSuchMethodPattern", "$get$TypeErrorDecoder_noSuchMethodPattern", function() {
    return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({
      toString: function() {
        return "$receiver$";
      }
    }));
  }, "TypeErrorDecoder_noSuchMethodPattern", "TypeErrorDecoder_notClosurePattern", "$get$TypeErrorDecoder_notClosurePattern", function() {
    return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn({$method$: null,
      toString: function() {
        return "$receiver$";
      }
    }));
  }, "TypeErrorDecoder_notClosurePattern", "TypeErrorDecoder_nullCallPattern", "$get$TypeErrorDecoder_nullCallPattern", function() {
    return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(null));
  }, "TypeErrorDecoder_nullCallPattern", "TypeErrorDecoder_nullLiteralCallPattern", "$get$TypeErrorDecoder_nullLiteralCallPattern", function() {
    return H.TypeErrorDecoder_extractPattern(function() {
      var $argumentsExpr$ = '$arguments$';
      try {
        null.$method$($argumentsExpr$);
      } catch (e) {
        return e.message;
      }
    }());
  }, "TypeErrorDecoder_nullLiteralCallPattern", "TypeErrorDecoder_undefinedCallPattern", "$get$TypeErrorDecoder_undefinedCallPattern", function() {
    return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokeCallErrorOn(void 0));
  }, "TypeErrorDecoder_undefinedCallPattern", "TypeErrorDecoder_undefinedLiteralCallPattern", "$get$TypeErrorDecoder_undefinedLiteralCallPattern", function() {
    return H.TypeErrorDecoder_extractPattern(function() {
      var $argumentsExpr$ = '$arguments$';
      try {
        (void 0).$method$($argumentsExpr$);
      } catch (e) {
        return e.message;
      }
    }());
  }, "TypeErrorDecoder_undefinedLiteralCallPattern", "TypeErrorDecoder_nullPropertyPattern", "$get$TypeErrorDecoder_nullPropertyPattern", function() {
    return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(null));
  }, "TypeErrorDecoder_nullPropertyPattern", "TypeErrorDecoder_nullLiteralPropertyPattern", "$get$TypeErrorDecoder_nullLiteralPropertyPattern", function() {
    return H.TypeErrorDecoder_extractPattern(function() {
      try {
        null.$method$;
      } catch (e) {
        return e.message;
      }
    }());
  }, "TypeErrorDecoder_nullLiteralPropertyPattern", "TypeErrorDecoder_undefinedPropertyPattern", "$get$TypeErrorDecoder_undefinedPropertyPattern", function() {
    return H.TypeErrorDecoder_extractPattern(H.TypeErrorDecoder_provokePropertyErrorOn(void 0));
  }, "TypeErrorDecoder_undefinedPropertyPattern", "TypeErrorDecoder_undefinedLiteralPropertyPattern", "$get$TypeErrorDecoder_undefinedLiteralPropertyPattern", function() {
    return H.TypeErrorDecoder_extractPattern(function() {
      try {
        (void 0).$method$;
      } catch (e) {
        return e.message;
      }
    }());
  }, "TypeErrorDecoder_undefinedLiteralPropertyPattern", "_AsyncRun__scheduleImmediateClosure", "$get$_AsyncRun__scheduleImmediateClosure", function() {
    return P._AsyncRun__initializeScheduleImmediate();
  }, "_AsyncRun__scheduleImmediateClosure", "Future__nullFuture", "$get$Future__nullFuture", function() {
    return P._Future$value(null, P.Null);
  }, "Future__nullFuture", "Future__falseFuture", "$get$Future__falseFuture", function() {
    return P._Future$value(false, P.bool);
  }, "Future__falseFuture", "_toStringVisiting", "$get$_toStringVisiting", function() {
    return [];
  }, "_toStringVisiting", "Utf8Decoder__decoder", "$get$Utf8Decoder__decoder", function() {
    return P.Utf8Decoder__makeDecoder();
  }, "Utf8Decoder__decoder", "_Base64Decoder__inverseAlphabet", "$get$_Base64Decoder__inverseAlphabet", function() {
    return H.NativeInt8List__create1(H._ensureNativeList([-2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -2, -1, -2, -2, -2, -2, -2, 62, -2, 62, -2, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -2, -2, -2, -1, -2, -2, -2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -2, -2, -2, -2, 63, -2, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -2, -2, -2, -2, -2]));
  }, "_Base64Decoder__inverseAlphabet", "_Uri__isWindowsCached", "$get$_Uri__isWindowsCached", function() {
    return typeof process != "undefined" && Object.prototype.toString.call(process) == "[object process]" && process.platform == "win32";
  }, "_Uri__isWindowsCached", "_Uri__needsNoEncoding", "$get$_Uri__needsNoEncoding", function() {
    return P.RegExp_RegExp("^[\\-\\.0-9A-Z_a-z~]*$", true, false);
  }, "_Uri__needsNoEncoding", "_hasErrorStackProperty", "$get$_hasErrorStackProperty", function() {
    return new Error().stack != void 0;
  }, "_hasErrorStackProperty", "_scannerTables", "$get$_scannerTables", function() {
    return P._createTables();
  }, "_scannerTables", "Option__invalidChars", "$get$Option__invalidChars", function() {
    return P.RegExp_RegExp("[ \\t\\r\\n\"'\\\\/]", true, false);
  }, "Option__invalidChars", "_soloOpt", "$get$_soloOpt", function() {
    return P.RegExp_RegExp("^-([a-zA-Z0-9])$", true, false);
  }, "_soloOpt", "_abbrOpt", "$get$_abbrOpt", function() {
    return P.RegExp_RegExp("^-([a-zA-Z0-9]+)(.*)$", true, false);
  }, "_abbrOpt", "_longOpt", "$get$_longOpt", function() {
    return P.RegExp_RegExp("^--([a-zA-Z\\-_0-9]+)(=(.*))?$", true, false);
  }, "_longOpt", "alwaysValid", "$get$alwaysValid", function() {
    return new Q.closure121();
  }, "alwaysValid", "readline", "$get$readline", function() {
    return self.require("readline");
  }, "readline", "windows", "$get$windows", function() {
    return M.Context_Context(null, $.$get$Style_windows());
  }, "windows", "url", "$get$url", function() {
    return M.Context_Context(null, $.$get$Style_url());
  }, "url", "context", "$get$context", function() {
    return new M.Context($.$get$Style_platform(), null);
  }, "context", "Style_posix", "$get$Style_posix", function() {
    return new E.PosixStyle("posix", "/", C.List_cSk, P.RegExp_RegExp("/", true, false), P.RegExp_RegExp("[^/]$", true, false), P.RegExp_RegExp("^/", true, false), null);
  }, "Style_posix", "Style_windows", "$get$Style_windows", function() {
    return new L.WindowsStyle("windows", "\\", C.List_WnV, P.RegExp_RegExp("[/\\\\]", true, false), P.RegExp_RegExp("[^/\\\\]$", true, false), P.RegExp_RegExp("^(\\\\\\\\[^\\\\]+\\\\[^\\\\/]+|[a-zA-Z]:[/\\\\])", true, false), P.RegExp_RegExp("^[/\\\\](?![/\\\\])", true, false));
  }, "Style_windows", "Style_url", "$get$Style_url", function() {
    return new F.UrlStyle("url", "/", C.List_cSk, P.RegExp_RegExp("/", true, false), P.RegExp_RegExp("(^[a-zA-Z][-+.a-zA-Z\\d]*://|[^/])$", true, false), P.RegExp_RegExp("[a-zA-Z][-+.a-zA-Z\\d]*://[^/]*", true, false), P.RegExp_RegExp("^/", true, false));
  }, "Style_url", "Style_platform", "$get$Style_platform", function() {
    return O.Style__getPlatformStyle();
  }, "Style_platform", "IfExpression_declaration", "$get$IfExpression_declaration", function() {
    return B.ArgumentDeclaration_ArgumentDeclaration$parse("$condition, $if-true, $if-false", null, null);
  }, "IfExpression_declaration", "colorsByName", "$get$colorsByName", function() {
    return B.normalizedMap(P.LinkedHashMap__makeLiteral(["yellowgreen", K.SassColor$rgb(154, 205, 50, null, null), "yellow", K.SassColor$rgb(255, 255, 0, null, null), "whitesmoke", K.SassColor$rgb(245, 245, 245, null, null), "white", K.SassColor$rgb(255, 255, 255, null, null), "wheat", K.SassColor$rgb(245, 222, 179, null, null), "violet", K.SassColor$rgb(238, 130, 238, null, null), "turquoise", K.SassColor$rgb(64, 224, 208, null, null), "transparent", K.SassColor$rgb(0, 0, 0, 0, null), "tomato", K.SassColor$rgb(255, 99, 71, null, null), "thistle", K.SassColor$rgb(216, 191, 216, null, null), "teal", K.SassColor$rgb(0, 128, 128, null, null), "tan", K.SassColor$rgb(210, 180, 140, null, null), "steelblue", K.SassColor$rgb(70, 130, 180, null, null), "springgreen", K.SassColor$rgb(0, 255, 127, null, null), "snow", K.SassColor$rgb(255, 250, 250, null, null), "slategrey", K.SassColor$rgb(112, 128, 144, null, null), "slategray", K.SassColor$rgb(112, 128, 144, null, null), "slateblue", K.SassColor$rgb(106, 90, 205, null, null), "skyblue", K.SassColor$rgb(135, 206, 235, null, null), "silver", K.SassColor$rgb(192, 192, 192, null, null), "sienna", K.SassColor$rgb(160, 82, 45, null, null), "seashell", K.SassColor$rgb(255, 245, 238, null, null), "seagreen", K.SassColor$rgb(46, 139, 87, null, null), "sandybrown", K.SassColor$rgb(244, 164, 96, null, null), "salmon", K.SassColor$rgb(250, 128, 114, null, null), "saddlebrown", K.SassColor$rgb(139, 69, 19, null, null), "royalblue", K.SassColor$rgb(65, 105, 225, null, null), "rosybrown", K.SassColor$rgb(188, 143, 143, null, null), "red", K.SassColor$rgb(255, 0, 0, null, null), "rebeccapurple", K.SassColor$rgb(102, 51, 153, null, null), "purple", K.SassColor$rgb(128, 0, 128, null, null), "powderblue", K.SassColor$rgb(176, 224, 230, null, null), "plum", K.SassColor$rgb(221, 160, 221, null, null), "pink", K.SassColor$rgb(255, 192, 203, null, null), "peru", K.SassColor$rgb(205, 133, 63, null, null), "peachpuff", K.SassColor$rgb(255, 218, 185, null, null), "papayawhip", K.SassColor$rgb(255, 239, 213, null, null), "palevioletred", K.SassColor$rgb(219, 112, 147, null, null), "paleturquoise", K.SassColor$rgb(175, 238, 238, null, null), "palegreen", K.SassColor$rgb(152, 251, 152, null, null), "palegoldenrod", K.SassColor$rgb(238, 232, 170, null, null), "orchid", K.SassColor$rgb(218, 112, 214, null, null), "orangered", K.SassColor$rgb(255, 69, 0, null, null), "orange", K.SassColor$rgb(255, 165, 0, null, null), "olivedrab", K.SassColor$rgb(107, 142, 35, null, null), "olive", K.SassColor$rgb(128, 128, 0, null, null), "oldlace", K.SassColor$rgb(253, 245, 230, null, null), "navy", K.SassColor$rgb(0, 0, 128, null, null), "navajowhite", K.SassColor$rgb(255, 222, 173, null, null), "moccasin", K.SassColor$rgb(255, 228, 181, null, null), "mistyrose", K.SassColor$rgb(255, 228, 225, null, null), "mintcream", K.SassColor$rgb(245, 255, 250, null, null), "midnightblue", K.SassColor$rgb(25, 25, 112, null, null), "mediumvioletred", K.SassColor$rgb(199, 21, 133, null, null), "mediumturquoise", K.SassColor$rgb(72, 209, 204, null, null), "mediumspringgreen", K.SassColor$rgb(0, 250, 154, null, null), "mediumslateblue", K.SassColor$rgb(123, 104, 238, null, null), "mediumseagreen", K.SassColor$rgb(60, 179, 113, null, null), "mediumpurple", K.SassColor$rgb(147, 112, 219, null, null), "mediumorchid", K.SassColor$rgb(186, 85, 211, null, null), "mediumblue", K.SassColor$rgb(0, 0, 205, null, null), "mediumaquamarine", K.SassColor$rgb(102, 205, 170, null, null), "maroon", K.SassColor$rgb(128, 0, 0, null, null), "magenta", K.SassColor$rgb(255, 0, 255, null, null), "linen", K.SassColor$rgb(250, 240, 230, null, null), "limegreen", K.SassColor$rgb(50, 205, 50, null, null), "lime", K.SassColor$rgb(0, 255, 0, null, null), "lightyellow", K.SassColor$rgb(255, 255, 224, null, null), "lightsteelblue", K.SassColor$rgb(176, 196, 222, null, null), "lightslategrey", K.SassColor$rgb(119, 136, 153, null, null), "lightslategray", K.SassColor$rgb(119, 136, 153, null, null), "lightskyblue", K.SassColor$rgb(135, 206, 250, null, null), "lightseagreen", K.SassColor$rgb(32, 178, 170, null, null), "lightsalmon", K.SassColor$rgb(255, 160, 122, null, null), "lightpink", K.SassColor$rgb(255, 182, 193, null, null), "lightgrey", K.SassColor$rgb(211, 211, 211, null, null), "lightgreen", K.SassColor$rgb(144, 238, 144, null, null), "lightgray", K.SassColor$rgb(211, 211, 211, null, null), "lightgoldenrodyellow", K.SassColor$rgb(250, 250, 210, null, null), "lightcyan", K.SassColor$rgb(224, 255, 255, null, null), "lightcoral", K.SassColor$rgb(240, 128, 128, null, null), "lightblue", K.SassColor$rgb(173, 216, 230, null, null), "lemonchiffon", K.SassColor$rgb(255, 250, 205, null, null), "lawngreen", K.SassColor$rgb(124, 252, 0, null, null), "lavenderblush", K.SassColor$rgb(255, 240, 245, null, null), "lavender", K.SassColor$rgb(230, 230, 250, null, null), "khaki", K.SassColor$rgb(240, 230, 140, null, null), "ivory", K.SassColor$rgb(255, 255, 240, null, null), "indigo", K.SassColor$rgb(75, 0, 130, null, null), "indianred", K.SassColor$rgb(205, 92, 92, null, null), "hotpink", K.SassColor$rgb(255, 105, 180, null, null), "honeydew", K.SassColor$rgb(240, 255, 240, null, null), "grey", K.SassColor$rgb(128, 128, 128, null, null), "greenyellow", K.SassColor$rgb(173, 255, 47, null, null), "green", K.SassColor$rgb(0, 128, 0, null, null), "gray", K.SassColor$rgb(128, 128, 128, null, null), "goldenrod", K.SassColor$rgb(218, 165, 32, null, null), "gold", K.SassColor$rgb(255, 215, 0, null, null), "ghostwhite", K.SassColor$rgb(248, 248, 255, null, null), "gainsboro", K.SassColor$rgb(220, 220, 220, null, null), "fuchsia", K.SassColor$rgb(255, 0, 255, null, null), "forestgreen", K.SassColor$rgb(34, 139, 34, null, null), "floralwhite", K.SassColor$rgb(255, 250, 240, null, null), "firebrick", K.SassColor$rgb(178, 34, 34, null, null), "dodgerblue", K.SassColor$rgb(30, 144, 255, null, null), "dimgrey", K.SassColor$rgb(105, 105, 105, null, null), "dimgray", K.SassColor$rgb(105, 105, 105, null, null), "deepskyblue", K.SassColor$rgb(0, 191, 255, null, null), "deeppink", K.SassColor$rgb(255, 20, 147, null, null), "darkviolet", K.SassColor$rgb(148, 0, 211, null, null), "darkturquoise", K.SassColor$rgb(0, 206, 209, null, null), "darkslategrey", K.SassColor$rgb(47, 79, 79, null, null), "darkslategray", K.SassColor$rgb(47, 79, 79, null, null), "darkslateblue", K.SassColor$rgb(72, 61, 139, null, null), "darkseagreen", K.SassColor$rgb(143, 188, 143, null, null), "darksalmon", K.SassColor$rgb(233, 150, 122, null, null), "darkred", K.SassColor$rgb(139, 0, 0, null, null), "darkorchid", K.SassColor$rgb(153, 50, 204, null, null), "darkorange", K.SassColor$rgb(255, 140, 0, null, null), "darkolivegreen", K.SassColor$rgb(85, 107, 47, null, null), "darkmagenta", K.SassColor$rgb(139, 0, 139, null, null), "darkkhaki", K.SassColor$rgb(189, 183, 107, null, null), "darkgrey", K.SassColor$rgb(169, 169, 169, null, null), "darkgreen", K.SassColor$rgb(0, 100, 0, null, null), "darkgray", K.SassColor$rgb(169, 169, 169, null, null), "darkgoldenrod", K.SassColor$rgb(184, 134, 11, null, null), "darkcyan", K.SassColor$rgb(0, 139, 139, null, null), "darkblue", K.SassColor$rgb(0, 0, 139, null, null), "cyan", K.SassColor$rgb(0, 255, 255, null, null), "crimson", K.SassColor$rgb(220, 20, 60, null, null), "cornsilk", K.SassColor$rgb(255, 248, 220, null, null), "cornflowerblue", K.SassColor$rgb(100, 149, 237, null, null), "coral", K.SassColor$rgb(255, 127, 80, null, null), "chocolate", K.SassColor$rgb(210, 105, 30, null, null), "chartreuse", K.SassColor$rgb(127, 255, 0, null, null), "cadetblue", K.SassColor$rgb(95, 158, 160, null, null), "burlywood", K.SassColor$rgb(222, 184, 135, null, null), "brown", K.SassColor$rgb(165, 42, 42, null, null), "blueviolet", K.SassColor$rgb(138, 43, 226, null, null), "blue", K.SassColor$rgb(0, 0, 255, null, null), "blanchedalmond", K.SassColor$rgb(255, 235, 205, null, null), "black", K.SassColor$rgb(0, 0, 0, null, null), "bisque", K.SassColor$rgb(255, 228, 196, null, null), "beige", K.SassColor$rgb(245, 245, 220, null, null), "azure", K.SassColor$rgb(240, 255, 255, null, null), "aquamarine", K.SassColor$rgb(127, 255, 212, null, null), "aqua", K.SassColor$rgb(0, 255, 255, null, null), "antiquewhite", K.SassColor$rgb(250, 235, 215, null, null), "aliceblue", K.SassColor$rgb(240, 248, 255, null, null)]));
  }, "colorsByName", "namesByColor", "$get$namesByColor", function() {
    return Y.mapMap($.$get$colorsByName(), new X.closure34(), new X.closure35());
  }, "namesByColor", "ExecutableOptions__separatorBar", "$get$ExecutableOptions__separatorBar", function() {
    return B.isWindows() === true ? "=" : "\u2501";
  }, "ExecutableOptions__separatorBar", "ExecutableOptions__parser", "$get$ExecutableOptions__parser", function() {
    return new B.ExecutableOptions_closure().call$0();
  }, "ExecutableOptions__parser", "_subselectorPseudos", "$get$_subselectorPseudos", function() {
    return P.LinkedHashSet_LinkedHashSet$from(["matches", "any", "nth-child", "nth-last-child"], P.String);
  }, "_subselectorPseudos", "_microsoftFilterStart", "$get$_microsoftFilterStart", function() {
    return P.RegExp_RegExp("^[a-zA-Z]+\\s*=", true, false);
  }, "_microsoftFilterStart", "_features", "$get$_features", function() {
    return P.LinkedHashSet_LinkedHashSet$from(["global-variable-shadowing", "extend-selector-pseudoclass", "units-level-3", "at-error", "custom-property"], P.String);
  }, "_features", "_random", "$get$_random", function() {
    return C.C__JSRandom;
  }, "_random", "_uniqueID", "$get$_uniqueID", function() {
    return $.$get$_random().nextInt$1(H.intTypeCast(P.pow(36, 6)));
  }, "_uniqueID", "coreFunctions", "$get$coreFunctions", function() {
    return P.UnmodifiableListView$([Q.BuiltInCallable$overloaded("rgb", P.LinkedHashMap__makeLiteral(["$red, $green, $blue", new Y.closure37(), "$red, $green", new Y.closure38(), "$red", new Y.closure39()])), Q.BuiltInCallable$overloaded("rgba", P.LinkedHashMap__makeLiteral(["$red, $green, $blue, $alpha", new Y.closure40(), "$color, $alpha", new Y.closure41(), "$red, $green, $blue", new Y.closure42(), "$red", new Y.closure43()])), Q.BuiltInCallable$("red", "$color", new Y.closure44()), Q.BuiltInCallable$("green", "$color", new Y.closure45()), Q.BuiltInCallable$("blue", "$color", new Y.closure46()), Q.BuiltInCallable$("mix", "$color1, $color2, $weight: 50%", new Y.closure47()), Q.BuiltInCallable$overloaded("hsl", P.LinkedHashMap__makeLiteral(["$hue, $saturation, $lightness", new Y.closure48(), "$hue, $saturation", new Y.closure49(), "$hue", new Y.closure50()])), Q.BuiltInCallable$overloaded("hsla", P.LinkedHashMap__makeLiteral(["$hue, $saturation, $lightness, $alpha", new Y.closure51(), "$hue, $saturation, $lightness", new Y.closure52(), "$hue, $saturation", new Y.closure53(), "$hue", new Y.closure54()])), Q.BuiltInCallable$("hue", "$color", new Y.closure55()), Q.BuiltInCallable$("saturation", "$color", new Y.closure56()), Q.BuiltInCallable$("lightness", "$color", new Y.closure57()), Q.BuiltInCallable$("adjust-hue", "$color, $degrees", new Y.closure58()), Q.BuiltInCallable$("lighten", "$color, $amount", new Y.closure59()), Q.BuiltInCallable$("darken", "$color, $amount", new Y.closure60()), Q.BuiltInCallable$overloaded("saturate", P.LinkedHashMap__makeLiteral(["$number", new Y.closure61(), "$color, $amount", new Y.closure62()])), Q.BuiltInCallable$("desaturate", "$color, $amount", new Y.closure63()), Q.BuiltInCallable$("grayscale", "$color", new Y.closure64()), Q.BuiltInCallable$("complement", "$color", new Y.closure65()), Q.BuiltInCallable$("invert", "$color, $weight: 50%", new Y.closure66()), Q.BuiltInCallable$overloaded("alpha", P.LinkedHashMap__makeLiteral(["$color", new Y.closure67(), "$args...", new Y.closure68()])), Q.BuiltInCallable$("opacity", "$color", new Y.closure69()), Q.BuiltInCallable$("opacify", "$color, $amount", Y.functions___opacify$closure()), Q.BuiltInCallable$("fade-in", "$color, $amount", Y.functions___opacify$closure()), Q.BuiltInCallable$("transparentize", "$color, $amount", Y.functions___transparentize$closure()), Q.BuiltInCallable$("fade-out", "$color, $amount", Y.functions___transparentize$closure()), Q.BuiltInCallable$("adjust-color", "$color, $kwargs...", new Y.closure70()), Q.BuiltInCallable$("scale-color", "$color, $kwargs...", new Y.closure71()), Q.BuiltInCallable$("change-color", "$color, $kwargs...", new Y.closure72()), Q.BuiltInCallable$("ie-hex-str", "$color", new Y.closure73()), Q.BuiltInCallable$("unquote", "$string", new Y.closure74()), Q.BuiltInCallable$("quote", "$string", new Y.closure75()), Q.BuiltInCallable$("str-length", "$string", new Y.closure76()), Q.BuiltInCallable$("str-insert", "$string, $insert, $index", new Y.closure77()), Q.BuiltInCallable$("str-index", "$string, $substring", new Y.closure78()), Q.BuiltInCallable$("str-slice", "$string, $start-at, $end-at: -1", new Y.closure79()), Q.BuiltInCallable$("to-upper-case", "$string", new Y.closure80()), Q.BuiltInCallable$("to-lower-case", "$string", new Y.closure81()), Q.BuiltInCallable$("percentage", "$number", new Y.closure82()), Y._numberFunction("round", T.number__fuzzyRound$closure()), Y._numberFunction("ceil", new Y.closure83()), Y._numberFunction("floor", new Y.closure84()), Y._numberFunction("abs", new Y.closure85()), Q.BuiltInCallable$("max", "$numbers...", new Y.closure86()), Q.BuiltInCallable$("min", "$numbers...", new Y.closure87()), Q.BuiltInCallable$("random", "$limit: null", new Y.closure88()), Q.BuiltInCallable$("length", "$list", new Y.closure89()), Q.BuiltInCallable$("nth", "$list, $n", new Y.closure90()), Q.BuiltInCallable$("set-nth", "$list, $n, $value", new Y.closure91()), Q.BuiltInCallable$("join", "$list1, $list2, $separator: auto, $bracketed: auto", new Y.closure92()), Q.BuiltInCallable$("append", "$list, $val, $separator: auto", new Y.closure93()), Q.BuiltInCallable$("zip", "$lists...", new Y.closure94()), Q.BuiltInCallable$("index", "$list, $value", new Y.closure95()), Q.BuiltInCallable$("list-separator", "$list", new Y.closure96()), Q.BuiltInCallable$("is-bracketed", "$list", new Y.closure97()), Q.BuiltInCallable$("map-get", "$map, $key", new Y.closure98()), Q.BuiltInCallable$("map-merge", "$map1, $map2", new Y.closure99()), Q.BuiltInCallable$("map-remove", "$map, $keys...", new Y.closure100()), Q.BuiltInCallable$("map-keys", "$map", new Y.closure101()), Q.BuiltInCallable$("map-values", "$map", new Y.closure102()), Q.BuiltInCallable$("map-has-key", "$map, $key", new Y.closure103()), Q.BuiltInCallable$("keywords", "$args", new Y.closure104()), Q.BuiltInCallable$("selector-nest", "$selectors...", new Y.closure105()), Q.BuiltInCallable$("selector-append", "$selectors...", new Y.closure106()), Q.BuiltInCallable$("selector-extend", "$selector, $extendee, $extender", new Y.closure107()), Q.BuiltInCallable$("selector-replace", "$selector, $original, $replacement", new Y.closure108()), Q.BuiltInCallable$("selector-unify", "$selector1, $selector2", new Y.closure109()), Q.BuiltInCallable$("is-superselector", "$super, $sub", new Y.closure110()), Q.BuiltInCallable$("simple-selectors", "$selector", new Y.closure111()), Q.BuiltInCallable$("selector-parse", "$selector", new Y.closure112()), Q.BuiltInCallable$("feature-exists", "$feature", new Y.closure113()), Q.BuiltInCallable$("inspect", "$value", new Y.closure114()), Q.BuiltInCallable$("type-of", "$value", new Y.closure115()), Q.BuiltInCallable$("unit", "$number", new Y.closure116()), Q.BuiltInCallable$("unitless", "$number", new Y.closure117()), Q.BuiltInCallable$("comparable", "$number1, $number2", new Y.closure118()), Q.BuiltInCallable$("if", "$condition, $if-true, $if-false", new Y.closure119()), Q.BuiltInCallable$("unique-id", "", new Y.closure120())], null);
  }, "coreFunctions", "Importer_noOp", "$get$Importer_noOp", function() {
    return new B.NoOpImporter();
  }, "Importer_noOp", "_fs", "$get$_fs", function() {
    return self.require("fs");
  }, "_fs", "stderr", "$get$stderr", function() {
    return new B.Stderr(self.process.stderr);
  }, "stderr", "Logger_quiet", "$get$Logger_quiet", function() {
    return new F._QuietLogger();
  }, "Logger_quiet", "chokidar", "$get$chokidar", function() {
    return self.require("chokidar");
  }, "chokidar", "_jsThrow", "$get$_jsThrow", function() {
    return new self.Function("error", "throw error;");
  }, "_jsThrow", "_isUndefined", "$get$_isUndefined", function() {
    return new self.Function("value", "return value === undefined;");
  }, "_isUndefined", "booleanConstructor", "$get$booleanConstructor", function() {
    return new Z.closure36().call$0();
  }, "booleanConstructor", "colorConstructor", "$get$colorConstructor", function() {
    return B.createClass(new K.closure24(), P.LinkedHashMap__makeLiteral(["getR", new K.closure25(), "getG", new K.closure26(), "getB", new K.closure27(), "getA", new K.closure28(), "setR", new K.closure29(), "setG", new K.closure30(), "setB", new K.closure31(), "setA", new K.closure32(), "toString", new K.closure33()]));
  }, "colorConstructor", "listConstructor", "$get$listConstructor", function() {
    return B.createClass(new D.closure17(), P.LinkedHashMap__makeLiteral(["getValue", new D.closure18(), "setValue", new D.closure19(), "getSeparator", new D.closure20(), "setSeparator", new D.closure21(), "getLength", new D.closure22(), "toString", new D.closure23()]));
  }, "listConstructor", "mapConstructor", "$get$mapConstructor", function() {
    return B.createClass(new A.closure10(), P.LinkedHashMap__makeLiteral(["getKey", new A.closure11(), "getValue", new A.closure12(), "getLength", new A.closure13(), "setKey", new A.closure14(), "setValue", new A.closure15(), "toString", new A.closure16()]));
  }, "mapConstructor", "nullConstructor", "$get$nullConstructor", function() {
    return new O.closure9().call$0();
  }, "nullConstructor", "numberConstructor", "$get$numberConstructor", function() {
    return B.createClass(new T.closure3(), P.LinkedHashMap__makeLiteral(["getValue", new T.closure4(), "setValue", new T.closure5(), "getUnit", new T.closure6(), "setUnit", new T.closure7(), "toString", new T.closure8()]));
  }, "numberConstructor", "stringConstructor", "$get$stringConstructor", function() {
    return B.createClass(new D.closure(), P.LinkedHashMap__makeLiteral(["getValue", new D.closure0(), "setValue", new D.closure1(), "toString", new D.closure2()]));
  }, "stringConstructor", "_selectorPseudoClasses", "$get$_selectorPseudoClasses", function() {
    return P.LinkedHashSet_LinkedHashSet$from(["not", "matches", "current", "any", "has", "host", "host-context"], P.String);
  }, "_selectorPseudoClasses", "_selectorPseudoElements", "$get$_selectorPseudoElements", function() {
    return P.LinkedHashSet_LinkedHashSet$from(["slotted"], P.String);
  }, "_selectorPseudoElements", "epsilon", "$get$epsilon", function() {
    return 1 / P.pow(10, 10);
  }, "epsilon", "_epsilonOver2", "$get$_epsilonOver2", function() {
    var t1 = $.$get$epsilon();
    if (typeof t1 !== "number")
      return t1.$div();
    return t1 / 2;
  }, "_epsilonOver2", "_noSourceUrl", "$get$_noSourceUrl", function() {
    return P.Uri_parse("-", 0, null);
  }, "_noSourceUrl", "_conversions", "$get$_conversions", function() {
    return P.LinkedHashMap__makeLiteral(["in", P.LinkedHashMap__makeLiteral(["in", 1, "cm", 0.39370078740157477, "pc", 0.16666666666666666, "mm", 0.03937007874015748, "q", 0.00984251968503937, "pt", 0.013888888888888888, "px", 0.010416666666666666]), "cm", P.LinkedHashMap__makeLiteral(["in", 2.54, "cm", 1, "pc", 0.42333333333333334, "mm", 0.1, "q", 0.025, "pt", 0.035277777777777776, "px", 0.026458333333333334]), "pc", P.LinkedHashMap__makeLiteral(["in", 6, "cm", 2.3622047244094486, "pc", 1, "mm", 0.2362204724409449, "q", 0.05905511811023623, "pt", 0.08333333333333333, "px", 0.0625]), "mm", P.LinkedHashMap__makeLiteral(["in", 25.4, "cm", 10, "pc", 4.233333333333333, "mm", 1, "q", 0.25, "pt", 0.35277777777777775, "px", 0.26458333333333334]), "q", P.LinkedHashMap__makeLiteral(["in", 101.6, "cm", 40, "pc", 16.933333333333334, "mm", 4, "q", 1, "pt", 1.411111111111111, "px", 1.0583333333333333]), "pt", P.LinkedHashMap__makeLiteral(["in", 72, "cm", 28.346456692913385, "pc", 12, "mm", 2.834645669291339, "q", 0.7086614173228347, "pt", 1, "px", 0.75]), "px", P.LinkedHashMap__makeLiteral(["in", 96, "cm", 37.79527559055118, "pc", 16, "mm", 3.7795275590551185, "q", 0.9448818897637796, "pt", 1.3333333333333333, "px", 1]), "deg", P.LinkedHashMap__makeLiteral(["deg", 1, "grad", 0.9, "rad", 57.29577951308232, "turn", 360]), "grad", P.LinkedHashMap__makeLiteral(["deg", 1.1111111111111112, "grad", 1, "rad", 63.66197723675813, "turn", 400]), "rad", P.LinkedHashMap__makeLiteral(["deg", 0.017453292519943295, "grad", 0.015707963267948967, "rad", 1, "turn", 6.283185307179586]), "turn", P.LinkedHashMap__makeLiteral(["deg", 0.002777777777777778, "grad", 0.0025, "rad", 0.15915494309189535, "turn", 1]), "s", P.LinkedHashMap__makeLiteral(["s", 1, "ms", 0.001]), "ms", P.LinkedHashMap__makeLiteral(["s", 1000, "ms", 1]), "Hz", P.LinkedHashMap__makeLiteral(["Hz", 1, "kHz", 1000]), "kHz", P.LinkedHashMap__makeLiteral(["Hz", 0.001, "kHz", 1]), "dpi", P.LinkedHashMap__makeLiteral(["dpi", 1, "dpcm", 2.54, "dppx", 96]), "dpcm", P.LinkedHashMap__makeLiteral(["dpi", 0.39370078740157477, "dpcm", 1, "dppx", 37.79527559055118]), "dppx", P.LinkedHashMap__makeLiteral(["dpi", 0.010416666666666666, "dpcm", 0.026458333333333334, "dppx", 1])]);
  }, "_conversions", "_emptyQuoted", "$get$_emptyQuoted", function() {
    return D.SassString$("", true);
  }, "_emptyQuoted", "_emptyUnquoted", "$get$_emptyUnquoted", function() {
    return D.SassString$("", false);
  }, "_emptyUnquoted", "_compressibleUnits", "$get$_compressibleUnits", function() {
    return P.LinkedHashSet_LinkedHashSet$from(["em", "ex", "ch", "rem", "vw", "wh", "vmin", "vmax", "cm", "mm", "q", "in", "pt", "pc", "px", "deg", "rad", "turn"], null);
  }, "_compressibleUnits", "MAX_INT32", "$get$MAX_INT32", function() {
    return P.pow(2, 31) - 1;
  }, "MAX_INT32", "MIN_INT32", "$get$MIN_INT32", function() {
    return -P.pow(2, 31);
  }, "MIN_INT32", "_vmFrame", "$get$_vmFrame", function() {
    return P.RegExp_RegExp("^#\\d+\\s+(\\S.*) \\((.+?)((?::\\d+){0,2})\\)$", true, false);
  }, "_vmFrame", "_v8Frame", "$get$_v8Frame", function() {
    return P.RegExp_RegExp("^\\s*at (?:(\\S.*?)(?: \\[as [^\\]]+\\])? \\((.*)\\)|(.*))$", true, false);
  }, "_v8Frame", "_v8UrlLocation", "$get$_v8UrlLocation", function() {
    return P.RegExp_RegExp("^(.*):(\\d+):(\\d+)|native$", true, false);
  }, "_v8UrlLocation", "_v8EvalLocation", "$get$_v8EvalLocation", function() {
    return P.RegExp_RegExp("^eval at (?:\\S.*?) \\((.*)\\)(?:, .*?:\\d+:\\d+)?$", true, false);
  }, "_v8EvalLocation", "_firefoxSafariFrame", "$get$_firefoxSafariFrame", function() {
    return P.RegExp_RegExp("^(?:([^@(/]*)(?:\\(.*\\))?((?:/[^/]*)*)(?:\\(.*\\))?@)?(.*?):(\\d*)(?::(\\d*))?$", true, false);
  }, "_firefoxSafariFrame", "_friendlyFrame", "$get$_friendlyFrame", function() {
    return P.RegExp_RegExp("^(\\S+)(?: (\\d+)(?::(\\d+))?)?\\s+([^\\d].*)$", true, false);
  }, "_friendlyFrame", "_asyncBody", "$get$_asyncBody", function() {
    return P.RegExp_RegExp("<(<anonymous closure>|[^>]+)_async_body>", true, false);
  }, "_asyncBody", "_initialDot", "$get$_initialDot", function() {
    return P.RegExp_RegExp("^\\.", true, false);
  }, "_initialDot", "Frame__uriRegExp", "$get$Frame__uriRegExp", function() {
    return P.RegExp_RegExp("^[a-zA-Z][-+.a-zA-Z\\d]*://", true, false);
  }, "Frame__uriRegExp", "Frame__windowsRegExp", "$get$Frame__windowsRegExp", function() {
    return P.RegExp_RegExp("^([a-zA-Z]:[\\\\/]|\\\\\\\\)", true, false);
  }, "Frame__windowsRegExp", "_terseRegExp", "$get$_terseRegExp", function() {
    return P.RegExp_RegExp("(-patch)?([/\\\\].*)?$", true, false);
  }, "_terseRegExp", "_v8Trace", "$get$_v8Trace", function() {
    return P.RegExp_RegExp("\\n    ?at ", true, false);
  }, "_v8Trace", "_v8TraceLine", "$get$_v8TraceLine", function() {
    return P.RegExp_RegExp("    ?at ", true, false);
  }, "_v8TraceLine", "_firefoxSafariTrace", "$get$_firefoxSafariTrace", function() {
    return P.RegExp_RegExp("^(([.0-9A-Za-z_$/<]|\\(.*\\))*@)?[^\\s]*:\\d*$", true, true);
  }, "_firefoxSafariTrace", "_friendlyTrace", "$get$_friendlyTrace", function() {
    return P.RegExp_RegExp("^[^\\s<][^\\s]*( \\d+(:\\d+)?)?[ \\t]+[^\\s]+$", true, true);
  }, "_friendlyTrace", "_newlineRegExp", "$get$_newlineRegExp", function() {
    return P.RegExp_RegExp("\\r\\n?|\\n", true, false);
  }, "_newlineRegExp"]);
  Isolate = Isolate.$finishIsolateConstructor(Isolate);
  $ = new Isolate();
  init.metadata = ["arguments", "thisArg", null, "value", "error", "stackTrace", "path", "_", "name", "complex", "index", "element", "frame", "line", "trace", "result", "data", "dartValue", "expression", "length", "e", "a", "invocation", "chunk", "callback", "message", "position", "s", "object", "b", "argument", "component", "simple", "each", "components", "arg", "list", "selector", "options", "key", "i", "unit", "query2", "match", "dir", "pair", "arg2", "variable", "clause", "arg1", "subscription", "arg3", "importer", "arg4", "url", "previous", "red", "number", "blue", "alpha", "parentComplex", "newComplex", "commaSeparator", "number2", "closure", "args", "path1", "path2", "string1", "string2", "string", "theError", "inner", "green", "encodedComponent", "file", "start", "end", "sourceStream", "color", "theStackTrace", "sink", "numberOfArguments", "pseudo", "self", "number1", "isComma", "state"];
  init.types = [{func: 1, args: [,]}, {func: 1}, {func: 1, args: [,,]}, {func: 1, v: true}, {func: 1, ret: P.Future}, {func: 1, opt: [,]}, {func: 1, ret: P.Future, args: [,]}, {func: 1, args: [, P.StackTrace]}, {func: 1, ret: P.bool, args: [P.num, P.num]}, {func: 1, v: true, args: [P.Object], opt: [P.StackTrace]}, {func: 1, args: [P.String, F.Value]}, {func: 1, args: [K._NodeSassColor]}, {func: 1, args: [K._NodeSassColor, P.num]}, {func: 1, ret: P.bool, args: [P.Object]}, {func: 1, args: [P.String]}, {func: 1, args: [T.Expression]}, {func: 1, args: [F.Value]}, {func: 1, args: [P.bool]}, {func: 1, v: true, opt: [P.Future]}, {func: 1, v: true, args: [{func: 1, v: true}]}, {func: 1, v: true, args: [P.Object]}, {func: 1, ret: O.Statement}, {func: 1, args: [P.String,,]}, {func: 1, args: [T._NodeSassNumber]}, {func: 1, args: [D._NodeSassList]}, {func: 1, v: true, opt: [,]}, {func: 1, ret: P.bool, args: [P.int]}, {func: 1, ret: K.SassColor, args: [[P.List, F.Value]]}, {func: 1, ret: P.String, args: [P.int]}, {func: 1, ret: Y.FileSpan, args: [T.Expression]}, {func: 1, ret: [P.List, O.Statement], args: [{func: 1, ret: O.Statement}]}, {func: 1, v: true, args: [P.Uint8List, P.String, P.int]}, {func: 1, args: [D._NodeSassString]}, {func: 1, ret: P.String, args: [P.String]}, {func: 1, ret: P.bool, args: [B.CssNode]}, {func: 1, args: [{func: 1, v: true}]}, {func: 1, args: [A._NodeSassMap, P.int,,]}, {func: 1, args: [A._NodeSassMap]}, {func: 1, args: [A._NodeSassMap, P.int]}, {func: 1, args: [P.String, P.num, P.num]}, {func: 1, v: true, args: [P.String], named: {length: P.int, match: P.Match, position: P.int}}, {func: 1, v: true, args: [P.Object, P.StackTrace]}, {func: 1, args: [, P.String]}, {func: 1, ret: [P.Iterable, P.String], args: [P.String]}, {func: 1, args: [P.int,,]}, {func: 1, args: [, P.String, P.String], opt: [,]}, {func: 1, ret: E.Fiber, args: [{func: 1}]}, {func: 1, opt: [,,,]}, {func: 1, args: [K._NodeSassColor, P.num, P.num, P.num], opt: [P.num, K.SassColor]}, {func: 1, args: [P.int]}, {func: 1, args: [P.num, P.num, P.num]}, {func: 1, args: [D._NodeSassList, P.int], opt: [P.bool, D.SassList]}, {func: 1, args: [D._NodeSassList, P.int]}, {func: 1, args: [D._NodeSassList, P.int,,]}, {func: 1, ret: [P.List, S.Extension], args: [M.SimpleSelector]}, {func: 1, args: [D._NodeSassList, P.bool]}, {func: 1, args: [A._NodeSassMap, P.int], opt: [A.SassMap]}, {func: 1, args: [S.ComplexSelector]}, {func: 1, v: true, args: [P.String, P.StackTrace]}, {func: 1, v: true, args: [D.Callable]}, {func: 1, args: [T._NodeSassNumber, P.num], opt: [P.String, T.SassNumber]}, {func: 1, v: true, args: [B.AsyncCallable]}, {func: 1, args: [T._NodeSassNumber, P.num]}, {func: 1, args: [T._NodeSassNumber, P.String]}, {func: 1, args: [D._NodeSassString, P.String], opt: [D.SassString]}, {func: 1, v: true, args: [,], opt: [P.StackTrace]}, {func: 1, args: [D._NodeSassString, P.String]}, {func: 1, ret: P.int, args: [P.num]}, {func: 1, ret: P.Uint8List, args: [,,]}, {func: 1, ret: O.Statement, named: {root: P.bool}}, {func: 1, ret: P.int, args: [P.int, P.int]}, {func: 1, args: [T.Expression], named: {number: P.bool}}, {func: 1, args: [V.BinaryOperator]}, {func: 1, ret: P.DateTime, args: [M.StylesheetNode]}, {func: 1, v: true, args: [P.String], opt: [,]}, {func: 1, ret: P.Future, args: [,,]}, {func: 1, v: true, args: [P.String, P.int]}, {func: 1, ret: P.Future, args: [{func: 1, ret: P.Future}]}, {func: 1, args: [P.Symbol0,,]}, {func: 1, v: true, args: [P.int, P.int]}, {func: 1, v: true, args: [F.CssMediaQuery]}, {func: 1, ret: Y.FileSpan, args: [P.int], opt: [P.int]}, {func: 1, ret: Y.FileLocation, args: [P.int]}, {func: 1, ret: P.String, args: [P.String], named: {color: null}}, {func: 1, ret: P.String}, {func: 1, ret: P.int, args: [,,]}, {func: 1, ret: P.int, args: [[P.List, P.int], P.int]}, {func: 1, ret: P.bool, args: [,,]}, {func: 1, ret: P.int, args: [,]}, {func: 1, ret: P.int, args: [P.Object]}, {func: 1, ret: P.bool, args: [P.Object, P.Object]}, {func: 1, args: [[P.List, P.String]]}, {func: 1, ret: P.bool, args: [M.SimpleSelector]}, {func: 1, v: true, args: [, P.StackTrace]}, {func: 1, v: true, args: [R.RenderOptions, {func: 1, v: true, args: [V.JSError, U.RenderResult]}]}, {func: 1, ret: U.RenderResult, args: [R.RenderOptions]}, {func: 1, ret: P.bool, args: [P.String, P.String]}, {func: 1, ret: P.int, args: [P.String]}, {func: 1, ret: P.Object, args: [F.Value]}, {func: 1, ret: P.int, args: [P.int]}, {func: 1, args: [,], opt: [,]}, {func: 1, ret: P.bool, args: [S.ComplexSelector]}];
  function convertToFastObject(properties) {
    function MyClass() {
    }
    MyClass.prototype = properties;
    new MyClass();
    return properties;
  }
  function convertToSlowObject(properties) {
    properties.__MAGIC_SLOW_PROPERTY = 1;
    delete properties.__MAGIC_SLOW_PROPERTY;
    return properties;
  }
  A = convertToFastObject(A);
  B = convertToFastObject(B);
  C = convertToFastObject(C);
  D = convertToFastObject(D);
  E = convertToFastObject(E);
  F = convertToFastObject(F);
  G = convertToFastObject(G);
  H = convertToFastObject(H);
  J = convertToFastObject(J);
  K = convertToFastObject(K);
  L = convertToFastObject(L);
  M = convertToFastObject(M);
  N = convertToFastObject(N);
  O = convertToFastObject(O);
  P = convertToFastObject(P);
  Q = convertToFastObject(Q);
  R = convertToFastObject(R);
  S = convertToFastObject(S);
  T = convertToFastObject(T);
  U = convertToFastObject(U);
  V = convertToFastObject(V);
  W = convertToFastObject(W);
  X = convertToFastObject(X);
  Y = convertToFastObject(Y);
  Z = convertToFastObject(Z);
  function init() {
    Isolate.$isolateProperties = Object.create(null);
    init.allClasses = map();
    init.getTypeFromName = function(name) {
      return init.allClasses[name];
    };
    init.interceptorsByTag = map();
    init.leafTags = map();
    init.finishedClasses = map();
    Isolate.$lazy = function(fieldName, getterName, lazyValue, staticName, prototype) {
      if (!init.lazies)
        init.lazies = Object.create(null);
      init.lazies[fieldName] = getterName;
      prototype = prototype || Isolate.$isolateProperties;
      var sentinelUndefined = {};
      var sentinelInProgress = {};
      prototype[fieldName] = sentinelUndefined;
      prototype[getterName] = function() {
        var result = this[fieldName];
        if (result == sentinelInProgress)
          H.throwCyclicInit(staticName || fieldName);
        try {
          if (result === sentinelUndefined) {
            this[fieldName] = sentinelInProgress;
            try {
              result = this[fieldName] = lazyValue();
            } finally {
              if (result === sentinelUndefined)
                this[fieldName] = null;
            }
          }
          return result;
        } finally {
          this[getterName] = function() {
            return this[fieldName];
          };
        }
      };
    };
    Isolate.$finishIsolateConstructor = function(oldIsolate) {
      var isolateProperties = oldIsolate.$isolateProperties;
      function Isolate() {
        var staticNames = Object.keys(isolateProperties);
        for (var i = 0; i < staticNames.length; i++) {
          var staticName = staticNames[i];
          this[staticName] = isolateProperties[staticName];
        }
        var lazies = init.lazies;
        var lazyInitializers = lazies ? Object.keys(lazies) : [];
        for (var i = 0; i < lazyInitializers.length; i++)
          this[lazies[lazyInitializers[i]]] = null;
        function ForceEfficientMap() {
        }
        ForceEfficientMap.prototype = this;
        new ForceEfficientMap();
        for (var i = 0; i < lazyInitializers.length; i++) {
          var lazyInitName = lazies[lazyInitializers[i]];
          this[lazyInitName] = isolateProperties[lazyInitName];
        }
      }
      Isolate.prototype = oldIsolate.prototype;
      Isolate.prototype.constructor = Isolate;
      Isolate.$isolateProperties = isolateProperties;
      Isolate.makeConstantList = oldIsolate.makeConstantList;
      Isolate.functionThatReturnsNull = oldIsolate.functionThatReturnsNull;
      return Isolate;
    };
  }
  !function() {
    var intern = function(s) {
      var o = {};
      o[s] = 1;
      return Object.keys(convertToFastObject(o))[0];
    };
    init.getIsolateTag = function(name) {
      return intern("___dart_" + name + init.isolateTag);
    };
    var tableProperty = "___dart_isolate_tags_";
    var usedProperties = Object[tableProperty] || (Object[tableProperty] = Object.create(null));
    var rootProperty = "_ZxYxX";
    for (var i = 0;; i++) {
      var property = intern(rootProperty + "_" + i + "_");
      if (!(property in usedProperties)) {
        usedProperties[property] = 1;
        init.isolateTag = property;
        break;
      }
    }
    init.dispatchPropertyName = init.getIsolateTag("dispatch_record");
  }();
  // BEGIN invoke [main].
  (function(callback) {
    if (typeof document === "undefined") {
      callback(null);
      return;
    }
    if (typeof document.currentScript != 'undefined') {
      callback(document.currentScript);
      return;
    }
    var scripts = document.scripts;
    function onLoad(event) {
      for (var i = 0; i < scripts.length; ++i)
        scripts[i].removeEventListener("load", onLoad, false);
      callback(event.target);
    }
    for (var i = 0; i < scripts.length; ++i)
      scripts[i].addEventListener("load", onLoad, false);
  })(function(currentScript) {
    init.currentScript = currentScript;
    if (typeof dartMainRunner === "function")
      dartMainRunner(B.main0, []);
    else
      B.main0([]);
  });
  // END invoke [main].
})();

//# sourceMappingURL=sass.dart.js.map
